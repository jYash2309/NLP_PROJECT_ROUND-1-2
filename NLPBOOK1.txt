In which we try to explain why we consider artificial intelligence to be a subject
most worthy of study, and in which we try to decide what exactly it is, this being a
good thing to decide before embarking.
INTELLIGENCE We call ourselves Homo sapiens—man the wise—because our intelligence is so important
to us. For thousands of years, we have tried to understand how we think; that is, how a mere
handful of matter can perceive, understand, predict, and manipulate a world far larger and
more complicated than itself. The field of artificial intelligence, or AI, goes further still: it ARTIFICIAL
INTELLIGENCE
attempts not just to understand but also to build intelligent entities.
AI is one of the newest fields in science and engineering. Work started in earnest soon
after World War II, and the name itself was coined in 1956. Along with molecular biology,
AI is regularly cited as the “field I would most like to be in” by scientists in other disciplines.
A student in physics might reasonably feel that all the good ideas have already been taken by
Galileo, Newton, Einstein, and the rest. AI, on the other hand, still has openings for several
full-time Einsteins and Edisons.
AI currently encompasses a huge variety of subfields, ranging from the general (learning
and perception) to the specific, such as playing chess, proving mathematical theorems, writing
poetry, driving a car on a crowded street, and diagnosing diseases. AI is relevant to any
intellectual task; it is truly a universal field.
1.1 WHAT IS AI?
We have claimed that AI is exciting, but we have not said what it is. In Figure 1.1 we see
eight definitions of AI, laid out along two dimensions. The definitions on top are concerned
with thought processes and reasoning, whereas the ones on the bottom address behavior. The
definitions on the left measure success in terms of fidelity to human performance, whereas
RATIONALITY the ones on the right measure against an ideal performance measure, called rationality. A
system is rational if it does the “right thing,” given what it knows.
Historically, all four approaches to AI have been followed, each by different people
with different methods. A human-centered approach must be in part an empirical science, in1
2 Chapter 1. Introduction
Thinking Humanly Thinking Rationally
“The exciting new effort to make computers think ... machines with minds, in the
full and literal sense.” (Haugeland, 1985)
“The study of mental faculties through the
use of computational models.”
(Charniak and McDermott, 1985)
“[The automation of] activities that we
associate with human thinking, activities
such as decision-making, problem solving, learning ...” (Bellman, 1978)
“The study of the computations that make
it possible to perceive, reason, and act.”
(Winston, 1992)
Acting Humanly Acting Rationally
“The art of creating machines that perform functions that require intelligence
when performed by people.” (Kurzweil,
1990)
“Computational Intelligence is the study
of the design of intelligent agents.” (Poole
et al., 1998)
“The study of how to make computers do
things at which, at the moment, people are
better.” (Rich and Knight, 1991)
“AI . . . is concerned with intelligent behavior in artifacts.” (Nilsson, 1998)
Figure 1.1 Some definitions of artificial intelligence, organized into four categories.
volving observations and hypotheses about human behavior. A rationalist1 approach involves
a combination of mathematics and engineering. The various group have both disparaged and
helped each other. Let us look at the four approaches in more detail.
1.1.1 Acting humanly: The Turing Test approach
TURING TEST The Turing Test, proposed by Alan Turing (1950), was designed to provide a satisfactory
operational definition of intelligence. A computer passes the test if a human interrogator, after
posing some written questions, cannot tell whether the written responses come from a person
or from a computer. Chapter 26 discusses the details of the test and whether a computer would
really be intelligent if it passed. For now, we note that programming a computer to pass a
rigorously applied test provides plenty to work on. The computer would need to possess the
following capabilities:
• natural language processing to enable it to communicate successfully in English; NATURAL LANGUAGE
PROCESSING
• knowledge representation to store what it knows or hears; KNOWLEDGE
REPRESENTATION
AUTOMATED
REASONING • automated reasoning to use the stored information to answer questions and to draw
new conclusions;
MACHINE LEARNING • machine learning to adapt to new circumstances and to detect and extrapolate patterns.
1 By distinguishing between human and rational behavior, we are not suggesting that humans are necessarily
“irrational” in the sense of “emotionally unstable” or “insane.” One merely need note that we are not perfect:
not all chess players are grandmasters; and, unfortunately, not everyone gets an A on the exam. Some systematic
errors in human reasoning are cataloged by Kahneman et al. (1982).
Section 1.1. What Is AI? 3
Turing’s test deliberately avoided direct physical interaction between the interrogator and the
computer, because physical simulation of a person is unnecessary for intelligence. However,
TOTAL TURING TEST the so-called total Turing Test includes a video signal so that the interrogator can test the
subject’s perceptual abilities, as well as the opportunity for the interrogator to pass physical
objects “through the hatch.” To pass the total Turing Test, the computer will need
COMPUTER VISION • computer vision to perceive objects, and
ROBOTICS • robotics to manipulate objects and move about.
These six disciplines compose most of AI, and Turing deserves credit for designing a test
that remains relevant 60 years later. Yet AI researchers have devoted little effort to passing
the Turing Test, believing that it is more important to study the underlying principles of intelligence than to duplicate an exemplar. The quest for “artificial flight” succeeded when the
Wright brothers and others stopped imitating birds and started using wind tunnels and learning about aerodynamics. Aeronautical engineering texts do not define the goal of their field
as making “machines that fly so exactly like pigeons that they can fool even other pigeons.”
1.1.2 Thinking humanly: The cognitive modeling approach
If we are going to say that a given program thinks like a human, we must have some way of
determining how humans think. We need to get inside the actual workings of human minds.
There are three ways to do this: through introspection—trying to catch our own thoughts as
they go by; through psychological experiments—observing a person in action; and through
brain imaging—observing the brain in action. Once we have a sufficiently precise theory of
the mind, it becomes possible to express the theory as a computer program. If the program’s
input–output behavior matches corresponding human behavior, that is evidence that some of
the program’s mechanisms could also be operating in humans. For example, Allen Newell
and Herbert Simon, who developed GPS, the “General Problem Solver” (Newell and Simon,
1961), were not content merely to have their program solve problems correctly. They were
more concerned with comparing the trace of its reasoning steps to traces of human subjects
COGNITIVE SCIENCE solving the same problems. The interdisciplinary field of cognitive science brings together
computer models from AI and experimental techniques from psychology to construct precise
and testable theories of the human mind.
Cognitive science is a fascinating field in itself, worthy of several textbooks and at least
one encyclopedia (Wilson and Keil, 1999). We will occasionally comment on similarities or
differences between AI techniques and human cognition. Real cognitive science, however, is
necessarily based on experimental investigation of actual humans or animals. We will leave
that for other books, as we assume the reader has only a computer for experimentation.
In the early days of AI there was often confusion between the approaches: an author
would argue that an algorithm performs well on a task and that it is therefore a good model
of human performance, or vice versa. Modern authors separate the two kinds of claims;
this distinction has allowed both AI and cognitive science to develop more rapidly. The two
fields continue to fertilize each other, most notably in computer vision, which incorporates
neurophysiological evidence into computational models.
4 Chapter 1. Introduction
1.1.3 Thinking rationally: The “laws of thought” approach
The Greek philosopher Aristotle was one of the first to attempt to codify “right thinking,” that
SYLLOGISM is, irrefutable reasoning processes. His syllogisms provided patterns for argument structures
that always yielded correct conclusions when given correct premises—for example, “Socrates
is a man; all men are mortal; therefore, Socrates is mortal.” These laws of thought were
LOGIC supposed to govern the operation of the mind; their study initiated the field called logic.
Logicians in the 19th century developed a precise notation for statements about all kinds
of objects in the world and the relations among them. (Contrast this with ordinary arithmetic
notation, which provides only for statements about numbers.) By 1965, programs existed
that could, in principle, solve any solvable problem described in logical notation. (Although
LOGICIST if no solution exists, the program might loop forever.) The so-called logicist tradition within
artificial intelligence hopes to build on such programs to create intelligent systems.
There are two main obstacles to this approach. First, it is not easy to take informal
knowledge and state it in the formal terms required by logical notation, particularly when
the knowledge is less than 100% certain. Second, there is a big difference between solving
a problem “in principle” and solving it in practice. Even problems with just a few hundred
facts can exhaust the computational resources of any computer unless it has some guidance
as to which reasoning steps to try first. Although both of these obstacles apply to any attempt
to build computational reasoning systems, they appeared first in the logicist tradition.
1.1.4 Acting rationally: The rational agent approach
AGENT An agent is just something that acts (agent comes from the Latin agere, to do). Of course,
all computer programs do something, but computer agents are expected to do more: operate
autonomously, perceive their environment, persist over a prolonged time period, adapt to
RATIONAL AGENT change, and create and pursue goals. A rational agent is one that acts so as to achieve the
best outcome or, when there is uncertainty, the best expected outcome.
In the “laws of thought” approach to AI, the emphasis was on correct inferences. Making correct inferences is sometimes part of being a rational agent, because one way to act
rationally is to reason logically to the conclusion that a given action will achieve one’s goals
and then to act on that conclusion. On the other hand, correct inference is not all of rationality; in some situations, there is no provably correct thing to do, but something must still be
done. There are also ways of acting rationally that cannot be said to involve inference. For
example, recoiling from a hot stove is a reflex action that is usually more successful than a
slower action taken after careful deliberation.
All the skills needed for the Turing Test also allow an agent to act rationally. Knowledge
representation and reasoning enable agents to reach good decisions. We need to be able to
generate comprehensible sentences in natural language to get by in a complex society. We
need learning not only for erudition, but also because it improves our ability to generate
effective behavior.
The rational-agent approach has two advantages over the other approaches. First, it
is more general than the “laws of thought” approach because correct inference is just one
of several possible mechanisms for achieving rationality. Second, it is more amenable to
Section 1.2. The Foundations of Artificial Intelligence 5
scientific development than are approaches based on human behavior or human thought. The
standard of rationality is mathematically well defined and completely general, and can be
“unpacked” to generate agent designs that provably achieve it. Human behavior, on the other
hand, is well adapted for one specific environment and is defined by, well, the sum total
of all the things that humans do. This book therefore concentrates on general principles
of rational agents and on components for constructing them. We will see that despite the
apparent simplicity with which the problem can be stated, an enormous variety of issues
come up when we try to solve it. Chapter 2 outlines some of these issues in more detail.
One important point to keep in mind: We will see before too long that achieving perfect
rationality—always doing the right thing—is not feasible in complicated environments. The
computational demands are just too high. For most of the book, however, we will adopt the
working hypothesis that perfect rationality is a good starting point for analysis. It simplifies
the problem and provides the appropriate setting for most of the foundational material in
the field. Chapters 5 and 17 deal explicitly with the issue of limited rationality—acting LIMITED
RATIONALITY
appropriately when there is not enough time to do all the computations one might like.
1.2 THE FOUNDATIONS OF ARTIFICIAL INTELLIGENCE
In this section, we provide a brief history of the disciplines that contributed ideas, viewpoints,
and techniques to AI. Like any history, this one is forced to concentrate on a small number
of people, events, and ideas and to ignore others that also were important. We organize the
history around a series of questions. We certainly would not wish to give the impression that
these questions are the only ones the disciplines address or that the disciplines have all been
working toward AI as their ultimate fruition.
1.2.1 Philosophy
• Can formal rules be used to draw valid conclusions?
• How does the mind arise from a physical brain?
• Where does knowledge come from?
• How does knowledge lead to action?
Aristotle (384–322 B.C.), whose bust appears on the front cover of this book, was the first
to formulate a precise set of laws governing the rational part of the mind. He developed an
informal system of syllogisms for proper reasoning, which in principle allowed one to generate conclusions mechanically, given initial premises. Much later, Ramon Lull (d. 1315) had
the idea that useful reasoning could actually be carried out by a mechanical artifact. Thomas
Hobbes (1588–1679) proposed that reasoning was like numerical computation, that “we add
and subtract in our silent thoughts.” The automation of computation itself was already well
under way. Around 1500, Leonardo da Vinci (1452–1519) designed but did not build a mechanical calculator; recent reconstructions have shown the design to be functional. The first
known calculating machine was constructed around 1623 by the German scientist Wilhelm
Schickard (1592–1635), although the Pascaline, built in 1642 by Blaise Pascal (1623–1662),
6 Chapter 1. Introduction
is more famous. Pascal wrote that “the arithmetical machine produces effects which appear
nearer to thought than all the actions of animals.” Gottfried Wilhelm Leibniz (1646–1716)
built a mechanical device intended to carry out operations on concepts rather than numbers,
but its scope was rather limited. Leibniz did surpass Pascal by building a calculator that
could add, subtract, multiply, and take roots, whereas the Pascaline could only add and subtract. Some speculated that machines might not just do calculations but actually be able to
think and act on their own. In his 1651 book Leviathan, Thomas Hobbes suggested the idea
of an “artificial animal,” arguing “For what is the heart but a spring; and the nerves, but so
many strings; and the joints, but so many wheels.”
It’s one thing to say that the mind operates, at least in part, according to logical rules, and
to build physical systems that emulate some of those rules; it’s another to say that the mind
itself is such a physical system. Ren´e Descartes (1596–1650) gave the first clear discussion
of the distinction between mind and matter and of the problems that arise. One problem with
a purely physical conception of the mind is that it seems to leave little room for free will:
if the mind is governed entirely by physical laws, then it has no more free will than a rock
“deciding” to fall toward the center of the earth. Descartes was a strong advocate of the power
RATIONALISM of reasoning in understanding the world, a philosophy now called rationalism, and one that
DUALISM counts Aristotle and Leibnitz as members. But Descartes was also a proponent of dualism.
He held that there is a part of the human mind (or soul or spirit) that is outside of nature,
exempt from physical laws. Animals, on the other hand, did not possess this dual quality;
MATERIALISM they could be treated as machines. An alternative to dualism is materialism, which holds
that the brain’s operation according to the laws of physics constitutes the mind. Free will is
simply the way that the perception of available choices appears to the choosing entity.
Given a physical mind that manipulates knowledge, the next problem is to establish
EMPIRICISM the source of knowledge. The empiricism movement, starting with Francis Bacon’s (1561–
1626) Novum Organum,
2 is characterized by a dictum of John Locke (1632–1704): “Nothing
is in the understanding, which was not first in the senses.” David Hume’s (1711–1776) A
Treatise of Human Nature (Hume, 1739) proposed what is now known as the principle of
INDUCTION induction: that general rules are acquired by exposure to repeated associations between their
elements. Building on the work of Ludwig Wittgenstein (1889–1951) and Bertrand Russell
(1872–1970), the famous Vienna Circle, led by Rudolf Carnap (1891–1970), developed the
LOGICAL POSITIVISM doctrine of logical positivism. This doctrine holds that all knowledge can be characterized by
logical theories connected, ultimately, to observation sentences that correspond to sensory OBSERVATION
SENTENCES
inputs; thus logical positivism combines rationalism and empiricism.3 The confirmation theory of Carnap and Carl Hempel (1905–1997) attempted to analyze the acquisition of knowl- CONFIRMATION
THEORY
edge from experience. Carnap’s book The Logical Structure of the World (1928) defined an
explicit computational procedure for extracting knowledge from elementary experiences. It
was probably the first theory of mind as a computational process.
2 The Novum Organum is an update of Aristotle’s Organon, or instrument of thought. Thus Aristotle can be
seen as both an empiricist and a rationalist.
3 In this picture, all meaningful statements can be verified or falsified either by experimentation or by analysis
of the meaning of the words. Because this rules out most of metaphysics, as was the intention, logical positivism
was unpopular in some circles.
Section 1.2. The Foundations of Artificial Intelligence 7
The final element in the philosophical picture of the mind is the connection between
knowledge and action. This question is vital to AI because intelligence requires action as well
as reasoning. Moreover, only by understanding how actions are justified can we understand
how to build an agent whose actions are justifiable (or rational). Aristotle argued (in De Motu
Animalium) that actions are justified by a logical connection between goals and knowledge of
the action’s outcome (the last part of this extract also appears on the front cover of this book,
in the original Greek):
But how does it happen that thinking is sometimes accompanied by action and sometimes
not, sometimes by motion, and sometimes not? It looks as if almost the same thing
happens as in the case of reasoning and making inferences about unchanging objects. But
in that case the end is a speculative proposition ... whereas here the conclusion which
results from the two premises is an action. ... I need covering; a cloak is a covering. I
need a cloak. What I need, I have to make; I need a cloak. I have to make a cloak. And
the conclusion, the “I have to make a cloak,” is an action.
In the Nicomachean Ethics (Book III. 3, 1112b), Aristotle further elaborates on this topic,
suggesting an algorithm:
We deliberate not about ends, but about means. For a doctor does not deliberate whether
he shall heal, nor an orator whether he shall persuade, ... They assume the end and
consider how and by what means it is attained, and if it seems easily and best produced
thereby; while if it is achieved by one means only they consider how it will be achieved
by this and by what means this will be achieved, till they come to the first cause, ... and
what is last in the order of analysis seems to be first in the order of becoming. And if we
come on an impossibility, we give up the search, e.g., if we need money and this cannot
be got; but if a thing appears possible we try to do it.
Aristotle’s algorithm was implemented 2300 years later by Newell and Simon in their GPS
program. We would now call it a regression planning system (see Chapter 10).
Goal-based analysis is useful, but does not say what to do when several actions will
achieve the goal or when no action will achieve it completely. Antoine Arnauld (1612–1694)
correctly described a quantitative formula for deciding what action to take in cases like this
(see Chapter 16). John Stuart Mill’s (1806–1873) book Utilitarianism (Mill, 1863) promoted
the idea of rational decision criteria in all spheres of human activity. The more formal theory
of decisions is discussed in the following section.
1.2.2 Mathematics
• What are the formal rules to draw valid conclusions?
• What can be computed?
• How do we reason with uncertain information?
Philosophers staked out some of the fundamental ideas of AI, but the leap to a formal science
required a level of mathematical formalization in three fundamental areas: logic, computation, and probability.
The idea of formal logic can be traced back to the philosophers of ancient Greece, but
its mathematical development really began with the work of George Boole (1815–1864), who
8 Chapter 1. Introduction
worked out the details of propositional, or Boolean, logic (Boole, 1847). In 1879, Gottlob
Frege (1848–1925) extended Boole’s logic to include objects and relations, creating the firstorder logic that is used today.4 Alfred Tarski (1902–1983) introduced a theory of reference
that shows how to relate the objects in a logic to objects in the real world.
The next step was to determine the limits of what could be done with logic and comALGORITHM putation. The first nontrivial algorithm is thought to be Euclid’s algorithm for computing
greatest common divisors. The word algorithm (and the idea of studying them) comes from
al-Khowarazmi, a Persian mathematician of the 9th century, whose writings also introduced
Arabic numerals and algebra to Europe. Boole and others discussed algorithms for logical
deduction, and, by the late 19th century, efforts were under way to formalize general mathematical reasoning as logical deduction. In 1930, Kurt G¨odel (1906–1978) showed that there
exists an effective procedure to prove any true statement in the first-order logic of Frege and
Russell, but that first-order logic could not capture the principle of mathematical induction
needed to characterize the natural numbers. In 1931, G¨odel showed that limits on deduction do exist. His incompleteness theorem showed that in any formal theory as strong as INCOMPLETENESS
THEOREM
Peano arithmetic (the elementary theory of natural numbers), there are true statements that
are undecidable in the sense that they have no proof within the theory.
This fundamental result can also be interpreted as showing that some functions on the
integers cannot be represented by an algorithm—that is, they cannot be computed. This
motivated Alan Turing (1912–1954) to try to characterize exactly which functions are comCOMPUTABLE putable—capable of being computed. This notion is actually slightly problematic because
the notion of a computation or effective procedure really cannot be given a formal definition.
However, the Church–Turing thesis, which states that the Turing machine (Turing, 1936) is
capable of computing any computable function, is generally accepted as providing a sufficient
definition. Turing also showed that there were some functions that no Turing machine can
compute. For example, no machine can tell in general whether a given program will return
an answer on a given input or run forever.
Although decidability and computability are important to an understanding of computaTRACTABILITY tion, the notion of tractability has had an even greater impact. Roughly speaking, a problem
is called intractable if the time required to solve instances of the problem grows exponentially
with the size of the instances. The distinction between polynomial and exponential growth
in complexity was first emphasized in the mid-1960s (Cobham, 1964; Edmonds, 1965). It is
important because exponential growth means that even moderately large instances cannot be
solved in any reasonable time. Therefore, one should strive to divide the overall problem of
generating intelligent behavior into tractable subproblems rather than intractable ones.
NP-COMPLETENESS How can one recognize an intractable problem? The theory of NP-completeness, pioneered by Steven Cook (1971) and Richard Karp (1972), provides a method. Cook and Karp
showed the existence of large classes of canonical combinatorial search and reasoning problems that are NP-complete. Any problem class to which the class of NP-complete problems
can be reduced is likely to be intractable. (Although it has not been proved that NP-complete
4 Frege’s proposed notation for first-order logic—an arcane combination of textual and geometric features—
never became popular.
Section 1.2. The Foundations of Artificial Intelligence 9
problems are necessarily intractable, most theoreticians believe it.) These results contrast
with the optimism with which the popular press greeted the first computers—“Electronic
Super-Brains” that were “Faster than Einstein!” Despite the increasing speed of computers,
careful use of resources will characterize intelligent systems. Put crudely, the world is an
extremely large problem instance! Work in AI has helped explain why some instances of
NP-complete problems are hard, yet others are easy (Cheeseman et al., 1991).
Besides logic and computation, the third great contribution of mathematics to AI is the
PROBABILITY theory of probability. The Italian Gerolamo Cardano (1501–1576) first framed the idea of
probability, describing it in terms of the possible outcomes of gambling events. In 1654,
Blaise Pascal (1623–1662), in a letter to Pierre Fermat (1601–1665), showed how to predict the future of an unfinished gambling game and assign average payoffs to the gamblers.
Probability quickly became an invaluable part of all the quantitative sciences, helping to deal
with uncertain measurements and incomplete theories. James Bernoulli (1654–1705), Pierre
Laplace (1749–1827), and others advanced the theory and introduced new statistical methods. Thomas Bayes (1702–1761), who appears on the front cover of this book, proposed
a rule for updating probabilities in the light of new evidence. Bayes’ rule underlies most
modern approaches to uncertain reasoning in AI systems.
1.2.3 Economics
• How should we make decisions so as to maximize payoff?
• How should we do this when others may not go along?
• How should we do this when the payoff may be far in the future?
The science of economics got its start in 1776, when Scottish philosopher Adam Smith
(1723–1790) published An Inquiry into the Nature and Causes of the Wealth of Nations.
While the ancient Greeks and others had made contributions to economic thought, Smith was
the first to treat it as a science, using the idea that economies can be thought of as consisting of individual agents maximizing their own economic well-being. Most people think of
economics as being about money, but economists will say that they are really studying how
people make choices that lead to preferred outcomes. When McDonald’s offers a hamburger
for a dollar, they are asserting that they would prefer the dollar and hoping that customers will
UTILITY prefer the hamburger. The mathematical treatment of “preferred outcomes” or utility was
first formalized by L´eon Walras (pronounced “Valrasse”) (1834-1910) and was improved by
Frank Ramsey (1931) and later by John von Neumann and Oskar Morgenstern in their book
The Theory of Games and Economic Behavior (1944).
DECISION THEORY Decision theory, which combines probability theory with utility theory, provides a formal and complete framework for decisions (economic or otherwise) made under uncertainty—
that is, in cases where probabilistic descriptions appropriately capture the decision maker’s
environment. This is suitable for “large” economies where each agent need pay no attention
to the actions of other agents as individuals. For “small” economies, the situation is much
more like a game: the actions of one player can significantly affect the utility of another
(either positively or negatively). Von Neumann and Morgenstern’s development of game
GAME THEORY theory (see also Luce and Raiffa, 1957) included the surprising result that, for some games,
10 Chapter 1. Introduction
a rational agent should adopt policies that are (or least appear to be) randomized. Unlike decision theory, game theory does not offer an unambiguous prescription for selecting actions.
For the most part, economists did not address the third question listed above, namely,
how to make rational decisions when payoffs from actions are not immediate but instead result from several actions taken in sequence. This topic was pursued in the field of operations
research, which emerged in World War II from efforts in Britain to optimize radar installa- OPERATIONS
RESEARCH
tions, and later found civilian applications in complex management decisions. The work of
Richard Bellman (1957) formalized a class of sequential decision problems called Markov
decision processes, which we study in Chapters 17 and 21.
Work in economics and operations research has contributed much to our notion of rational agents, yet for many years AI research developed along entirely separate paths. One
reason was the apparent complexity of making rational decisions. The pioneering AI researcher Herbert Simon (1916–2001) won the Nobel Prize in economics in 1978 for his early
SATISFICING work showing that models based on satisficing—making decisions that are “good enough,”
rather than laboriously calculating an optimal decision—gave a better description of actual
human behavior (Simon, 1947). Since the 1990s, there has been a resurgence of interest in
decision-theoretic techniques for agent systems (Wellman, 1995).
1.2.4 Neuroscience
• How do brains process information?
NEUROSCIENCE Neuroscience is the study of the nervous system, particularly the brain. Although the exact
way in which the brain enables thought is one of the great mysteries of science, the fact that it
does enable thought has been appreciated for thousands of years because of the evidence that
strong blows to the head can lead to mental incapacitation. It has also long been known that
human brains are somehow different; in about 335 B.C. Aristotle wrote, “Of all the animals,
man has the largest brain in proportion to his size.”5 Still, it was not until the middle of the
18th century that the brain was widely recognized as the seat of consciousness. Before then,
candidate locations included the heart and the spleen.
Paul Broca’s (1824–1880) study of aphasia (speech deficit) in brain-damaged patients
in 1861 demonstrated the existence of localized areas of the brain responsible for specific
cognitive functions. In particular, he showed that speech production was localized to the
portion of the left hemisphere now called Broca’s area.6 By that time, it was known that
NEURON the brain consisted of nerve cells, or neurons, but it was not until 1873 that Camillo Golgi
(1843–1926) developed a staining technique allowing the observation of individual neurons
in the brain (see Figure 1.2). This technique was used by Santiago Ramon y Cajal (1852–
1934) in his pioneering studies of the brain’s neuronal structures.7 Nicolas Rashevsky (1936,
1938) was the first to apply mathematical models to the study of the nervous sytem.
5 Since then, it has been discovered that the tree shrew (Scandentia) has a higher ratio of brain to body mass.
6 Many cite Alexander Hood (1824) as a possible prior source.
7 Golgi persisted in his belief that the brain’s functions were carried out primarily in a continuous medium in
which neurons were embedded, whereas Cajal propounded the “neuronal doctrine.” The two shared the Nobel
prize in 1906 but gave mutually antagonistic acceptance speeches.
Section 1.2. The Foundations of Artificial Intelligence 11
Axon
Cell body or Soma
Nucleus
Dendrite
Synapses
Axonal arborization
Axon from another cell
Synapse
Figure 1.2 The parts of a nerve cell or neuron. Each neuron consists of a cell body,
or soma, that contains a cell nucleus. Branching out from the cell body are a number of
fibers called dendrites and a single long fiber called the axon. The axon stretches out for a
long distance, much longer than the scale in this diagram indicates. Typically, an axon is
1 cm long (100 times the diameter of the cell body), but can reach up to 1 meter. A neuron
makes connections with 10 to 100,000 other neurons at junctions called synapses. Signals are
propagated from neuron to neuron by a complicated electrochemical reaction. The signals
control brain activity in the short term and also enable long-term changes in the connectivity
of neurons. These mechanisms are thought to form the basis for learning in the brain. Most
information processing goes on in the cerebral cortex, the outer layer of the brain. The basic
organizational unit appears to be a column of tissue about 0.5 mm in diameter, containing
about 20,000 neurons and extending the full depth of the cortex about 4 mm in humans).
We now have some data on the mapping between areas of the brain and the parts of the
body that they control or from which they receive sensory input. Such mappings are able to
change radically over the course of a few weeks, and some animals seem to have multiple
maps. Moreover, we do not fully understand how other areas can take over functions when
one area is damaged. There is almost no theory on how an individual memory is stored.
The measurement of intact brain activity began in 1929 with the invention by Hans
Berger of the electroencephalograph (EEG). The recent development of functional magnetic
resonance imaging (fMRI) (Ogawa et al., 1990; Cabeza and Nyberg, 2001) is giving neuroscientists unprecedentedly detailed images of brain activity, enabling measurements that
correspond in interesting ways to ongoing cognitive processes. These are augmented by
advances in single-cell recording of neuron activity. Individual neurons can be stimulated
electrically, chemically, or even optically (Han and Boyden, 2007), allowing neuronal input–
output relationships to be mapped. Despite these advances, we are still a long way from
understanding how cognitive processes actually work.
The truly amazing conclusion is that a collection of simple cells can lead to thought,
action, and consciousness or, in the pithy words of John Searle (1992), brains cause minds.
12 Chapter 1. Introduction
Supercomputer Personal Computer Human Brain
Computational units 104 CPUs, 1012 transistors 4 CPUs, 109 transistors 1011 neurons
Storage units 1014 bits RAM 1011 bits RAM 1011 neurons
1015 bits disk 1013 bits disk 1014 synapses
Cycle time 10−9 sec 10−9 sec 10−3 sec
Operations/sec 1015 1010 1017
Memory updates/sec 1014 1010 1014
Figure 1.3 A crude comparison of the raw computational resources available to the IBM
BLUE GENE supercomputer, a typical personal computer of 2008, and the human brain. The
brain’s numbers are essentially fixed, whereas the supercomputer’s numbers have been increasing by a factor of 10 every 5 years or so, allowing it to achieve rough parity with the
brain. The personal computer lags behind on all metrics except cycle time.
The only real alternative theory is mysticism: that minds operate in some mystical realm that
is beyond physical science.
Brains and digital computers have somewhat different properties. Figure 1.3 shows that
computers have a cycle time that is a million times faster than a brain. The brain makes up
for that with far more storage and interconnection than even a high-end personal computer,
although the largest supercomputers have a capacity that is similar to the brain’s. (It should
be noted, however, that the brain does not seem to use all of its neurons simultaneously.)
SINGULARITY Futurists make much of these numbers, pointing to an approaching singularity at which
computers reach a superhuman level of performance (Vinge, 1993; Kurzweil, 2005), but the
raw comparisons are not especially informative. Even with a computer of virtually unlimited
capacity, we still would not know how to achieve the brain’s level of intelligence.
1.2.5 Psychology
• How do humans and animals think and act?
The origins of scientific psychology are usually traced to the work of the German physicist Hermann von Helmholtz (1821–1894) and his student Wilhelm Wundt (1832–1920).
Helmholtz applied the scientific method to the study of human vision, and his Handbook
of Physiological Optics is even now described as “the single most important treatise on the
physics and physiology of human vision” (Nalwa, 1993, p.15). In 1879, Wundt opened the
first laboratory of experimental psychology, at the University of Leipzig. Wundt insisted
on carefully controlled experiments in which his workers would perform a perceptual or associative task while introspecting on their thought processes. The careful controls went a
long way toward making psychology a science, but the subjective nature of the data made
it unlikely that an experimenter would ever disconfirm his or her own theories. Biologists
studying animal behavior, on the other hand, lacked introspective data and developed an objective methodology, as described by H. S. Jennings (1906) in his influential work Behavior of
BEHAVIORISM the Lower Organisms. Applying this viewpoint to humans, the behaviorism movement, led
by John Watson (1878–1958), rejected any theory involving mental processes on the grounds
Section 1.2. The Foundations of Artificial Intelligence 13
that introspection could not provide reliable evidence. Behaviorists insisted on studying only
objective measures of the percepts (or stimulus) given to an animal and its resulting actions
(or response). Behaviorism discovered a lot about rats and pigeons but had less success at
understanding humans.
Cognitive psychology, which views the brain as an information-processing device, COGNITIVE
PSYCHOLOGY
can be traced back at least to the works of William James (1842–1910). Helmholtz also
insisted that perception involved a form of unconscious logical inference. The cognitive
viewpoint was largely eclipsed by behaviorism in the United States, but at Cambridge’s Applied Psychology Unit, directed by Frederic Bartlett (1886–1969), cognitive modeling was
able to flourish. The Nature of Explanation, by Bartlett’s student and successor Kenneth
Craik (1943), forcefully reestablished the legitimacy of such “mental” terms as beliefs and
goals, arguing that they are just as scientific as, say, using pressure and temperature to talk
about gases, despite their being made of molecules that have neither. Craik specified the
three key steps of a knowledge-based agent: (1) the stimulus must be translated into an internal representation, (2) the representation is manipulated by cognitive processes to derive new
internal representations, and (3) these are in turn retranslated back into action. He clearly
explained why this was a good design for an agent:
If the organism carries a “small-scale model” of external reality and of its own possible
actions within its head, it is able to try out various alternatives, conclude which is the best
of them, react to future situations before they arise, utilize the knowledge of past events
in dealing with the present and future, and in every way to react in a much fuller, safer,
and more competent manner to the emergencies which face it. (Craik, 1943)
After Craik’s death in a bicycle accident in 1945, his work was continued by Donald Broadbent, whose book Perception and Communication (1958) was one of the first works to model
psychological phenomena as information processing. Meanwhile, in the United States, the
development of computer modeling led to the creation of the field of cognitive science. The
field can be said to have started at a workshop in September 1956 at MIT. (We shall see that
this is just two months after the conference at which AI itself was “born.”) At the workshop,
George Miller presented The Magic Number Seven, Noam Chomsky presented Three Models
of Language, and Allen Newell and Herbert Simon presented The Logic Theory Machine.
These three influential papers showed how computer models could be used to address the
psychology of memory, language, and logical thinking, respectively. It is now a common
(although far from universal) view among psychologists that “a cognitive theory should be
like a computer program” (Anderson, 1980); that is, it should describe a detailed informationprocessing mechanism whereby some cognitive function might be implemented.
1.2.6 Computer engineering
• How can we build an efficient computer?
For artificial intelligence to succeed, we need two things: intelligence and an artifact. The
computer has been the artifact of choice. The modern digital electronic computer was invented independently and almost simultaneously by scientists in three countries embattled in
14 Chapter 1. Introduction
World War II. The first operational computer was the electromechanical Heath Robinson,8
built in 1940 by Alan Turing’s team for a single purpose: deciphering German messages. In
1943, the same group developed the Colossus, a powerful general-purpose machine based
on vacuum tubes.9 The first operational programmable computer was the Z-3, the invention of Konrad Zuse in Germany in 1941. Zuse also invented floating-point numbers and the
first high-level programming language, Plankalk¨ul. The first electronic computer, the ABC,
was assembled by John Atanasoff and his student Clifford Berry between 1940 and 1942
at Iowa State University. Atanasoff’s research received little support or recognition; it was
the ENIAC, developed as part of a secret military project at the University of Pennsylvania
by a team including John Mauchly and John Eckert, that proved to be the most influential
forerunner of modern computers.
Since that time, each generation of computer hardware has brought an increase in speed
and capacity and a decrease in price. Performance doubled every 18 months or so until around
2005, when power dissipation problems led manufacturers to start multiplying the number of
CPU cores rather than the clock speed. Current expectations are that future increases in power
will come from massive parallelism—a curious convergence with the properties of the brain.
Of course, there were calculating devices before the electronic computer. The earliest
automated machines, dating from the 17th century, were discussed on page 6. The first programmable machine was a loom, devised in 1805 by Joseph Marie Jacquard (1752–1834),
that used punched cards to store instructions for the pattern to be woven. In the mid-19th
century, Charles Babbage (1792–1871) designed two machines, neither of which he completed. The Difference Engine was intended to compute mathematical tables for engineering
and scientific projects. It was finally built and shown to work in 1991 at the Science Museum
in London (Swade, 2000). Babbage’s Analytical Engine was far more ambitious: it included
addressable memory, stored programs, and conditional jumps and was the first artifact capable of universal computation. Babbage’s colleague Ada Lovelace, daughter of the poet Lord
Byron, was perhaps the world’s first programmer. (The programming language Ada is named
after her.) She wrote programs for the unfinished Analytical Engine and even speculated that
the machine could play chess or compose music.
AI also owes a debt to the software side of computer science, which has supplied the
operating systems, programming languages, and tools needed to write modern programs (and
papers about them). But this is one area where the debt has been repaid: work in AI has pioneered many ideas that have made their way back to mainstream computer science, including
time sharing, interactive interpreters, personal computers with windows and mice, rapid development environments, the linked list data type, automatic storage management, and key
concepts of symbolic, functional, declarative, and object-oriented programming.
8 Heath Robinson was a cartoonist famous for his depictions of whimsical and absurdly complicated contraptions for everyday tasks such as buttering toast.
9 In the postwar period, Turing wanted to use these computers for AI research—for example, one of the first
chess programs (Turing et al., 1953). His efforts were blocked by the British government.
Section 1.2. The Foundations of Artificial Intelligence 15
1.2.7 Control theory and cybernetics
• How can artifacts operate under their own control?
Ktesibios of Alexandria (c. 250 B.C.) built the first self-controlling machine: a water clock
with a regulator that maintained a constant flow rate. This invention changed the definition
of what an artifact could do. Previously, only living things could modify their behavior in
response to changes in the environment. Other examples of self-regulating feedback control
systems include the steam engine governor, created by James Watt (1736–1819), and the
thermostat, invented by Cornelis Drebbel (1572–1633), who also invented the submarine.
The mathematical theory of stable feedback systems was developed in the 19th century.
CONTROL THEORY The central figure in the creation of what is now called control theory was Norbert
Wiener (1894–1964). Wiener was a brilliant mathematician who worked with Bertrand Russell, among others, before developing an interest in biological and mechanical control systems
and their connection to cognition. Like Craik (who also used control systems as psychological
models), Wiener and his colleagues Arturo Rosenblueth and Julian Bigelow challenged the
behaviorist orthodoxy (Rosenblueth et al., 1943). They viewed purposive behavior as arising from a regulatory mechanism trying to minimize “error”—the difference between current
state and goal state. In the late 1940s, Wiener, along with Warren McCulloch, Walter Pitts,
and John von Neumann, organized a series of influential conferences that explored the new
CYBERNETICS mathematical and computational models of cognition. Wiener’s book Cybernetics (1948) became a bestseller and awoke the public to the possibility of artificially intelligent machines.
Meanwhile, in Britain, W. Ross Ashby (Ashby, 1940) pioneered similar ideas. Ashby, Alan
Turing, Grey Walter, and others formed the Ratio Club for “those who had Wiener’s ideas
before Wiener’s book appeared.” Ashby’s Design for a Brain (1948, 1952) elaborated on his
HOMEOSTATIC idea that intelligence could be created by the use of homeostatic devices containing appropriate feedback loops to achieve stable adaptive behavior.
Modern control theory, especially the branch known as stochastic optimal control, has
as its goal the design of systems that maximize an objective function over time. This roughly OBJECTIVE
FUNCTION
matches our view of AI: designing systems that behave optimally. Why, then, are AI and
control theory two different fields, despite the close connections among their founders? The
answer lies in the close coupling between the mathematical techniques that were familiar to
the participants and the corresponding sets of problems that were encompassed in each world
view. Calculus and matrix algebra, the tools of control theory, lend themselves to systems that
are describable by fixed sets of continuous variables, whereas AI was founded in part as a way
to escape from the these perceived limitations. The tools of logical inference and computation
allowed AI researchers to consider problems such as language, vision, and planning that fell
completely outside the control theorist’s purview.
1.2.8 Linguistics
• How does language relate to thought?
In 1957, B. F. Skinner published Verbal Behavior. This was a comprehensive, detailed account of the behaviorist approach to language learning, written by the foremost expert in
16 Chapter 1. Introduction
the field. But curiously, a review of the book became as well known as the book itself, and
served to almost kill off interest in behaviorism. The author of the review was the linguist
Noam Chomsky, who had just published a book on his own theory, Syntactic Structures.
Chomsky pointed out that the behaviorist theory did not address the notion of creativity in
language—it did not explain how a child could understand and make up sentences that he or
she had never heard before. Chomsky’s theory—based on syntactic models going back to the
Indian linguist Panini (c. 350 B.C.)—could explain this, and unlike previous theories, it was
formal enough that it could in principle be programmed.
Modern linguistics and AI, then, were “born” at about the same time, and grew up
together, intersecting in a hybrid field called computational linguistics or natural language COMPUTATIONAL
LINGUISTICS
processing. The problem of understanding language soon turned out to be considerably more
complex than it seemed in 1957. Understanding language requires an understanding of the
subject matter and context, not just an understanding of the structure of sentences. This might
seem obvious, but it was not widely appreciated until the 1960s. Much of the early work in
knowledge representation (the study of how to put knowledge into a form that a computer
can reason with) was tied to language and informed by research in linguistics, which was
connected in turn to decades of work on the philosophical analysis of language.
1.3 THE HISTORY OF ARTIFICIAL INTELLIGENCE
With the background material behind us, we are ready to cover the development of AI itself.
1.3.1 The gestation of artificial intelligence (1943–1955)
The first work that is now generally recognized as AI was done by Warren McCulloch and
Walter Pitts (1943). They drew on three sources: knowledge of the basic physiology and
function of neurons in the brain; a formal analysis of propositional logic due to Russell and
Whitehead; and Turing’s theory of computation. They proposed a model of artificial neurons
in which each neuron is characterized as being “on” or “off,” with a switch to “on” occurring
in response to stimulation by a sufficient number of neighboring neurons. The state of a
neuron was conceived of as “factually equivalent to a proposition which proposed its adequate
stimulus.” They showed, for example, that any computable function could be computed by
some network of connected neurons, and that all the logical connectives (and, or, not, etc.)
could be implemented by simple net structures. McCulloch and Pitts also suggested that
suitably defined networks could learn. Donald Hebb (1949) demonstrated a simple updating
rule for modifying the connection strengths between neurons. His rule, now called Hebbian
HEBBIAN LEARNING learning, remains an influential model to this day.
Two undergraduate students at Harvard, Marvin Minsky and Dean Edmonds, built the
first neural network computer in 1950. The SNARC, as it was called, used 3000 vacuum
tubes and a surplus automatic pilot mechanism from a B-24 bomber to simulate a network of
40 neurons. Later, at Princeton, Minsky studied universal computation in neural networks.
His Ph.D. committee was skeptical about whether this kind of work should be considered
Section 1.3. The History of Artificial Intelligence 17
mathematics, but von Neumann reportedly said, “If it isn’t now, it will be someday.” Minsky
was later to prove influential theorems showing the limitations of neural network research.
There were a number of early examples of work that can be characterized as AI, but
Alan Turing’s vision was perhaps the most influential. He gave lectures on the topic as early
as 1947 at the London Mathematical Society and articulated a persuasive agenda in his 1950
article “Computing Machinery and Intelligence.” Therein, he introduced the Turing Test,
machine learning, genetic algorithms, and reinforcement learning. He proposed the Child
Programme idea, explaining “Instead of trying to produce a programme to simulate the adult
mind, why not rather try to produce one which simulated the child’s?”
1.3.2 The birth of artificial intelligence (1956)
Princeton was home to another influential figure in AI, John McCarthy. After receiving his
PhD there in 1951 and working for two years as an instructor, McCarthy moved to Stanford and then to Dartmouth College, which was to become the official birthplace of the field.
McCarthy convinced Minsky, Claude Shannon, and Nathaniel Rochester to help him bring
together U.S. researchers interested in automata theory, neural nets, and the study of intelligence. They organized a two-month workshop at Dartmouth in the summer of 1956. The
proposal states:10
We propose that a 2 month, 10 man study of artificial intelligence be carried
out during the summer of 1956 at Dartmouth College in Hanover, New Hampshire. The study is to proceed on the basis of the conjecture that every aspect of
learning or any other feature of intelligence can in principle be so precisely described that a machine can be made to simulate it. An attempt will be made to find
how to make machines use language, form abstractions and concepts, solve kinds
of problems now reserved for humans, and improve themselves. We think that a
significant advance can be made in one or more of these problems if a carefully
selected group of scientists work on it together for a summer.
There were 10 attendees in all, including Trenchard More from Princeton, Arthur Samuel
from IBM, and Ray Solomonoff and Oliver Selfridge from MIT.
Two researchers from Carnegie Tech,11 Allen Newell and Herbert Simon, rather stole
the show. Although the others had ideas and in some cases programs for particular applications such as checkers, Newell and Simon already had a reasoning program, the Logic
Theorist (LT), about which Simon claimed, “We have invented a computer program capable
of thinking non-numerically, and thereby solved the venerable mind–body problem.”12 Soon
after the workshop, the program was able to prove most of the theorems in Chapter 2 of Rus10 This was the first official usage of McCarthy’s term artificial intelligence. Perhaps “computational rationality”
would have been more precise and less threatening, but “AI” has stuck. At the 50th anniversary of the Dartmouth
conference, McCarthy stated that he resisted the terms “computer” or “computational” in deference to Norbert
Weiner, who was promoting analog cybernetic devices rather than digital computers.
11 Now Carnegie Mellon University (CMU).
12 Newell and Simon also invented a list-processing language, IPL, to write LT. They had no compiler and
translated it into machine code by hand. To avoid errors, they worked in parallel, calling out binary numbers to
each other as they wrote each instruction to make sure they agreed.
18 Chapter 1. Introduction
sell and Whitehead’s Principia Mathematica. Russell was reportedly delighted when Simon
showed him that the program had come up with a proof for one theorem that was shorter than
the one in Principia. The editors of the Journal of Symbolic Logic were less impressed; they
rejected a paper coauthored by Newell, Simon, and Logic Theorist.
The Dartmouth workshop did not lead to any new breakthroughs, but it did introduce
all the major figures to each other. For the next 20 years, the field would be dominated by
these people and their students and colleagues at MIT, CMU, Stanford, and IBM.
Looking at the proposal for the Dartmouth workshop (McCarthy et al., 1955), we can
see why it was necessary for AI to become a separate field. Why couldn’t all the work done
in AI have taken place under the name of control theory or operations research or decision
theory, which, after all, have objectives similar to those of AI? Or why isn’t AI a branch
of mathematics? The first answer is that AI from the start embraced the idea of duplicating
human faculties such as creativity, self-improvement, and language use. None of the other
fields were addressing these issues. The second answer is methodology. AI is the only one
of these fields that is clearly a branch of computer science (although operations research does
share an emphasis on computer simulations), and AI is the only field to attempt to build
machines that will function autonomously in complex, changing environments.
1.3.3 Early enthusiasm, great expectations (1952–1969)
The early years of AI were full of successes—in a limited way. Given the primitive computers and programming tools of the time and the fact that only a few years earlier computers
were seen as things that could do arithmetic and no more, it was astonishing whenever a computer did anything remotely clever. The intellectual establishment, by and large, preferred to
believe that “a machine can never do X.” (See Chapter 26 for a long list of X’s gathered
by Turing.) AI researchers naturally responded by demonstrating one X after another. John
McCarthy referred to this period as the “Look, Ma, no hands!” era.
Newell and Simon’s early success was followed up with the General Problem Solver,
or GPS. Unlike Logic Theorist, this program was designed from the start to imitate human
problem-solving protocols. Within the limited class of puzzles it could handle, it turned out
that the order in which the program considered subgoals and possible actions was similar to
that in which humans approached the same problems. Thus, GPS was probably the first program to embody the “thinking humanly” approach. The success of GPS and subsequent programs as models of cognition led Newell and Simon (1976) to formulate the famous physical
symbol system hypothesis, which states that “a physical symbol system has the necessary and PHYSICAL SYMBOL
SYSTEM
sufficient means for general intelligent action.” What they meant is that any system (human
or machine) exhibiting intelligence must operate by manipulating data structures composed
of symbols. We will see later that this hypothesis has been challenged from many directions.
At IBM, Nathaniel Rochester and his colleagues produced some of the first AI programs. Herbert Gelernter (1959) constructed the Geometry Theorem Prover, which was
able to prove theorems that many students of mathematics would find quite tricky. Starting
in 1952, Arthur Samuel wrote a series of programs for checkers (draughts) that eventually
learned to play at a strong amateur level. Along the way, he disproved the idea that comput-
Section 1.3. The History of Artificial Intelligence 19
ers can do only what they are told to: his program quickly learned to play a better game than
its creator. The program was demonstrated on television in February 1956, creating a strong
impression. Like Turing, Samuel had trouble finding computer time. Working at night, he
used machines that were still on the testing floor at IBM’s manufacturing plant. Chapter 5
covers game playing, and Chapter 21 explains the learning techniques used by Samuel.
John McCarthy moved from Dartmouth to MIT and there made three crucial contributions in one historic year: 1958. In MIT AI Lab Memo No. 1, McCarthy defined the high-level
LISP language Lisp, which was to become the dominant AI programming language for the next 30
years. With Lisp, McCarthy had the tool he needed, but access to scarce and expensive computing resources was also a serious problem. In response, he and others at MIT invented time
sharing. Also in 1958, McCarthy published a paper entitled Programs with Common Sense,
in which he described the Advice Taker, a hypothetical program that can be seen as the first
complete AI system. Like the Logic Theorist and Geometry Theorem Prover, McCarthy’s
program was designed to use knowledge to search for solutions to problems. But unlike the
others, it was to embody general knowledge of the world. For example, he showed how
some simple axioms would enable the program to generate a plan to drive to the airport. The
program was also designed to accept new axioms in the normal course of operation, thereby
allowing it to achieve competence in new areas without being reprogrammed. The Advice
Taker thus embodied the central principles of knowledge representation and reasoning: that
it is useful to have a formal, explicit representation of the world and its workings and to be
able to manipulate that representation with deductive processes. It is remarkable how much
of the 1958 paper remains relevant today.
1958 also marked the year that Marvin Minsky moved to MIT. His initial collaboration
with McCarthy did not last, however. McCarthy stressed representation and reasoning in formal logic, whereas Minsky was more interested in getting programs to work and eventually
developed an anti-logic outlook. In 1963, McCarthy started the AI lab at Stanford. His plan
to use logic to build the ultimate Advice Taker was advanced by J. A. Robinson’s discovery in 1965 of the resolution method (a complete theorem-proving algorithm for first-order
logic; see Chapter 9). Work at Stanford emphasized general-purpose methods for logical
reasoning. Applications of logic included Cordell Green’s question-answering and planning
systems (Green, 1969b) and the Shakey robotics project at the Stanford Research Institute
(SRI). The latter project, discussed further in Chapter 25, was the first to demonstrate the
complete integration of logical reasoning and physical activity.
Minsky supervised a series of students who chose limited problems that appeared to
MICROWORLD require intelligence to solve. These limited domains became known as microworlds. James
Slagle’s SAINT program (1963) was able to solve closed-form calculus integration problems
typical of first-year college courses. Tom Evans’s ANALOGY program (1968) solved geometric analogy problems that appear in IQ tests. Daniel Bobrow’s STUDENT program (1967)
solved algebra story problems, such as the following:
If the number of customers Tom gets is twice the square of 20 percent of the number
of advertisements he runs, and the number of advertisements he runs is 45, what is the
number of customers Tom gets?
20 Chapter 1. Introduction
Red
Green
Red
Green
Green
Blue
Blue
Red
Figure 1.4 A scene from the blocks world. SHRDLU (Winograd, 1972) has just completed
the command “Find a block which is taller than the one you are holding and put it in the box.”
The most famous microworld was the blocks world, which consists of a set of solid blocks
placed on a tabletop (or more often, a simulation of a tabletop), as shown in Figure 1.4.
A typical task in this world is to rearrange the blocks in a certain way, using a robot hand
that can pick up one block at a time. The blocks world was home to the vision project of
David Huffman (1971), the vision and constraint-propagation work of David Waltz (1975),
the learning theory of Patrick Winston (1970), the natural-language-understanding program
of Terry Winograd (1972), and the planner of Scott Fahlman (1974).
Early work building on the neural networks of McCulloch and Pitts also flourished.
The work of Winograd and Cowan (1963) showed how a large number of elements could
collectively represent an individual concept, with a corresponding increase in robustness and
parallelism. Hebb’s learning methods were enhanced by Bernie Widrow (Widrow and Hoff,
1960; Widrow, 1962), who called his networks adalines, and by Frank Rosenblatt (1962)
with his perceptrons. The perceptron convergence theorem (Block et al., 1962) says that
the learning algorithm can adjust the connection strengths of a perceptron to match any input
data, provided such a match exists. These topics are covered in Chapter 20.
1.3.4 A dose of reality (1966–1973)
From the beginning, AI researchers were not shy about making predictions of their coming
successes. The following statement by Herbert Simon in 1957 is often quoted:
It is not my aim to surprise or shock you—but the simplest way I can summarize is to say
that there are now in the world machines that think, that learn and that create. Moreover,
Section 1.3. The History of Artificial Intelligence 21
their ability to do these things is going to increase rapidly until—in a visible future—the
range of problems they can handle will be coextensive with the range to which the human
mind has been applied.
Terms such as “visible future” can be interpreted in various ways, but Simon also made
more concrete predictions: that within 10 years a computer would be chess champion, and
a significant mathematical theorem would be proved by machine. These predictions came
true (or approximately true) within 40 years rather than 10. Simon’s overconfidence was due
to the promising performance of early AI systems on simple examples. In almost all cases,
however, these early systems turned out to fail miserably when tried out on wider selections
of problems and on more difficult problems.
The first kind of difficulty arose because most early programs knew nothing of their
subject matter; they succeeded by means of simple syntactic manipulations. A typical story
occurred in early machine translation efforts, which were generously funded by the U.S. National Research Council in an attempt to speed up the translation of Russian scientific papers
in the wake of the Sputnik launch in 1957. It was thought initially that simple syntactic transformations based on the grammars of Russian and English, and word replacement from an
electronic dictionary, would suffice to preserve the exact meanings of sentences. The fact is
that accurate translation requires background knowledge in order to resolve ambiguity and
establish the content of the sentence. The famous retranslation of “the spirit is willing but
the flesh is weak” as “the vodka is good but the meat is rotten” illustrates the difficulties encountered. In 1966, a report by an advisory committee found that “there has been no machine
translation of general scientific text, and none is in immediate prospect.” All U.S. government
funding for academic translation projects was canceled. Today, machine translation is an imperfect but widely used tool for technical, commercial, government, and Internet documents.
The second kind of difficulty was the intractability of many of the problems that AI was
attempting to solve. Most of the early AI programs solved problems by trying out different
combinations of steps until the solution was found. This strategy worked initially because
microworlds contained very few objects and hence very few possible actions and very short
solution sequences. Before the theory of computational complexity was developed, it was
widely thought that “scaling up” to larger problems was simply a matter of faster hardware
and larger memories. The optimism that accompanied the development of resolution theorem
proving, for example, was soon dampened when researchers failed to prove theorems involving more than a few dozen facts. The fact that a program can find a solution in principle does
not mean that the program contains any of the mechanisms needed to find it in practice.
The illusion of unlimited computational power was not confined to problem-solving
MACHINE EVOLUTION programs. Early experiments in machine evolution (now called genetic algorithms) (FriedGENETIC
ALGORITHM berg, 1958; Friedberg et al., 1959) were based on the undoubtedly correct belief that by
making an appropriate series of small mutations to a machine-code program, one can generate a program with good performance for any particular task. The idea, then, was to try
random mutations with a selection process to preserve mutations that seemed useful. Despite thousands of hours of CPU time, almost no progress was demonstrated. Modern genetic
algorithms use better representations and have shown more success.
22 Chapter 1. Introduction
Failure to come to grips with the “combinatorial explosion” was one of the main criticisms of AI contained in the Lighthill report (Lighthill, 1973), which formed the basis for the
decision by the British government to end support for AI research in all but two universities.
(Oral tradition paints a somewhat different and more colorful picture, with political ambitions
and personal animosities whose description is beside the point.)
A third difficulty arose because of some fundamental limitations on the basic structures
being used to generate intelligent behavior. For example, Minsky and Papert’s book Perceptrons (1969) proved that, although perceptrons (a simple form of neural network) could be
shown to learn anything they were capable of representing, they could represent very little. In
particular, a two-input perceptron (restricted to be simpler than the form Rosenblatt originally
studied) could not be trained to recognize when its two inputs were different. Although their
results did not apply to more complex, multilayer networks, research funding for neural-net
research soon dwindled to almost nothing. Ironically, the new back-propagation learning algorithms for multilayer networks that were to cause an enormous resurgence in neural-net
research in the late 1980s were actually discovered first in 1969 (Bryson and Ho, 1969).
1.3.5 Knowledge-based systems: The key to power? (1969–1979)
The picture of problem solving that had arisen during the first decade of AI research was of
a general-purpose search mechanism trying to string together elementary reasoning steps to
WEAK METHOD find complete solutions. Such approaches have been called weak methods because, although
general, they do not scale up to large or difficult problem instances. The alternative to weak
methods is to use more powerful, domain-specific knowledge that allows larger reasoning
steps and can more easily handle typically occurring cases in narrow areas of expertise. One
might say that to solve a hard problem, you have to almost know the answer already.
The DENDRAL program (Buchanan et al., 1969) was an early example of this approach.
It was developed at Stanford, where Ed Feigenbaum (a former student of Herbert Simon),
Bruce Buchanan (a philosopher turned computer scientist), and Joshua Lederberg (a Nobel
laureate geneticist) teamed up to solve the problem of inferring molecular structure from the
information provided by a mass spectrometer. The input to the program consists of the elementary formula of the molecule (e.g., C6H13NO2) and the mass spectrum giving the masses
of the various fragments of the molecule generated when it is bombarded by an electron beam.
For example, the mass spectrum might contain a peak at m = 15, corresponding to the mass
of a methyl (CH3) fragment.
The naive version of the program generated all possible structures consistent with the
formula, and then predicted what mass spectrum would be observed for each, comparing this
with the actual spectrum. As one might expect, this is intractable for even moderate-sized
molecules. The DENDRAL researchers consulted analytical chemists and found that they
worked by looking for well-known patterns of peaks in the spectrum that suggested common
substructures in the molecule. For example, the following rule is used to recognize a ketone
(C=O) subgroup (which weighs 28):
if there are two peaks at x1 and x2 such that
(a) x1 + x2 = M + 28 (M is the mass of the whole molecule);
Section 1.3. The History of Artificial Intelligence 23
(b) x1 − 28 is a high peak;
(c) x2 − 28 is a high peak;
(d) At least one of x1 and x2 is high.
then there is a ketone subgroup
Recognizing that the molecule contains a particular substructure reduces the number of possible candidates enormously. DENDRAL was powerful because
All the relevant theoretical knowledge to solve these problems has been mapped over from
its general form in the [spectrum prediction component] (“first principles”) to efficient
special forms (“cookbook recipes”). (Feigenbaum et al., 1971)
The significance of DENDRAL was that it was the first successful knowledge-intensive system: its expertise derived from large numbers of special-purpose rules. Later systems also
incorporated the main theme of McCarthy’s Advice Taker approach—the clean separation of
the knowledge (in the form of rules) from the reasoning component.
With this lesson in mind, Feigenbaum and others at Stanford began the Heuristic Programming Project (HPP) to investigate the extent to which the new methodology of expert
EXPERT SYSTEMS systems could be applied to other areas of human expertise. The next major effort was in
the area of medical diagnosis. Feigenbaum, Buchanan, and Dr. Edward Shortliffe developed
MYCIN to diagnose blood infections. With about 450 rules, MYCIN was able to perform
as well as some experts, and considerably better than junior doctors. It also contained two
major differences from DENDRAL. First, unlike the DENDRAL rules, no general theoretical
model existed from which the MYCIN rules could be deduced. They had to be acquired from
extensive interviewing of experts, who in turn acquired them from textbooks, other experts,
and direct experience of cases. Second, the rules had to reflect the uncertainty associated with
CERTAINTY FACTOR medical knowledge. MYCIN incorporated a calculus of uncertainty called certainty factors
(see Chapter 14), which seemed (at the time) to fit well with how doctors assessed the impact
of evidence on the diagnosis.
The importance of domain knowledge was also apparent in the area of understanding
natural language. Although Winograd’s SHRDLU system for understanding natural language
had engendered a good deal of excitement, its dependence on syntactic analysis caused some
of the same problems as occurred in the early machine translation work. It was able to
overcome ambiguity and understand pronoun references, but this was mainly because it was
designed specifically for one area—the blocks world. Several researchers, including Eugene
Charniak, a fellow graduate student of Winograd’s at MIT, suggested that robust language
understanding would require general knowledge about the world and a general method for
using that knowledge.
At Yale, linguist-turned-AI-researcher Roger Schank emphasized this point, claiming,
“There is no such thing as syntax,” which upset a lot of linguists but did serve to start a useful
discussion. Schank and his students built a series of programs (Schank and Abelson, 1977;
Wilensky, 1978; Schank and Riesbeck, 1981; Dyer, 1983) that all had the task of understanding natural language. The emphasis, however, was less on language per se and more on
the problems of representing and reasoning with the knowledge required for language understanding. The problems included representing stereotypical situations (Cullingford, 1981),
24 Chapter 1. Introduction
describing human memory organization (Rieger, 1976; Kolodner, 1983), and understanding
plans and goals (Wilensky, 1983).
The widespread growth of applications to real-world problems caused a concurrent increase in the demands for workable knowledge representation schemes. A large number
of different representation and reasoning languages were developed. Some were based on
logic—for example, the Prolog language became popular in Europe, and the PLANNER famFRAMES ily in the United States. Others, following Minsky’s idea of frames (1975), adopted a more
structured approach, assembling facts about particular object and event types and arranging
the types into a large taxonomic hierarchy analogous to a biological taxonomy.
1.3.6 AI becomes an industry (1980–present)
The first successful commercial expert system, R1, began operation at the Digital Equipment
Corporation (McDermott, 1982). The program helped configure orders for new computer
systems; by 1986, it was saving the company an estimated $40 million a year. By 1988,
DEC’s AI group had 40 expert systems deployed, with more on the way. DuPont had 100 in
use and 500 in development, saving an estimated $10 million a year. Nearly every major U.S.
corporation had its own AI group and was either using or investigating expert systems.
In 1981, the Japanese announced the “Fifth Generation” project, a 10-year plan to build
intelligent computers running Prolog. In response, the United States formed the Microelectronics and Computer Technology Corporation (MCC) as a research consortium designed to
assure national competitiveness. In both cases, AI was part of a broad effort, including chip
design and human-interface research. In Britain, the Alvey report reinstated the funding that
was cut by the Lighthill report.13 In all three countries, however, the projects never met their
ambitious goals.
Overall, the AI industry boomed from a few million dollars in 1980 to billions of dollars
in 1988, including hundreds of companies building expert systems, vision systems, robots,
and software and hardware specialized for these purposes. Soon after that came a period
called the “AI Winter,” in which many companies fell by the wayside as they failed to deliver
on extravagant promises.
1.3.7 The return of neural networks (1986–present)
BACK-PROPAGATION In the mid-1980s at least four different groups reinvented the back-propagation learning
algorithm first found in 1969 by Bryson and Ho. The algorithm was applied to many learning problems in computer science and psychology, and the widespread dissemination of the
results in the collection Parallel Distributed Processing (Rumelhart and McClelland, 1986)
caused great excitement.
CONNECTIONIST These so-called connectionist models of intelligent systems were seen by some as direct competitors both to the symbolic models promoted by Newell and Simon and to the
logicist approach of McCarthy and others (Smolensky, 1988). It might seem obvious that
at some level humans manipulate symbols—in fact, Terrence Deacon’s book The Symbolic
13 To save embarrassment, a new field called IKBS (Intelligent Knowledge-Based Systems) was invented because
Artificial Intelligence had been officially canceled.
Section 1.3. The History of Artificial Intelligence 25
Species (1997) suggests that this is the defining characteristic of humans—but the most ardent connectionists questioned whether symbol manipulation had any real explanatory role in
detailed models of cognition. This question remains unanswered, but the current view is that
connectionist and symbolic approaches are complementary, not competing. As occurred with
the separation of AI and cognitive science, modern neural network research has bifurcated
into two fields, one concerned with creating effective network architectures and algorithms
and understanding their mathematical properties, the other concerned with careful modeling
of the empirical properties of actual neurons and ensembles of neurons.
1.3.8 AI adopts the scientific method (1987–present)
Recent years have seen a revolution in both the content and the methodology of work in
artificial intelligence.14 It is now more common to build on existing theories than to propose
brand-new ones, to base claims on rigorous theorems or hard experimental evidence rather
than on intuition, and to show relevance to real-world applications rather than toy examples.
AI was founded in part as a rebellion against the limitations of existing fields like control
theory and statistics, but now it is embracing those fields. As David McAllester (1998) put it:
In the early period of AI it seemed plausible that new forms of symbolic computation,
e.g., frames and semantic networks, made much of classical theory obsolete. This led to
a form of isolationism in which AI became largely separated from the rest of computer
science. This isolationism is currently being abandoned. There is a recognition that
machine learning should not be isolated from information theory, that uncertain reasoning
should not be isolated from stochastic modeling, that search should not be isolated from
classical optimization and control, and that automated reasoning should not be isolated
from formal methods and static analysis.
In terms of methodology, AI has finally come firmly under the scientific method. To be accepted, hypotheses must be subjected to rigorous empirical experiments, and the results must
be analyzed statistically for their importance (Cohen, 1995). It is now possible to replicate
experiments by using shared repositories of test data and code.
The field of speech recognition illustrates the pattern. In the 1970s, a wide variety of
different architectures and approaches were tried. Many of these were rather ad hoc and
fragile, and were demonstrated on only a few specially selected examples. In recent years,
approaches based on hidden Markov models (HMMs) have come to dominate the area. Two HIDDEN MARKOV
MODELS
aspects of HMMs are relevant. First, they are based on a rigorous mathematical theory. This
has allowed speech researchers to build on several decades of mathematical results developed
in other fields. Second, they are generated by a process of training on a large corpus of
real speech data. This ensures that the performance is robust, and in rigorous blind tests the
HMMs have been improving their scores steadily. Speech technology and the related field of
handwritten character recognition are already making the transition to widespread industrial
14 Some have characterized this change as a victory of the neats—those who think that AI theories should be
grounded in mathematical rigor—over the scruffies—those who would rather try out lots of ideas, write some
programs, and then assess what seems to be working. Both approaches are important. A shift toward neatness
implies that the field has reached a level of stability and maturity. Whether that stability will be disrupted by a
new scruffy idea is another question.
26 Chapter 1. Introduction
and consumer applications. Note that there is no scientific claim that humans use HMMs to
recognize speech; rather, HMMs provide a mathematical framework for understanding the
problem and support the engineering claim that they work well in practice.
Machine translation follows the same course as speech recognition. In the 1950s there
was initial enthusiasm for an approach based on sequences of words, with models learned
according to the principles of information theory. That approach fell out of favor in the
1960s, but returned in the late 1990s and now dominates the field.
Neural networks also fit this trend. Much of the work on neural nets in the 1980s was
done in an attempt to scope out what could be done and to learn how neural nets differ from
“traditional” techniques. Using improved methodology and theoretical frameworks, the field
arrived at an understanding in which neural nets can now be compared with corresponding
techniques from statistics, pattern recognition, and machine learning, and the most promising
technique can be applied to each application. As a result of these developments, so-called
DATA MINING data mining technology has spawned a vigorous new industry.
Judea Pearl’s (1988) Probabilistic Reasoning in Intelligent Systems led to a new acceptance of probability and decision theory in AI, following a resurgence of interest epitomized
BAYESIAN NETWORK by Peter Cheeseman’s (1985) article “In Defense of Probability.” The Bayesian network
formalism was invented to allow efficient representation of, and rigorous reasoning with,
uncertain knowledge. This approach largely overcomes many problems of the probabilistic
reasoning systems of the 1960s and 1970s; it now dominates AI research on uncertain reasoning and expert systems. The approach allows for learning from experience, and it combines
the best of classical AI and neural nets. Work by Judea Pearl (1982a) and by Eric Horvitz and
David Heckerman (Horvitz and Heckerman, 1986; Horvitz et al., 1986) promoted the idea of
normative expert systems: ones that act rationally according to the laws of decision theory
and do not try to imitate the thought steps of human experts. The WindowsTM operating system includes several normative diagnostic expert systems for correcting problems. Chapters
13 to 16 cover this area.
Similar gentle revolutions have occurred in robotics, computer vision, and knowledge
representation. A better understanding of the problems and their complexity properties, combined with increased mathematical sophistication, has led to workable research agendas and
robust methods. Although increased formalization and specialization led fields such as vision
and robotics to become somewhat isolated from “mainstream” AI in the 1990s, this trend has
reversed in recent years as tools from machine learning in particular have proved effective for
many problems. The process of reintegration is already yielding significant benefits
1.3.9 The emergence of intelligent agents (1995–present)
Perhaps encouraged by the progress in solving the subproblems of AI, researchers have also
started to look at the “whole agent” problem again. The work of Allen Newell, John Laird,
and Paul Rosenbloom on SOAR (Newell, 1990; Laird et al., 1987) is the best-known example
of a complete agent architecture. One of the most important environments for intelligent
agents is the Internet. AI systems have become so common in Web-based applications that
the “-bot” suffix has entered everyday language. Moreover, AI technologies underlie many
Section 1.3. The History of Artificial Intelligence 27
Internet tools, such as search engines, recommender systems, and Web site aggregators.
One consequence of trying to build complete agents is the realization that the previously
isolated subfields of AI might need to be reorganized somewhat when their results are to be
tied together. In particular, it is now widely appreciated that sensory systems (vision, sonar,
speech recognition, etc.) cannot deliver perfectly reliable information about the environment.
Hence, reasoning and planning systems must be able to handle uncertainty. A second major
consequence of the agent perspective is that AI has been drawn into much closer contact
with other fields, such as control theory and economics, that also deal with agents. Recent
progress in the control of robotic cars has derived from a mixture of approaches ranging from
better sensors, control-theoretic integration of sensing, localization and mapping, as well as
a degree of high-level planning.
Despite these successes, some influential founders of AI, including John McCarthy
(2007), Marvin Minsky (2007), Nils Nilsson (1995, 2005) and Patrick Winston (Beal and
Winston, 2009), have expressed discontent with the progress of AI. They think that AI should
put less emphasis on creating ever-improved versions of applications that are good at a specific task, such as driving a car, playing chess, or recognizing speech. Instead, they believe
AI should return to its roots of striving for, in Simon’s words, “machines that think, that learn
HUMAN-LEVEL AI and that create.” They call the effort human-level AI or HLAI; their first symposium was in
2004 (Minsky et al., 2004). The effort will require very large knowledge bases; Hendler et al.
(1995) discuss where these knowledge bases might come from.
A related idea is the subfield of Artificial General Intelligence or AGI (Goertzel and ARTIFICIAL GENERAL
INTELLIGENCE
Pennachin, 2007), which held its first conference and organized the Journal of Artificial General Intelligence in 2008. AGI looks for a universal algorithm for learning and acting in
any environment, and has its roots in the work of Ray Solomonoff (1964), one of the attendees of the original 1956 Dartmouth conference. Guaranteeing that what we create is really
FRIENDLY AI Friendly AI is also a concern (Yudkowsky, 2008; Omohundro, 2008), one we will return to
in Chapter 26.
1.3.10 The availability of very large data sets (2001–present)
Throughout the 60-year history of computer science, the emphasis has been on the algorithm
as the main subject of study. But some recent work in AI suggests that for many problems, it
makes more sense to worry about the data and be less picky about what algorithm to apply.
This is true because of the increasing availability of very large data sources: for example,
trillions of words of English and billions of images from the Web (Kilgarriff and Grefenstette,
2006); or billions of base pairs of genomic sequences (Collins et al., 2003).
One influential paper in this line was Yarowsky’s (1995) work on word-sense disambiguation: given the use of the word “plant” in a sentence, does that refer to flora or factory?
Previous approaches to the problem had relied on human-labeled examples combined with
machine learning algorithms. Yarowsky showed that the task can be done, with accuracy
above 96%, with no labeled examples at all. Instead, given a very large corpus of unannotated text and just the dictionary definitions of the two senses—“works, industrial plant” and
“flora, plant life”—one can label examples in the corpus, and from there bootstrap to learn
28 Chapter 1. Introduction
new patterns that help label new examples. Banko and Brill (2001) show that techniques
like this perform even better as the amount of available text goes from a million words to a
billion and that the increase in performance from using more data exceeds any difference in
algorithm choice; a mediocre algorithm with 100 million words of unlabeled training data
outperforms the best known algorithm with 1 million words.
As another example, Hays and Efros (2007) discuss the problem of filling in holes in a
photograph. Suppose you use Photoshop to mask out an ex-friend from a group photo, but
now you need to fill in the masked area with something that matches the background. Hays
and Efros defined an algorithm that searches through a collection of photos to find something
that will match. They found the performance of their algorithm was poor when they used
a collection of only ten thousand photos, but crossed a threshold into excellent performance
when they grew the collection to two million photos.
Work like this suggests that the “knowledge bottleneck” in AI—the problem of how to
express all the knowledge that a system needs—may be solved in many applications by learning methods rather than hand-coded knowledge engineering, provided the learning algorithms
have enough data to go on (Halevy et al., 2009). Reporters have noticed the surge of new applications and have written that “AI Winter” may be yielding to a new Spring (Havenstein,
2005). As Kurzweil (2005) writes, “today, many thousands of AI applications are deeply
embedded in the infrastructure of every industry.”
1.4 THE STATE OF THE ART
What can AI do today? A concise answer is difficult because there are so many activities in
so many subfields. Here we sample a few applications; others appear throughout the book.
Robotic vehicles: A driverless robotic car named STANLEY sped through the rough
terrain of the Mojave dessert at 22 mph, finishing the 132-mile course first to win the 2005
DARPA Grand Challenge. STANLEY is a Volkswagen Touareg outfitted with cameras, radar,
and laser rangefinders to sense the environment and onboard software to command the steering, braking, and acceleration (Thrun, 2006). The following year CMU’s BOSS won the Urban Challenge, safely driving in traffic through the streets of a closed Air Force base, obeying
traffic rules and avoiding pedestrians and other vehicles.
Speech recognition: A traveler calling United Airlines to book a flight can have the entire conversation guided by an automated speech recognition and dialog management system.
Autonomous planning and scheduling: A hundred million miles from Earth, NASA’s
Remote Agent program became the first on-board autonomous planning program to control
the scheduling of operations for a spacecraft (Jonsson et al., 2000). REMOTE AGENT generated plans from high-level goals specified from the ground and monitored the execution of
those plans—detecting, diagnosing, and recovering from problems as they occurred. Successor program MAPGEN (Al-Chang et al., 2004) plans the daily operations for NASA’s Mars
Exploration Rovers, and MEXAR2 (Cesta et al., 2007) did mission planning—both logistics
and science planning—for the European Space Agency’s Mars Express mission in 2008.
Section 1.5. Summary 29
Game playing: IBM’s DEEP BLUE became the first computer program to defeat the
world champion in a chess match when it bested Garry Kasparov by a score of 3.5 to 2.5 in
an exhibition match (Goodman and Keene, 1997). Kasparov said that he felt a “new kind of
intelligence” across the board from him. Newsweek magazine described the match as “The
brain’s last stand.” The value of IBM’s stock increased by $18 billion. Human champions
studied Kasparov’s loss and were able to draw a few matches in subsequent years, but the
most recent human-computer matches have been won convincingly by the computer.
Spam fighting: Each day, learning algorithms classify over a billion messages as spam,
saving the recipient from having to waste time deleting what, for many users, could comprise
80% or 90% of all messages, if not classified away by algorithms. Because the spammers are
continually updating their tactics, it is difficult for a static programmed approach to keep up,
and learning algorithms work best (Sahami et al., 1998; Goodman and Heckerman, 2004).
Logistics planning: During the Persian Gulf crisis of 1991, U.S. forces deployed a
Dynamic Analysis and Replanning Tool, DART (Cross and Walker, 1994), to do automated
logistics planning and scheduling for transportation. This involved up to 50,000 vehicles,
cargo, and people at a time, and had to account for starting points, destinations, routes, and
conflict resolution among all parameters. The AI planning techniques generated in hours
a plan that would have taken weeks with older methods. The Defense Advanced Research
Project Agency (DARPA) stated that this single application more than paid back DARPA’s
30-year investment in AI.
Robotics: The iRobot Corporation has sold over two million Roomba robotic vacuum
cleaners for home use. The company also deploys the more rugged PackBot to Iraq and
Afghanistan, where it is used to handle hazardous materials, clear explosives, and identify
the location of snipers.
Machine Translation: A computer program automatically translates from Arabic to
English, allowing an English speaker to see the headline “Ardogan Confirms That Turkey
Would Not Accept Any Pressure, Urging Them to Recognize Cyprus.” The program uses a
statistical model built from examples of Arabic-to-English translations and from examples of
English text totaling two trillion words (Brants et al., 2007). None of the computer scientists
on the team speak Arabic, but they do understand statistics and machine learning algorithms.
These are just a few examples of artificial intelligence systems that exist today. Not
magic or science fiction—but rather science, engineering, and mathematics, to which this
book provides an introduction.
1.5 SUMMARY
This chapter defines AI and establishes the cultural background against which it has developed. Some of the important points are as follows:
• Different people approach AI with different goals in mind. Two important questions to
ask are: Are you concerned with thinking or behavior? Do you want to model humans
or work from an ideal standard?
30 Chapter 1. Introduction
• In this book, we adopt the view that intelligence is concerned mainly with rational
action. Ideally, an intelligent agent takes the best possible action in a situation. We
study the problem of building agents that are intelligent in this sense.
• Philosophers (going back to 400 B.C.) made AI conceivable by considering the ideas
that the mind is in some ways like a machine, that it operates on knowledge encoded in
some internal language, and that thought can be used to choose what actions to take.
• Mathematicians provided the tools to manipulate statements of logical certainty as well
as uncertain, probabilistic statements. They also set the groundwork for understanding
computation and reasoning about algorithms.
• Economists formalized the problem of making decisions that maximize the expected
outcome to the decision maker.
• Neuroscientists discovered some facts about how the brain works and the ways in which
it is similar to and different from computers.
• Psychologists adopted the idea that humans and animals can be considered informationprocessing machines. Linguists showed that language use fits into this model.
• Computer engineers provided the ever-more-powerful machines that make AI applications possible.
• Control theory deals with designing devices that act optimally on the basis of feedback
from the environment. Initially, the mathematical tools of control theory were quite
different from AI, but the fields are coming closer together.
• The history of AI has had cycles of success, misplaced optimism, and resulting cutbacks
in enthusiasm and funding. There have also been cycles of introducing new creative
approaches and systematically refining the best ones.
• AI has advanced more rapidly in the past decade because of greater use of the scientific
method in experimenting with and comparing approaches.
• Recent progress in understanding the theoretical basis for intelligence has gone hand in
hand with improvements in the capabilities of real systems. The subfields of AI have
become more integrated, and AI has found common ground with other disciplines.
BIBLIOGRAPHICAL AND HISTORICAL NOTES
The methodological status of artificial intelligence is investigated in The Sciences of the Artificial, by Herb Simon (1981), which discusses research areas concerned with complex artifacts.
It explains how AI can be viewed as both science and mathematics. Cohen (1995) gives an
overview of experimental methodology within AI.
The Turing Test (Turing, 1950) is discussed by Shieber (1994), who severely criticizes
the usefulness of its instantiation in the Loebner Prize competition, and by Ford and Hayes
(1995), who argue that the test itself is not helpful for AI. Bringsjord (2008) gives advice for
a Turing Test judge. Shieber (2004) and Epstein et al. (2008) collect a number of essays on
the Turing Test. Artificial Intelligence: The Very Idea, by John Haugeland (1985), gives a
Exercises 31
readable account of the philosophical and practical problems of AI. Significant early papers
in AI are anthologized in the collections by Webber and Nilsson (1981) and by Luger (1995).
The Encyclopedia of AI (Shapiro, 1992) contains survey articles on almost every topic in
AI, as does Wikipedia. These articles usually provide a good entry point into the research
literature on each topic. An insightful and comprehensive history of AI is given by Nils
Nillson (2009), one of the early pioneers of the field.
The most recent work appears in the proceedings of the major AI conferences: the biennial International Joint Conference on AI (IJCAI), the annual European Conference on AI
(ECAI), and the National Conference on AI, more often known as AAAI, after its sponsoring
organization. The major journals for general AI are Artificial Intelligence, Computational
Intelligence, the IEEE Transactions on Pattern Analysis and Machine Intelligence, IEEE Intelligent Systems, and the electronic Journal of Artificial Intelligence Research. There are also
many conferences and journals devoted to specific areas, which we cover in the appropriate
chapters. The main professional societies for AI are the American Association for Artificial
Intelligence (AAAI), the ACM Special Interest Group in Artificial Intelligence (SIGART),
and the Society for Artificial Intelligence and Simulation of Behaviour (AISB). AAAI’s AI
Magazine contains many topical and tutorial articles, and its Web site, aaai.org, contains
news, tutorials, and background information.
EXERCISES
These exercises are intended to stimulate discussion, and some might be set as term projects.
Alternatively, preliminary attempts can be made now, and these attempts can be reviewed
after the completion of the book.
1.1 Define in your own words: (a) intelligence, (b) artificial intelligence, (c) agent, (d)
rationality, (e) logical reasoning.
1.2 Read Turing’s original paper on AI (Turing, 1950). In the paper, he discusses several
objections to his proposed enterprise and his test for intelligence. Which objections still carry
weight? Are his refutations valid? Can you think of new objections arising from developments since he wrote the paper? In the paper, he predicts that, by the year 2000, a computer
will have a 30% chance of passing a five-minute Turing Test with an unskilled interrogator.
What chance do you think a computer would have today? In another 50 years?
1.3 Are reflex actions (such as flinching from a hot stove) rational? Are they intelligent?
1.4 Suppose we extend Evans’s ANALOGY program so that it can score 200 on a standard
IQ test. Would we then have a program more intelligent than a human? Explain.
1.5 The neural structure of the sea slug Aplysia has been widely studied (first by Nobel
Laureate Eric Kandel) because it has only about 20,000 neurons, most of them large and
easily manipulated. Assuming that the cycle time for an Aplysia neuron is roughly the same
as for a human neuron, how does the computational power, in terms of memory updates per
second, compare with the high-end computer described in Figure 1.3?
32 Chapter 1. Introduction
1.6 How could introspection—reporting on one’s inner thoughts—be inaccurate? Could I
be wrong about what I’m thinking? Discuss.
1.7 To what extent are the following computer systems instances of artificial intelligence:
• Supermarket bar code scanners.
• Web search engines.
• Voice-activated telephone menus.
• Internet routing algorithms that respond dynamically to the state of the network.
1.8 Many of the computational models of cognitive activities that have been proposed involve quite complex mathematical operations, such as convolving an image with a Gaussian
or finding a minimum of the entropy function. Most humans (and certainly all animals) never
learn this kind of mathematics at all, almost no one learns it before college, and almost no
one can compute the convolution of a function with a Gaussian in their head. What sense
does it make to say that the “vision system” is doing this kind of mathematics, whereas the
actual person has no idea how to do it?
1.9 Why would evolution tend to result in systems that act rationally? What goals are such
systems designed to achieve?
1.10 Is AI a science, or is it engineering? Or neither or both? Explain.
1.11 “Surely computers cannot be intelligent—they can do only what their programmers
tell them.” Is the latter statement true, and does it imply the former?
1.12 “Surely animals cannot be intelligent—they can do only what their genes tell them.”
Is the latter statement true, and does it imply the former?
1.13 “Surely animals, humans, and computers cannot be intelligent—they can do only what
their constituent atoms are told to do by the laws of physics.” Is the latter statement true, and
does it imply the former?
1.14 Examine the AI literature to discover whether the following tasks can currently be
solved by computers:
a. Playing a decent game of table tennis (Ping-Pong).
b. Driving in the center of Cairo, Egypt.
c. Driving in Victorville, California.
d. Buying a week’s worth of groceries at the market.
e. Buying a week’s worth of groceries on the Web.
f. Playing a decent game of bridge at a competitive level.
g. Discovering and proving new mathematical theorems.
h. Writing an intentionally funny story.
i. Giving competent legal advice in a specialized area of law.
j. Translating spoken English into spoken Swedish in real time.
k. Performing a complex surgical operation.
Exercises 33
For the currently infeasible tasks, try to find out what the difficulties are and predict when, if
ever, they will be overcome.
1.15 Various subfields of AI have held contests by defining a standard task and inviting researchers to do their best. Examples include the DARPA Grand Challenge for robotic cars,
The International Planning Competition, the Robocup robotic soccer league, the TREC information retrieval event, and contests in machine translation, speech recognition. Investigate
five of these contests, and describe the progress made over the years. To what degree have the
contests advanced toe state of the art in AI? Do what degree do they hurt the field by drawing
energy away from new ideas?
2 INTELLIGENT AGENTS
In which we discuss the nature of agents, perfect or otherwise, the diversity of
environments, and the resulting menagerie of agent types.
Chapter 1 identified the concept of rational agents as central to our approach to artificial
intelligence. In this chapter, we make this notion more concrete. We will see that the concept
of rationality can be applied to a wide variety of agents operating in any imaginable environment. Our plan in this book is to use this concept to develop a small set of design principles
for building successful agents—systems that can reasonably be called intelligent.
We begin by examining agents, environments, and the coupling between them. The
observation that some agents behave better than others leads naturally to the idea of a rational
agent—one that behaves as well as possible. How well an agent can behave depends on
the nature of the environment; some environments are more difficult than others. We give a
crude categorization of environments and show how properties of an environment influence
the design of suitable agents for that environment. We describe a number of basic “skeleton”
agent designs, which we flesh out in the rest of the book.
2.1 AGENTS AND ENVIRONMENTS
ENVIRONMENT An agent is anything that can be viewed as perceiving its environment through sensors and
SENSOR acting upon that environment through actuators. This simple idea is illustrated in Figure 2.1.
ACTUATOR A human agent has eyes, ears, and other organs for sensors and hands, legs, vocal tract, and so
on for actuators. A robotic agent might have cameras and infrared range finders for sensors
and various motors for actuators. A software agent receives keystrokes, file contents, and
network packets as sensory inputs and acts on the environment by displaying on the screen,
writing files, and sending network packets.
PERCEPT We use the term percept to refer to the agent’s perceptual inputs at any given instant. An
PERCEPT SEQUENCE agent’s percept sequence is the complete history of everything the agent has ever perceived.
In general, an agent’s choice of action at any given instant can depend on the entire percept
sequence observed to date, but not on anything it hasn’t perceived. By specifying the agent’s
choice of action for every possible percept sequence, we have said more or less everything
34
Section 2.1. Agents and Environments 35
Agent Sensors
Actuators
Environment
Percepts
Actions
?
Figure 2.1 Agents interact with environments through sensors and actuators.
there is to say about the agent. Mathematically speaking, we say that an agent’s behavior is
AGENT FUNCTION described by the agent function that maps any given percept sequence to an action.
We can imagine tabulating the agent function that describes any given agent; for most
agents, this would be a very large table—infinite, in fact, unless we place a bound on the
length of percept sequences we want to consider. Given an agent to experiment with, we can,
in principle, construct this table by trying out all possible percept sequences and recording
which actions the agent does in response.1 The table is, of course, an external characterization
of the agent. Internally, the agent function for an artificial agent will be implemented by an
AGENT PROGRAM agent program. It is important to keep these two ideas distinct. The agent function is an
abstract mathematical description; the agent program is a concrete implementation, running
within some physical system.
To illustrate these ideas, we use a very simple example—the vacuum-cleaner world
shown in Figure 2.2. This world is so simple that we can describe everything that happens;
it’s also a made-up world, so we can invent many variations. This particular world has just two
locations: squares A and B. The vacuum agent perceives which square it is in and whether
there is dirt in the square. It can choose to move left, move right, suck up the dirt, or do
nothing. One very simple agent function is the following: if the current square is dirty, then
suck; otherwise, move to the other square. A partial tabulation of this agent function is shown
in Figure 2.3 and an agent program that implements it appears in Figure 2.8 on page 48.
Looking at Figure 2.3, we see that various vacuum-world agents can be defined simply
by filling in the right-hand column in various ways. The obvious question, then, is this: What
is the right way to fill out the table? In other words, what makes an agent good or bad,
intelligent or stupid? We answer these questions in the next section.
1 If the agent uses some randomization to choose its actions, then we would have to try each sequence many
times to identify the probability of each action. One might imagine that acting randomly is rather silly, but we
show later in this chapter that it can be very intelligent.
36 Chapter 2. Intelligent Agents
A B
Figure 2.2 A vacuum-cleaner world with just two locations.
Percept sequence Action
[A, Clean] Right
[A, Dirty] Suck
[B, Clean] Left
[B, Dirty] Suck
[A, Clean], [A, Clean] Right
[A, Clean], [A, Dirty] Suck
.
.
. .
.
.
[A, Clean], [A, Clean], [A, Clean] Right
[A, Clean], [A, Clean], [A, Dirty] Suck
.
.
. .
.
.
Figure 2.3 Partial tabulation of a simple agent function for the vacuum-cleaner world
shown in Figure 2.2.
Before closing this section, we should emphasize that the notion of an agent is meant to
be a tool for analyzing systems, not an absolute characterization that divides the world into
agents and non-agents. One could view a hand-held calculator as an agent that chooses the
action of displaying “4” when given the percept sequence “2 + 2 =,” but such an analysis
would hardly aid our understanding of the calculator. In a sense, all areas of engineering can
be seen as designing artifacts that interact with the world; AI operates at (what the authors
consider to be) the most interesting end of the spectrum, where the artifacts have significant
computational resources and the task environment requires nontrivial decision making.
2.2 GOOD BEHAVIOR: THE CONCEPT OF RATIONALITY
RATIONAL AGENT A rational agent is one that does the right thing—conceptually speaking, every entry in the
table for the agent function is filled out correctly. Obviously, doing the right thing is better
than doing the wrong thing, but what does it mean to do the right thing?
Section 2.2. Good Behavior: The Concept of Rationality 37
We answer this age-old question in an age-old way: by considering the consequences
of the agent’s behavior. When an agent is plunked down in an environment, it generates a
sequence of actions according to the percepts it receives. This sequence of actions causes the
environment to go through a sequence of states. If the sequence is desirable, then the agent
has performed well. This notion of desirability is captured by a performance measure that PERFORMANCE
MEASURE
evaluates any given sequence of environment states.
Notice that we said environment states, not agent states. If we define success in terms
of agent’s opinion of its own performance, an agent could achieve perfect rationality simply
by deluding itself that its performance was perfect. Human agents in particular are notorious
for “sour grapes”—believing they did not really want something (e.g., a Nobel Prize) after
not getting it.
Obviously, there is not one fixed performance measure for all tasks and agents; typically,
a designer will devise one appropriate to the circumstances. This is not as easy as it sounds.
Consider, for example, the vacuum-cleaner agent from the preceding section. We might
propose to measure performance by the amount of dirt cleaned up in a single eight-hour shift.
With a rational agent, of course, what you ask for is what you get. A rational agent can
maximize this performance measure by cleaning up the dirt, then dumping it all on the floor,
then cleaning it up again, and so on. A more suitable performance measure would reward the
agent for having a clean floor. For example, one point could be awarded for each clean square
at each time step (perhaps with a penalty for electricity consumed and noise generated). As
a general rule, it is better to design performance measures according to what one actually
wants in the environment, rather than according to how one thinks the agent should behave.
Even when the obvious pitfalls are avoided, there remain some knotty issues to untangle.
For example, the notion of “clean floor” in the preceding paragraph is based on average
cleanliness over time. Yet the same average cleanliness can be achieved by two different
agents, one of which does a mediocre job all the time while the other cleans energetically but
takes long breaks. Which is preferable might seem to be a fine point of janitorial science, but
in fact it is a deep philosophical question with far-reaching implications. Which is better—
a reckless life of highs and lows, or a safe but humdrum existence? Which is better—an
economy where everyone lives in moderate poverty, or one in which some live in plenty
while others are very poor? We leave these questions as an exercise for the diligent reader.
2.2.1 Rationality
What is rational at any given time depends on four things:
• The performance measure that defines the criterion of success.
• The agent’s prior knowledge of the environment.
• The actions that the agent can perform.
• The agent’s percept sequence to date.
This leads to a definition of a rational agent: DEFINITION OF A
RATIONAL AGENT
For each possible percept sequence, a rational agent should select an action that is expected to maximize its performance measure, given the evidence provided by the percept
sequence and whatever built-in knowledge the agent has.
38 Chapter 2. Intelligent Agents
Consider the simple vacuum-cleaner agent that cleans a square if it is dirty and moves to the
other square if not; this is the agent function tabulated in Figure 2.3. Is this a rational agent?
That depends! First, we need to say what the performance measure is, what is known about
the environment, and what sensors and actuators the agent has. Let us assume the following:
• The performance measure awards one point for each clean square at each time step,
over a “lifetime” of 1000 time steps.
• The “geography” of the environment is known a priori (Figure 2.2) but the dirt distribution and the initial location of the agent are not. Clean squares stay clean and sucking
cleans the current square. The Left and Right actions move the agent left and right
except when this would take the agent outside the environment, in which case the agent
remains where it is.
• The only available actions are Left, Right, and Suck.
• The agent correctly perceives its location and whether that location contains dirt.
We claim that under these circumstances the agent is indeed rational; its expected performance is at least as high as any other agent’s. Exercise 2.2 asks you to prove this.
One can see easily that the same agent would be irrational under different circumstances. For example, once all the dirt is cleaned up, the agent will oscillate needlessly back
and forth; if the performance measure includes a penalty of one point for each movement left
or right, the agent will fare poorly. A better agent for this case would do nothing once it is
sure that all the squares are clean. If clean squares can become dirty again, the agent should
occasionally check and re-clean them if needed. If the geography of the environment is unknown, the agent will need to explore it rather than stick to squares A and B. Exercise 2.2
asks you to design agents for these cases.
2.2.2 Omniscience, learning, and autonomy
OMNISCIENCE We need to be careful to distinguish between rationality and omniscience. An omniscient
agent knows the actual outcome of its actions and can act accordingly; but omniscience is
impossible in reality. Consider the following example: I am walking along the Champs
Elys´ees one day and I see an old friend across the street. There is no traffic nearby and I’m
not otherwise engaged, so, being rational, I start to cross the street. Meanwhile, at 33,000
feet, a cargo door falls off a passing airliner,2 and before I make it to the other side of the
street I am flattened. Was I irrational to cross the street? It is unlikely that my obituary would
read “Idiot attempts to cross street.”
This example shows that rationality is not the same as perfection. Rationality maximizes expected performance, while perfection maximizes actual performance. Retreating
from a requirement of perfection is not just a question of being fair to agents. The point is
that if we expect an agent to do what turns out to be the best action after the fact, it will be
impossible to design an agent to fulfill this specification—unless we improve the performance
of crystal balls or time machines.
2 See N. Henderson, “New door latches urged for Boeing 747 jumbo jets,” Washington Post, August 24, 1989.
Section 2.2. Good Behavior: The Concept of Rationality 39
Our definition of rationality does not require omniscience, then, because the rational
choice depends only on the percept sequence to date. We must also ensure that we haven’t
inadvertently allowed the agent to engage in decidedly underintelligent activities. For example, if an agent does not look both ways before crossing a busy road, then its percept sequence
will not tell it that there is a large truck approaching at high speed. Does our definition of
rationality say that it’s now OK to cross the road? Far from it! First, it would not be rational
to cross the road given this uninformative percept sequence: the risk of accident from crossing without looking is too great. Second, a rational agent should choose the “looking” action
before stepping into the street, because looking helps maximize the expected performance.
Doing actions in order to modify future percepts—sometimes called information gathering—is an important part of rationality and is covered in depth in Chapter 16. A second INFORMATION
GATHERING
EXPLORATION example of information gathering is provided by the exploration that must be undertaken by
a vacuum-cleaning agent in an initially unknown environment.
LEARNING Our definition requires a rational agent not only to gather information but also to learn
as much as possible from what it perceives. The agent’s initial configuration could reflect
some prior knowledge of the environment, but as the agent gains experience this may be
modified and augmented. There are extreme cases in which the environment is completely
known a priori. In such cases, the agent need not perceive or learn; it simply acts correctly.
Of course, such agents are fragile. Consider the lowly dung beetle. After digging its nest and
laying its eggs, it fetches a ball of dung from a nearby heap to plug the entrance. If the ball of
dung is removed from its grasp en route, the beetle continues its task and pantomimes plugging the nest with the nonexistent dung ball, never noticing that it is missing. Evolution has
built an assumption into the beetle’s behavior, and when it is violated, unsuccessful behavior
results. Slightly more intelligent is the sphex wasp. The female sphex will dig a burrow, go
out and sting a caterpillar and drag it to the burrow, enter the burrow again to check all is
well, drag the caterpillar inside, and lay its eggs. The caterpillar serves as a food source when
the eggs hatch. So far so good, but if an entomologist moves the caterpillar a few inches
away while the sphex is doing the check, it will revert to the “drag” step of its plan and will
continue the plan without modification, even after dozens of caterpillar-moving interventions.
The sphex is unable to learn that its innate plan is failing, and thus will not change it.
To the extent that an agent relies on the prior knowledge of its designer rather than
AUTONOMY on its own percepts, we say that the agent lacks autonomy. A rational agent should be
autonomous—it should learn what it can to compensate for partial or incorrect prior knowledge. For example, a vacuum-cleaning agent that learns to foresee where and when additional
dirt will appear will do better than one that does not. As a practical matter, one seldom requires complete autonomy from the start: when the agent has had little or no experience, it
would have to act randomly unless the designer gave some assistance. So, just as evolution
provides animals with enough built-in reflexes to survive long enough to learn for themselves,
it would be reasonable to provide an artificial intelligent agent with some initial knowledge
as well as an ability to learn. After sufficient experience of its environment, the behavior
of a rational agent can become effectively independent of its prior knowledge. Hence, the
incorporation of learning allows one to design a single rational agent that will succeed in a
vast variety of environments.
40 Chapter 2. Intelligent Agents
2.3 THE NATURE OF ENVIRONMENTS
Now that we have a definition of rationality, we are almost ready to think about building
TASK ENVIRONMENT rational agents. First, however, we must think about task environments, which are essentially the “problems” to which rational agents are the “solutions.” We begin by showing how
to specify a task environment, illustrating the process with a number of examples. We then
show that task environments come in a variety of flavors. The flavor of the task environment
directly affects the appropriate design for the agent program.
2.3.1 Specifying the task environment
In our discussion of the rationality of the simple vacuum-cleaner agent, we had to specify
the performance measure, the environment, and the agent’s actuators and sensors. We group
all these under the heading of the task environment. For the acronymically minded, we call
PEAS this the PEAS (Performance, Environment, Actuators, Sensors) description. In designing an
agent, the first step must always be to specify the task environment as fully as possible.
The vacuum world was a simple example; let us consider a more complex problem: an
automated taxi driver. We should point out, before the reader becomes alarmed, that a fully
automated taxi is currently somewhat beyond the capabilities of existing technology. (page 28
describes an existing driving robot.) The full driving task is extremely open-ended. There is
no limit to the novel combinations of circumstances that can arise—another reason we chose
it as a focus for discussion. Figure 2.4 summarizes the PEAS description for the taxi’s task
environment. We discuss each element in more detail in the following paragraphs.
Agent Type Performance
Measure
Environment Actuators Sensors
Taxi driver Safe, fast, legal,
comfortable trip,
maximize profits
Roads, other
traffic,
pedestrians,
customers
Steering,
accelerator,
brake, signal,
horn, display
Cameras, sonar,
speedometer,
GPS, odometer,
accelerometer,
engine sensors,
keyboard
Figure 2.4 PEAS description of the task environment for an automated taxi.
First, what is the performance measure to which we would like our automated driver
to aspire? Desirable qualities include getting to the correct destination; minimizing fuel consumption and wear and tear; minimizing the trip time or cost; minimizing violations of traffic
laws and disturbances to other drivers; maximizing safety and passenger comfort; maximizing profits. Obviously, some of these goals conflict, so tradeoffs will be required.
Next, what is the driving environment that the taxi will face? Any taxi driver must
deal with a variety of roads, ranging from rural lanes and urban alleys to 12-lane freeways.
The roads contain other traffic, pedestrians, stray animals, road works, police cars, puddles,
Section 2.3. The Nature of Environments 41
and potholes. The taxi must also interact with potential and actual passengers. There are also
some optional choices. The taxi might need to operate in Southern California, where snow
is seldom a problem, or in Alaska, where it seldom is not. It could always be driving on the
right, or we might want it to be flexible enough to drive on the left when in Britain or Japan.
Obviously, the more restricted the environment, the easier the design problem.
The actuators for an automated taxi include those available to a human driver: control
over the engine through the accelerator and control over steering and braking. In addition, it
will need output to a display screen or voice synthesizer to talk back to the passengers, and
perhaps some way to communicate with other vehicles, politely or otherwise.
The basic sensors for the taxi will include one or more controllable video cameras so
that it can see the road; it might augment these with infrared or sonar sensors to detect distances to other cars and obstacles. To avoid speeding tickets, the taxi should have a speedometer, and to control the vehicle properly, especially on curves, it should have an accelerometer.
To determine the mechanical state of the vehicle, it will need the usual array of engine, fuel,
and electrical system sensors. Like many human drivers, it might want a global positioning
system (GPS) so that it doesn’t get lost. Finally, it will need a keyboard or microphone for
the passenger to request a destination.
In Figure 2.5, we have sketched the basic PEAS elements for a number of additional
agent types. Further examples appear in Exercise 2.4. It may come as a surprise to some readers that our list of agent types includes some programs that operate in the entirely artificial
environment defined by keyboard input and character output on a screen. “Surely,” one might
say, “this is not a real environment, is it?” In fact, what matters is not the distinction between
“real” and “artificial” environments, but the complexity of the relationship among the behavior of the agent, the percept sequence generated by the environment, and the performance
measure. Some “real” environments are actually quite simple. For example, a robot designed
to inspect parts as they come by on a conveyor belt can make use of a number of simplifying
assumptions: that the lighting is always just so, that the only thing on the conveyor belt will
be parts of a kind that it knows about, and that only two actions (accept or reject) are possible.
SOFTWARE AGENT In contrast, some software agents (or software robots or softbots) exist in rich, unlimSOFTBOT ited domains. Imagine a softbot Web site operator designed to scan Internet news sources and
show the interesting items to its users, while selling advertising space to generate revenue.
To do well, that operator will need some natural language processing abilities, it will need
to learn what each user and advertiser is interested in, and it will need to change its plans
dynamically—for example, when the connection for one news source goes down or when a
new one comes online. The Internet is an environment whose complexity rivals that of the
physical world and whose inhabitants include many artificial and human agents.
2.3.2 Properties of task environments
The range of task environments that might arise in AI is obviously vast. We can, however,
identify a fairly small number of dimensions along which task environments can be categorized. These dimensions determine, to a large extent, the appropriate agent design and the
applicability of each of the principal families of techniques for agent implementation. First,
42 Chapter 2. Intelligent Agents
Agent Type Performance
Measure
Environment Actuators Sensors
Medical
diagnosis system
Healthy patient,
reduced costs
Patient, hospital,
staff
Display of
questions, tests,
diagnoses,
treatments,
referrals
Keyboard entry
of symptoms,
findings, patient’s
answers
Satellite image
analysis system
Correct image
categorization
Downlink from
orbiting satellite
Display of scene
categorization
Color pixel
arrays
Part-picking
robot
Percentage of
parts in correct
bins
Conveyor belt
with parts; bins
Jointed arm and
hand
Camera, joint
angle sensors
Refinery
controller
Purity, yield,
safety
Refinery,
operators
Valves, pumps,
heaters, displays
Temperature,
pressure,
chemical sensors
Interactive
English tutor
Student’s score
on test
Set of students,
testing agency
Display of
exercises,
suggestions,
corrections
Keyboard entry
Figure 2.5 Examples of agent types and their PEAS descriptions.
we list the dimensions, then we analyze several task environments to illustrate the ideas. The
definitions here are informal; later chapters provide more precise statements and examples of
each kind of environment.
FULLY OBSERVABLE Fully observable vs. partially observable: If an agent’s sensors give it access to the PARTIALLY
OBSERVABLE complete state of the environment at each point in time, then we say that the task environment is fully observable. A task environment is effectively fully observable if the sensors
detect all aspects that are relevant to the choice of action; relevance, in turn, depends on the
performance measure. Fully observable environments are convenient because the agent need
not maintain any internal state to keep track of the world. An environment might be partially
observable because of noisy and inaccurate sensors or because parts of the state are simply
missing from the sensor data—for example, a vacuum agent with only a local dirt sensor
cannot tell whether there is dirt in other squares, and an automated taxi cannot see what other
drivers are thinking. If the agent has no sensors at all then the environment is unobservUNOBSERVABLE able. One might think that in such cases the agent’s plight is hopeless, but, as we discuss in
Chapter 4, the agent’s goals may still be achievable, sometimes with certainty.
SINGLE AGENT Single agent vs. multiagent: The distinction between single-agent and multiagent enMULTIAGENT
Section 2.3. The Nature of Environments 43
vironments may seem simple enough. For example, an agent solving a crossword puzzle by
itself is clearly in a single-agent environment, whereas an agent playing chess is in a twoagent environment. There are, however, some subtle issues. First, we have described how an
entity may be viewed as an agent, but we have not explained which entities must be viewed
as agents. Does an agent A (the taxi driver for example) have to treat an object B (another
vehicle) as an agent, or can it be treated merely as an object behaving according to the laws of
physics, analogous to waves at the beach or leaves blowing in the wind? The key distinction
is whether B’s behavior is best described as maximizing a performance measure whose value
depends on agent A’s behavior. For example, in chess, the opponent entity B is trying to
maximize its performance measure, which, by the rules of chess, minimizes agent A’s perCOMPETITIVE formance measure. Thus, chess is a competitive multiagent environment. In the taxi-driving
environment, on the other hand, avoiding collisions maximizes the performance measure of
COOPERATIVE all agents, so it is a partially cooperative multiagent environment. It is also partially competitive because, for example, only one car can occupy a parking space. The agent-design
problems in multiagent environments are often quite different from those in single-agent environments; for example, communication often emerges as a rational behavior in multiagent
environments; in some competitive environments, randomized behavior is rational because
it avoids the pitfalls of predictability.
DETERMINISTIC Deterministic vs. stochastic. If the next state of the environment is completely deterSTOCHASTIC mined by the current state and the action executed by the agent, then we say the environment
is deterministic; otherwise, it is stochastic. In principle, an agent need not worry about uncertainty in a fully observable, deterministic environment. (In our definition, we ignore uncertainty that arises purely from the actions of other agents in a multiagent environment; thus,
a game can be deterministic even though each agent may be unable to predict the actions of
the others.) If the environment is partially observable, however, then it could appear to be
stochastic. Most real situations are so complex that it is impossible to keep track of all the
unobserved aspects; for practical purposes, they must be treated as stochastic. Taxi driving is
clearly stochastic in this sense, because one can never predict the behavior of traffic exactly;
moreover, one’s tires blow out and one’s engine seizes up without warning. The vacuum
world as we described it is deterministic, but variations can include stochastic elements such
as randomly appearing dirt and an unreliable suction mechanism (Exercise 2.13). We say an
UNCERTAIN environment is uncertain if it is not fully observable or not deterministic. One final note:
our use of the word “stochastic” generally implies that uncertainty about outcomes is quanNONDETERMINISTIC tified in terms of probabilities; a nondeterministic environment is one in which actions are
characterized by their possible outcomes, but no probabilities are attached to them. Nondeterministic environment descriptions are usually associated with performance measures that
require the agent to succeed for all possible outcomes of its actions.
EPISODIC Episodic vs. sequential: In an episodic task environment, the agent’s experience is
SEQUENTIAL divided into atomic episodes. In each episode the agent receives a percept and then performs
a single action. Crucially, the next episode does not depend on the actions taken in previous
episodes. Many classification tasks are episodic. For example, an agent that has to spot
defective parts on an assembly line bases each decision on the current part, regardless of
previous decisions; moreover, the current decision doesn’t affect whether the next part is
44 Chapter 2. Intelligent Agents
defective. In sequential environments, on the other hand, the current decision could affect
all future decisions.3 Chess and taxi driving are sequential: in both cases, short-term actions
can have long-term consequences. Episodic environments are much simpler than sequential
environments because the agent does not need to think ahead.
STATIC Static vs. dynamic: If the environment can change while an agent is deliberating, then
DYNAMIC we say the environment is dynamic for that agent; otherwise, it is static. Static environments
are easy to deal with because the agent need not keep looking at the world while it is deciding
on an action, nor need it worry about the passage of time. Dynamic environments, on the
other hand, are continuously asking the agent what it wants to do; if it hasn’t decided yet,
that counts as deciding to do nothing. If the environment itself does not change with the
passage of time but the agent’s performance score does, then we say the environment is
SEMIDYNAMIC semidynamic. Taxi driving is clearly dynamic: the other cars and the taxi itself keep moving
while the driving algorithm dithers about what to do next. Chess, when played with a clock,
is semidynamic. Crossword puzzles are static.
DISCRETE Discrete vs. continuous: The discrete/continuous distinction applies to the state of the
CONTINUOUS environment, to the way time is handled, and to the percepts and actions of the agent. For
example, the chess environment has a finite number of distinct states (excluding the clock).
Chess also has a discrete set of percepts and actions. Taxi driving is a continuous-state and
continuous-time problem: the speed and location of the taxi and of the other vehicles sweep
through a range of continuous values and do so smoothly over time. Taxi-driving actions are
also continuous (steering angles, etc.). Input from digital cameras is discrete, strictly speaking, but is typically treated as representing continuously varying intensities and locations.
KNOWN Known vs. unknown: Strictly speaking, this distinction refers not to the environment
UNKNOWN itself but to the agent’s (or designer’s) state of knowledge about the “laws of physics” of
the environment. In a known environment, the outcomes (or outcome probabilities if the
environment is stochastic) for all actions are given. Obviously, if the environment is unknown,
the agent will have to learn how it works in order to make good decisions. Note that the
distinction between known and unknown environments is not the same as the one between
fully and partially observable environments. It is quite possible for a known environment
to be partially observable—for example, in solitaire card games, I know the rules but am
still unable to see the cards that have not yet been turned over. Conversely, an unknown
environment can be fully observable—in a new video game, the screen may show the entire
game state but I still don’t know what the buttons do until I try them.
As one might expect, the hardest case is partially observable, multiagent, stochastic,
sequential, dynamic, continuous, and unknown. Taxi driving is hard in all these senses, except
that for the most part the driver’s environment is known. Driving a rented car in a new country
with unfamiliar geography and traffic laws is a lot more exciting.
Figure 2.6 lists the properties of a number of familiar environments. Note that the
answers are not always cut and dried. For example, we describe the part-picking robot as
episodic, because it normally considers each part in isolation. But if one day there is a large
3 The word “sequential” is also used in computer science as the antonym of “parallel.” The two meanings are
largely unrelated.
Section 2.3. The Nature of Environments 45
Task Environment Observable Agents Deterministic Episodic Static Discrete
Crossword puzzle Fully Single Deterministic Sequential Static Discrete
Chess with a clock Fully Multi Deterministic Sequential Semi Discrete
Poker Partially Multi Stochastic Sequential Static Discrete
Backgammon Fully Multi Stochastic Sequential Static Discrete
Taxi driving Partially Multi Stochastic Sequential Dynamic Continuous
Medical diagnosis Partially Single Stochastic Sequential Dynamic Continuous
Image analysis Fully Single Deterministic Episodic Semi Continuous
Part-picking robot Partially Single Stochastic Episodic Dynamic Continuous
Refinery controller Partially Single Stochastic Sequential Dynamic Continuous
Interactive English tutor Partially Multi Stochastic Sequential Dynamic Discrete
Figure 2.6 Examples of task environments and their characteristics.
batch of defective parts, the robot should learn from several observations that the distribution
of defects has changed, and should modify its behavior for subsequent parts. We have not
included a “known/unknown” column because, as explained earlier, this is not strictly a property of the environment. For some environments, such as chess and poker, it is quite easy to
supply the agent with full knowledge of the rules, but it is nonetheless interesting to consider
how an agent might learn to play these games without such knowledge.
Several of the answers in the table depend on how the task environment is defined. We
have listed the medical-diagnosis task as single-agent because the disease process in a patient
is not profitably modeled as an agent; but a medical-diagnosis system might also have to
deal with recalcitrant patients and skeptical staff, so the environment could have a multiagent
aspect. Furthermore, medical diagnosis is episodic if one conceives of the task as selecting a
diagnosis given a list of symptoms; the problem is sequential if the task can include proposing
a series of tests, evaluating progress over the course of treatment, and so on. Also, many
environments are episodic at higher levels than the agent’s individual actions. For example,
a chess tournament consists of a sequence of games; each game is an episode because (by
and large) the contribution of the moves in one game to the agent’s overall performance is
not affected by the moves in its previous game. On the other hand, decision making within a
single game is certainly sequential.
The code repository associated with this book (aima.cs.berkeley.edu) includes implementations of a number of environments, together with a general-purpose environment simulator that places one or more agents in a simulated environment, observes their behavior over
time, and evaluates them according to a given performance measure. Such experiments are
often carried out not for a single environment but for many environments drawn from an environment class. For example, to evaluate a taxi driver in simulated traffic, we would want to ENVIRONMENT
CLASS
run many simulations with different traffic, lighting, and weather conditions. If we designed
the agent for a single scenario, we might be able to take advantage of specific properties
of the particular case but might not identify a good design for driving in general. For this
46 Chapter 2. Intelligent Agents
reason, the code repository also includes an environment generator for each environment ENVIRONMENT
GENERATOR
class that selects particular environments (with certain likelihoods) in which to run the agent.
For example, the vacuum environment generator initializes the dirt pattern and agent location
randomly. We are then interested in the agent’s average performance over the environment
class. A rational agent for a given environment class maximizes this average performance.
Exercises 2.8 to 2.13 take you through the process of developing an environment class and
evaluating various agents therein.
2.4 THE STRUCTURE OF AGENTS
So far we have talked about agents by describing behavior—the action that is performed after
any given sequence of percepts. Now we must bite the bullet and talk about how the insides
AGENT PROGRAM work. The job of AI is to design an agent program that implements the agent function—
the mapping from percepts to actions. We assume this program will run on some sort of
ARCHITECTURE computing device with physical sensors and actuators—we call this the architecture:
agent = architecture + program .
Obviously, the program we choose has to be one that is appropriate for the architecture. If the
program is going to recommend actions like Walk, the architecture had better have legs. The
architecture might be just an ordinary PC, or it might be a robotic car with several onboard
computers, cameras, and other sensors. In general, the architecture makes the percepts from
the sensors available to the program, runs the program, and feeds the program’s action choices
to the actuators as they are generated. Most of this book is about designing agent programs,
although Chapters 24 and 25 deal directly with the sensors and actuators.
2.4.1 Agent programs
The agent programs that we design in this book all have the same skeleton: they take the
current percept as input from the sensors and return an action to the actuators.4 Notice the
difference between the agent program, which takes the current percept as input, and the agent
function, which takes the entire percept history. The agent program takes just the current
percept as input because nothing more is available from the environment; if the agent’s actions
need to depend on the entire percept sequence, the agent will have to remember the percepts.
We describe the agent programs in the simple pseudocode language that is defined in
Appendix B. (The online code repository contains implementations in real programming
languages.) For example, Figure 2.7 shows a rather trivial agent program that keeps track of
the percept sequence and then uses it to index into a table of actions to decide what to do.
The table—an example of which is given for the vacuum world in Figure 2.3—represents
explicitly the agent function that the agent program embodies. To build a rational agent in
4 There are other choices for the agent program skeleton; for example, we could have the agent programs be
coroutines that run asynchronously with the environment. Each such coroutine has an input and output port and
consists of a loop that reads the input port for percepts and writes actions to the output port.
Section 2.4. The Structure of Agents 47
function TABLE-DRIVEN-AGENT(percept) returns an action
persistent: percepts, a sequence, initially empty
table, a table of actions, indexed by percept sequences, initially fully specified
append percept to the end of percepts
action ← LOOKUP(percepts,table)
return action
Figure 2.7 The TABLE-DRIVEN-AGENT program is invoked for each new percept and
returns an action each time. It retains the complete percept sequence in memory.
this way, we as designers must construct a table that contains the appropriate action for every
possible percept sequence.
It is instructive to consider why the table-driven approach to agent construction is
doomed to failure. Let P be the set of possible percepts and let T be the lifetime of the
agent (the total number of percepts it will receive). The lookup table will contain T
t = 1 |P|t
entries. Consider the automated taxi: the visual input from a single camera comes in at the
rate of roughly 27 megabytes per second (30 frames per second, 640 × 480 pixels with 24
bits of color information). This gives a lookup table with over 10250,000,000,000 entries for an
hour’s driving. Even the lookup table for chess—a tiny, well-behaved fragment of the real
world—would have at least 10150 entries. The daunting size of these tables (the number of
atoms in the observable universe is less than 1080) means that (a) no physical agent in this
universe will have the space to store the table, (b) the designer would not have time to create
the table, (c) no agent could ever learn all the right table entries from its experience, and (d)
even if the environment is simple enough to yield a feasible table size, the designer still has
no guidance about how to fill in the table entries.
Despite all this, TABLE-DRIVEN-AGENT does do what we want: it implements the
desired agent function. The key challenge for AI is to find out how to write programs that,
to the extent possible, produce rational behavior from a smallish program rather than from
a vast table. We have many examples showing that this can be done successfully in other
areas: for example, the huge tables of square roots used by engineers and schoolchildren prior
to the 1970s have now been replaced by a five-line program for Newton’s method running
on electronic calculators. The question is, can AI do for general intelligent behavior what
Newton did for square roots? We believe the answer is yes.
In the remainder of this section, we outline four basic kinds of agent programs that
embody the principles underlying almost all intelligent systems:
• Simple reflex agents;
• Model-based reflex agents;
• Goal-based agents; and
• Utility-based agents.
Each kind of agent program combines particular components in particular ways to generate
actions. Section 2.4.6 explains in general terms how to convert all these agents into learning
48 Chapter 2. Intelligent Agents
function REFLEX-VACUUM-AGENT([location,status]) returns an action
if status = Dirty then return Suck
else if location = A then return Right
else if location = B then return Left
Figure 2.8 The agent program for a simple reflex agent in the two-state vacuum environment. This program implements the agent function tabulated in Figure 2.3.
agents that can improve the performance of their components so as to generate better actions.
Finally, Section 2.4.7 describes the variety of ways in which the components themselves can
be represented within the agent. This variety provides a major organizing principle for the
field and for the book itself.
2.4.2 Simple reflex agents
The simplest kind of agent is the simple reflex agent. These agents select actions on the basis SIMPLE REFLEX
AGENT
of the current percept, ignoring the rest of the percept history. For example, the vacuum agent
whose agent function is tabulated in Figure 2.3 is a simple reflex agent, because its decision
is based only on the current location and on whether that location contains dirt. An agent
program for this agent is shown in Figure 2.8.
Notice that the vacuum agent program is very small indeed compared to the corresponding table. The most obvious reduction comes from ignoring the percept history, which cuts
down the number of possibilities from 4T to just 4. A further, small reduction comes from
the fact that when the current square is dirty, the action does not depend on the location.
Simple reflex behaviors occur even in more complex environments. Imagine yourself
as the driver of the automated taxi. If the car in front brakes and its brake lights come on, then
you should notice this and initiate braking. In other words, some processing is done on the
visual input to establish the condition we call “The car in front is braking.” Then, this triggers
some established connection in the agent program to the action “initiate braking.” We call
such a connection a condition–action rule,
5 written as CONDITION–ACTION
RULE
if car-in-front-is-braking then initiate-braking.
Humans also have many such connections, some of which are learned responses (as for driving) and some of which are innate reflexes (such as blinking when something approaches the
eye). In the course of the book, we show several different ways in which such connections
can be learned and implemented.
The program in Figure 2.8 is specific to one particular vacuum environment. A more
general and flexible approach is first to build a general-purpose interpreter for condition–
action rules and then to create rule sets for specific task environments. Figure 2.9 gives the
structure of this general program in schematic form, showing how the condition–action rules
allow the agent to make the connection from percept to action. (Do not worry if this seems
5 Also called situation–action rules, productions, or if–then rules.
Section 2.4. The Structure of Agents 49
Agent
Environment
Sensors
What action I
should do now Condition-action rules
Actuators
What the world
is like now
Figure 2.9 Schematic diagram of a simple reflex agent.
function SIMPLE-REFLEX-AGENT(percept) returns an action
persistent: rules, a set of condition–action rules
state ← INTERPRET-INPUT(percept)
rule ← RULE-MATCH(state, rules)
action ← rule.ACTION
return action
Figure 2.10 A simple reflex agent. It acts according to a rule whose condition matches
the current state, as defined by the percept.
trivial; it gets more interesting shortly.) We use rectangles to denote the current internal state
of the agent’s decision process, and ovals to represent the background information used in
the process. The agent program, which is also very simple, is shown in Figure 2.10. The
INTERPRET-INPUT function generates an abstracted description of the current state from the
percept, and the RULE-MATCH function returns the first rule in the set of rules that matches
the given state description. Note that the description in terms of “rules” and “matching” is
purely conceptual; actual implementations can be as simple as a collection of logic gates
implementing a Boolean circuit.
Simple reflex agents have the admirable property of being simple, but they turn out to be
of limited intelligence. The agent in Figure 2.10 will work only if the correct decision can be
made on the basis of only the current percept—that is, only if the environment is fully observable. Even a little bit of unobservability can cause serious trouble. For example, the braking
rule given earlier assumes that the condition car-in-front-is-braking can be determined from
the current percept—a single frame of video. This works if the car in front has a centrally
mounted brake light. Unfortunately, older models have different configurations of taillights,
50 Chapter 2. Intelligent Agents
brake lights, and turn-signal lights, and it is not always possible to tell from a single image
whether the car is braking. A simple reflex agent driving behind such a car would either brake
continuously and unnecessarily, or, worse, never brake at all.
We can see a similar problem arising in the vacuum world. Suppose that a simple reflex
vacuum agent is deprived of its location sensor and has only a dirt sensor. Such an agent
has just two possible percepts: [Dirty] and [Clean]. It can Suck in response to [Dirty]; what
should it do in response to [Clean]? Moving Left fails (forever) if it happens to start in square
A, and moving Right fails (forever) if it happens to start in square B. Infinite loops are often
unavoidable for simple reflex agents operating in partially observable environments.
RANDOMIZATION Escape from infinite loops is possible if the agent can randomize its actions. For example, if the vacuum agent perceives [Clean], it might flip a coin to choose between Left and
Right. It is easy to show that the agent will reach the other square in an average of two steps.
Then, if that square is dirty, the agent will clean it and the task will be complete. Hence, a
randomized simple reflex agent might outperform a deterministic simple reflex agent.
We mentioned in Section 2.3 that randomized behavior of the right kind can be rational
in some multiagent environments. In single-agent environments, randomization is usually not
rational. It is a useful trick that helps a simple reflex agent in some situations, but in most
cases we can do much better with more sophisticated deterministic agents.
2.4.3 Model-based reflex agents
The most effective way to handle partial observability is for the agent to keep track of the
part of the world it can’t see now. That is, the agent should maintain some sort of internal
INTERNAL STATE state that depends on the percept history and thereby reflects at least some of the unobserved
aspects of the current state. For the braking problem, the internal state is not too extensive—
just the previous frame from the camera, allowing the agent to detect when two red lights at
the edge of the vehicle go on or off simultaneously. For other driving tasks such as changing
lanes, the agent needs to keep track of where the other cars are if it can’t see them all at once.
And for any driving to be possible at all, the agent needs to keep track of where its keys are.
Updating this internal state information as time goes by requires two kinds of knowledge to be encoded in the agent program. First, we need some information about how the
world evolves independently of the agent—for example, that an overtaking car generally will
be closer behind than it was a moment ago. Second, we need some information about how
the agent’s own actions affect the world—for example, that when the agent turns the steering
wheel clockwise, the car turns to the right, or that after driving for five minutes northbound
on the freeway, one is usually about five miles north of where one was five minutes ago. This
knowledge about “how the world works”—whether implemented in simple Boolean circuits
or in complete scientific theories—is called a model of the world. An agent that uses such a
model is called a model-based agent. MODEL-BASED
AGENT
Figure 2.11 gives the structure of the model-based reflex agent with internal state, showing how the current percept is combined with the old internal state to generate the updated
description of the current state, based on the agent’s model of how the world works. The agent
program is shown in Figure 2.12. The interesting part is the function UPDATE-STATE, which
Section 2.4. The Structure of Agents 51
Agent
Environment
Sensors
State
How the world evolves
What my actions do
Condition-action rules
Actuators
What the world
is like now
What action I
should do now
Figure 2.11 A model-based reflex agent.
function MODEL-BASED-REFLEX-AGENT(percept) returns an action
persistent: state, the agent’s current conception of the world state
model, a description of how the next state depends on current state and action
rules, a set of condition–action rules
action, the most recent action, initially none
state ← UPDATE-STATE(state, action, percept, model)
rule ← RULE-MATCH(state, rules)
action ← rule.ACTION
return action
Figure 2.12 A model-based reflex agent. It keeps track of the current state of the world,
using an internal model. It then chooses an action in the same way as the reflex agent.
is responsible for creating the new internal state description. The details of how models and
states are represented vary widely depending on the type of environment and the particular
technology used in the agent design. Detailed examples of models and updating algorithms
appear in Chapters 4, 12, 11, 15, 17, and 25.
Regardless of the kind of representation used, it is seldom possible for the agent to
determine the current state of a partially observable environment exactly. Instead, the box
labeled “what the world is like now” (Figure 2.11) represents the agent’s “best guess” (or
sometimes best guesses). For example, an automated taxi may not be able to see around the
large truck that has stopped in front of it and can only guess about what may be causing the
hold-up. Thus, uncertainty about the current state may be unavoidable, but the agent still has
to make a decision.
A perhaps less obvious point about the internal “state” maintained by a model-based
agent is that it does not have to describe “what the world is like now” in a literal sense. For
52 Chapter 2. Intelligent Agents
Agent
Environment
Sensors
What action I
should do now
State
How the world evolves
What my actions do
Actuators
What the world
is like now
What it will be like
 if I do action A
Goals
Figure 2.13 A model-based, goal-based agent. It keeps track of the world state as well as
a set of goals it is trying to achieve, and chooses an action that will (eventually) lead to the
achievement of its goals.
example, the taxi may be driving back home, and it may have a rule telling it to fill up with
gas on the way home unless it has at least half a tank. Although “driving back home” may
seem to an aspect of the world state, the fact of the taxi’s destination is actually an aspect of
the agent’s internal state. If you find this puzzling, consider that the taxi could be in exactly
the same place at the same time, but intending to reach a different destination.
2.4.4 Goal-based agents
Knowing something about the current state of the environment is not always enough to decide
what to do. For example, at a road junction, the taxi can turn left, turn right, or go straight
on. The correct decision depends on where the taxi is trying to get to. In other words, as well
GOAL as a current state description, the agent needs some sort of goal information that describes
situations that are desirable—for example, being at the passenger’s destination. The agent
program can combine this with the model (the same information as was used in the modelbased reflex agent) to choose actions that achieve the goal. Figure 2.13 shows the goal-based
agent’s structure.
Sometimes goal-based action selection is straightforward—for example, when goal satisfaction results immediately from a single action. Sometimes it will be more tricky—for
example, when the agent has to consider long sequences of twists and turns in order to find a
way to achieve the goal. Search (Chapters 3 to 5) and planning (Chapters 10 and 11) are the
subfields of AI devoted to finding action sequences that achieve the agent’s goals.
Notice that decision making of this kind is fundamentally different from the condition–
action rules described earlier, in that it involves consideration of the future—both “What will
happen if I do such-and-such?” and “Will that make me happy?” In the reflex agent designs,
this information is not explicitly represented, because the built-in rules map directly from
Section 2.4. The Structure of Agents 53
percepts to actions. The reflex agent brakes when it sees brake lights. A goal-based agent, in
principle, could reason that if the car in front has its brake lights on, it will slow down. Given
the way the world usually evolves, the only action that will achieve the goal of not hitting
other cars is to brake.
Although the goal-based agent appears less efficient, it is more flexible because the
knowledge that supports its decisions is represented explicitly and can be modified. If it starts
to rain, the agent can update its knowledge of how effectively its brakes will operate; this will
automatically cause all of the relevant behaviors to be altered to suit the new conditions.
For the reflex agent, on the other hand, we would have to rewrite many condition–action
rules. The goal-based agent’s behavior can easily be changed to go to a different destination,
simply by specifying that destination as the goal. The reflex agent’s rules for when to turn
and when to go straight will work only for a single destination; they must all be replaced to
go somewhere new.
2.4.5 Utility-based agents
Goals alone are not enough to generate high-quality behavior in most environments. For
example, many action sequences will get the taxi to its destination (thereby achieving the
goal) but some are quicker, safer, more reliable, or cheaper than others. Goals just provide a
crude binary distinction between “happy” and “unhappy” states. A more general performance
measure should allow a comparison of different world states according to exactly how happy
they would make the agent. Because “happy” does not sound very scientific, economists and
computer scientists use the term utility instead.6 UTILITY
We have already seen that a performance measure assigns a score to any given sequence
of environment states, so it can easily distinguish between more and less desirable ways of
UTILITY FUNCTION getting to the taxi’s destination. An agent’s utility function is essentially an internalization
of the performance measure. If the internal utility function and the external performance
measure are in agreement, then an agent that chooses actions to maximize its utility will be
rational according to the external performance measure.
Let us emphasize again that this is not the only way to be rational—we have already
seen a rational agent program for the vacuum world (Figure 2.8) that has no idea what its
utility function is—but, like goal-based agents, a utility-based agent has many advantages in
terms of flexibility and learning. Furthermore, in two kinds of cases, goals are inadequate but
a utility-based agent can still make rational decisions. First, when there are conflicting goals,
only some of which can be achieved (for example, speed and safety), the utility function
specifies the appropriate tradeoff. Second, when there are several goals that the agent can
aim for, none of which can be achieved with certainty, utility provides a way in which the
likelihood of success can be weighed against the importance of the goals.
Partial observability and stochasticity are ubiquitous in the real world, and so, therefore,
is decision making under uncertainty. Technically speaking, a rational utility-based agent
EXPECTED UTILITY chooses the action that maximizes the expected utility of the action outcomes—that is, the
utility the agent expects to derive, on average, given the probabilities and utilities of each
6 The word “utility” here refers to “the quality of being useful,” not to the electric company or waterworks.
54 Chapter 2. Intelligent Agents
Agent
Environment
Sensors
How happy I will be
in such a state
State
How the world evolves
What my actions do
Utility
Actuators
What action I
should do now
What it will be like
if I do action A
What the world
is like now
Figure 2.14 A model-based, utility-based agent. It uses a model of the world, along with
a utility function that measures its preferences among states of the world. Then it chooses the
action that leads to the best expected utility, where expected utility is computed by averaging
over all possible outcome states, weighted by the probability of the outcome.
outcome. (Appendix A defines expectation more precisely.) In Chapter 16, we show that any
rational agent must behave as if it possesses a utility function whose expected value it tries
to maximize. An agent that possesses an explicit utility function can make rational decisions
with a general-purpose algorithm that does not depend on the specific utility function being
maximized. In this way, the “global” definition of rationality—designating as rational those
agent functions that have the highest performance—is turned into a “local” constraint on
rational-agent designs that can be expressed in a simple program.
The utility-based agent structure appears in Figure 2.14. Utility-based agent programs
appear in Part IV, where we design decision-making agents that must handle the uncertainty
inherent in stochastic or partially observable environments.
At this point, the reader may be wondering, “Is it that simple? We just build agents that
maximize expected utility, and we’re done?” It’s true that such agents would be intelligent,
but it’s not simple. A utility-based agent has to model and keep track of its environment,
tasks that have involved a great deal of research on perception, representation, reasoning,
and learning. The results of this research fill many of the chapters of this book. Choosing
the utility-maximizing course of action is also a difficult task, requiring ingenious algorithms
that fill several more chapters. Even with these algorithms, perfect rationality is usually
unachievable in practice because of computational complexity, as we noted in Chapter 1.
2.4.6 Learning agents
We have described agent programs with various methods for selecting actions. We have
not, so far, explained how the agent programs come into being. In his famous early paper,
Turing (1950) considers the idea of actually programming his intelligent machines by hand.
Section 2.4. The Structure of Agents 55
Performance standard
Agent
Environment
Sensors
Performance
element
changes
knowledge
learning
 goals
Problem
generator
feedback
 Learning
element
Critic
Actuators
Figure 2.15 A general learning agent.
He estimates how much work this might take and concludes “Some more expeditious method
seems desirable.” The method he proposes is to build learning machines and then to teach
them. In many areas of AI, this is now the preferred method for creating state-of-the-art
systems. Learning has another advantage, as we noted earlier: it allows the agent to operate
in initially unknown environments and to become more competent than its initial knowledge
alone might allow. In this section, we briefly introduce the main ideas of learning agents.
Throughout the book, we comment on opportunities and methods for learning in particular
kinds of agents. Part V goes into much more depth on the learning algorithms themselves.
A learning agent can be divided into four conceptual components, as shown in FigLEARNING ELEMENT ure 2.15. The most important distinction is between the learning element, which is responsible for making improvements, and the performance element, which is responsible for PERFORMANCE
ELEMENT
selecting external actions. The performance element is what we have previously considered
to be the entire agent: it takes in percepts and decides on actions. The learning element uses
CRITIC feedback from the critic on how the agent is doing and determines how the performance
element should be modified to do better in the future.
The design of the learning element depends very much on the design of the performance
element. When trying to design an agent that learns a certain capability, the first question is
not “How am I going to get it to learn this?” but “What kind of performance element will my
agent need to do this once it has learned how?” Given an agent design, learning mechanisms
can be constructed to improve every part of the agent.
The critic tells the learning element how well the agent is doing with respect to a fixed
performance standard. The critic is necessary because the percepts themselves provide no
indication of the agent’s success. For example, a chess program could receive a percept
indicating that it has checkmated its opponent, but it needs a performance standard to know
that this is a good thing; the percept itself does not say so. It is important that the performance
56 Chapter 2. Intelligent Agents
standard be fixed. Conceptually, one should think of it as being outside the agent altogether
because the agent must not modify it to fit its own behavior.
The last component of the learning agent is the problem generator. It is responsible PROBLEM
GENERATOR
for suggesting actions that will lead to new and informative experiences. The point is that
if the performance element had its way, it would keep doing the actions that are best, given
what it knows. But if the agent is willing to explore a little and do some perhaps suboptimal
actions in the short run, it might discover much better actions for the long run. The problem
generator’s job is to suggest these exploratory actions. This is what scientists do when they
carry out experiments. Galileo did not think that dropping rocks from the top of a tower in
Pisa was valuable in itself. He was not trying to break the rocks or to modify the brains of
unfortunate passers-by. His aim was to modify his own brain by identifying a better theory
of the motion of objects.
To make the overall design more concrete, let us return to the automated taxi example.
The performance element consists of whatever collection of knowledge and procedures the
taxi has for selecting its driving actions. The taxi goes out on the road and drives, using
this performance element. The critic observes the world and passes information along to the
learning element. For example, after the taxi makes a quick left turn across three lanes of traffic, the critic observes the shocking language used by other drivers. From this experience, the
learning element is able to formulate a rule saying this was a bad action, and the performance
element is modified by installation of the new rule. The problem generator might identify
certain areas of behavior in need of improvement and suggest experiments, such as trying out
the brakes on different road surfaces under different conditions.
The learning element can make changes to any of the “knowledge” components shown
in the agent diagrams (Figures 2.9, 2.11, 2.13, and 2.14). The simplest cases involve learning
directly from the percept sequence. Observation of pairs of successive states of the environment can allow the agent to learn “How the world evolves,” and observation of the results of
its actions can allow the agent to learn “What my actions do.” For example, if the taxi exerts
a certain braking pressure when driving on a wet road, then it will soon find out how much
deceleration is actually achieved. Clearly, these two learning tasks are more difficult if the
environment is only partially observable.
The forms of learning in the preceding paragraph do not need to access the external
performance standard—in a sense, the standard is the universal one of making predictions
that agree with experiment. The situation is slightly more complex for a utility-based agent
that wishes to learn utility information. For example, suppose the taxi-driving agent receives
no tips from passengers who have been thoroughly shaken up during the trip. The external
performance standard must inform the agent that the loss of tips is a negative contribution to
its overall performance; then the agent might be able to learn that violent maneuvers do not
contribute to its own utility. In a sense, the performance standard distinguishes part of the
incoming percept as a reward (or penalty) that provides direct feedback on the quality of the
agent’s behavior. Hard-wired performance standards such as pain and hunger in animals can
be understood in this way. This issue is discussed further in Chapter 21.
In summary, agents have a variety of components, and those components can be represented in many ways within the agent program, so there appears to be great variety among
Section 2.4. The Structure of Agents 57
learning methods. There is, however, a single unifying theme. Learning in intelligent agents
can be summarized as a process of modification of each component of the agent to bring the
components into closer agreement with the available feedback information, thereby improving the overall performance of the agent.
2.4.7 How the components of agent programs work
We have described agent programs (in very high-level terms) as consisting of various components, whose function it is to answer questions such as: “What is the world like now?” “What
action should I do now?” “What do my actions do?” The next question for a student of AI
is, “How on earth do these components work?” It takes about a thousand pages to begin to
answer that question properly, but here we want to draw the reader’s attention to some basic
distinctions among the various ways that the components can represent the environment that
the agent inhabits.
Roughly speaking, we can place the representations along an axis of increasing complexity and expressive power—atomic, factored, and structured. To illustrate these ideas,
it helps to consider a particular agent component, such as the one that deals with “What my
actions do.” This component describes the changes that might occur in the environment as
the result of taking an action, and Figure 2.16 provides schematic depictions of how those
transitions might be represented.
B C
(a) Atomic (b) Factored (b) Structured
B C
Figure 2.16 Three ways to represent states and the transitions between them. (a) Atomic
representation: a state (such as B or C) is a black box with no internal structure; (b) Factored
representation: a state consists of a vector of attribute values; values can be Boolean, realvalued, or one of a fixed set of symbols. (c) Structured representation: a state includes
objects, each of which may have attributes of its own as well as relationships to other objects.
In an atomic representation each state of the world is indivisible—it has no internal ATOMIC
REPRESENTATION
structure. Consider the problem of finding a driving route from one end of a country to the
other via some sequence of cities (we address this problem in Figure 3.2 on page 68). For the
purposes of solving this problem, it may suffice to reduce the state of world to just the name
of the city we are in—a single atom of knowledge; a “black box” whose only discernible
property is that of being identical to or different from another black box. The algorithms
58 Chapter 2. Intelligent Agents
underlying search and game-playing (Chapters 3–5), Hidden Markov models (Chapter 15),
and Markov decision processes (Chapter 17) all work with atomic representations—or, at
least, they treat representations as if they were atomic.
Now consider a higher-fidelity description for the same problem, where we need to be
concerned with more than just atomic location in one city or another; we might need to pay
attention to how much gas is in the tank, our current GPS coordinates, whether or not the oil
warning light is working, how much spare change we have for toll crossings, what station is
on the radio, and so on. A factored representation splits up each state into a fixed set of FACTORED
REPRESENTATION
VARIABLE variables or attributes, each of which can have a value. While two different atomic states
ATTRIBUTE
VALUE
have nothing in common—they are just different black boxes—two different factored states
can share some attributes (such as being at some particular GPS location) and not others (such
as having lots of gas or having no gas); this makes it much easier to work out how to turn
one state into another. With factored representations, we can also represent uncertainty—for
example, ignorance about the amount of gas in the tank can be represented by leaving that
attribute blank. Many important areas of AI are based on factored representations, including
constraint satisfaction algorithms (Chapter 6), propositional logic (Chapter 7), planning
(Chapters 10 and 11), Bayesian networks (Chapters 13–16), and the machine learning algorithms in Chapters 18, 20, and 21.
For many purposes, we need to understand the world as having things in it that are
related to each other, not just variables with values. For example, we might notice that a
large truck ahead of us is reversing into the driveway of a dairy farm but a cow has got loose
and is blocking the truck’s path. A factored representation is unlikely to be pre-equipped
with the attribute TruckAheadBackingIntoDairyFarmDrivewayBlockedByLooseCow with
value true or false. Instead, we would need a structured representation, in which ob- STRUCTURED
REPRESENTATION
jects such as cows and trucks and their various and varying relationships can be described
explicitly. (See Figure 2.16(c).) Structured representations underlie relational databases
and first-order logic (Chapters 8, 9, and 12), first-order probability models (Chapter 14),
knowledge-based learning (Chapter 19) and much of natural language understanding
(Chapters 22 and 23). In fact, almost everything that humans express in natural language
concerns objects and their relationships.
As we mentioned earlier, the axis along which atomic, factored, and structured repreEXPRESSIVENESS sentations lie is the axis of increasing expressiveness. Roughly speaking, a more expressive
representation can capture, at least as concisely, everything a less expressive one can capture,
plus some more. Often, the more expressive language is much more concise; for example, the
rules of chess can be written in a page or two of a structured-representation language such
as first-order logic but require thousands of pages when written in a factored-representation
language such as propositional logic. On the other hand, reasoning and learning become
more complex as the expressive power of the representation increases. To gain the benefits
of expressive representations while avoiding their drawbacks, intelligent systems for the real
world may need to operate at all points along the axis simultaneously.
Section 2.5. Summary 59
2.5 SUMMARY
This chapter has been something of a whirlwind tour of AI, which we have conceived of as
the science of agent design. The major points to recall are as follows:
• An agent is something that perceives and acts in an environment. The agent function
for an agent specifies the action taken by the agent in response to any percept sequence.
• The performance measure evaluates the behavior of the agent in an environment. A
rational agent acts so as to maximize the expected value of the performance measure,
given the percept sequence it has seen so far.
• A task environment specification includes the performance measure, the external environment, the actuators, and the sensors. In designing an agent, the first step must
always be to specify the task environment as fully as possible.
• Task environments vary along several significant dimensions. They can be fully or
partially observable, single-agent or multiagent, deterministic or stochastic, episodic or
sequential, static or dynamic, discrete or continuous, and known or unknown.
• The agent program implements the agent function. There exists a variety of basic
agent-program designs reflecting the kind of information made explicit and used in the
decision process. The designs vary in efficiency, compactness, and flexibility. The
appropriate design of the agent program depends on the nature of the environment.
• Simple reflex agents respond directly to percepts, whereas model-based reflex agents
maintain internal state to track aspects of the world that are not evident in the current
percept. Goal-based agents act to achieve their goals, and utility-based agents try to
maximize their own expected “happiness.”
• All agents can improve their performance through learning.
BIBLIOGRAPHICAL AND HISTORICAL NOTES
The central role of action in intelligence—the notion of practical reasoning—goes back at
least as far as Aristotle’s Nicomachean Ethics. Practical reasoning was also the subject of
McCarthy’s (1958) influential paper “Programs with Common Sense.” The fields of robotics
and control theory are, by their very nature, concerned principally with physical agents. The
CONTROLLER concept of a controller in control theory is identical to that of an agent in AI. Perhaps surprisingly, AI has concentrated for most of its history on isolated components of agents—
question-answering systems, theorem-provers, vision systems, and so on—rather than on
whole agents. The discussion of agents in the text by Genesereth and Nilsson (1987) was an
influential exception. The whole-agent view is now widely accepted and is a central theme in
recent texts (Poole et al., 1998; Nilsson, 1998; Padgham and Winikoff, 2004; Jones, 2007).
Chapter 1 traced the roots of the concept of rationality in philosophy and economics. In
AI, the concept was of peripheral interest until the mid-1980s, when it began to suffuse many
60 Chapter 2. Intelligent Agents
discussions about the proper technical foundations of the field. A paper by Jon Doyle (1983)
predicted that rational agent design would come to be seen as the core mission of AI, while
other popular topics would spin off to form new disciplines.
Careful attention to the properties of the environment and their consequences for rational agent design is most apparent in the control theory tradition—for example, classical
control systems (Dorf and Bishop, 2004; Kirk, 2004) handle fully observable, deterministic
environments; stochastic optimal control (Kumar and Varaiya, 1986; Bertsekas and Shreve,
2007) handles partially observable, stochastic environments; and hybrid control (Henzinger
and Sastry, 1998; Cassandras and Lygeros, 2006) deals with environments containing both
discrete and continuous elements. The distinction between fully and partially observable environments is also central in the dynamic programming literature developed in the field of
operations research (Puterman, 1994), which we discuss in Chapter 17.
Reflex agents were the primary model for psychological behaviorists such as Skinner
(1953), who attempted to reduce the psychology of organisms strictly to input/output or stimulus/response mappings. The advance from behaviorism to functionalism in psychology,
which was at least partly driven by the application of the computer metaphor to agents (Putnam, 1960; Lewis, 1966), introduced the internal state of the agent into the picture. Most
work in AI views the idea of pure reflex agents with state as too simple to provide much
leverage, but work by Rosenschein (1985) and Brooks (1986) questioned this assumption
(see Chapter 25). In recent years, a great deal of work has gone into finding efficient algorithms for keeping track of complex environments (Hamscher et al., 1992; Simon, 2006). The
Remote Agent program (described on page 28) that controlled the Deep Space One spacecraft
is a particularly impressive example (Muscettola et al., 1998; Jonsson et al., 2000).
Goal-based agents are presupposed in everything from Aristotle’s view of practical reasoning to McCarthy’s early papers on logical AI. Shakey the Robot (Fikes and Nilsson,
1971; Nilsson, 1984) was the first robotic embodiment of a logical, goal-based agent. A
full logical analysis of goal-based agents appeared in Genesereth and Nilsson (1987), and a
goal-based programming methodology called agent-oriented programming was developed by
Shoham (1993). The agent-based approach is now extremely popular in software engineering (Ciancarini and Wooldridge, 2001). It has also infiltrated the area of operating systems,
where autonomic computing refers to computer systems and networks that monitor and con- AUTONOMIC
COMPUTING
trol themselves with a perceive–act loop and machine learning methods (Kephart and Chess,
2003). Noting that a collection of agent programs designed to work well together in a true
multiagent environment necessarily exhibits modularity—the programs share no internal state
and communicate with each other only through the environment—it is common within the
field of multiagent systems to design the agent program of a single agent as a collection of MULTIAGENT
SYSTEMS
autonomous sub-agents. In some cases, one can even prove that the resulting system gives
the same optimal solutions as a monolithic design.
The goal-based view of agents also dominates the cognitive psychology tradition in the
area of problem solving, beginning with the enormously influential Human Problem Solving (Newell and Simon, 1972) and running through all of Newell’s later work (Newell, 1990).
Goals, further analyzed as desires (general) and intentions (currently pursued), are central to
the theory of agents developed by Bratman (1987). This theory has been influential both in
Exercises 61
natural language understanding and multiagent systems.
Horvitz et al. (1988) specifically suggest the use of rationality conceived as the maximization of expected utility as a basis for AI. The text by Pearl (1988) was the first in AI to
cover probability and utility theory in depth; its exposition of practical methods for reasoning
and decision making under uncertainty was probably the single biggest factor in the rapid
shift towards utility-based agents in the 1990s (see Part IV).
The general design for learning agents portrayed in Figure 2.15 is classic in the machine
learning literature (Buchanan et al., 1978; Mitchell, 1997). Examples of the design, as embodied in programs, go back at least as far as Arthur Samuel’s (1959, 1967) learning program
for playing checkers. Learning agents are discussed in depth in Part V.
Interest in agents and in agent design has risen rapidly in recent years, partly because of
the growth of the Internet and the perceived need for automated and mobile softbot (Etzioni
and Weld, 1994). Relevant papers are collected in Readings in Agents (Huhns and Singh,
1998) and Foundations of Rational Agency (Wooldridge and Rao, 1999). Texts on multiagent
systems usually provide a good introduction to many aspects of agent design (Weiss, 2000a;
Wooldridge, 2002). Several conference series devoted to agents began in the 1990s, including
the International Workshop on Agent Theories, Architectures, and Languages (ATAL), the
International Conference on Autonomous Agents (AGENTS), and the International Conference on Multi-Agent Systems (ICMAS). In 2002, these three merged to form the International
Joint Conference on Autonomous Agents and Multi-Agent Systems (AAMAS). The journal
Autonomous Agents and Multi-Agent Systems was founded in 1998. Finally, Dung Beetle
Ecology (Hanski and Cambefort, 1991) provides a wealth of interesting information on the
behavior of dung beetles. YouTube features inspiring video recordings of their activities.
EXERCISES
2.1 Suppose that the performance measure is concerned with just the first T time steps of
the environment and ignores everything thereafter. Show that a rational agent’s action may
depend not just on the state of the environment but also on the time step it has reached.
2.2 Let us examine the rationality of various vacuum-cleaner agent functions.
a. Show that the simple vacuum-cleaner agent function described in Figure 2.3 is indeed
rational under the assumptions listed on page 38.
b. Describe a rational agent function for the case in which each movement costs one point.
Does the corresponding agent program require internal state?
c. Discuss possible agent designs for the cases in which clean squares can become dirty
and the geography of the environment is unknown. Does it make sense for the agent to
learn from its experience in these cases? If so, what should it learn? If not, why not?
2.3 For each of the following assertions, say whether it is true or false and support your
answer with examples or counterexamples where appropriate.
a. An agent that senses only partial information about the state cannot be perfectly rational.
62 Chapter 2. Intelligent Agents
b. There exist task environments in which no pure reflex agent can behave rationally.
c. There exists a task environment in which every agent is rational.
d. The input to an agent program is the same as the input to the agent function.
e. Every agent function is implementable by some program/machine combination.
f. Suppose an agent selects its action uniformly at random from the set of possible actions.
There exists a deterministic task environment in which this agent is rational.
g. It is possible for a given agent to be perfectly rational in two distinct task environments.
h. Every agent is rational in an unobservable environment.
i. A perfectly rational poker-playing agent never loses.
2.4 For each of the following activities, give a PEAS description of the task environment
and characterize it in terms of the properties listed in Section 2.3.2.
• Playing soccer.
• Exploring the subsurface oceans of Titan.
• Shopping for used AI books on the Internet.
• Playing a tennis match.
• Practicing tennis against a wall.
• Performing a high jump.
• Knitting a sweater.
• Bidding on an item at an auction.
2.5 Define in your own words the following terms: agent, agent function, agent program,
rationality, autonomy, reflex agent, model-based agent, goal-based agent, utility-based agent,
learning agent.
2.6 This exercise explores the differences between agent functions and agent programs.
a. Can there be more than one agent program that implements a given agent function?
Give an example, or show why one is not possible.
b. Are there agent functions that cannot be implemented by any agent program?
c. Given a fixed machine architecture, does each agent program implement exactly one
agent function?
d. Given an architecture with n bits of storage, how many different possible agent programs are there?
e. Suppose we keep the agent program fixed but speed up the machine by a factor of two.
Does that change the agent function?
2.7 Write pseudocode agent programs for the goal-based and utility-based agents.
The following exercises all concern the implementation of environments and agents for the
vacuum-cleaner world.
Exercises 63
2.8 Implement a performance-measuring environment simulator for the vacuum-cleaner
world depicted in Figure 2.2 and specified on page 38. Your implementation should be modular so that the sensors, actuators, and environment characteristics (size, shape, dirt placement,
etc.) can be changed easily. (Note: for some choices of programming language and operating
system there are already implementations in the online code repository.)
2.9 Implement a simple reflex agent for the vacuum environment in Exercise 2.8. Run the
environment with this agent for all possible initial dirt configurations and agent locations.
Record the performance score for each configuration and the overall average score.
2.10 Consider a modified version of the vacuum environment in Exercise 2.8, in which the
agent is penalized one point for each movement.
a. Can a simple reflex agent be perfectly rational for this environment? Explain.
b. What about a reflex agent with state? Design such an agent.
c. How do your answers to a and b change if the agent’s percepts give it the clean/dirty
status of every square in the environment?
2.11 Consider a modified version of the vacuum environment in Exercise 2.8, in which the
geography of the environment—its extent, boundaries, and obstacles—is unknown, as is the
initial dirt configuration. (The agent can go Up and Down as well as Left and Right.)
a. Can a simple reflex agent be perfectly rational for this environment? Explain.
b. Can a simple reflex agent with a randomized agent function outperform a simple reflex
agent? Design such an agent and measure its performance on several environments.
c. Can you design an environment in which your randomized agent will perform poorly?
Show your results.
d. Can a reflex agent with state outperform a simple reflex agent? Design such an agent
and measure its performance on several environments. Can you design a rational agent
of this type?
2.12 Repeat Exercise 2.11 for the case in which the location sensor is replaced with a
“bump” sensor that detects the agent’s attempts to move into an obstacle or to cross the
boundaries of the environment. Suppose the bump sensor stops working; how should the
agent behave?
2.13 The vacuum environments in the preceding exercises have all been deterministic. Discuss possible agent programs for each of the following stochastic versions:
a. Murphy’s law: twenty-five percent of the time, the Suck action fails to clean the floor if
it is dirty and deposits dirt onto the floor if the floor is clean. How is your agent program
affected if the dirt sensor gives the wrong answer 10% of the time?
b. Small children: At each time step, each clean square has a 10% chance of becoming
dirty. Can you come up with a rational agent design for this case?
3 SOLVING PROBLEMS BY
SEARCHING
In which we see how an agent can find a sequence of actions that achieves its
goals when no single action will do.
The simplest agents discussed in Chapter 2 were the reflex agents, which base their actions on
a direct mapping from states to actions. Such agents cannot operate well in environments for
which this mapping would be too large to store and would take too long to learn. Goal-based
agents, on the other hand, consider future actions and the desirability of their outcomes.
This chapter describes one kind of goal-based agent called a problem-solving agent. PROBLEM-SOLVING
AGENT
Problem-solving agents use atomic representations, as described in Section 2.4.7—that is,
states of the world are considered as wholes, with no internal structure visible to the problemsolving algorithms. Goal-based agents that use more advanced factored or structured representations are usually called planning agents and are discussed in Chapters 7 and 10.
Our discussion of problem solving begins with precise definitions of problems and their
solutions and give several examples to illustrate these definitions. We then describe several
general-purpose search algorithms that can be used to solve these problems. We will see
several uninformed search algorithms—algorithms that are given no information about the
problem other than its definition. Although some of these algorithms can solve any solvable
problem, none of them can do so efficiently. Informed search algorithms, on the other hand,
can do quite well given some guidance on where to look for solutions.
In this chapter, we limit ourselves to the simplest kind of task environment, for which
the solution to a problem is always a fixed sequence of actions. The more general case—where
the agent’s future actions may vary depending on future percepts—is handled in Chapter 4.
This chapter uses the concepts of asymptotic complexity (that is, O() notation) and
NP-completeness. Readers unfamiliar with these concepts should consult Appendix A.
3.1 PROBLEM-SOLVING AGENTS
Intelligent agents are supposed to maximize their performance measure. As we mentioned
in Chapter 2, achieving this is sometimes simplified if the agent can adopt a goal and aim at
satisfying it. Let us first look at why and how an agent might do this.
64
Section 3.1. Problem-Solving Agents 65
Imagine an agent in the city of Arad, Romania, enjoying a touring holiday. The agent’s
performance measure contains many factors: it wants to improve its suntan, improve its Romanian, take in the sights, enjoy the nightlife (such as it is), avoid hangovers, and so on. The
decision problem is a complex one involving many tradeoffs and careful reading of guidebooks. Now, suppose the agent has a nonrefundable ticket to fly out of Bucharest the following day. In that case, it makes sense for the agent to adopt the goal of getting to Bucharest.
Courses of action that don’t reach Bucharest on time can be rejected without further consideration and the agent’s decision problem is greatly simplified. Goals help organize behavior
by limiting the objectives that the agent is trying to achieve and hence the actions it needs
GOAL FORMULATION to consider. Goal formulation, based on the current situation and the agent’s performance
measure, is the first step in problem solving.
We will consider a goal to be a set of world states—exactly those states in which the
goal is satisfied. The agent’s task is to find out how to act, now and in the future, so that it
reaches a goal state. Before it can do this, it needs to decide (or we need to decide on its
behalf) what sorts of actions and states it should consider. If it were to consider actions at
the level of “move the left foot forward an inch” or “turn the steering wheel one degree left,”
the agent would probably never find its way out of the parking lot, let alone to Bucharest,
because at that level of detail there is too much uncertainty in the world and there would be
too many steps in a solution. Problem formulation is the process of deciding what actions PROBLEM
FORMULATION
and states to consider, given a goal. We discuss this process in more detail later. For now, let
us assume that the agent will consider actions at the level of driving from one major town to
another. Each state therefore corresponds to being in a particular town.
Our agent has now adopted the goal of driving to Bucharest and is considering where
to go from Arad. Three roads lead out of Arad, one toward Sibiu, one to Timisoara, and one
to Zerind. None of these achieves the goal, so unless the agent is familiar with the geography
of Romania, it will not know which road to follow.1 In other words, the agent will not know
which of its possible actions is best, because it does not yet know enough about the state
that results from taking each action. If the agent has no additional information—i.e., if the
environment is unknown in the sense defined in Section 2.3—then it is has no choice but to
try one of the actions at random. This sad situation is discussed in Chapter 4.
But suppose the agent has a map of Romania. The point of a map is to provide the
agent with information about the states it might get itself into and the actions it can take. The
agent can use this information to consider subsequent stages of a hypothetical journey via
each of the three towns, trying to find a journey that eventually gets to Bucharest. Once it has
found a path on the map from Arad to Bucharest, it can achieve its goal by carrying out the
driving actions that correspond to the legs of the journey. In general, an agent with several
immediate options of unknown value can decide what to do by first examining future actions
that eventually lead to states of known value.
To be more specific about what we mean by “examining future actions,” we have to
be more specific about properties of the environment, as defined in Section 2.3. For now,
1 We are assuming that most readers are in the same position and can easily imagine themselves to be as clueless
as our agent. We apologize to Romanian readers who are unable to take advantage of this pedagogical device.
66 Chapter 3. Solving Problems by Searching
we assume that the environment is observable, so the agent always knows the current state.
For the agent driving in Romania, it’s reasonable to suppose that each city on the map has a
sign indicating its presence to arriving drivers. We also assume the environment is discrete,
so at any given state there are only finitely many actions to choose from. This is true for
navigating in Romania because each city is connected to a small number of other cities. We
will assume the environment is known, so the agent knows which states are reached by each
action. (Having an accurate map suffices to meet this condition for navigation problems.)
Finally, we assume that the environment is deterministic, so each action has exactly one
outcome. Under ideal conditions, this is true for the agent in Romania—it means that if it
chooses to drive from Arad to Sibiu, it does end up in Sibiu. Of course, conditions are not
always ideal, as we show in Chapter 4.
Under these assumptions, the solution to any problem is a fixed sequence of actions.
“Of course!” one might say, “What else could it be?” Well, in general it could be a branching
strategy that recommends different actions in the future depending on what percepts arrive.
For example, under less than ideal conditions, the agent might plan to drive from Arad to
Sibiu and then to Rimnicu Vilcea but may also need to have a contingency plan in case it
arrives by accident in Zerind instead of Sibiu. Fortunately, if the agent knows the initial state
and the environment is known and deterministic, it knows exactly where it will be after the
first action and what it will perceive. Since only one percept is possible after the first action,
the solution can specify only one possible second action, and so on.
SEARCH The process of looking for a sequence of actions that reaches the goal is called search.
SOLUTION A search algorithm takes a problem as input and returns a solution in the form of an action
sequence. Once a solution is found, the actions it recommends can be carried out. This
EXECUTION is called the execution phase. Thus, we have a simple “formulate, search, execute” design
for the agent, as shown in Figure 3.1. After formulating a goal and a problem to solve,
the agent calls a search procedure to solve it. It then uses the solution to guide its actions,
doing whatever the solution recommends as the next thing to do—typically, the first action of
the sequence—and then removing that step from the sequence. Once the solution has been
executed, the agent will formulate a new goal.
Notice that while the agent is executing the solution sequence it ignores its percepts
when choosing an action because it knows in advance what they will be. An agent that
carries out its plans with its eyes closed, so to speak, must be quite certain of what is going
OPEN-LOOP on. Control theorists call this an open-loop system, because ignoring the percepts breaks the
loop between agent and environment.
We first describe the process of problem formulation, and then devote the bulk of the
chapter to various algorithms for the SEARCH function. We do not discuss the workings of
the UPDATE-STATE and FORMULATE-GOAL functions further in this chapter.
3.1.1 Well-defined problems and solutions
PROBLEM A problem can be defined formally by five components:
INITIAL STATE • The initial state that the agent starts in. For example, the initial state for our agent in
Romania might be described as In(Arad).
Section 3.1. Problem-Solving Agents 67
function SIMPLE-PROBLEM-SOLVING-AGENT(percept) returns an action
persistent: seq, an action sequence, initially empty
state, some description of the current world state
goal, a goal, initially null
problem, a problem formulation
state ← UPDATE-STATE(state, percept)
if seq is empty then
goal ← FORMULATE-GOAL(state)
problem ← FORMULATE-PROBLEM(state, goal)
seq ← SEARCH(problem)
if seq = failure then return a null action
action ← FIRST(seq)
seq ← REST(seq)
return action
Figure 3.1 A simple problem-solving agent. It first formulates a goal and a problem,
searches for a sequence of actions that would solve the problem, and then executes the actions
one at a time. When this is complete, it formulates another goal and starts over.
ACTIONS • A description of the possible actions available to the agent. Given a particular state s,
ACTIONS(s) returns the set of actions that can be executed in s. We say that each of
APPLICABLE these actions is applicable in s. For example, from the state In(Arad), the applicable
actions are {Go(Sibiu), Go(Timisoara), Go(Zerind)}.
• A description of what each action does; the formal name for this is the transition
TRANSITION MODEL model, specified by a function RESULT(s, a) that returns the state that results from
SUCCESSOR doing action a in state s. We also use the term successor to refer to any state reachable
from a given state by a single action.2 For example, we have
RESULT(In(Arad),Go(Zerind)) = In(Zerind) .
STATE SPACE Together, the initial state, actions, and transition model implicitly define the state space
of the problem—the set of all states reachable from the initial state by any sequence
GRAPH of actions. The state space forms a directed network or graph in which the nodes
are states and the links between nodes are actions. (The map of Romania shown in
Figure 3.2 can be interpreted as a state-space graph if we view each road as standing
PATH for two driving actions, one in each direction.) A path in the state space is a sequence
of states connected by a sequence of actions.
GOAL TEST • The goal test, which determines whether a given state is a goal state. Sometimes there
is an explicit set of possible goal states, and the test simply checks whether the given
state is one of them. The agent’s goal in Romania is the singleton set {In(Bucharest)}.
2 Many treatments of problem solving, including previous editions of this book, use a successor function, which
returns the set of all successors, instead of separate ACTIONS and RESULT functions. The successor function
makes it difficult to describe an agent that knows what actions it can try but not what they achieve. Also, note
some author use RESULT(a, s) instead of RESULT(s, a), and some use DO instead of RESULT.
68 Chapter 3. Solving Problems by Searching
Giurgiu
Urziceni
Hirsova
Eforie
Neamt
Oradea
Zerind
Arad
Timisoara
Lugoj
Mehadia
Drobeta
Craiova
Sibiu Fagaras
Pitesti
Vaslui
Iasi
Rimnicu Vilcea
Bucharest
71
75
118
111
70
75
120
151
140
99
80
97
101
211
138
146 85
90
98
142
92
87
86
Figure 3.2 A simplified road map of part of Romania.
Sometimes the goal is specified by an abstract property rather than an explicitly enumerated set of states. For example, in chess, the goal is to reach a state called “checkmate,”
where the opponent’s king is under attack and can’t escape.
PATH COST • A path cost function that assigns a numeric cost to each path. The problem-solving
agent chooses a cost function that reflects its own performance measure. For the agent
trying to get to Bucharest, time is of the essence, so the cost of a path might be its length
in kilometers. In this chapter, we assume that the cost of a path can be described as the
sum of the costs of the individual actions along the path.3 STEP COST The step cost of taking action
a in state s to reach state s is denoted by c(s, a, s
). The step costs for Romania are
shown in Figure 3.2 as route distances. We assume that step costs are nonnegative.4
The preceding elements define a problem and can be gathered into a single data structure
that is given as input to a problem-solving algorithm. A solution to a problem is an action
sequence that leads from the initial state to a goal state. Solution quality is measured by the
OPTIMAL SOLUTION path cost function, and an optimal solution has the lowest path cost among all solutions.
3.1.2 Formulating problems
In the preceding section we proposed a formulation of the problem of getting to Bucharest in
terms of the initial state, actions, transition model, goal test, and path cost. This formulation
seems reasonable, but it is still a model—an abstract mathematical description—and not the
3 This assumption is algorithmically convenient but also theoretically justifiable—see page 649 in Chapter 17.
4 The implications of negative costs are explored in Exercise 3.8.
Section 3.2. Example Problems 69
real thing. Compare the simple state description we have chosen, In(Arad), to an actual crosscountry trip, where the state of the world includes so many things: the traveling companions,
the current radio program, the scenery out of the window, the proximity of law enforcement
officers, the distance to the next rest stop, the condition of the road, the weather, and so on.
All these considerations are left out of our state descriptions because they are irrelevant to the
problem of finding a route to Bucharest. The process of removing detail from a representation
ABSTRACTION is called abstraction.
In addition to abstracting the state description, we must abstract the actions themselves.
A driving action has many effects. Besides changing the location of the vehicle and its occupants, it takes up time, consumes fuel, generates pollution, and changes the agent (as they
say, travel is broadening). Our formulation takes into account only the change in location.
Also, there are many actions that we omit altogether: turning on the radio, looking out of
the window, slowing down for law enforcement officers, and so on. And of course, we don’t
specify actions at the level of “turn steering wheel to the left by one degree.”
Can we be more precise about defining the appropriate level of abstraction? Think of the
abstract states and actions we have chosen as corresponding to large sets of detailed world
states and detailed action sequences. Now consider a solution to the abstract problem: for
example, the path from Arad to Sibiu to Rimnicu Vilcea to Pitesti to Bucharest. This abstract
solution corresponds to a large number of more detailed paths. For example, we could drive
with the radio on between Sibiu and Rimnicu Vilcea, and then switch it off for the rest of
the trip. The abstraction is valid if we can expand any abstract solution into a solution in the
more detailed world; a sufficient condition is that for every detailed state that is “in Arad,”
there is a detailed path to some state that is “in Sibiu,” and so on.5 The abstraction is useful
if carrying out each of the actions in the solution is easier than the original problem; in this
case they are easy enough that they can be carried out without further search or planning by
an average driving agent. The choice of a good abstraction thus involves removing as much
detail as possible while retaining validity and ensuring that the abstract actions are easy to
carry out. Were it not for the ability to construct useful abstractions, intelligent agents would
be completely swamped by the real world.
3.2 EXAMPLE PROBLEMS
The problem-solving approach has been applied to a vast array of task environments. We
list some of the best known here, distinguishing between toy and real-world problems. A
TOY PROBLEM toy problem is intended to illustrate or exercise various problem-solving methods. It can be
given a concise, exact description and hence is usable by different researchers to compare the
performance of algorithms. A real-world problem is one whose solutions people actually REAL-WORLD
PROBLEM
care about. Such problems tend not to have a single agreed-upon description, but we can give
the general flavor of their formulations.
5 See Section 11.2 for a more complete set of definitions and algorithms.
70 Chapter 3. Solving Problems by Searching
R
L
S S
S S
R
L
R
L
R
L
S
S S
S
L
L
L L R
R
R
R
Figure 3.3 The state space for the vacuum world. Links denote actions: L = Left,R=
Right,S= Suck.
3.2.1 Toy problems
The first example we examine is the vacuum world first introduced in Chapter 2. (See
Figure 2.2.) This can be formulated as a problem as follows:
• States: The state is determined by both the agent location and the dirt locations. The
agent is in one of two locations, each of which might or might not contain dirt. Thus,
there are 2 × 22 = 8 possible world states. A larger environment with n locations has
n · 2n states.
• Initial state: Any state can be designated as the initial state.
• Actions: In this simple environment, each state has just three actions: Left, Right, and
Suck. Larger environments might also include Up and Down.
• Transition model: The actions have their expected effects, except that moving Left in
the leftmost square, moving Right in the rightmost square, and Sucking in a clean square
have no effect. The complete state space is shown in Figure 3.3.
• Goal test: This checks whether all the squares are clean.
• Path cost: Each step costs 1, so the path cost is the number of steps in the path.
Compared with the real world, this toy problem has discrete locations, discrete dirt, reliable
cleaning, and it never gets any dirtier. Chapter 4 relaxes some of these assumptions.
8-PUZZLE The 8-puzzle, an instance of which is shown in Figure 3.4, consists of a 3×3 board with
eight numbered tiles and a blank space. A tile adjacent to the blank space can slide into the
space. The object is to reach a specified goal state, such as the one shown on the right of the
figure. The standard formulation is as follows:
Section 3.2. Example Problems 71
2
Start State Goal State
1
3 4
6 7
5
1
2
3
4
6
7
8
5
8
Figure 3.4 A typical instance of the 8-puzzle.
• States: A state description specifies the location of each of the eight tiles and the blank
in one of the nine squares.
• Initial state: Any state can be designated as the initial state. Note that any given goal
can be reached from exactly half of the possible initial states (Exercise 3.4).
• Actions: The simplest formulation defines the actions as movements of the blank space
Left, Right, Up, or Down. Different subsets of these are possible depending on where
the blank is.
• Transition model: Given a state and action, this returns the resulting state; for example,
if we apply Left to the start state in Figure 3.4, the resulting state has the 5 and the blank
switched.
• Goal test: This checks whether the state matches the goal configuration shown in Figure 3.4. (Other goal configurations are possible.)
• Path cost: Each step costs 1, so the path cost is the number of steps in the path.
What abstractions have we included here? The actions are abstracted to their beginning and
final states, ignoring the intermediate locations where the block is sliding. We have abstracted
away actions such as shaking the board when pieces get stuck and ruled out extracting the
pieces with a knife and putting them back again. We are left with a description of the rules of
the puzzle, avoiding all the details of physical manipulations.
The 8-puzzle belongs to the family of sliding-block puzzles, which are often used as SLIDING-BLOCK
PUZZLES
test problems for new search algorithms in AI. This family is known to be NP-complete,
so one does not expect to find methods significantly better in the worst case than the search
algorithms described in this chapter and the next. The 8-puzzle has 9!/2 = 181, 440 reachable
states and is easily solved. The 15-puzzle (on a 4×4 board) has around 1.3 trillion states, and
random instances can be solved optimally in a few milliseconds by the best search algorithms.
The 24-puzzle (on a 5 × 5 board) has around 1025 states, and random instances take several
hours to solve optimally.
8-QUEENS PROBLEM The goal of the 8-queens problem is to place eight queens on a chessboard such that
no queen attacks any other. (A queen attacks any piece in the same row, column or diagonal.) Figure 3.5 shows an attempted solution that fails: the queen in the rightmost column is
attacked by the queen at the top left.
72 Chapter 3. Solving Problems by Searching
Figure 3.5 Almost a solution to the 8-queens problem. (Solution is left as an exercise.)
Although efficient special-purpose algorithms exist for this problem and for the whole
n-queens family, it remains a useful test problem for search algorithms. There are two main
kinds of formulation. An incremental formulation involves operators that augment the state INCREMENTAL
FORMULATION
description, starting with an empty state; for the 8-queens problem, this means that each
action adds a queen to the state. A complete-state formulation starts with all 8 queens on COMPLETE-STATE
FORMULATION
the board and moves them around. In either case, the path cost is of no interest because only
the final state counts. The first incremental formulation one might try is the following:
• States: Any arrangement of 0 to 8 queens on the board is a state.
• Initial state: No queens on the board.
• Actions: Add a queen to any empty square.
• Transition model: Returns the board with a queen added to the specified square.
• Goal test: 8 queens are on the board, none attacked.
In this formulation, we have 64 · 63 ··· 57 ≈ 1.8 × 1014 possible sequences to investigate. A
better formulation would prohibit placing a queen in any square that is already attacked:
• States: All possible arrangements of n queens (0 ≤ n ≤ 8), one per column in the
leftmost n columns, with no queen attacking another.
• Actions: Add a queen to any square in the leftmost empty column such that it is not
attacked by any other queen.
This formulation reduces the 8-queens state space from 1.8 × 1014 to just 2,057, and solutions
are easy to find. On the other hand, for 100 queens the reduction is from roughly 10400 states
to about 1052 states (Exercise 3.5)—a big improvement, but not enough to make the problem
tractable. Section 4.1 describes the complete-state formulation, and Chapter 6 gives a simple
algorithm that solves even the million-queens problem with ease.
Section 3.2. Example Problems 73
Our final toy problem was devised by Donald Knuth (1964) and illustrates how infinite
state spaces can arise. Knuth conjectured that, starting with the number 4, a sequence of factorial, square root, and floor operations will reach any desired positive integer. For example,
we can reach 5 from 4 as follows:


	
(4!)!
= 5 .
The problem definition is very simple:
• States: Positive numbers.
• Initial state: 4.
• Actions: Apply factorial, square root, or floor operation (factorial for integers only).
• Transition model: As given by the mathematical definitions of the operations.
• Goal test: State is the desired positive integer.
To our knowledge there is no bound on how large a number might be constructed in the process of reaching a given target—for example, the number 620,448,401,733,239,439,360,000
is generated in the expression for 5—so the state space for this problem is infinite. Such
state spaces arise frequently in tasks involving the generation of mathematical expressions,
circuits, proofs, programs, and other recursively defined objects.
3.2.2 Real-world problems
We have already seen how the route-finding problem is defined in terms of specified loca- ROUTE-FINDING
PROBLEM
tions and transitions along links between them. Route-finding algorithms are used in a variety
of applications. Some, such as Web sites and in-car systems that provide driving directions,
are relatively straightforward extensions of the Romania example. Others, such as routing
video streams in computer networks, military operations planning, and airline travel-planning
systems, involve much more complex specifications. Consider the airline travel problems that
must be solved by a travel-planning Web site:
• States: Each state obviously includes a location (e.g., an airport) and the current time.
Furthermore, because the cost of an action (a flight segment) may depend on previous
segments, their fare bases, and their status as domestic or international, the state must
record extra information about these “historical” aspects.
• Initial state: This is specified by the user’s query.
• Actions: Take any flight from the current location, in any seat class, leaving after the
current time, leaving enough time for within-airport transfer if needed.
• Transition model: The state resulting from taking a flight will have the flight’s destination as the current location and the flight’s arrival time as the current time.
• Goal test: Are we at the final destination specified by the user?
• Path cost: This depends on monetary cost, waiting time, flight time, customs and immigration procedures, seat quality, time of day, type of airplane, frequent-flyer mileage
awards, and so on.
74 Chapter 3. Solving Problems by Searching
Commercial travel advice systems use a problem formulation of this kind, with many additional complications to handle the byzantine fare structures that airlines impose. Any seasoned traveler knows, however, that not all air travel goes according to plan. A really good
system should include contingency plans—such as backup reservations on alternate flights—
to the extent that these are justified by the cost and likelihood of failure of the original plan.
TOURING PROBLEM Touring problems are closely related to route-finding problems, but with an important difference. Consider, for example, the problem “Visit every city in Figure 3.2 at least
once, starting and ending in Bucharest.” As with route finding, the actions correspond
to trips between adjacent cities. The state space, however, is quite different. Each state
must include not just the current location but also the set of cities the agent has visited.
So the initial state would be In(Bucharest), Visited({Bucharest}), a typical intermediate state would be In(Vaslui), Visited({Bucharest, Urziceni, Vaslui}), and the goal test
would check whether the agent is in Bucharest and all 20 cities have been visited.
The traveling salesperson problem (TSP) is a touring problem in which each city TRAVELING
SALESPERSON
PROBLEM
must be visited exactly once. The aim is to find the shortest tour. The problem is known to
be NP-hard, but an enormous amount of effort has been expended to improve the capabilities
of TSP algorithms. In addition to planning trips for traveling salespersons, these algorithms
have been used for tasks such as planning movements of automatic circuit-board drills and of
stocking machines on shop floors.
VLSI LAYOUT A VLSI layout problem requires positioning millions of components and connections
on a chip to minimize area, minimize circuit delays, minimize stray capacitances, and maximize manufacturing yield. The layout problem comes after the logical design phase and is
usually split into two parts: cell layout and channel routing. In cell layout, the primitive
components of the circuit are grouped into cells, each of which performs some recognized
function. Each cell has a fixed footprint (size and shape) and requires a certain number of
connections to each of the other cells. The aim is to place the cells on the chip so that they do
not overlap and so that there is room for the connecting wires to be placed between the cells.
Channel routing finds a specific route for each wire through the gaps between the cells. These
search problems are extremely complex, but definitely worth solving. Later in this chapter,
we present some algorithms capable of solving them.
ROBOT NAVIGATION Robot navigation is a generalization of the route-finding problem described earlier.
Rather than following a discrete set of routes, a robot can move in a continuous space with
(in principle) an infinite set of possible actions and states. For a circular robot moving on a
flat surface, the space is essentially two-dimensional. When the robot has arms and legs or
wheels that must also be controlled, the search space becomes many-dimensional. Advanced
techniques are required just to make the search space finite. We examine some of these
methods in Chapter 25. In addition to the complexity of the problem, real robots must also
deal with errors in their sensor readings and motor controls.
Automatic assembly sequencing of complex objects by a robot was first demonstrated AUTOMATIC
ASSEMBLY
SEQUENCING
by FREDDY (Michie, 1972). Progress since then has been slow but sure, to the point where
the assembly of intricate objects such as electric motors is economically feasible. In assembly
problems, the aim is to find an order in which to assemble the parts of some object. If the
wrong order is chosen, there will be no way to add some part later in the sequence without
Section 3.3. Searching for Solutions 75
undoing some of the work already done. Checking a step in the sequence for feasibility is a
difficult geometrical search problem closely related to robot navigation. Thus, the generation
of legal actions is the expensive part of assembly sequencing. Any practical algorithm must
avoid exploring all but a tiny fraction of the state space. Another important assembly problem
PROTEIN DESIGN is protein design, in which the goal is to find a sequence of amino acids that will fold into a
three-dimensional protein with the right properties to cure some disease.
3.3 SEARCHING FOR SOLUTIONS
Having formulated some problems, we now need to solve them. A solution is an action
sequence, so search algorithms work by considering various possible action sequences. The
SEARCH TREE possible action sequences starting at the initial state form a search tree with the initial state
NODE at the root; the branches are actions and the nodes correspond to states in the state space of
the problem. Figure 3.6 shows the first few steps in growing the search tree for finding a route
from Arad to Bucharest. The root node of the tree corresponds to the initial state, In(Arad).
The first step is to test whether this is a goal state. (Clearly it is not, but it is important to
check so that we can solve trick problems like “starting in Arad, get to Arad.”) Then we
EXPANDING need to consider taking various actions. We do this by expanding the current state; that is,
GENERATING applying each legal action to the current state, thereby generating a new set of states. In
PARENT NODE this case, we add three branches from the parent node In(Arad) leading to three new child
CHILD NODE nodes: In(Sibiu), In(Timisoara), and In(Zerind). Now we must choose which of these three
possibilities to consider further.
This is the essence of search—following up one option now and putting the others aside
for later, in case the first choice does not lead to a solution. Suppose we choose Sibiu first.
We check to see whether it is a goal state (it is not) and then expand it to get In(Arad),
In(Fagaras), In(Oradea), and In(RimnicuVilcea). We can then choose any of these four or go
LEAF NODE back and choose Timisoara or Zerind. Each of these six nodes is a leaf node, that is, a node
with no children in the tree. The set of all leaf nodes available for expansion at any given
FRONTIER point is called the frontier. (Many authors call it the open list, which is both geographically
OPEN LIST less evocative and less accurate, because other data structures are better suited than a list.) In
Figure 3.6, the frontier of each tree consists of those nodes with bold outlines.
The process of expanding nodes on the frontier continues until either a solution is found
or there are no more states to expand. The general TREE-SEARCH algorithm is shown informally in Figure 3.7. Search algorithms all share this basic structure; they vary primarily
SEARCH STRATEGY according to how they choose which state to expand next—the so-called search strategy.
The eagle-eyed reader will notice one peculiar thing about the search tree shown in Figure 3.6: it includes the path from Arad to Sibiu and back to Arad again! We say that In(Arad)
REPEATED STATE is a repeated state in the search tree, generated in this case by a loopy path. Considering
LOOPY PATH such loopy paths means that the complete search tree for Romania is infinite because there
is no limit to how often one can traverse a loop. On the other hand, the state space—the
map shown in Figure 3.2—has only 20 states. As we discuss in Section 3.4, loops can cause
76 Chapter 3. Solving Problems by Searching
certain algorithms to fail, making otherwise solvable problems unsolvable. Fortunately, there
is no need to consider loopy paths. We can rely on more than intuition for this: because path
costs are additive and step costs are nonnegative, a loopy path to any given state is never
better than the same path with the loop removed.
REDUNDANT PATH Loopy paths are a special case of the more general concept of redundant paths, which
exist whenever there is more than one way to get from one state to another. Consider the paths
Arad–Sibiu (140 km long) and Arad–Zerind–Oradea–Sibiu (297 km long). Obviously, the
second path is redundant—it’s just a worse way to get to the same state. If you are concerned
about reaching the goal, there’s never any reason to keep more than one path to any given
state, because any goal state that is reachable by extending one path is also reachable by
extending the other.
In some cases, it is possible to define the problem itself so as to eliminate redundant
paths. For example, if we formulate the 8-queens problem (page 71) so that a queen can be
placed in any column, then each state with n queens can be reached by n! different paths; but
if we reformulate the problem so that each new queen is placed in the leftmost empty column,
then each state can be reached only through one path.
(a) The initial state
(b) After expanding Arad
(c) After expanding Sibiu
Arad Fagaras Oradea Rimnicu Vilcea Arad Lugoj Arad Oradea
Rimnicu Vilcea Lugoj
Sibiu Zerind
Arad Fagaras Oradea
Timisoara
Arad Arad Oradea
Arad Lugoj Arad Oradea
Zerind
Arad
Sibiu Timisoara
Arad
Rimnicu Vilcea
Zerind
Arad
Sibiu
Arad Fagaras Oradea
Timisoara
Figure 3.6 Partial search trees for finding a route from Arad to Bucharest. Nodes that
have been expanded are shaded; nodes that have been generated but not yet expanded are
outlined in bold; nodes that have not yet been generated are shown in faint dashed lines.
Section 3.3. Searching for Solutions 77
function TREE-SEARCH(problem) returns a solution, or failure
initialize the frontier using the initial state of problem
loop do
if the frontier is empty then return failure
choose a leaf node and remove it from the frontier
if the node contains a goal state then return the corresponding solution
expand the chosen node, adding the resulting nodes to the frontier
function GRAPH-SEARCH(problem) returns a solution, or failure
initialize the frontier using the initial state of problem
initialize the explored set to be empty
loop do
if the frontier is empty then return failure
choose a leaf node and remove it from the frontier
if the node contains a goal state then return the corresponding solution
add the node to the explored set
expand the chosen node, adding the resulting nodes to the frontier
only if not in the frontier or explored set
Figure 3.7 An informal description of the general tree-search and graph-search algorithms. The parts of GRAPH-SEARCH marked in bold italic are the additions needed to
handle repeated states.
In other cases, redundant paths are unavoidable. This includes all problems where
the actions are reversible, such as route-finding problems and sliding-block puzzles. RouteRECTANGULAR GRID finding on a rectangular grid (like the one used later for Figure 3.9) is a particularly important example in computer games. In such a grid, each state has four successors, so a search
tree of depth d that includes repeated states has 4d leaves; but there are only about 2d2 distinct
states within d steps of any given state. For d = 20, this means about a trillion nodes but only
about 800 distinct states. Thus, following redundant paths can cause a tractable problem to
become intractable. This is true even for algorithms that know how to avoid infinite loops.
As the saying goes, algorithms that forget their history are doomed to repeat it. The
way to avoid exploring redundant paths is to remember where one has been. To do this, we
EXPLORED SET augment the TREE-SEARCH algorithm with a data structure called the explored set (also
CLOSED LIST known as the closed list), which remembers every expanded node. Newly generated nodes
that match previously generated nodes—ones in the explored set or the frontier—can be discarded instead of being added to the frontier. The new algorithm, called GRAPH-SEARCH, is
shown informally in Figure 3.7. The specific algorithms in this chapter draw on this general
design.
Clearly, the search tree constructed by the GRAPH-SEARCH algorithm contains at most
one copy of each state, so we can think of it as growing a tree directly on the state-space graph,
SEPARATOR as shown in Figure 3.8. The algorithm has another nice property: the frontier separates the
state-space graph into the explored region and the unexplored region, so that every path from
78 Chapter 3. Solving Problems by Searching
Figure 3.8 A sequence of search trees generated by a graph search on the Romania problem of Figure 3.2. At each stage, we have extended each path by one step. Notice that at the
third stage, the northernmost city (Oradea) has become a dead end: both of its successors are
already explored via other paths.
(a) (b) (c)
Figure 3.9 The separation property of GRAPH-SEARCH, illustrated on a rectangular-grid
problem. The frontier (white nodes) always separates the explored region of the state space
(black nodes) from the unexplored region (gray nodes). In (a), just the root has been expanded. In (b), one leaf node has been expanded. In (c), the remaining successors of the root
have been expanded in clockwise order.
the initial state to an unexplored state has to pass through a state in the frontier. (If this
seems completely obvious, try Exercise 3.13 now.) This property is illustrated in Figure 3.9.
As every step moves a state from the frontier into the explored region while moving some
states from the unexplored region into the frontier, we see that the algorithm is systematically
examining the states in the state space, one by one, until it finds a solution.
3.3.1 Infrastructure for search algorithms
Search algorithms require a data structure to keep track of the search tree that is being constructed. For each node n of the tree, we have a structure that contains four components:
• n.STATE: the state in the state space to which the node corresponds;
• n.PARENT: the node in the search tree that generated this node;
• n.ACTION: the action that was applied to the parent to generate the node;
• n.PATH-COST: the cost, traditionally denoted by g(n), of the path from the initial state
to the node, as indicated by the parent pointers.
Section 3.3. Searching for Solutions 79
1
3 2
5 4
6
7
1 8
3 2
5 4
6
7
8
Node
STATE
PARENT
ACTION = Right
PATH-COST = 6
Figure 3.10 Nodes are the data structures from which the search tree is constructed. Each
has a parent, a state, and various bookkeeping fields. Arrows point from child to parent.
Given the components for a parent node, it is easy to see how to compute the necessary
components for a child node. The function CHILD-NODE takes a parent node and an action
and returns the resulting child node:
function CHILD-NODE(problem, parent, action) returns a node
return a node with
STATE = problem.RESULT(parent.STATE, action),
PARENT = parent, ACTION = action,
PATH-COST = parent.PATH-COST + problem.STEP-COST(parent.STATE, action)
The node data structure is depicted in Figure 3.10. Notice how the PARENT pointers
string the nodes together into a tree structure. These pointers also allow the solution path to be
extracted when a goal node is found; we use the SOLUTION function to return the sequence
of actions obtained by following parent pointers back to the root.
Up to now, we have not been very careful to distinguish between nodes and states, but in
writing detailed algorithms it’s important to make that distinction. A node is a bookkeeping
data structure used to represent the search tree. A state corresponds to a configuration of the
world. Thus, nodes are on particular paths, as defined by PARENT pointers, whereas states
are not. Furthermore, two different nodes can contain the same world state if that state is
generated via two different search paths.
Now that we have nodes, we need somewhere to put them. The frontier needs to be
stored in such a way that the search algorithm can easily choose the next node to expand
QUEUE according to its preferred strategy. The appropriate data structure for this is a queue. The
operations on a queue are as follows:
• EMPTY?(queue) returns true only if there are no more elements in the queue.
• POP(queue) removes the first element of the queue and returns it.
• INSERT(element, queue) inserts an element and returns the resulting queue.
80 Chapter 3. Solving Problems by Searching
Queues are characterized by the order in which they store the inserted nodes. Three common
FIFO QUEUE variants are the first-in, first-out or FIFO queue, which pops the oldest element of the queue;
LIFO QUEUE the last-in, first-out or LIFO queue (also known as a stack), which pops the newest element
PRIORITY QUEUE of the queue; and the priority queue, which pops the element of the queue with the highest
priority according to some ordering function.
The explored set can be implemented with a hash table to allow efficient checking for
repeated states. With a good implementation, insertion and lookup can be done in roughly
constant time no matter how many states are stored. One must take care to implement the
hash table with the right notion of equality between states. For example, in the traveling
salesperson problem (page 74), the hash table needs to know that the set of visited cities
{Bucharest,Urziceni,Vaslui} is the same as {Urziceni,Vaslui,Bucharest}. Sometimes this can
be achieved most easily by insisting that the data structures for states be in some canonical
CANONICAL FORM form; that is, logically equivalent states should map to the same data structure. In the case
of states described by sets, for example, a bit-vector representation or a sorted list without
repetition would be canonical, whereas an unsorted list would not.
3.3.2 Measuring problem-solving performance
Before we get into the design of specific search algorithms, we need to consider the criteria
that might be used to choose among them. We can evaluate an algorithm’s performance in
four ways:
COMPLETENESS • Completeness: Is the algorithm guaranteed to find a solution when there is one?
OPTIMALITY • Optimality: Does the strategy find the optimal solution, as defined on page 68?
TIME COMPLEXITY • Time complexity: How long does it take to find a solution?
SPACE COMPLEXITY • Space complexity: How much memory is needed to perform the search?
Time and space complexity are always considered with respect to some measure of the problem difficulty. In theoretical computer science, the typical measure is the size of the state
space graph, |V | + |E|, where V is the set of vertices (nodes) of the graph and E is the set
of edges (links). This is appropriate when the graph is an explicit data structure that is input
to the search program. (The map of Romania is an example of this.) In AI, the graph is often
represented implicitly by the initial state, actions, and transition model and is frequently infinite. For these reasons, complexity is expressed in terms of three quantities: b, the branching
BRANCHING FACTOR factor or maximum number of successors of any node; d, the depth of the shallowest goal
DEPTH node (i.e., the number of steps along the path from the root); and m, the maximum length of
any path in the state space. Time is often measured in terms of the number of nodes generated
during the search, and space in terms of the maximum number of nodes stored in memory.
For the most part, we describe time and space complexity for search on a tree; for a graph,
the answer depends on how “redundant” the paths in the state space are.
SEARCH COST To assess the effectiveness of a search algorithm, we can consider just the search cost—
which typically depends on the time complexity but can also include a term for memory
TOTAL COST usage—or we can use the total cost, which combines the search cost and the path cost of the
solution found. For the problem of finding a route from Arad to Bucharest, the search cost
is the amount of time taken by the search and the solution cost is the total length of the path
Section 3.4. Uninformed Search Strategies 81
in kilometers. Thus, to compute the total cost, we have to add milliseconds and kilometers.
There is no “official exchange rate” between the two, but it might be reasonable in this case to
convert kilometers into milliseconds by using an estimate of the car’s average speed (because
time is what the agent cares about). This enables the agent to find an optimal tradeoff point
at which further computation to find a shorter path becomes counterproductive. The more
general problem of tradeoffs between different goods is taken up in Chapter 16.
3.4 UNINFORMED SEARCH STRATEGIES
This section covers several search strategies that come under the heading of uninformed
search (also called blind search). The term means that the strategies have no additional UNINFORMED
SEARCH
BLIND SEARCH information about states beyond that provided in the problem definition. All they can do is
generate successors and distinguish a goal state from a non-goal state. All search strategies
are distinguished by the order in which nodes are expanded. Strategies that know whether
INFORMED SEARCH one non-goal state is “more promising” than another are called informed search or heuristic
HEURISTIC SEARCH search strategies; they are covered in Section 3.5.
3.4.1 Breadth-first search
Breadth-first search is a simple strategy in which the root node is expanded first, then all the BREADTH-FIRST
SEARCH
successors of the root node are expanded next, then their successors, and so on. In general,
all the nodes are expanded at a given depth in the search tree before any nodes at the next
level are expanded.
Breadth-first search is an instance of the general graph-search algorithm (Figure 3.7) in
which the shallowest unexpanded node is chosen for expansion. This is achieved very simply
by using a FIFO queue for the frontier. Thus, new nodes (which are always deeper than their
parents) go to the back of the queue, and old nodes, which are shallower than the new nodes,
get expanded first. There is one slight tweak on the general graph-search algorithm, which is
that the goal test is applied to each node when it is generated rather than when it is selected for
expansion. This decision is explained below, where we discuss time complexity. Note also
that the algorithm, following the general template for graph search, discards any new path to
a state already in the frontier or explored set; it is easy to see that any such path must be at
least as deep as the one already found. Thus, breadth-first search always has the shallowest
path to every node on the frontier.
Pseudocode is given in Figure 3.11. Figure 3.12 shows the progress of the search on a
simple binary tree.
How does breadth-first search rate according to the four criteria from the previous section? We can easily see that it is complete—if the shallowest goal node is at some finite depth
d, breadth-first search will eventually find it after generating all shallower nodes (provided
the branching factor b is finite). Note that as soon as a goal node is generated, we know it
is the shallowest goal node because all shallower nodes must have been generated already
and failed the goal test. Now, the shallowest goal node is not necessarily the optimal one;
82 Chapter 3. Solving Problems by Searching
function BREADTH-FIRST-SEARCH(problem) returns a solution, or failure
node ←a node with STATE = problem.INITIAL-STATE, PATH-COST = 0
if problem.GOAL-TEST(node.STATE) then return SOLUTION(node)
frontier ← a FIFO queue with node as the only element
explored ← an empty set
loop do
if EMPTY?(frontier ) then return failure
node ← POP(frontier ) /* chooses the shallowest node in frontier */
add node.STATE to explored
for each action in problem.ACTIONS(node.STATE) do
child ← CHILD-NODE(problem, node, action)
if child.STATE is not in explored or frontier then
if problem.GOAL-TEST(child.STATE) then return SOLUTION(child)
frontier ← INSERT(child,frontier )
Figure 3.11 Breadth-first search on a graph.
technically, breadth-first search is optimal if the path cost is a nondecreasing function of the
depth of the node. The most common such scenario is that all actions have the same cost.
So far, the news about breadth-first search has been good. The news about time and
space is not so good. Imagine searching a uniform tree where every state has b successors.
The root of the search tree generates b nodes at the first level, each of which generates b more
nodes, for a total of b2 at the second level. Each of these generates b more nodes, yielding b3
nodes at the third level, and so on. Now suppose that the solution is at depth d. In the worst
case, it is the last node generated at that level. Then the total number of nodes generated is
b + b2 + b3 + ··· + bd = O(bd) .
(If the algorithm were to apply the goal test to nodes when selected for expansion, rather than
when generated, the whole layer of nodes at depth d would be expanded before the goal was
detected and the time complexity would be O(bd+1).)
As for space complexity: for any kind of graph search, which stores every expanded
node in the explored set, the space complexity is always within a factor of b of the time
complexity. For breadth-first graph search in particular, every node generated remains in
memory. There will be O(bd−1) nodes in the explored set and O(bd) nodes in the frontier,
A
B C
D E F G
A
B
D E F G
C
A
C
D E F G
B C B
D E F G
A
Figure 3.12 Breadth-first search on a simple binary tree. At each stage, the node to be
expanded next is indicated by a marker.
Section 3.4. Uninformed Search Strategies 83
so the space complexity is O(bd), i.e., it is dominated by the size of the frontier. Switching
to a tree search would not save much space, and in a state space with many redundant paths,
switching could cost a great deal of time.
An exponential complexity bound such as O(bd) is scary. Figure 3.13 shows why. It
lists, for various values of the solution depth d, the time and memory required for a breadthfirst search with branching factor b = 10. The table assumes that 1 million nodes can be
generated per second and that a node requires 1000 bytes of storage. Many search problems
fit roughly within these assumptions (give or take a factor of 100) when run on a modern
personal computer.
Depth Nodes Time Memory
2 110 .11 milliseconds 107 kilobytes
4 11,110 11 milliseconds 10.6 megabytes
6 106 1.1 seconds 1 gigabyte
8 108 2 minutes 103 gigabytes
10 1010 3 hours 10 terabytes
12 1012 13 days 1 petabyte
14 1014 3.5 years 99 petabytes
16 1016 350 years 10 exabytes
Figure 3.13 Time and memory requirements for breadth-first search. The numbers shown
assume branching factor b = 10; 1 million nodes/second; 1000 bytes/node.
Two lessons can be learned from Figure 3.13. First, the memory requirements are a
bigger problem for breadth-first search than is the execution time. One might wait 13 days
for the solution to an important problem with search depth 12, but no personal computer has
the petabyte of memory it would take. Fortunately, other strategies require less memory.
The second lesson is that time is still a major factor. If your problem has a solution at
depth 16, then (given our assumptions) it will take about 350 years for breadth-first search (or
indeed any uninformed search) to find it. In general, exponential-complexity search problems
cannot be solved by uninformed methods for any but the smallest instances.
3.4.2 Uniform-cost search
When all step costs are equal, breadth-first search is optimal because it always expands the
shallowest unexpanded node. By a simple extension, we can find an algorithm that is optimal
with any step-cost function. Instead of expanding the shallowest node, uniform-cost search UNIFORM-COST
SEARCH
expands the node n with the lowest path cost g(n). This is done by storing the frontier as a
priority queue ordered by g. The algorithm is shown in Figure 3.14.
In addition to the ordering of the queue by path cost, there are two other significant
differences from breadth-first search. The first is that the goal test is applied to a node when
it is selected for expansion (as in the generic graph-search algorithm shown in Figure 3.7)
rather than when it is first generated. The reason is that the first goal node that is generated
84 Chapter 3. Solving Problems by Searching
function UNIFORM-COST-SEARCH(problem) returns a solution, or failure
node ←a node with STATE = problem.INITIAL-STATE, PATH-COST = 0
frontier ← a priority queue ordered by PATH-COST, with node as the only element
explored ← an empty set
loop do
if EMPTY?(frontier ) then return failure
node ← POP(frontier ) /* chooses the lowest-cost node in frontier */
if problem.GOAL-TEST(node.STATE) then return SOLUTION(node)
add node.STATE to explored
for each action in problem.ACTIONS(node.STATE) do
child ← CHILD-NODE(problem, node, action)
if child.STATE is not in explored or frontier then
frontier ← INSERT(child,frontier )
else if child.STATE is in frontier with higher PATH-COST then
replace that frontier node with child
Figure 3.14 Uniform-cost search on a graph. The algorithm is identical to the general
graph search algorithm in Figure 3.7, except for the use of a priority queue and the addition
of an extra check in case a shorter path to a frontier state is discovered. The data structure for
frontier needs to support efficient membership testing, so it should combine the capabilities
of a priority queue and a hash table.
Sibiu Fagaras
Pitesti
Rimnicu Vilcea
Bucharest
99
80
97
101
211
Figure 3.15 Part of the Romania state space, selected to illustrate uniform-cost search.
may be on a suboptimal path. The second difference is that a test is added in case a better
path is found to a node currently on the frontier.
Both of these modifications come into play in the example shown in Figure 3.15, where
the problem is to get from Sibiu to Bucharest. The successors of Sibiu are Rimnicu Vilcea and
Fagaras, with costs 80 and 99, respectively. The least-cost node, Rimnicu Vilcea, is expanded
next, adding Pitesti with cost 80 + 97 = 177. The least-cost node is now Fagaras, so it is
expanded, adding Bucharest with cost 99 + 211 = 310. Now a goal node has been generated,
but uniform-cost search keeps going, choosing Pitesti for expansion and adding a second path
Section 3.4. Uninformed Search Strategies 85
to Bucharest with cost 80+ 97+ 101 = 278. Now the algorithm checks to see if this new path
is better than the old one; it is, so the old one is discarded. Bucharest, now with g-cost 278,
is selected for expansion and the solution is returned.
It is easy to see that uniform-cost search is optimal in general. First, we observe that
whenever uniform-cost search selects a node n for expansion, the optimal path to that node
has been found. (Were this not the case, there would have to be another frontier node n on
the optimal path from the start node to n, by the graph separation property of Figure 3.9;
by definition, n would have lower g-cost than n and would have been selected first.) Then,
because step costs are nonnegative, paths never get shorter as nodes are added. These two
facts together imply that uniform-cost search expands nodes in order of their optimal path
cost. Hence, the first goal node selected for expansion must be the optimal solution.
Uniform-cost search does not care about the number of steps a path has, but only about
their total cost. Therefore, it will get stuck in an infinite loop if there is a path with an infinite
sequence of zero-cost actions—for example, a sequence of NoOp actions.6 Completeness is
guaranteed provided the cost of every step exceeds some small positive constant .
Uniform-cost search is guided by path costs rather than depths, so its complexity is not
easily characterized in terms of b and d. Instead, let C∗ be the cost of the optimal solution,7
and assume that every action costs at least . Then the algorithm’s worst-case time and space
complexity is O(b1+C∗/), which can be much greater than bd. This is because uniformcost search can explore large trees of small steps before exploring paths involving large and
perhaps useful steps. When all step costs are equal, b1+C∗/ is just bd+1. When all step
costs are the same, uniform-cost search is similar to breadth-first search, except that the latter
stops as soon as it generates a goal, whereas uniform-cost search examines all the nodes at
the goal’s depth to see if one has a lower cost; thus uniform-cost search does strictly more
work by expanding nodes at depth d unnecessarily.
3.4.3 Depth-first search
Depth-first search always expands the deepest node in the current frontier of the search tree. DEPTH-FIRST
SEARCH
The progress of the search is illustrated in Figure 3.16. The search proceeds immediately
to the deepest level of the search tree, where the nodes have no successors. As those nodes
are expanded, they are dropped from the frontier, so then the search “backs up” to the next
deepest node that still has unexplored successors.
The depth-first search algorithm is an instance of the graph-search algorithm in Figure 3.7; whereas breadth-first-search uses a FIFO queue, depth-first search uses a LIFO queue.
A LIFO queue means that the most recently generated node is chosen for expansion. This
must be the deepest unexpanded node because it is one deeper than its parent—which, in turn,
was the deepest unexpanded node when it was selected.
As an alternative to the GRAPH-SEARCH-style implementation, it is common to implement depth-first search with a recursive function that calls itself on each of its children in
turn. (A recursive depth-first algorithm incorporating a depth limit is shown in Figure 3.17.)
6 NoOp, or “no operation,” is the name of an assembly language instruction that does nothing.
7 Here, and throughout the book, the “star” in C∗ means an optimal value for C.
86 Chapter 3. Solving Problems by Searching
A
C
F G
M N O
A
C
F G
L M N O
A
C
F G
L M N O
C
F G
L M N O
A
B C
E F G
K L M N O
A
C
E F G
J K L M N O
A
C
E F G
J K L M N O
A
B C
D E F G
I J K L M N O
A
B C
D E F G
H I J K L M N O
A
B C
D E F G
H I J K L M N O
A
B C
D E F G
H I J K L M N O
A
B C
D E F G
H I J K L M N O
Figure 3.16 Depth-first search on a binary tree. The unexplored region is shown in light
gray. Explored nodes with no descendants in the frontier are removed from memory. Nodes
at depth 3 have no successors and M is the only goal node.
The properties of depth-first search depend strongly on whether the graph-search or
tree-search version is used. The graph-search version, which avoids repeated states and redundant paths, is complete in finite state spaces because it will eventually expand every node.
The tree-search version, on the other hand, is not complete—for example, in Figure 3.6 the
algorithm will follow the Arad–Sibiu–Arad–Sibiu loop forever. Depth-first tree search can be
modified at no extra memory cost so that it checks new states against those on the path from
the root to the current node; this avoids infinite loops in finite state spaces but does not avoid
the proliferation of redundant paths. In infinite state spaces, both versions fail if an infinite
non-goal path is encountered. For example, in Knuth’s 4 problem, depth-first search would
keep applying the factorial operator forever.
For similar reasons, both versions are nonoptimal. For example, in Figure 3.16, depthfirst search will explore the entire left subtree even if node C is a goal node. If node J were
also a goal node, then depth-first search would return it as a solution instead of C, which
would be a better solution; hence, depth-first search is not optimal.
Section 3.4. Uninformed Search Strategies 87
The time complexity of depth-first graph search is bounded by the size of the state space
(which may be infinite, of course). A depth-first tree search, on the other hand, may generate
all of the O(bm) nodes in the search tree, where m is the maximum depth of any node; this
can be much greater than the size of the state space. Note that m itself can be much larger
than d (the depth of the shallowest solution) and is infinite if the tree is unbounded.
So far, depth-first search seems to have no clear advantage over breadth-first search,
so why do we include it? The reason is the space complexity. For a graph search, there is
no advantage, but a depth-first tree search needs to store only a single path from the root
to a leaf node, along with the remaining unexpanded sibling nodes for each node on the
path. Once a node has been expanded, it can be removed from memory as soon as all its
descendants have been fully explored. (See Figure 3.16.) For a state space with branching
factor b and maximum depth m, depth-first search requires storage of only O(bm) nodes.
Using the same assumptions as for Figure 3.13 and assuming that nodes at the same depth as
the goal node have no successors, we find that depth-first search would require 156 kilobytes
instead of 10 exabytes at depth d = 16, a factor of 7 trillion times less space. This has
led to the adoption of depth-first tree search as the basic workhorse of many areas of AI,
including constraint satisfaction (Chapter 6), propositional satisfiability (Chapter 7), and logic
programming (Chapter 9). For the remainder of this section, we focus primarily on the treesearch version of depth-first search.
A variant of depth-first search called backtracking search uses still less memory. (See BACKTRACKING
SEARCH
Chapter 6 for more details.) In backtracking, only one successor is generated at a time rather
than all successors; each partially expanded node remembers which successor to generate
next. In this way, only O(m) memory is needed rather than O(bm). Backtracking search
facilitates yet another memory-saving (and time-saving) trick: the idea of generating a successor by modifying the current state description directly rather than copying it first. This
reduces the memory requirements to just one state description and O(m) actions. For this to
work, we must be able to undo each modification when we go back to generate the next successor. For problems with large state descriptions, such as robotic assembly, these techniques
are critical to success.
3.4.4 Depth-limited search
The embarrassing failure of depth-first search in infinite state spaces can be alleviated by
supplying depth-first search with a predetermined depth limit . That is, nodes at depth  are
treated as if they have no successors. This approach is called depth-limited search. The DEPTH-LIMITED
SEARCH
depth limit solves the infinite-path problem. Unfortunately, it also introduces an additional
source of incompleteness if we choose <d, that is, the shallowest goal is beyond the depth
limit. (This is likely when d is unknown.) Depth-limited search will also be nonoptimal if
we choose >d. Its time complexity is O(b) and its space complexity is O(b). Depth-first
search can be viewed as a special case of depth-limited search with  =∞.
Sometimes, depth limits can be based on knowledge of the problem. For example, on
the map of Romania there are 20 cities. Therefore, we know that if there is a solution, it must
be of length 19 at the longest, so  = 19 is a possible choice. But in fact if we studied the
88 Chapter 3. Solving Problems by Searching
function DEPTH-LIMITED-SEARCH(problem, limit) returns a solution, or failure/cutoff
return RECURSIVE-DLS(MAKE-NODE(problem.INITIAL-STATE), problem, limit)
function RECURSIVE-DLS(node, problem, limit) returns a solution, or failure/cutoff
if problem.GOAL-TEST(node.STATE) then return SOLUTION(node)
else if limit = 0 then return cutoff
else
cutoff occurred?←false
for each action in problem.ACTIONS(node.STATE) do
child ← CHILD-NODE(problem, node, action)
result ← RECURSIVE-DLS(child, problem, limit − 1)
if result = cutoff then cutoff occurred?← true
else if result = failure then return result
if cutoff occurred? then return cutoff else return failure
Figure 3.17 A recursive implementation of depth-limited tree search.
map carefully, we would discover that any city can be reached from any other city in at most
DIAMETER 9 steps. This number, known as the diameter of the state space, gives us a better depth limit,
which leads to a more efficient depth-limited search. For most problems, however, we will
not know a good depth limit until we have solved the problem.
Depth-limited search can be implemented as a simple modification to the general treeor graph-search algorithm. Alternatively, it can be implemented as a simple recursive algorithm as shown in Figure 3.17. Notice that depth-limited search can terminate with two
kinds of failure: the standard failure value indicates no solution; the cutoff value indicates
no solution within the depth limit.
3.4.5 Iterative deepening depth-first search
Iterative deepening search (or iterative deepening depth-first search) is a general strategy, ITERATIVE
DEEPENING SEARCH
often used in combination with depth-first tree search, that finds the best depth limit. It does
this by gradually increasing the limit—first 0, then 1, then 2, and so on—until a goal is found.
This will occur when the depth limit reaches d, the depth of the shallowest goal node. The
algorithm is shown in Figure 3.18. Iterative deepening combines the benefits of depth-first
and breadth-first search. Like depth-first search, its memory requirements are modest: O(bd)
to be precise. Like breadth-first search, it is complete when the branching factor is finite and
optimal when the path cost is a nondecreasing function of the depth of the node. Figure 3.19
shows four iterations of ITERATIVE-DEEPENING-SEARCH on a binary search tree, where the
solution is found on the fourth iteration.
Iterative deepening search may seem wasteful because states are generated multiple
times. It turns out this is not too costly. The reason is that in a search tree with the same (or
nearly the same) branching factor at each level, most of the nodes are in the bottom level,
so it does not matter much that the upper levels are generated multiple times. In an iterative
deepening search, the nodes on the bottom level (depth d) are generated once, those on the
Section 3.4. Uninformed Search Strategies 89
function ITERATIVE-DEEPENING-SEARCH(problem) returns a solution, or failure
for depth = 0 to ∞ do
result ← DEPTH-LIMITED-SEARCH(problem, depth)
if result = cutoff then return result
Figure 3.18 The iterative deepening search algorithm, which repeatedly applies depthlimited search with increasing limits. It terminates when a solution is found or if the depthlimited search returns failure, meaning that no solution exists.
Limit = 3
Limit = 2
Limit = 1
Limit = 0 A A
A
B C
A
B C
A
B C
A
B C
A
B C
D E F G
A
B C
D E F G
A
B C
D E F G
A
B C
D E F G
A
B C
D E F G
A
B C
D E F G
A
B C
D E F G
A
B C
D E F G
A
B C
D E F G
H I J K L M N O
A
B C
D E F G
H I J K L M N O
A
B C
D E F G
H I J K L M N O
A
B C
D E F G
H I J K L M N O
A
B C
D E F G
H I J K L M N O
A
B C
D E F G
H I J K L M N O
A
B C
D E F G
H I J K L M N O
A
B C
D E F G
H I J K L M N O
A
B C
D E F G
H I J K L M N O
A
B C
D E F G
H I J K L M N O
A
B C
D E F G
H I J K L M N O
A
B C
D E F G
H I J K L M N O
Figure 3.19 Four iterations of iterative deepening search on a binary tree.
90 Chapter 3. Solving Problems by Searching
next-to-bottom level are generated twice, and so on, up to the children of the root, which are
generated d times. So the total number of nodes generated in the worst case is
N(IDS)=(d)b + (d − 1)b2 + ··· + (1)bd ,
which gives a time complexity of O(bd)—asymptotically the same as breadth-first search.
There is some extra cost for generating the upper levels multiple times, but it is not large. For
example, if b = 10 and d = 5, the numbers are
N(IDS) = 50 + 400 + 3, 000 + 20, 000 + 100, 000 = 123, 450
N(BFS) = 10 + 100 + 1, 000 + 10, 000 + 100, 000 = 111, 110 .
If you are really concerned about repeating the repetition, you can use a hybrid approach
that runs breadth-first search until almost all the available memory is consumed, and then
runs iterative deepening from all the nodes in the frontier. In general, iterative deepening is
the preferred uninformed search method when the search space is large and the depth of the
solution is not known.
Iterative deepening search is analogous to breadth-first search in that it explores a complete layer of new nodes at each iteration before going on to the next layer. It would seem
worthwhile to develop an iterative analog to uniform-cost search, inheriting the latter algorithm’s optimality guarantees while avoiding its memory requirements. The idea is to use
increasing path-cost limits instead of increasing depth limits. The resulting algorithm, called
iterative lengthening search, is explored in Exercise 3.17. It turns out, unfortunately, that ITERATIVE
LENGTHENING
SEARCH
iterative lengthening incurs substantial overhead compared to uniform-cost search.
3.4.6 Bidirectional search
The idea behind bidirectional search is to run two simultaneous searches—one forward from
the initial state and the other backward from the goal—hoping that the two searches meet in
the middle (Figure 3.20). The motivation is that bd/2 + bd/2 is much less than bd, or in the
figure, the area of the two small circles is less than the area of one big circle centered on the
start and reaching to the goal.
Bidirectional search is implemented by replacing the goal test with a check to see
whether the frontiers of the two searches intersect; if they do, a solution has been found.
(It is important to realize that the first such solution found may not be optimal, even if the
two searches are both breadth-first; some additional search is required to make sure there
isn’t another short-cut across the gap.) The check can be done when each node is generated
or selected for expansion and, with a hash table, will take constant time. For example, if a
problem has solution depth d = 6, and each direction runs breadth-first search one node at a
time, then in the worst case the two searches meet when they have generated all of the nodes
at depth 3. For b = 10, this means a total of 2,220 node generations, compared with 1,111,110
for a standard breadth-first search. Thus, the time complexity of bidirectional search using
breadth-first searches in both directions is O(bd/2). The space complexity is also O(bd/2).
We can reduce this by roughly half if one of the two searches is done by iterative deepening,
but at least one of the frontiers must be kept in memory so that the intersection check can be
done. This space requirement is the most significant weakness of bidirectional search.
Section 3.4. Uninformed Search Strategies 91
Goal Start
Figure 3.20 A schematic view of a bidirectional search that is about to succeed when a
branch from the start node meets a branch from the goal node.
The reduction in time complexity makes bidirectional search attractive, but how do we
PREDECESSOR search backward? This is not as easy as it sounds. Let the predecessors of a state x be all
those states that have x as a successor. Bidirectional search requires a method for computing
predecessors. When all the actions in the state space are reversible, the predecessors of x are
just its successors. Other cases may require substantial ingenuity.
Consider the question of what we mean by “the goal” in searching “backward from the
goal.” For the 8-puzzle and for finding a route in Romania, there is just one goal state, so the
backward search is very much like the forward search. If there are several explicitly listed
goal states—for example, the two dirt-free goal states in Figure 3.3—then we can construct a
new dummy goal state whose immediate predecessors are all the actual goal states. But if the
goal is an abstract description, such as the goal that “no queen attacks another queen” in the
n-queens problem, then bidirectional search is difficult to use.
3.4.7 Comparing uninformed search strategies
Figure 3.21 compares search strategies in terms of the four evaluation criteria set forth in
Section 3.3.2. This comparison is for tree-search versions. For graph searches, the main
differences are that depth-first search is complete for finite state spaces and that the space and
time complexities are bounded by the size of the state space.
Criterion Breadth- Uniform- Depth- Depth- Iterative Bidirectional
First Cost First Limited Deepening (if applicable)
Complete? Yesa Yesa,b No No Yesa Yesa,d
Time O(bd) O(b1+C∗/) O(bm) O(b) O(bd) O(bd/2)
Space O(bd) O(b1+C∗/) O(bm) O(b) O(bd) O(bd/2)
Optimal? Yesc Yes No No Yesc Yesc,d
Figure 3.21 Evaluation of tree-search strategies. b is the branching factor; d is the depth
of the shallowest solution; m is the maximum depth of the search tree; l is the depth limit.
Superscript caveats are as follows: a complete if b is finite; b complete if step costs ≥  for
positive ; c optimal if step costs are all identical; d if both directions use breadth-first search.
92 Chapter 3. Solving Problems by Searching
3.5 INFORMED (HEURISTIC) SEARCH STRATEGIES
INFORMED SEARCH This section shows how an informed search strategy—one that uses problem-specific knowledge beyond the definition of the problem itself—can find solutions more efficiently than can
an uninformed strategy.
BEST-FIRST SEARCH The general approach we consider is called best-first search. Best-first search is an
instance of the general TREE-SEARCH or GRAPH-SEARCH algorithm in which a node is
selected for expansion based on an evaluation function, f(n). The evaluation function is EVALUATION
FUNCTION
construed as a cost estimate, so the node with the lowest evaluation is expanded first. The
implementation of best-first graph search is identical to that for uniform-cost search (Figure 3.14), except for the use of f instead of g to order the priority queue.
The choice of f determines the search strategy. (For example, as Exercise 3.21 shows,
best-first tree search includes depth-first search as a special case.) Most best-first algorithms
include as a component of f a heuristic function, denoted h(n): HEURISTIC
FUNCTION
h(n) = estimated cost of the cheapest path from the state at node n to a goal state.
(Notice that h(n) takes a node as input, but, unlike g(n), it depends only on the state at that
node.) For example, in Romania, one might estimate the cost of the cheapest path from Arad
to Bucharest via the straight-line distance from Arad to Bucharest.
Heuristic functions are the most common form in which additional knowledge of the
problem is imparted to the search algorithm. We study heuristics in more depth in Section 3.6.
For now, we consider them to be arbitrary, nonnegative, problem-specific functions, with one
constraint: if n is a goal node, then h(n)=0. The remainder of this section covers two ways
to use heuristic information to guide search.
3.5.1 Greedy best-first search
Greedy best-first search8 tries to expand the node that is closest to the goal, on the grounds GREEDY BEST-FIRST
SEARCH
that this is likely to lead to a solution quickly. Thus, it evaluates nodes by using just the
heuristic function; that is, f(n) = h(n).
Let us see how this works for route-finding problems in Romania; we use the straightline distance heuristic, which we will call hSLD . If the goal is Bucharest, we need to STRAIGHT-LINE
DISTANCE
know the straight-line distances to Bucharest, which are shown in Figure 3.22. For example, hSLD (In(Arad)) = 366. Notice that the values of hSLD cannot be computed from the
problem description itself. Moreover, it takes a certain amount of experience to know that
hSLD is correlated with actual road distances and is, therefore, a useful heuristic.
Figure 3.23 shows the progress of a greedy best-first search using hSLD to find a path
from Arad to Bucharest. The first node to be expanded from Arad will be Sibiu because it
is closer to Bucharest than either Zerind or Timisoara. The next node to be expanded will
be Fagaras because it is closest. Fagaras in turn generates Bucharest, which is the goal. For
this particular problem, greedy best-first search using hSLD finds a solution without ever
8 Our first edition called this greedy search; other authors have called it best-first search. Our more general
usage of the latter term follows Pearl (1984).
Section 3.5. Informed (Heuristic) Search Strategies 93
Urziceni
Neamt
Oradea
Zerind
Timisoara
Mehadia
Sibiu
Pitesti
Rimnicu Vilcea
Vaslui
Bucharest
Giurgiu
Hirsova
Eforie
Arad
Lugoj
Drobeta
Craiova
Fagaras
Iasi
 0
160
242
161
77
151
366
244
226
176
241
253
329
80
199
380
234
374
100
193
Figure 3.22 Values of hSLD—straight-line distances to Bucharest.
expanding a node that is not on the solution path; hence, its search cost is minimal. It is
not optimal, however: the path via Sibiu and Fagaras to Bucharest is 32 kilometers longer
than the path through Rimnicu Vilcea and Pitesti. This shows why the algorithm is called
“greedy”—at each step it tries to get as close to the goal as it can.
Greedy best-first tree search is also incomplete even in a finite state space, much like
depth-first search. Consider the problem of getting from Iasi to Fagaras. The heuristic suggests that Neamt be expanded first because it is closest to Fagaras, but it is a dead end. The
solution is to go first to Vaslui—a step that is actually farther from the goal according to
the heuristic—and then to continue to Urziceni, Bucharest, and Fagaras. The algorithm will
never find this solution, however, because expanding Neamt puts Iasi back into the frontier,
Iasi is closer to Fagaras than Vaslui is, and so Iasi will be expanded again, leading to an infinite loop. (The graph search version is complete in finite spaces, but not in infinite ones.) The
worst-case time and space complexity for the tree version is O(bm), where m is the maximum
depth of the search space. With a good heuristic function, however, the complexity can be
reduced substantially. The amount of the reduction depends on the particular problem and on
the quality of the heuristic.
3.5.2 A* search: Minimizing the total estimated solution cost
The most widely known form of best-first search is called A∗ A search (pronounced “A-star ∗ SEARCH
search”). It evaluates nodes by combining g(n), the cost to reach the node, and h(n), the cost
to get from the node to the goal:
f(n) = g(n) + h(n) .
Since g(n) gives the path cost from the start node to node n, and h(n) is the estimated cost
of the cheapest path from n to the goal, we have
f(n) = estimated cost of the cheapest solution through n .
Thus, if we are trying to find the cheapest solution, a reasonable thing to try first is the
node with the lowest value of g(n) + h(n). It turns out that this strategy is more than just
reasonable: provided that the heuristic function h(n) satisfies certain conditions, A∗ search is
both complete and optimal. The algorithm is identical to UNIFORM-COST-SEARCH except
that A∗ uses g + h instead of g.
94 Chapter 3. Solving Problems by Searching
Rimnicu Vilcea
Zerind
Arad
Sibiu
Arad Fagaras Oradea
Timisoara
Sibiu Bucharest
329 374
366 380 193
253 0
Rimnicu Vilcea
Arad
Sibiu
Arad Fagaras Oradea
Timisoara
329
Zerind
374
366 176 380 193
Zerind
Arad
Sibiu Timisoara
253 329 374
Arad
366
(a) The initial state
(b) After expanding Arad
(c) After expanding Sibiu
(d) After expanding Fagaras
Figure 3.23 Stages in a greedy best-first tree search for Bucharest with the straight-line
distance heuristic hSLD . Nodes are labeled with their h-values.
Conditions for optimality: Admissibility and consistency
The first condition we require for optimality is that h(n) be an admissible heuristic. An ADMISSIBLE
HEURISTIC
admissible heuristic is one that never overestimates the cost to reach the goal. Because g(n)
is the actual cost to reach n along the current path, and f(n) = g(n) + h(n), we have as an
immediate consequence that f(n) never overestimates the true cost of a solution along the
current path through n.
Admissible heuristics are by nature optimistic because they think the cost of solving
the problem is less than it actually is. An obvious example of an admissible heuristic is the
straight-line distance hSLD that we used in getting to Bucharest. Straight-line distance is
admissible because the shortest path between any two points is a straight line, so the straight
Section 3.5. Informed (Heuristic) Search Strategies 95
line cannot be an overestimate. In Figure 3.24, we show the progress of an A∗ tree search for
Bucharest. The values of g are computed from the step costs in Figure 3.2, and the values of
hSLD are given in Figure 3.22. Notice in particular that Bucharest first appears on the frontier
at step (e), but it is not selected for expansion because its f-cost (450) is higher than that of
Pitesti (417). Another way to say this is that there might be a solution through Pitesti whose
cost is as low as 417, so the algorithm will not settle for a solution that costs 450.
CONSISTENCY A second, slightly stronger condition called consistency (or sometimes monotonicity)
MONOTONICITY is required only for applications of A∗ to graph search.9 A heuristic h(n) is consistent if, for
every node n and every successor n of n generated by any action a, the estimated cost of
reaching the goal from n is no greater than the step cost of getting to n plus the estimated
cost of reaching the goal from n
:
h(n) ≤ c(n, a, n
) + h(n
) .
This is a form of the general triangle inequality, which stipulates that each side of a triangle TRIANGLE
INEQUALITY
cannot be longer than the sum of the other two sides. Here, the triangle is formed by n, n
,
and the goal Gn closest to n. For an admissible heuristic, the inequality makes perfect sense:
if there were a route from n to Gn via n that was cheaper than h(n), that would violate the
property that h(n) is a lower bound on the cost to reach Gn.
It is fairly easy to show (Exercise 3.29) that every consistent heuristic is also admissible.
Consistency is therefore a stricter requirement than admissibility, but one has to work quite
hard to concoct heuristics that are admissible but not consistent. All the admissible heuristics
we discuss in this chapter are also consistent. Consider, for example, hSLD . We know that
the general triangle inequality is satisfied when each side is measured by the straight-line
distance and that the straight-line distance between n and n is no greater than c(n, a, n
).
Hence, hSLD is a consistent heuristic.
Optimality of A*
As we mentioned earlier, A∗ has the following properties: the tree-search version of A∗ is
optimal if h(n) is admissible, while the graph-search version is optimal if h(n) is consistent.
We show the second of these two claims since it is more useful. The argument essentially mirrors the argument for the optimality of uniform-cost search, with g replaced by
f—just as in the A∗ algorithm itself.
The first step is to establish the following: if h(n) is consistent, then the values of
f(n) along any path are nondecreasing. The proof follows directly from the definition of
consistency. Suppose n is a successor of n; then g(n
) = g(n) + c(n, a, n
) for some action
a, and we have
f(n
) = g(n
) + h(n
) = g(n) + c(n, a, n
) + h(n
) ≥ g(n) + h(n) = f(n) .
The next step is to prove that whenever A∗ selects a node n for expansion, the optimal path
to that node has been found. Were this not the case, there would have to be another frontier
node n on the optimal path from the start node to n, by the graph separation property of
9 With an admissible but inconsistent heuristic, A∗ requires some extra bookkeeping to ensure optimality.
96 Chapter 3. Solving Problems by Searching
(a) The initial state
(b) After expanding Arad
(c) After expanding Sibiu
Arad
Sibiu Timisoara
447=118+329
Zerind
393=140+253 449=75+374
Arad
366=0+366
(d) After expanding Rimnicu Vilcea
(e) After expanding Fagaras
(f) After expanding Pitesti
Zerind
Arad
Sibiu
Arad
Timisoara
Fagaras Oradea Rimnicu Vilcea
447=118+329 449=75+374
646=280+366 413=220+193 415=239+176 671=291+380
Zerind
Arad
Sibiu Timisoara
447=118+329 449=75+374
Rimnicu Vilcea
Craiova Pitesti Sibiu
526=366+160 553=300+253 417=317+100
Zerind
Arad
Sibiu
Arad
Timisoara
Sibiu Bucharest
Fagaras Oradea
Craiova Pitesti Sibiu
447=118+329 449=75+374
646=280+366
591=338+253 450=450+0 526=366+160 417=317+100 553=300+253
671=291+380
Zerind
Arad
Sibiu
Arad
Timisoara
Sibiu Bucharest
Oradea
Craiova Pitesti Sibiu
Bucharest Craiova Rimnicu Vilcea
418=418+0
447=118+329 449=75+374
646=280+366
591=338+253 450=450+0 526=366+160 553=300+253
615=455+160 607=414+193
671=291+380
Rimnicu Vilcea
Fagaras Rimnicu Vilcea
Arad Fagaras Oradea
646=280+366 415=239+176 671=291+380
Figure 3.24 Stages in an A∗ search for Bucharest. Nodes are labeled with f = g + h. The
h values are the straight-line distances to Bucharest taken from Figure 3.22.
Section 3.5. Informed (Heuristic) Search Strategies 97
O
Z
A
T
L
M
D
C
R
F
P
G
B
U
H
E
V
I
N
380
400
420
S
Figure 3.25 Map of Romania showing contours at f = 380, f = 400, and f = 420, with
Arad as the start state. Nodes inside a given contour have f-costs less than or equal to the
contour value.
Figure 3.9; because f is nondecreasing along any path, n would have lower f-cost than n
and would have been selected first.
From the two preceding observations, it follows that the sequence of nodes expanded
by A∗ using GRAPH-SEARCH is in nondecreasing order of f(n). Hence, the first goal node
selected for expansion must be an optimal solution because f is the true cost for goal nodes
(which have h = 0) and all later goal nodes will be at least as expensive.
The fact that f-costs are nondecreasing along any path also means that we can draw
CONTOUR contours in the state space, just like the contours in a topographic map. Figure 3.25 shows
an example. Inside the contour labeled 400, all nodes have f(n) less than or equal to 400,
and so on. Then, because A∗ expands the frontier node of lowest f-cost, we can see that an
A∗ search fans out from the start node, adding nodes in concentric bands of increasing f-cost.
With uniform-cost search (A∗ search using h(n)=0), the bands will be “circular”
around the start state. With more accurate heuristics, the bands will stretch toward the goal
state and become more narrowly focused around the optimal path. If C∗ is the cost of the
optimal solution path, then we can say the following:
• A∗ expands all nodes with f(n) < C∗.
• A∗ might then expand some of the nodes right on the “goal contour” (where f(n) = C∗)
before selecting a goal node.
Completeness requires that there be only finitely many nodes with cost less than or equal to
C∗, a condition that is true if all step costs exceed some finite  and if b is finite.
Notice that A∗ expands no nodes with f(n) > C∗—for example, Timisoara is not
expanded in Figure 3.24 even though it is a child of the root. We say that the subtree below
98 Chapter 3. Solving Problems by Searching
PRUNING Timisoara is pruned; because hSLD is admissible, the algorithm can safely ignore this subtree
while still guaranteeing optimality. The concept of pruning—eliminating possibilities from
consideration without having to examine them—is important for many areas of AI.
One final observation is that among optimal algorithms of this type—algorithms that
extend search paths from the root and use the same heuristic information—A∗ is optimally
efficient for any given consistent heuristic. That is, no other optimal algorithm is guaran- OPTIMALLY
EFFICIENT
teed to expand fewer nodes than A∗ (except possibly through tie-breaking among nodes with
f(n) = C∗). This is because any algorithm that does not expand all nodes with f(n) < C∗
runs the risk of missing the optimal solution.
That A∗ search is complete, optimal, and optimally efficient among all such algorithms
is rather satisfying. Unfortunately, it does not mean that A∗ is the answer to all our searching
needs. The catch is that, for most problems, the number of states within the goal contour
search space is still exponential in the length of the solution. The details of the analysis are
beyond the scope of this book, but the basic results are as follows. For problems with constant
step costs, the growth in run time as a function of the optimal solution depth d is analyzed in
ABSOLUTE ERROR terms of the the absolute error or the relative error of the heuristic. The absolute error is
RELATIVE ERROR defined as Δ ≡ h∗ − h, where h∗ is the actual cost of getting from the root to the goal, and
the relative error is defined as  ≡ (h∗ − h)/h∗.
The complexity results depend very strongly on the assumptions made about the state
space. The simplest model studied is a state space that has a single goal and is essentially a
tree with reversible actions. (The 8-puzzle satisfies the first and third of these assumptions.)
In this case, the time complexity of A∗ is exponential in the maximum absolute error, that is,
O(bΔ). For constant step costs, we can write this as O(bd), where d is the solution depth.
For almost all heuristics in practical use, the absolute error is at least proportional to the path
cost h∗, so  is constant or growing and the time complexity is exponential in d. We can
also see the effect of a more accurate heuristic: O(bd) = O((b)d), so the effective branching
factor (defined more formally in the next section) is b.
When the state space has many goal states—particularly near-optimal goal states—the
search process can be led astray from the optimal path and there is an extra cost proportional
to the number of goals whose cost is within a factor  of the optimal cost. Finally, in the
general case of a graph, the situation is even worse. There can be exponentially many states
with f(n) < C∗ even if the absolute error is bounded by a constant. For example, consider
a version of the vacuum world where the agent can clean up any square for unit cost without
even having to visit it: in that case, squares can be cleaned in any order. With N initially dirty
squares, there are 2N states where some subset has been cleaned and all of them are on an
optimal solution path—and hence satisfy f(n) < C∗—even if the heuristic has an error of 1.
The complexity of A∗ often makes it impractical to insist on finding an optimal solution.
One can use variants of A∗ that find suboptimal solutions quickly, or one can sometimes
design heuristics that are more accurate but not strictly admissible. In any case, the use of a
good heuristic still provides enormous savings compared to the use of an uninformed search.
In Section 3.6, we look at the question of designing good heuristics.
Computation time is not, however, A∗’s main drawback. Because it keeps all generated
nodes in memory (as do all GRAPH-SEARCH algorithms), A∗ usually runs out of space long
Section 3.5. Informed (Heuristic) Search Strategies 99
function RECURSIVE-BEST-FIRST-SEARCH(problem) returns a solution, or failure
return RBFS(problem, MAKE-NODE(problem.INITIAL-STATE),∞)
function RBFS(problem, node,f limit) returns a solution, or failure and a new f-cost limit
if problem.GOAL-TEST(node.STATE) then return SOLUTION(node)
successors ←[ ]
for each action in problem.ACTIONS(node.STATE) do
add CHILD-NODE(problem, node, action) into successors
if successors is empty then return failure, ∞
for each s in successors do /* update f with value from previous search, if any */
s.f ← max(s.g + s.h, node.f ))
loop do
best ← the lowest f-value node in successors
if best.f > f limit then return failure, best.f
alternative ←the second-lowest f-value among successors
result, best.f ← RBFS(problem, best, min(f limit, alternative))
if result = failure then return result
Figure 3.26 The algorithm for recursive best-first search.
before it runs out of time. For this reason, A∗ is not practical for many large-scale problems. There are, however, algorithms that overcome the space problem without sacrificing
optimality or completeness, at a small cost in execution time. We discuss these next.
3.5.3 Memory-bounded heuristic search
The simplest way to reduce memory requirements for A∗ is to adapt the idea of iterative
deepening to the heuristic search context, resulting in the iterative-deepening A∗ (IDA∗) al- ITERATIVEDEEPENING
A
∗
gorithm. The main difference between IDA∗ and standard iterative deepening is that the cutoff
used is the f-cost (g +h) rather than the depth; at each iteration, the cutoff value is the smallest f-cost of any node that exceeded the cutoff on the previous iteration. IDA∗ is practical
for many problems with unit step costs and avoids the substantial overhead associated with
keeping a sorted queue of nodes. Unfortunately, it suffers from the same difficulties with realvalued costs as does the iterative version of uniform-cost search described in Exercise 3.17.
This section briefly examines two other memory-bounded algorithms, called RBFS and MA∗.
Recursive best-first search (RBFS) is a simple recursive algorithm that attempts to RECURSIVE
BEST-FIRST SEARCH
mimic the operation of standard best-first search, but using only linear space. The algorithm
is shown in Figure 3.26. Its structure is similar to that of a recursive depth-first search, but
rather than continuing indefinitely down the current path, it uses the f limit variable to keep
track of the f-value of the best alternative path available from any ancestor of the current
node. If the current node exceeds this limit, the recursion unwinds back to the alternative
path. As the recursion unwinds, RBFS replaces the f-value of each node along the path
BACKED-UP VALUE with a backed-up value—the best f-value of its children. In this way, RBFS remembers the
f-value of the best leaf in the forgotten subtree and can therefore decide whether it’s worth
100 Chapter 3. Solving Problems by Searching
Zerind
Arad
Sibiu
Arad Fagaras Oradea
Craiova Sibiu
Bucharest Craiova Rimnicu Vilcea
Zerind
Arad
Sibiu
Arad
Sibiu Bucharest
Oradea Rimnicu Vilcea
Zerind
Arad
Sibiu
Arad
Timisoara
Timisoara
Timisoara
Fagaras Oradea Rimnicu Vilcea
Craiova Pitesti Sibiu
646 415 671
526 553
646 671
591 450
646 671
526 553
418 615 607
447 449
447
447 449
449
366
393
366
393
413
415 413 417
366
393
415 450 417 Rimnicu Vilcea
Fagaras
447
415
447
447
417
(a) After expanding Arad, Sibiu,
 and Rimnicu Vilcea
(c) After switching back to Rimnicu Vilcea
 and expanding Pitesti
(b) After unwinding back to Sibiu
 and expanding Fagaras
447
447
∞
∞
∞
417
417
Pitesti
Figure 3.27 Stages in an RBFS search for the shortest route to Bucharest. The f-limit
value for each recursive call is shown on top of each current node, and every node is labeled
with its f-cost. (a) The path via Rimnicu Vilcea is followed until the current best leaf (Pitesti)
has a value that is worse than the best alternative path (Fagaras). (b) The recursion unwinds
and the best leaf value of the forgotten subtree (417) is backed up to Rimnicu Vilcea; then
Fagaras is expanded, revealing a best leaf value of 450. (c) The recursion unwinds and the
best leaf value of the forgotten subtree (450) is backed up to Fagaras; then Rimnicu Vilcea is
expanded. This time, because the best alternative path (through Timisoara) costs at least 447,
the expansion continues to Bucharest.
reexpanding the subtree at some later time. Figure 3.27 shows how RBFS reaches Bucharest.
RBFS is somewhat more efficient than IDA∗, but still suffers from excessive node regeneration. In the example in Figure 3.27, RBFS follows the path via Rimnicu Vilcea, then
Section 3.5. Informed (Heuristic) Search Strategies 101
“changes its mind” and tries Fagaras, and then changes its mind back again. These mind
changes occur because every time the current best path is extended, its f-value is likely to
increase—h is usually less optimistic for nodes closer to the goal. When this happens, the
second-best path might become the best path, so the search has to backtrack to follow it.
Each mind change corresponds to an iteration of IDA∗ and could require many reexpansions
of forgotten nodes to recreate the best path and extend it one more node.
Like A∗ tree search, RBFS is an optimal algorithm if the heuristic function h(n) is
admissible. Its space complexity is linear in the depth of the deepest optimal solution, but
its time complexity is rather difficult to characterize: it depends both on the accuracy of the
heuristic function and on how often the best path changes as nodes are expanded.
IDA∗ and RBFS suffer from using too little memory. Between iterations, IDA∗ retains
only a single number: the current f-cost limit. RBFS retains more information in memory,
but it uses only linear space: even if more memory were available, RBFS has no way to make
use of it. Because they forget most of what they have done, both algorithms may end up reexpanding the same states many times over. Furthermore, they suffer the potentially exponential
increase in complexity associated with redundant paths in graphs (see Section 3.3).
It seems sensible, therefore, to use all available memory. Two algorithms that do this
are MA∗ (memory-bounded A∗) and SMA∗ (simplified MA∗). SMA∗ MA* is—well—simpler, so
SMA* we will describe it. SMA∗ proceeds just like A∗, expanding the best leaf until memory is full.
At this point, it cannot add a new node to the search tree without dropping an old one. SMA∗
always drops the worst leaf node—the one with the highest f-value. Like RBFS, SMA∗
then backs up the value of the forgotten node to its parent. In this way, the ancestor of a
forgotten subtree knows the quality of the best path in that subtree. With this information,
SMA∗ regenerates the subtree only when all other paths have been shown to look worse than
the path it has forgotten. Another way of saying this is that, if all the descendants of a node n
are forgotten, then we will not know which way to go from n, but we will still have an idea
of how worthwhile it is to go anywhere from n.
The complete algorithm is too complicated to reproduce here,10 but there is one subtlety
worth mentioning. We said that SMA∗ expands the best leaf and deletes the worst leaf. What
if all the leaf nodes have the same f-value? To avoid selecting the same node for deletion
and expansion, SMA∗ expands the newest best leaf and deletes the oldest worst leaf. These
coincide when there is only one leaf, but in that case, the current search tree must be a single
path from root to leaf that fills all of memory. If the leaf is not a goal node, then even if it is on
an optimal solution path, that solution is not reachable with the available memory. Therefore,
the node can be discarded exactly as if it had no successors.
SMA∗ is complete if there is any reachable solution—that is, if d, the depth of the
shallowest goal node, is less than the memory size (expressed in nodes). It is optimal if any
optimal solution is reachable; otherwise, it returns the best reachable solution. In practical
terms, SMA∗ is a fairly robust choice for finding optimal solutions, particularly when the state
space is a graph, step costs are not uniform, and node generation is expensive compared to
the overhead of maintaining the frontier and the explored set.
10 A rough sketch appeared in the first edition of this book.
102 Chapter 3. Solving Problems by Searching
On very hard problems, however, it will often be the case that SMA∗ is forced to switch
back and forth continually among many candidate solution paths, only a small subset of which
THRASHING can fit in memory. (This resembles the problem of thrashing in disk paging systems.) Then
the extra time required for repeated regeneration of the same nodes means that problems
that would be practically solvable by A∗, given unlimited memory, become intractable for
SMA∗. That is to say, memory limitations can make a problem intractable from the point
of view of computation time. Although no current theory explains the tradeoff between time
and memory, it seems that this is an inescapable problem. The only way out is to drop the
optimality requirement.
3.5.4 Learning to search better
We have presented several fixed strategies—breadth-first, greedy best-first, and so on—that
have been designed by computer scientists. Could an agent learn how to search better? The
answer is yes, and the method rests on an important concept called the metalevel state space. METALEVEL STATE
SPACE
Each state in a metalevel state space captures the internal (computational) state of a program
that is searching in an object-level state space such as Romania. For example, the internal OBJECT-LEVEL STATE
SPACE
state of the A∗ algorithm consists of the current search tree. Each action in the metalevel state
space is a computation step that alters the internal state; for example, each computation step
in A∗ expands a leaf node and adds its successors to the tree. Thus, Figure 3.24, which shows
a sequence of larger and larger search trees, can be seen as depicting a path in the metalevel
state space where each state on the path is an object-level search tree.
Now, the path in Figure 3.24 has five steps, including one step, the expansion of Fagaras,
that is not especially helpful. For harder problems, there will be many such missteps, and a
metalevel learning algorithm can learn from these experiences to avoid exploring unpromis- METALEVEL
LEARNING
ing subtrees. The techniques used for this kind of learning are described in Chapter 21. The
goal of learning is to minimize the total cost of problem solving, trading off computational
expense and path cost.
3.6 HEURISTIC FUNCTIONS
In this section, we look at heuristics for the 8-puzzle, in order to shed light on the nature of
heuristics in general.
The 8-puzzle was one of the earliest heuristic search problems. As mentioned in Section 3.2, the object of the puzzle is to slide the tiles horizontally or vertically into the empty
space until the configuration matches the goal configuration (Figure 3.28).
The average solution cost for a randomly generated 8-puzzle instance is about 22 steps.
The branching factor is about 3. (When the empty tile is in the middle, four moves are
possible; when it is in a corner, two; and when it is along an edge, three.) This means
that an exhaustive tree search to depth 22 would look at about 322 ≈ 3.1 × 1010 states.
A graph search would cut this down by a factor of about 170,000 because only 9!/2 =
181, 440 distinct states are reachable. (See Exercise 3.4.) This is a manageable number, but
Section 3.6. Heuristic Functions 103
2
Start State Goal State
1
3 4
6 7
5
1
2
3
4
6
7
8
5
8
Figure 3.28 A typical instance of the 8-puzzle. The solution is 26 steps long.
the corresponding number for the 15-puzzle is roughly 1013, so the next order of business is
to find a good heuristic function. If we want to find the shortest solutions by using A∗, we
need a heuristic function that never overestimates the number of steps to the goal. There is a
long history of such heuristics for the 15-puzzle; here are two commonly used candidates:
• h1 = the number of misplaced tiles. For Figure 3.28, all of the eight tiles are out of
position, so the start state would have h1 = 8. h1 is an admissible heuristic because it
is clear that any tile that is out of place must be moved at least once.
• h2 = the sum of the distances of the tiles from their goal positions. Because tiles
cannot move along diagonals, the distance we will count is the sum of the horizontal
and vertical distances. This is sometimes called the city block distance or Manhattan
distance. h2 is also admissible because all any move can do is move one tile one step MANHATTAN
DISTANCE
closer to the goal. Tiles 1 to 8 in the start state give a Manhattan distance of
h2 = 3 + 1 + 2 + 2 + 2 + 3 + 3 + 2 = 18 .
As expected, neither of these overestimates the true solution cost, which is 26.
3.6.1 The effect of heuristic accuracy on performance
One way to characterize the quality of a heuristic is the effective branching factor b∗. If the EFFECTIVE
BRANCHING FACTOR
total number of nodes generated by A∗ for a particular problem is N and the solution depth is
d, then b∗ is the branching factor that a uniform tree of depth d would have to have in order
to contain N + 1 nodes. Thus,
N +1=1+ b∗ + (b∗)
2 + ··· + (b∗)
d .
For example, if A∗ finds a solution at depth 5 using 52 nodes, then the effective branching
factor is 1.92. The effective branching factor can vary across problem instances, but usually
it is fairly constant for sufficiently hard problems. (The existence of an effective branching
factor follows from the result, mentioned earlier, that the number of nodes expanded by A∗
grows exponentially with solution depth.) Therefore, experimental measurements of b∗ on a
small set of problems can provide a good guide to the heuristic’s overall usefulness. A welldesigned heuristic would have a value of b∗ close to 1, allowing fairly large problems to be
solved at reasonable computational cost.
104 Chapter 3. Solving Problems by Searching
To test the heuristic functions h1 and h2, we generated 1200 random problems with
solution lengths from 2 to 24 (100 for each even number) and solved them with iterative
deepening search and with A∗ tree search using both h1 and h2. Figure 3.29 gives the average
number of nodes generated by each strategy and the effective branching factor. The results
suggest that h2 is better than h1, and is far better than using iterative deepening search. Even
for small problems with d = 12, A∗ with h2 is 50,000 times more efficient than uninformed
iterative deepening search.
Search Cost (nodes generated) Effective Branching Factor
d IDS A∗(h1) A∗(h2) IDS A∗(h1) A∗(h2)
2 10 6 6 2.45 1.79 1.79
4 112 13 12 2.87 1.48 1.45
6 680 20 18 2.73 1.34 1.30
8 6384 39 25 2.80 1.33 1.24
10 47127 93 39 2.79 1.38 1.22
12 3644035 227 73 2.78 1.42 1.24
14 – 539 113 – 1.44 1.23
16 – 1301 211 – 1.45 1.25
18 – 3056 363 – 1.46 1.26
20 – 7276 676 – 1.47 1.27
22 – 18094 1219 – 1.48 1.28
24 – 39135 1641 – 1.48 1.26
Figure 3.29 Comparison of the search costs and effective branching factors for the
ITERATIVE-DEEPENING-SEARCH and A∗ algorithms with h1, h2. Data are averaged over
100 instances of the 8-puzzle for each of various solution lengths d.
One might ask whether h2 is always better than h1. The answer is “Essentially, yes.” It
is easy to see from the definitions of the two heuristics that, for any node n, h2(n) ≥ h1(n).
We thus say that h2 dominates h1. Domination translates directly into efficiency: A∗ DOMINATION using
h2 will never expand more nodes than A∗ using h1 (except possibly for some nodes with
f(n) = C∗). The argument is simple. Recall the observation on page 97 that every node
with f(n) < C∗ will surely be expanded. This is the same as saying that every node with
h(n) < C∗ − g(n) will surely be expanded. But because h2 is at least as big as h1 for all
nodes, every node that is surely expanded by A∗ search with h2 will also surely be expanded
with h1, and h1 might cause other nodes to be expanded as well. Hence, it is generally
better to use a heuristic function with higher values, provided it is consistent and that the
computation time for the heuristic is not too long.
3.6.2 Generating admissible heuristics from relaxed problems
We have seen that both h1 (misplaced tiles) and h2 (Manhattan distance) are fairly good
heuristics for the 8-puzzle and that h2 is better. How might one have come up with h2? Is it
possible for a computer to invent such a heuristic mechanically?
h1 and h2 are estimates of the remaining path length for the 8-puzzle, but they are also
perfectly accurate path lengths for simplified versions of the puzzle. If the rules of the puzzle
Section 3.6. Heuristic Functions 105
were changed so that a tile could move anywhere instead of just to the adjacent empty square,
then h1 would give the exact number of steps in the shortest solution. Similarly, if a tile could
move one square in any direction, even onto an occupied square, then h2 would give the exact
number of steps in the shortest solution. A problem with fewer restrictions on the actions is
RELAXED PROBLEM called a relaxed problem. The state-space graph of the relaxed problem is a supergraph of
the original state space because the removal of restrictions creates added edges in the graph.
Because the relaxed problem adds edges to the state space, any optimal solution in the
original problem is, by definition, also a solution in the relaxed problem; but the relaxed
problem may have better solutions if the added edges provide short cuts. Hence, the cost of
an optimal solution to a relaxed problem is an admissible heuristic for the original problem.
Furthermore, because the derived heuristic is an exact cost for the relaxed problem, it must
obey the triangle inequality and is therefore consistent (see page 95).
If a problem definition is written down in a formal language, it is possible to construct
relaxed problems automatically.11 For example, if the 8-puzzle actions are described as
A tile can move from square A to square B if
A is horizontally or vertically adjacent to B and B is blank,
we can generate three relaxed problems by removing one or both of the conditions:
(a) A tile can move from square A to square B if A is adjacent to B.
(b) A tile can move from square A to square B if B is blank.
(c) A tile can move from square A to square B.
From (a), we can derive h2 (Manhattan distance). The reasoning is that h2 would be the
proper score if we moved each tile in turn to its destination. The heuristic derived from (b) is
discussed in Exercise 3.31. From (c), we can derive h1 (misplaced tiles) because it would be
the proper score if tiles could move to their intended destination in one step. Notice that it is
crucial that the relaxed problems generated by this technique can be solved essentially without
search, because the relaxed rules allow the problem to be decomposed into eight independent
subproblems. If the relaxed problem is hard to solve, then the values of the corresponding
heuristic will be expensive to obtain.12
A program called ABSOLVER can generate heuristics automatically from problem definitions, using the “relaxed problem” method and various other techniques (Prieditis, 1993).
ABSOLVER generated a new heuristic for the 8-puzzle that was better than any preexisting
heuristic and found the first useful heuristic for the famous Rubik’s Cube puzzle.
One problem with generating new heuristic functions is that one often fails to get a
single “clearly best” heuristic. If a collection of admissible heuristics h1 ...hm is available
for a problem and none of them dominates any of the others, which should we choose? As it
turns out, we need not make a choice. We can have the best of all worlds, by defining
h(n) = max{h1(n),...,hm(n)} .
11 In Chapters 8 and 10, we describe formal languages suitable for this task; with formal descriptions that can be
manipulated, the construction of relaxed problems can be automated. For now, we use English.
12 Note that a perfect heuristic can be obtained simply by allowing h to run a full breadth-first search “on the
sly.” Thus, there is a tradeoff between accuracy and computation time for heuristic functions.
106 Chapter 3. Solving Problems by Searching
Start State Goal State
1
2
3
4
6
8
5
1 2
3 6
7 8
54
Figure 3.30 A subproblem of the 8-puzzle instance given in Figure 3.28. The task is to
get tiles 1, 2, 3, and 4 into their correct positions, without worrying about what happens to
the other tiles.
This composite heuristic uses whichever function is most accurate on the node in question.
Because the component heuristics are admissible, h is admissible; it is also easy to prove that
h is consistent. Furthermore, h dominates all of its component heuristics.
3.6.3 Generating admissible heuristics from subproblems: Pattern databases
SUBPROBLEM Admissible heuristics can also be derived from the solution cost of a subproblem of a given
problem. For example, Figure 3.30 shows a subproblem of the 8-puzzle instance in Figure 3.28. The subproblem involves getting tiles 1, 2, 3, 4 into their correct positions. Clearly,
the cost of the optimal solution of this subproblem is a lower bound on the cost of the complete problem. It turns out to be more accurate than Manhattan distance in some cases.
PATTERN DATABASE The idea behind pattern databases is to store these exact solution costs for every possible subproblem instance—in our example, every possible configuration of the four tiles
and the blank. (The locations of the other four tiles are irrelevant for the purposes of solving the subproblem, but moves of those tiles do count toward the cost.) Then we compute
an admissible heuristic hDB for each complete state encountered during a search simply by
looking up the corresponding subproblem configuration in the database. The database itself is
constructed by searching back13 from the goal and recording the cost of each new pattern encountered; the expense of this search is amortized over many subsequent problem instances.
The choice of 1-2-3-4 is fairly arbitrary; we could also construct databases for 5-6-7-8,
for 2-4-6-8, and so on. Each database yields an admissible heuristic, and these heuristics can
be combined, as explained earlier, by taking the maximum value. A combined heuristic of
this kind is much more accurate than the Manhattan distance; the number of nodes generated
when solving random 15-puzzles can be reduced by a factor of 1000.
One might wonder whether the heuristics obtained from the 1-2-3-4 database and the
5-6-7-8 could be added, since the two subproblems seem not to overlap. Would this still give
an admissible heuristic? The answer is no, because the solutions of the 1-2-3-4 subproblem
and the 5-6-7-8 subproblem for a given state will almost certainly share some moves—it is
13 By working backward from the goal, the exact solution cost of every instance encountered is immediately
available. This is an example of dynamic programming, which we discuss further in Chapter 17.
Section 3.6. Heuristic Functions 107
unlikely that 1-2-3-4 can be moved into place without touching 5-6-7-8, and vice versa. But
what if we don’t count those moves? That is, we record not the total cost of solving the 1-2-
3-4 subproblem, but just the number of moves involving 1-2-3-4. Then it is easy to see that
the sum of the two costs is still a lower bound on the cost of solving the entire problem. This
is the idea behind disjoint pattern databases. With such databases, it is possible to solve DISJOINT PATTERN
DATABASES
random 15-puzzles in a few milliseconds—the number of nodes generated is reduced by a
factor of 10,000 compared with the use of Manhattan distance. For 24-puzzles, a speedup of
roughly a factor of a million can be obtained.
Disjoint pattern databases work for sliding-tile puzzles because the problem can be
divided up in such a way that each move affects only one subproblem—because only one tile
is moved at a time. For a problem such as Rubik’s Cube, this kind of subdivision is difficult
because each move affects 8 or 9 of the 26 cubies. More general ways of defining additive,
admissible heuristics have been proposed that do apply to Rubik’s cube (Yang et al., 2008),
but they have not yielded a heuristic better than the best nonadditive heuristic for the problem.
3.6.4 Learning heuristics from experience
A heuristic function h(n) is supposed to estimate the cost of a solution beginning from the
state at node n. How could an agent construct such a function? One solution was given in
the preceding sections—namely, to devise relaxed problems for which an optimal solution
can be found easily. Another solution is to learn from experience. “Experience” here means
solving lots of 8-puzzles, for instance. Each optimal solution to an 8-puzzle problem provides
examples from which h(n) can be learned. Each example consists of a state from the solution path and the actual cost of the solution from that point. From these examples, a learning
algorithm can be used to construct a function h(n) that can (with luck) predict solution costs
for other states that arise during search. Techniques for doing just this using neural nets, decision trees, and other methods are demonstrated in Chapter 18. (The reinforcement learning
methods described in Chapter 21 are also applicable.)
FEATURE Inductive learning methods work best when supplied with features of a state that are
relevant to predicting the state’s value, rather than with just the raw state description. For
example, the feature “number of misplaced tiles” might be helpful in predicting the actual
distance of a state from the goal. Let’s call this feature x1(n). We could take 100 randomly
generated 8-puzzle configurations and gather statistics on their actual solution costs. We
might find that when x1(n) is 5, the average solution cost is around 14, and so on. Given
these data, the value of x1 can be used to predict h(n). Of course, we can use several features.
A second feature x2(n) might be “number of pairs of adjacent tiles that are not adjacent in the
goal state.” How should x1(n) and x2(n) be combined to predict h(n)? A common approach
is to use a linear combination:
h(n) = c1x1(n) + c2x2(n) .
The constants c1 and c2 are adjusted to give the best fit to the actual data on solution costs.
One expects both c1 and c2 to be positive because misplaced tiles and incorrect adjacent pairs
make the problem harder to solve. Notice that this heuristic does satisfy the condition that
h(n)=0 for goal states, but it is not necessarily admissible or consistent.
108 Chapter 3. Solving Problems by Searching
3.7 SUMMARY
This chapter has introduced methods that an agent can use to select actions in environments
that are deterministic, observable, static, and completely known. In such cases, the agent can
construct sequences of actions that achieve its goals; this process is called search.
• Before an agent can start searching for solutions, a goal must be identified and a welldefined problem must be formulated.
• A problem consists of five parts: the initial state, a set of actions, a transition model
describing the results of those actions, a goal test function, and a path cost function.
The environment of the problem is represented by a state space. A path through the
state space from the initial state to a goal state is a solution.
• Search algorithms treat states and actions as atomic: they do not consider any internal
structure they might possess.
• A general TREE-SEARCH algorithm considers all possible paths to find a solution,
whereas a GRAPH-SEARCH algorithm avoids consideration of redundant paths.
• Search algorithms are judged on the basis of completeness, optimality, time complexity, and space complexity. Complexity depends on b, the branching factor in the state
space, and d, the depth of the shallowest solution.
• Uninformed search methods have access only to the problem definition. The basic
algorithms are as follows:
– Breadth-first search expands the shallowest nodes first; it is complete, optimal
for unit step costs, but has exponential space complexity.
– Uniform-cost search expands the node with lowest path cost, g(n), and is optimal
for general step costs.
– Depth-first search expands the deepest unexpanded node first. It is neither complete nor optimal, but has linear space complexity. Depth-limited search adds a
depth bound.
– Iterative deepening search calls depth-first search with increasing depth limits
until a goal is found. It is complete, optimal for unit step costs, has time complexity
comparable to breadth-first search, and has linear space complexity.
– Bidirectional search can enormously reduce time complexity, but it is not always
applicable and may require too much space.
• Informed search methods may have access to a heuristic function h(n) that estimates
the cost of a solution from n.
– The generic best-first search algorithm selects a node for expansion according to
an evaluation function.
– Greedy best-first search expands nodes with minimal h(n). It is not optimal but
is often efficient.
Bibliographical and Historical Notes 109
– A∗ search expands nodes with minimal f(n) = g(n) + h(n). A∗ is complete and
optimal, provided that h(n) is admissible (for TREE-SEARCH) or consistent (for
GRAPH-SEARCH). The space complexity of A∗ is still prohibitive.
– RBFS (recursive best-first search) and SMA∗ (simplified memory-bounded A∗)
are robust, optimal search algorithms that use limited amounts of memory; given
enough time, they can solve problems that A∗ cannot solve because it runs out of
memory.
• The performance of heuristic search algorithms depends on the quality of the heuristic
function. One can sometimes construct good heuristics by relaxing the problem definition, by storing precomputed solution costs for subproblems in a pattern database, or
by learning from experience with the problem class.
BIBLIOGRAPHICAL AND HISTORICAL NOTES
The topic of state-space search originated in more or less its current form in the early years of
AI. Newell and Simon’s work on the Logic Theorist (1957) and GPS (1961) led to the establishment of search algorithms as the primary weapons in the armory of 1960s AI researchers
and to the establishment of problem solving as the canonical AI task. Work in operations
research by Richard Bellman (1957) showed the importance of additive path costs in simplifying optimization algorithms. The text on Automated Problem Solving by Nils Nilsson
(1971) established the area on a solid theoretical footing.
Most of the state-space search problems analyzed in this chapter have a long history
in the literature and are less trivial than they might seem. The missionaries and cannibals
problem used in Exercise 3.9 was analyzed in detail by Amarel (1968). It had been considered earlier—in AI by Simon and Newell (1961) and in operations research by Bellman and
Dreyfus (1962).
The 8-puzzle is a smaller cousin of the 15-puzzle, whose history is recounted at length
by Slocum and Sonneveld (2006). It was widely believed to have been invented by the famous American game designer Sam Loyd, based on his claims to that effect from 1891 onward (Loyd, 1959). Actually it was invented by Noyes Chapman, a postmaster in Canastota,
New York, in the mid-1870s. (Chapman was unable to patent his invention, as a generic
patent covering sliding blocks with letters, numbers, or pictures was granted to Ernest Kinsey
in 1878.) It quickly attracted the attention of the public and of mathematicians (Johnson and
Story, 1879; Tait, 1880). The editors of the American Journal of Mathematics stated, “The
‘15’ puzzle for the last few weeks has been prominently before the American public, and may
safely be said to have engaged the attention of nine out of ten persons of both sexes and all
ages and conditions of the community.” Ratner and Warmuth (1986) showed that the general
n × n version of the 15-puzzle belongs to the class of NP-complete problems.
The 8-queens problem was first published anonymously in the German chess magazine Schach in 1848; it was later attributed to one Max Bezzel. It was republished in 1850
and at that time drew the attention of the eminent mathematician Carl Friedrich Gauss, who
110 Chapter 3. Solving Problems by Searching
attempted to enumerate all possible solutions; initially he found only 72, but eventually he
found the correct answer of 92, although Nauck published all 92 solutions first, in 1850.
Netto (1901) generalized the problem to n queens, and Abramson and Yung (1989) found an
O(n) algorithm.
Each of the real-world search problems listed in the chapter has been the subject of a
good deal of research effort. Methods for selecting optimal airline flights remain proprietary
for the most part, but Carl de Marcken (personal communication) has shown that airline ticket
pricing and restrictions have become so convoluted that the problem of selecting an optimal
flight is formally undecidable. The traveling-salesperson problem is a standard combinatorial problem in theoretical computer science (Lawler et al., 1992). Karp (1972) proved the
TSP to be NP-hard, but effective heuristic approximation methods were developed (Lin and
Kernighan, 1973). Arora (1998) devised a fully polynomial approximation scheme for Euclidean TSPs. VLSI layout methods are surveyed by Shahookar and Mazumder (1991), and
many layout optimization papers appear in VLSI journals. Robotic navigation and assembly
problems are discussed in Chapter 25.
Uninformed search algorithms for problem solving are a central topic of classical computer science (Horowitz and Sahni, 1978) and operations research (Dreyfus, 1969). Breadthfirst search was formulated for solving mazes by Moore (1959). The method of dynamic
programming (Bellman, 1957; Bellman and Dreyfus, 1962), which systematically records
solutions for all subproblems of increasing lengths, can be seen as a form of breadth-first
search on graphs. The two-point shortest-path algorithm of Dijkstra (1959) is the origin
of uniform-cost search. These works also introduced the idea of explored and frontier sets
(closed and open lists).
A version of iterative deepening designed to make efficient use of the chess clock was
first used by Slate and Atkin (1977) in the CHESS 4.5 game-playing program. Martelli’s
algorithm B (1977) includes an iterative deepening aspect and also dominates A∗’s worst-case
performance with admissible but inconsistent heuristics. The iterative deepening technique
came to the fore in work by Korf (1985a). Bidirectional search, which was introduced by
Pohl (1971), can also be effective in some cases.
The use of heuristic information in problem solving appears in an early paper by Simon
and Newell (1958), but the phrase “heuristic search” and the use of heuristic functions that
estimate the distance to the goal came somewhat later (Newell and Ernst, 1965; Lin, 1965).
Doran and Michie (1966) conducted extensive experimental studies of heuristic search. Although they analyzed path length and “penetrance” (the ratio of path length to the total number of nodes examined so far), they appear to have ignored the information provided by the
path cost g(n). The A∗ algorithm, incorporating the current path cost into heuristic search,
was developed by Hart, Nilsson, and Raphael (1968), with some later corrections (Hart et al.,
1972). Dechter and Pearl (1985) demonstrated the optimal efficiency of A∗.
The original A∗ paper introduced the consistency condition on heuristic functions. The
monotone condition was introduced by Pohl (1977) as a simpler replacement, but Pearl (1984)
showed that the two were equivalent.
Pohl (1977) pioneered the study of the relationship between the error in heuristic functions and the time complexity of A∗. Basic results were obtained for tree search with unit step
Bibliographical and Historical Notes 111
costs and a single goal node (Pohl, 1977; Gaschnig, 1979; Huyn et al., 1980; Pearl, 1984) and
with multiple goal nodes (Dinh et al., 2007). The “effective branching factor” was proposed
by Nilsson (1971) as an empirical measure of the efficiency; it is equivalent to assuming a
time cost of O((b∗)d). For tree search applied to a graph, Korf et al. (2001) argue that the time
cost is better modeled as O(bd−k), where k depends on the heuristic accuracy; this analysis
has elicited some controversy, however. For graph search, Helmert and R¨oger (2008) noted
that several well-known problems contained exponentially many nodes on optimal solution
paths, implying exponential time complexity for A∗ even with constant absolute error in h.
There are many variations on the A∗ algorithm. Pohl (1973) proposed the use of dynamic
weighting, which uses a weighted sum fw(n) = wgg(n) + whh(n) of the current path length
and the heuristic function as an evaluation function, rather than the simple sum f(n) = g(n)+
h(n) used in A∗. The weights wg and wh are adjusted dynamically as the search progresses.
Pohl’s algorithm can be shown to be -admissible—that is, guaranteed to find solutions within
a factor 1 +  of the optimal solution, where  is a parameter supplied to the algorithm. The
same property is exhibited by the A∗
 algorithm (Pearl, 1984), which can select any node from
the frontier provided its f-cost is within a factor 1 +  of the lowest-f-cost frontier node. The
selection can be done so as to minimize search cost.
Bidirectional versions of A∗ have been investigated; a combination of bidirectional A∗
and known landmarks was used to efficiently find driving routes for Microsoft’s online map
service (Goldberg et al., 2006). After caching a set of paths between landmarks, the algorithm
can find an optimal path between any pair of points in a 24 million point graph of the United
States, searching less than 0.1% of the graph. Others approaches to bidirectional search
include a breadth-first search backward from the goal up to a fixed depth, followed by a
forward IDA∗ search (Dillenburg and Nelson, 1994; Manzini, 1995).
A∗ and other state-space search algorithms are closely related to the branch-and-bound
techniques that are widely used in operations research (Lawler and Wood, 1966). The
relationships between state-space search and branch-and-bound have been investigated in
depth (Kumar and Kanal, 1983; Nau et al., 1984; Kumar et al., 1988). Martelli and Montanari (1978) demonstrate a connection between dynamic programming (see Chapter 17) and
certain types of state-space search. Kumar and Kanal (1988) attempt a “grand unification” of
heuristic search, dynamic programming, and branch-and-bound techniques under the name
of CDP—the “composite decision process.”
Because computers in the late 1950s and early 1960s had at most a few thousand words
of main memory, memory-bounded heuristic search was an early research topic. The Graph
Traverser (Doran and Michie, 1966), one of the earliest search programs, commits to an
operator after searching best-first up to the memory limit. IDA∗ (Korf, 1985a, 1985b) was the
first widely used optimal, memory-bounded heuristic search algorithm, and a large number
of variants have been developed. An analysis of the efficiency of IDA∗ and of its difficulties
with real-valued heuristics appears in Patrick et al. (1992).
RBFS (Korf, 1993) is actually somewhat more complicated than the algorithm shown
in Figure 3.26, which is closer to an independently developed algorithm called iterative expansion (Russell, 1992). RBFS uses a lower bound as well as the upper bound; the two al- ITERATIVE
EXPANSION
gorithms behave identically with admissible heuristics, but RBFS expands nodes in best-first
112 Chapter 3. Solving Problems by Searching
order even with an inadmissible heuristic. The idea of keeping track of the best alternative
path appeared earlier in Bratko’s (1986) elegant Prolog implementation of A∗ and in the DTA∗
algorithm (Russell and Wefald, 1991). The latter work also discusses metalevel state spaces
and metalevel learning.
The MA∗ algorithm appeared in Chakrabarti et al. (1989). SMA∗, or Simplified MA∗,
emerged from an attempt to implement MA∗ as a comparison algorithm for IE (Russell, 1992).
Kaindl and Khorsand (1994) have applied SMA∗ to produce a bidirectional search algorithm
that is substantially faster than previous algorithms. Korf and Zhang (2000) describe a divideand-conquer approach, and Zhou and Hansen (2002) introduce memory-bounded A∗ graph
search and a strategy for switching to breadth-first search to increase memory-efficiency
(Zhou and Hansen, 2006). Korf (1995) surveys memory-bounded search techniques.
The idea that admissible heuristics can be derived by problem relaxation appears in the
seminal paper by Held and Karp (1970), who used the minimum-spanning-tree heuristic to
solve the TSP. (See Exercise 3.30.)
The automation of the relaxation process was implemented successfully by Prieditis (1993), building on earlier work with Mostow (Mostow and Prieditis, 1989). Holte and
Hernadvolgyi (2001) describe more recent steps towards automating the process. The use of
pattern databases to derive admissible heuristics is due to Gasser (1995) and Culberson and
Schaeffer (1996, 1998); disjoint pattern databases are described by Korf and Felner (2002);
a similar method using symbolic patterns is due to Edelkamp (2009). Felner et al. (2007)
show how to compress pattern databases to save space. The probabilistic interpretation of
heuristics was investigated in depth by Pearl (1984) and Hansson and Mayer (1989).
By far the most comprehensive source on heuristics and heuristic search algorithms
is Pearl’s (1984) Heuristics text. This book provides especially good coverage of the wide
variety of offshoots and variations of A∗, including rigorous proofs of their formal properties.
Kanal and Kumar (1988) present an anthology of important articles on heuristic search, and
Rayward-Smith et al. (1996) cover approaches from Operations Research. Papers about new
search algorithms—which, remarkably, continue to be discovered—appear in journals such
as Artificial Intelligence and Journal of the ACM.
PARALLEL SEARCH The topic of parallel search algorithms was not covered in the chapter, partly because
it requires a lengthy discussion of parallel computer architectures. Parallel search became a
popular topic in the 1990s in both AI and theoretical computer science (Mahanti and Daniels,
1993; Grama and Kumar, 1995; Crauser et al., 1998) and is making a comeback in the era
of new multicore and cluster architectures (Ralphs et al., 2004; Korf and Schultze, 2005).
Also of increasing importance are search algorithms for very large graphs that require disk
storage (Korf, 2008).
EXERCISES
3.1 Explain why problem formulation must follow goal formulation.
3.2 Your goal is to navigate a robot out of a maze. The robot starts in the center of the maze
Exercises 113
facing north. You can turn the robot to face north, east, south, or west. You can direct the
robot to move forward a certain distance, although it will stop before hitting a wall.
a. Formulate this problem. How large is the state space?
b. In navigating a maze, the only place we need to turn is at the intersection of two or
more corridors. Reformulate this problem using this observation. How large is the state
space now?
c. From each point in the maze, we can move in any of the four directions until we reach a
turning point, and this is the only action we need to do. Reformulate the problem using
these actions. Do we need to keep track of the robot’s orientation now?
d. In our initial description of the problem we already abstracted from the real world,
restricting actions and removing details. List three such simplifications we made.
3.3 Suppose two friends live in different cities on a map, such as the Romania map shown
in Figure 3.2. On every turn, we can simultaneously move each friend to a neighboring city
on the map. The amount of time needed to move from city i to neighbor j is equal to the road
distance d(i, j) between the cities, but on each turn the friend that arrives first must wait until
the other one arrives (and calls the first on his/her cell phone) before the next turn can begin.
We want the two friends to meet as quickly as possible.
a. Write a detailed formulation for this search problem. (You will find it helpful to define
some formal notation here.)
b. Let D(i, j) be the straight-line distance between cities i and j. Which of the following
heuristic functions are admissible? (i) D(i, j); (ii) 2 · D(i, j); (iii) D(i, j)/2.
c. Are there completely connected maps for which no solution exists?
d. Are there maps in which all solutions require one friend to visit the same city twice?
3.4 Show that the 8-puzzle states are divided into two disjoint sets, such that any state is
reachable from any other state in the same set, while no state is reachable from any state in
the other set. (Hint: See Berlekamp et al. (1982).) Devise a procedure to decide which set a
given state is in, and explain why this is useful for generating random states.
3.5 Consider the n-queens problem using the “efficient” incremental formulation given on
page 72. Explain why the state space has at least √3 n! states and estimate the largest n for
which exhaustive exploration is feasible. (Hint: Derive a lower bound on the branching factor
by considering the maximum number of squares that a queen can attack in any column.)
3.6 Give a complete problem formulation for each of the following. Choose a formulation
that is precise enough to be implemented.
a. Using only four colors, you have to color a planar map in such a way that no two
adjacent regions have the same color.
b. A 3-foot-tall monkey is in a room where some bananas are suspended from the 8-foot
ceiling. He would like to get the bananas. The room contains two stackable, movable,
climbable 3-foot-high crates.
114 Chapter 3. Solving Problems by Searching
S
G
Figure 3.31 A scene with polygonal obstacles. S and G are the start and goal states.
c. You have a program that outputs the message “illegal input record” when fed a certain
file of input records. You know that processing of each record is independent of the
other records. You want to discover what record is illegal.
d. You have three jugs, measuring 12 gallons, 8 gallons, and 3 gallons, and a water faucet.
You can fill the jugs up or empty them out from one to another or onto the ground. You
need to measure out exactly one gallon.
3.7 Consider the problem of finding the shortest path between two points on a plane that has
convex polygonal obstacles as shown in Figure 3.31. This is an idealization of the problem
that a robot has to solve to navigate in a crowded environment.
a. Suppose the state space consists of all positions (x, y) in the plane. How many states
are there? How many paths are there to the goal?
b. Explain briefly why the shortest path from one polygon vertex to any other in the scene
must consist of straight-line segments joining some of the vertices of the polygons.
Define a good state space now. How large is this state space?
c. Define the necessary functions to implement the search problem, including an ACTIONS
function that takes a vertex as input and returns a set of vectors, each of which maps the
current vertex to one of the vertices that can be reached in a straight line. (Do not forget
the neighbors on the same polygon.) Use the straight-line distance for the heuristic
function.
d. Apply one or more of the algorithms in this chapter to solve a range of problems in the
domain, and comment on their performance.
3.8 On page 68, we said that we would not consider problems with negative path costs. In
this exercise, we explore this decision in more depth.
a. Suppose that actions can have arbitrarily large negative costs; explain why this possibility would force any optimal algorithm to explore the entire state space.
Exercises 115
b. Does it help if we insist that step costs must be greater than or equal to some negative
constant c? Consider both trees and graphs.
c. Suppose that a set of actions forms a loop in the state space such that executing the set in
some order results in no net change to the state. If all of these actions have negative cost,
what does this imply about the optimal behavior for an agent in such an environment?
d. One can easily imagine actions with high negative cost, even in domains such as route
finding. For example, some stretches of road might have such beautiful scenery as to
far outweigh the normal costs in terms of time and fuel. Explain, in precise terms,
within the context of state-space search, why humans do not drive around scenic loops
indefinitely, and explain how to define the state space and actions for route finding so
that artificial agents can also avoid looping.
e. Can you think of a real domain in which step costs are such as to cause looping?
3.9 The missionaries and cannibals problem is usually stated as follows. Three missionaries and three cannibals are on one side of a river, along with a boat that can hold one or
two people. Find a way to get everyone to the other side without ever leaving a group of missionaries in one place outnumbered by the cannibals in that place. This problem is famous in
AI because it was the subject of the first paper that approached problem formulation from an
analytical viewpoint (Amarel, 1968).
a. Formulate the problem precisely, making only those distinctions necessary to ensure a
valid solution. Draw a diagram of the complete state space.
b. Implement and solve the problem optimally using an appropriate search algorithm. Is it
a good idea to check for repeated states?
c. Why do you think people have a hard time solving this puzzle, given that the state space
is so simple?
3.10 Define in your own words the following terms: state, state space, search tree, search
node, goal, action, transition model, and branching factor.
3.11 What’s the difference between a world state, a state description, and a search node?
Why is this distinction useful?
3.12 An action such as Go(Sibiu) really consists of a long sequence of finer-grained actions:
turn on the car, release the brake, accelerate forward, etc. Having composite actions of this
kind reduces the number of steps in a solution sequence, thereby reducing the search time.
Suppose we take this to the logical extreme, by making super-composite actions out of every
possible sequence of Go actions. Then every problem instance is solved by a single supercomposite action, such as Go(Sibiu)Go(Rimnicu Vilcea)Go(Pitesti)Go(Bucharest). Explain
how search would work in this formulation. Is this a practical approach for speeding up
problem solving?
3.13 Prove that GRAPH-SEARCH satisfies the graph separation property illustrated in Figure 3.9. (Hint: Begin by showing that the property holds at the start, then show that if it holds
before an iteration of the algorithm, it holds afterwards.) Describe a search algorithm that
violates the property.
116 Chapter 3. Solving Problems by Searching
x 12
x 16
x 2 x 2
Figure 3.32 The track pieces in a wooden railway set; each is labeled with the number of
copies in the set. Note that curved pieces and “fork” pieces (“switches” or “points”) can be
flipped over so they can curve in either direction. Each curve subtends 45 degrees.
3.14 Which of the following are true and which are false? Explain your answers.
a. Depth-first search always expands at least as many nodes as A∗ search with an admissible heuristic.
b. h(n)=0 is an admissible heuristic for the 8-puzzle.
c. A∗ is of no use in robotics because percepts, states, and actions are continuous.
d. Breadth-first search is complete even if zero step costs are allowed.
e. Assume that a rook can move on a chessboard any number of squares in a straight line,
vertically or horizontally, but cannot jump over other pieces. Manhattan distance is an
admissible heuristic for the problem of moving the rook from square A to square B in
the smallest number of moves.
3.15 Consider a state space where the start state is number 1 and each state k has two
successors: numbers 2k and 2k + 1.
a. Draw the portion of the state space for states 1 to 15.
b. Suppose the goal state is 11. List the order in which nodes will be visited for breadthfirst search, depth-limited search with limit 3, and iterative deepening search.
c. How well would bidirectional search work on this problem? What is the branching
factor in each direction of the bidirectional search?
d. Does the answer to (c) suggest a reformulation of the problem that would allow you to
solve the problem of getting from state 1 to a given goal state with almost no search?
e. Call the action going from k to 2k Left, and the action going to 2k + 1 Right. Can you
find an algorithm that outputs the solution to this problem without any search at all?
3.16 A basic wooden railway set contains the pieces shown in Figure 3.32. The task is to
connect these pieces into a railway that has no overlapping tracks and no loose ends where a
train could run off onto the floor.
a. Suppose that the pieces fit together exactly with no slack. Give a precise formulation of
the task as a search problem.
b. Identify a suitable uninformed search algorithm for this task and explain your choice.
c. Explain why removing any one of the “fork” pieces makes the problem unsolvable.
Exercises 117
d. Give an upper bound on the total size of the state space defined by your formulation.
(Hint: think about the maximum branching factor for the construction process and the
maximum depth, ignoring the problem of overlapping pieces and loose ends. Begin by
pretending that every piece is unique.)
3.17 On page 90, we mentioned iterative lengthening search, an iterative analog of uniform cost search. The idea is to use increasing limits on path cost. If a node is generated
whose path cost exceeds the current limit, it is immediately discarded. For each new iteration, the limit is set to the lowest path cost of any node discarded in the previous iteration.
a. Show that this algorithm is optimal for general path costs.
b. Consider a uniform tree with branching factor b, solution depth d, and unit step costs.
How many iterations will iterative lengthening require?
c. Now consider step costs drawn from the continuous range [, 1], where 0 << 1. How
many iterations are required in the worst case?
d. Implement the algorithm and apply it to instances of the 8-puzzle and traveling salesperson problems. Compare the algorithm’s performance to that of uniform-cost search,
and comment on your results.
3.18 Describe a state space in which iterative deepening search performs much worse than
depth-first search (for example, O(n2) vs. O(n)).
3.19 Write a program that will take as input two Web page URLs and find a path of links
from one to the other. What is an appropriate search strategy? Is bidirectional search a good
idea? Could a search engine be used to implement a predecessor function?
3.20 Consider the vacuum-world problem defined in Figure 2.2.
a. Which of the algorithms defined in this chapter would be appropriate for this problem?
Should the algorithm use tree search or graph search?
b. Apply your chosen algorithm to compute an optimal sequence of actions for a 3 × 3
world whose initial state has dirt in the three top squares and the agent in the center.
c. Construct a search agent for the vacuum world, and evaluate its performance in a set of
3 × 3 worlds with probability 0.2 of dirt in each square. Include the search cost as well
as path cost in the performance measure, using a reasonable exchange rate.
d. Compare your best search agent with a simple randomized reflex agent that sucks if
there is dirt and otherwise moves randomly.
e. Consider what would happen if the world were enlarged to n × n. How does the performance of the search agent and of the reflex agent vary with n?
3.21 Prove each of the following statements, or give a counterexample:
a. Breadth-first search is a special case of uniform-cost search.
b. Depth-first search is a special case of best-first tree search.
c. Uniform-cost search is a special case of A∗ search.
118 Chapter 3. Solving Problems by Searching
3.22 Compare the performance of A∗ and RBFS on a set of randomly generated problems
in the 8-puzzle (with Manhattan distance) and TSP (with MST—see Exercise 3.30) domains.
Discuss your results. What happens to the performance of RBFS when a small random number is added to the heuristic values in the 8-puzzle domain?
3.23 Trace the operation of A∗ search applied to the problem of getting to Bucharest from
Lugoj using the straight-line distance heuristic. That is, show the sequence of nodes that the
algorithm will consider and the f, g, and h score for each node.
3.24 Devise a state space in which A∗ using GRAPH-SEARCH returns a suboptimal solution
with an h(n) function that is admissible but inconsistent.
3.25 The heuristic path algorithm (Pohl, 1977) is a best-first search in which the evalu- HEURISTIC PATH
ALGORITHM
ation function is f(n) = (2 − w)g(n) + wh(n). For what values of w is this complete?
For what values is it optimal, assuming that h is admissible? What kind of search does this
perform for w = 0, w = 1, and w = 2?
3.26 Consider the unbounded version of the regular 2D grid shown in Figure 3.9. The start
state is at the origin, (0,0), and the goal state is at (x, y).
a. What is the branching factor b in this state space?
b. How many distinct states are there at depth k (for k > 0)?
c. What is the maximum number of nodes expanded by breadth-first tree search?
d. What is the maximum number of nodes expanded by breadth-first graph search?
e. Is h = |u − x| + |v − y| an admissible heuristic for a state at (u, v)? Explain.
f. How many nodes are expanded by A∗ graph search using h?
g. Does h remain admissible if some links are removed?
h. Does h remain admissible if some links are added between nonadjacent states?
3.27 n vehicles occupy squares (1, 1) through (n, 1) (i.e., the bottom row) of an n × n grid.
The vehicles must be moved to the top row but in reverse order; so the vehicle i that starts in
(i, 1) must end up in (n − i + 1, n). On each time step, every one of the n vehicles can move
one square up, down, left, or right, or stay put; but if a vehicle stays put, one other adjacent
vehicle (but not more than one) can hop over it. Two vehicles cannot occupy the same square.
a. Calculate the size of the state space as a function of n.
b. Calculate the branching factor as a function of n.
c. Suppose that vehicle i is at (xi, yi); write a nontrivial admissible heuristic hi for the
number of moves it will require to get to its goal location (n − i + 1, n), assuming no
other vehicles are on the grid.
d. Which of the following heuristics are admissible for the problem of moving all n vehicles to their destinations? Explain.
(i) n
i = 1 hi.
(ii) max{h1,...,hn}.
(iii) min{h1,...,hn}.
Exercises 119
3.28 Invent a heuristic function for the 8-puzzle that sometimes overestimates, and show
how it can lead to a suboptimal solution on a particular problem. (You can use a computer to
help if you want.) Prove that if h never overestimates by more than c, A∗ using h returns a
solution whose cost exceeds that of the optimal solution by no more than c.
3.29 Prove that if a heuristic is consistent, it must be admissible. Construct an admissible
heuristic that is not consistent.
3.30 The traveling salesperson problem (TSP) can be solved with the minimum-spanningtree (MST) heuristic, which estimates the cost of completing a tour, given that a partial tour
has already been constructed. The MST cost of a set of cities is the smallest sum of the link
costs of any tree that connects all the cities.
a. Show how this heuristic can be derived from a relaxed version of the TSP.
b. Show that the MST heuristic dominates straight-line distance.
c. Write a problem generator for instances of the TSP where cities are represented by
random points in the unit square.
d. Find an efficient algorithm in the literature for constructing the MST, and use it with A∗
graph search to solve instances of the TSP.
3.31 On page 105, we defined the relaxation of the 8-puzzle in which a tile can move from
square A to square B if B is blank. The exact solution of this problem defines Gaschnig’s
heuristic (Gaschnig, 1979). Explain why Gaschnig’s heuristic is at least as accurate as h1
(misplaced tiles), and show cases where it is more accurate than both h1 and h2 (Manhattan
distance). Explain how to calculate Gaschnig’s heuristic efficiently.
3.32 We gave two simple heuristics for the 8-puzzle: Manhattan distance and misplaced
tiles. Several heuristics in the literature purport to improve on this—see, for example, Nilsson (1971), Mostow and Prieditis (1989), and Hansson et al. (1992). Test these claims by
implementing the heuristics and comparing the performance of the resulting algorithms.
4 BEYOND CLASSICAL
SEARCH
In which we relax the simplifying assumptions of the previous chapter, thereby
getting closer to the real world.
Chapter 3 addressed a single category of problems: observable, deterministic, known environments where the solution is a sequence of actions. In this chapter, we look at what happens
when these assumptions are relaxed. We begin with a fairly simple case: Sections 4.1 and 4.2
cover algorithms that perform purely local search in the state space, evaluating and modifying one or more current states rather than systematically exploring paths from an initial state.
These algorithms are suitable for problems in which all that matters is the solution state, not
the path cost to reach it. The family of local search algorithms includes methods inspired by
statistical physics (simulated annealing) and evolutionary biology (genetic algorithms).
Then, in Sections 4.3–4.4, we examine what happens when we relax the assumptions
of determinism and observability. The key idea is that if an agent cannot predict exactly what
percept it will receive, then it will need to consider what to do under each contingency that
its percepts may reveal. With partial observability, the agent will also need to keep track of
the states it might be in.
Finally, Section 4.5 investigates online search, in which the agent is faced with a state
space that is initially unknown and must be explored.
4.1 LOCAL SEARCH ALGORITHMS AND OPTIMIZATION PROBLEMS
The search algorithms that we have seen so far are designed to explore search spaces systematically. This systematicity is achieved by keeping one or more paths in memory and by
recording which alternatives have been explored at each point along the path. When a goal is
found, the path to that goal also constitutes a solution to the problem. In many problems, however, the path to the goal is irrelevant. For example, in the 8-queens problem (see page 71),
what matters is the final configuration of queens, not the order in which they are added. The
same general property holds for many important applications such as integrated-circuit design, factory-floor layout, job-shop scheduling, automatic programming, telecommunications
network optimization, vehicle routing, and portfolio management.
120
Section 4.1. Local Search Algorithms and Optimization Problems 121
If the path to the goal does not matter, we might consider a different class of algoLOCAL SEARCH rithms, ones that do not worry about paths at all. Local search algorithms operate using
CURRENT NODE a single current node (rather than multiple paths) and generally move only to neighbors
of that node. Typically, the paths followed by the search are not retained. Although local
search algorithms are not systematic, they have two key advantages: (1) they use very little
memory—usually a constant amount; and (2) they can often find reasonable solutions in large
or infinite (continuous) state spaces for which systematic algorithms are unsuitable.
In addition to finding goals, local search algorithms are useful for solving pure optimization problems, in which the aim is to find the best state according to an objective OPTIMIZATION
PROBLEM
function. Many optimization problems do not fit the “standard” search model introduced in OBJECTIVE
FUNCTION
Chapter 3. For example, nature provides an objective function—reproductive fitness—that
Darwinian evolution could be seen as attempting to optimize, but there is no “goal test” and
no “path cost” for this problem.
To understand local search, we find it useful to consider the state-space landscape (as STATE-SPACE
LANDSCAPE
in Figure 4.1). A landscape has both “location” (defined by the state) and “elevation” (defined
by the value of the heuristic cost function or objective function). If elevation corresponds to
GLOBAL MINIMUM cost, then the aim is to find the lowest valley—a global minimum; if elevation corresponds
GLOBAL MAXIMUM to an objective function, then the aim is to find the highest peak—a global maximum. (You
can convert from one to the other just by inserting a minus sign.) Local search algorithms
explore this landscape. A complete local search algorithm always finds a goal if one exists;
an optimal algorithm always finds a global minimum/maximum.
current
state
objective function
state space
global maximum
local maximum
“flat” local maximum
shoulder
Figure 4.1 A one-dimensional state-space landscape in which elevation corresponds to the
objective function. The aim is to find the global maximum. Hill-climbing search modifies
the current state to try to improve it, as shown by the arrow. The various topographic features
are defined in the text.
122 Chapter 4. Beyond Classical Search
function HILL-CLIMBING(problem) returns a state that is a local maximum
current ← MAKE-NODE(problem.INITIAL-STATE)
loop do
neighbor ← a highest-valued successor of current
if neighbor.VALUE ≤ current.VALUE then return current.STATE
current ← neighbor
Figure 4.2 The hill-climbing search algorithm, which is the most basic local search technique. At each step the current node is replaced by the best neighbor; in this version, that
means the neighbor with the highest VALUE, but if a heuristic cost estimate h is used, we
would find the neighbor with the lowest h.
4.1.1 Hill-climbing search
HILL CLIMBING The hill-climbing search algorithm (steepest-ascent version) is shown in Figure 4.2. It is
STEEPEST ASCENT simply a loop that continually moves in the direction of increasing value—that is, uphill. It
terminates when it reaches a “peak” where no neighbor has a higher value. The algorithm
does not maintain a search tree, so the data structure for the current node need only record
the state and the value of the objective function. Hill climbing does not look ahead beyond
the immediate neighbors of the current state. This resembles trying to find the top of Mount
Everest in a thick fog while suffering from amnesia.
To illustrate hill climbing, we will use the 8-queens problem introduced on page 71.
Local search algorithms typically use a complete-state formulation, where each state has
8 queens on the board, one per column. The successors of a state are all possible states
generated by moving a single queen to another square in the same column (so each state has
8 × 7 = 56 successors). The heuristic cost function h is the number of pairs of queens that
are attacking each other, either directly or indirectly. The global minimum of this function
is zero, which occurs only at perfect solutions. Figure 4.3(a) shows a state with h = 17. The
figure also shows the values of all its successors, with the best successors having h = 12.
Hill-climbing algorithms typically choose randomly among the set of best successors if there
is more than one.
Hill climbing is sometimes called greedy local search because it grabs a good neighbor GREEDY LOCAL
SEARCH
state without thinking ahead about where to go next. Although greed is considered one of the
seven deadly sins, it turns out that greedy algorithms often perform quite well. Hill climbing
often makes rapid progress toward a solution because it is usually quite easy to improve a bad
state. For example, from the state in Figure 4.3(a), it takes just five steps to reach the state
in Figure 4.3(b), which has h = 1 and is very nearly a solution. Unfortunately, hill climbing
often gets stuck for the following reasons:
LOCAL MAXIMUM • Local maxima: a local maximum is a peak that is higher than each of its neighboring
states but lower than the global maximum. Hill-climbing algorithms that reach the
vicinity of a local maximum will be drawn upward toward the peak but will then be
stuck with nowhere else to go. Figure 4.1 illustrates the problem schematically. More
Section 4.1. Local Search Algorithms and Optimization Problems 123
14
18
17
15
14
18
14
14
14
14
14
12
16
12
13
16
17
14
18
13
14
17
15
18
15
13
15
13
12
15
15
13
15
12
13
14
14
14
16
12
14
12
12
15
16
13
14
12
14
18
16
16
16
14
16
14
(a) (b)
Figure 4.3 (a) An 8-queens state with heuristic cost estimate h = 17, showing the value of
h for each possible successor obtained by moving a queen within its column. The best moves
are marked. (b) A local minimum in the 8-queens state space; the state has h = 1 but every
successor has a higher cost.
concretely, the state in Figure 4.3(b) is a local maximum (i.e., a local minimum for the
cost h); every move of a single queen makes the situation worse.
RIDGE • Ridges: a ridge is shown in Figure 4.4. Ridges result in a sequence of local maxima
that is very difficult for greedy algorithms to navigate.
PLATEAU • Plateaux: a plateau is a flat area of the state-space landscape. It can be a flat local
SHOULDER maximum, from which no uphill exit exists, or a shoulder, from which progress is
possible. (See Figure 4.1.) A hill-climbing search might get lost on the plateau.
In each case, the algorithm reaches a point at which no progress is being made. Starting from
a randomly generated 8-queens state, steepest-ascent hill climbing gets stuck 86% of the time,
solving only 14% of problem instances. It works quickly, taking just 4 steps on average when
it succeeds and 3 when it gets stuck—not bad for a state space with 88 ≈ 17 million states.
The algorithm in Figure 4.2 halts if it reaches a plateau where the best successor has
the same value as the current state. Might it not be a good idea to keep going—to allow a
SIDEWAYS MOVE sideways move in the hope that the plateau is really a shoulder, as shown in Figure 4.1? The
answer is usually yes, but we must take care. If we always allow sideways moves when there
are no uphill moves, an infinite loop will occur whenever the algorithm reaches a flat local
maximum that is not a shoulder. One common solution is to put a limit on the number of consecutive sideways moves allowed. For example, we could allow up to, say, 100 consecutive
sideways moves in the 8-queens problem. This raises the percentage of problem instances
solved by hill climbing from 14% to 94%. Success comes at a cost: the algorithm averages
roughly 21 steps for each successful instance and 64 for each failure.
124 Chapter 4. Beyond Classical Search
Figure 4.4 Illustration of why ridges cause difficulties for hill climbing. The grid of states
(dark circles) is superimposed on a ridge rising from left to right, creating a sequence of local
maxima that are not directly connected to each other. From each local maximum, all the
available actions point downhill.
Many variants of hill climbing have been invented. Stochastic hill climbing chooses at STOCHASTIC HILL
CLIMBING
random from among the uphill moves; the probability of selection can vary with the steepness
of the uphill move. This usually converges more slowly than steepest ascent, but in some
state landscapes, it finds better solutions. First-choice hill climbing implements stochastic FIRST-CHOICE HILL
CLIMBING
hill climbing by generating successors randomly until one is generated that is better than the
current state. This is a good strategy when a state has many (e.g., thousands) of successors.
The hill-climbing algorithms described so far are incomplete—they often fail to find
a goal when one exists because they can get stuck on local maxima. Random-restart hill
climbing adopts the well-known adage, “If at first you don’t succeed, try, try again.” It con- RANDOM-RESTART
HILL CLIMBING
ducts a series of hill-climbing searches from randomly generated initial states,1 until a goal
is found. It is trivially complete with probability approaching 1, because it will eventually
generate a goal state as the initial state. If each hill-climbing search has a probability p of
success, then the expected number of restarts required is 1/p. For 8-queens instances with
no sideways moves allowed, p ≈ 0.14, so we need roughly 7 iterations to find a goal (6 failures and 1 success). The expected number of steps is the cost of one successful iteration plus
(1−p)/p times the cost of failure, or roughly 22 steps in all. When we allow sideways moves,
1/0.94 ≈ 1.06 iterations are needed on average and (1 × 21) + (0.06/0.94) × 64 ≈ 25 steps.
For 8-queens, then, random-restart hill climbing is very effective indeed. Even for three million queens, the approach can find solutions in under a minute.2
1 Generating a random state from an implicitly specified state space can be a hard problem in itself.
2 Luby et al. (1993) prove that it is best, in some cases, to restart a randomized search algorithm after a particular,
fixed amount of time and that this can be much more efficient than letting each search continue indefinitely.
Disallowing or limiting the number of sideways moves is an example of this idea.
Section 4.1. Local Search Algorithms and Optimization Problems 125
The success of hill climbing depends very much on the shape of the state-space landscape: if there are few local maxima and plateaux, random-restart hill climbing will find a
good solution very quickly. On the other hand, many real problems have a landscape that
looks more like a widely scattered family of balding porcupines on a flat floor, with miniature
porcupines living on the tip of each porcupine needle, ad infinitum. NP-hard problems typically have an exponential number of local maxima to get stuck on. Despite this, a reasonably
good local maximum can often be found after a small number of restarts.
4.1.2 Simulated annealing
A hill-climbing algorithm that never makes “downhill” moves toward states with lower value
(or higher cost) is guaranteed to be incomplete, because it can get stuck on a local maximum. In contrast, a purely random walk—that is, moving to a successor chosen uniformly
at random from the set of successors—is complete but extremely inefficient. Therefore, it
seems reasonable to try to combine hill climbing with a random walk in some way that yields
both efficiency and completeness. Simulated annealing is such an algorithm. In metallurgy, SIMULATED
ANNEALING
annealing is the process used to temper or harden metals and glass by heating them to a
high temperature and then gradually cooling them, thus allowing the material to reach a lowenergy crystalline state. To explain simulated annealing, we switch our point of view from
GRADIENT DESCENT hill climbing to gradient descent (i.e., minimizing cost) and imagine the task of getting a
ping-pong ball into the deepest crevice in a bumpy surface. If we just let the ball roll, it will
come to rest at a local minimum. If we shake the surface, we can bounce the ball out of the
local minimum. The trick is to shake just hard enough to bounce the ball out of local minima but not hard enough to dislodge it from the global minimum. The simulated-annealing
solution is to start by shaking hard (i.e., at a high temperature) and then gradually reduce the
intensity of the shaking (i.e., lower the temperature).
The innermost loop of the simulated-annealing algorithm (Figure 4.5) is quite similar to
hill climbing. Instead of picking the best move, however, it picks a random move. If the move
improves the situation, it is always accepted. Otherwise, the algorithm accepts the move with
some probability less than 1. The probability decreases exponentially with the “badness” of
the move—the amount ΔE by which the evaluation is worsened. The probability also decreases as the “temperature” T goes down: “bad” moves are more likely to be allowed at the
start when T is high, and they become more unlikely as T decreases. If the schedule lowers
T slowly enough, the algorithm will find a global optimum with probability approaching 1.
Simulated annealing was first used extensively to solve VLSI layout problems in the
early 1980s. It has been applied widely to factory scheduling and other large-scale optimization tasks. In Exercise 4.4, you are asked to compare its performance to that of random-restart
hill climbing on the 8-queens puzzle.
4.1.3 Local beam search
Keeping just one node in memory might seem to be an extreme reaction to the problem of
memory limitations. The local beam search algorithm3 keeps track of k states rather than LOCAL BEAM
SEARCH
3 Local beam search is an adaptation of beam search, which is a path-based algorithm.
126 Chapter 4. Beyond Classical Search
function SIMULATED-ANNEALING(problem, schedule) returns a solution state
inputs: problem, a problem
schedule, a mapping from time to “temperature”
current ← MAKE-NODE(problem.INITIAL-STATE)
for t = 1 to ∞ do
T ← schedule(t)
if T = 0 then return current
next ← a randomly selected successor of current
ΔE ← next.VALUE – current.VALUE
if ΔE > 0 then current ← next
else current ← next only with probability eΔE/T
Figure 4.5 The simulated annealing algorithm, a version of stochastic hill climbing where
some downhill moves are allowed. Downhill moves are accepted readily early in the annealing schedule and then less often as time goes on. The schedule input determines the value of
the temperature T as a function of time.
just one. It begins with k randomly generated states. At each step, all the successors of all k
states are generated. If any one is a goal, the algorithm halts. Otherwise, it selects the k best
successors from the complete list and repeats.
At first sight, a local beam search with k states might seem to be nothing more than
running k random restarts in parallel instead of in sequence. In fact, the two algorithms
are quite different. In a random-restart search, each search process runs independently of
the others. In a local beam search, useful information is passed among the parallel search
threads. In effect, the states that generate the best successors say to the others, “Come over
here, the grass is greener!” The algorithm quickly abandons unfruitful searches and moves
its resources to where the most progress is being made.
In its simplest form, local beam search can suffer from a lack of diversity among the
k states—they can quickly become concentrated in a small region of the state space, making
the search little more than an expensive version of hill climbing. A variant called stochastic
beam search, analogous to stochastic hill climbing, helps alleviate this problem. Instead STOCHASTIC BEAM
SEARCH
of choosing the best k from the the pool of candidate successors, stochastic beam search
chooses k successors at random, with the probability of choosing a given successor being
an increasing function of its value. Stochastic beam search bears some resemblance to the
process of natural selection, whereby the “successors” (offspring) of a “state” (organism)
populate the next generation according to its “value” (fitness).
4.1.4 Genetic algorithms
A genetic algorithm (or GA) is a variant of stochastic beam search in which successor states GENETIC
ALGORITHM
are generated by combining two parent states rather than by modifying a single state. The
analogy to natural selection is the same as in stochastic beam search, except that now we are
dealing with sexual rather than asexual reproduction.
Section 4.1. Local Search Algorithms and Optimization Problems 127
(a)
Initial Population
(b)
Fitness Function
(c)
Selection
(d)
Crossover
(e)
Mutation
24
23
20
11
29%
31%
26%
14%
32752411
24748552
32752411
24415124
32748552
24752411
32752124
24415411
32252124
24752411
32748152
24415417
24748552
32752411
24415124
32543213
Figure 4.6 The genetic algorithm, illustrated for digit strings representing 8-queens states.
The initial population in (a) is ranked by the fitness function in (b), resulting in pairs for
mating in (c). They produce offspring in (d), which are subject to mutation in (e).
+ =
Figure 4.7 The 8-queens states corresponding to the first two parents in Figure 4.6(c) and
the first offspring in Figure 4.6(d). The shaded columns are lost in the crossover step and the
unshaded columns are retained.
Like beam searches, GAs begin with a set of k randomly generated states, called the
POPULATION population. Each state, or individual, is represented as a string over a finite alphabet—most
INDIVIDUAL commonly, a string of 0s and 1s. For example, an 8-queens state must specify the positions of
8 queens, each in a column of 8 squares, and so requires 8 × log2 8 = 24 bits. Alternatively,
the state could be represented as 8 digits, each in the range from 1 to 8. (We demonstrate later
that the two encodings behave differently.) Figure 4.6(a) shows a population of four 8-digit
strings representing 8-queens states.
The production of the next generation of states is shown in Figure 4.6(b)–(e). In (b),
FITNESS FUNCTION each state is rated by the objective function, or (in GA terminology) the fitness function. A
fitness function should return higher values for better states, so, for the 8-queens problem
we use the number of nonattacking pairs of queens, which has a value of 28 for a solution.
The values of the four states are 24, 23, 20, and 11. In this particular variant of the genetic
algorithm, the probability of being chosen for reproducing is directly proportional to the
fitness score, and the percentages are shown next to the raw scores.
In (c), two pairs are selected at random for reproduction, in accordance with the prob-
128 Chapter 4. Beyond Classical Search
abilities in (b). Notice that one individual is selected twice and one not at all.4 For each
CROSSOVER pair to be mated, a crossover point is chosen randomly from the positions in the string. In
Figure 4.6, the crossover points are after the third digit in the first pair and after the fifth digit
in the second pair.5
In (d), the offspring themselves are created by crossing over the parent strings at the
crossover point. For example, the first child of the first pair gets the first three digits from the
first parent and the remaining digits from the second parent, whereas the second child gets
the first three digits from the second parent and the rest from the first parent. The 8-queens
states involved in this reproduction step are shown in Figure 4.7. The example shows that
when two parent states are quite different, the crossover operation can produce a state that is
a long way from either parent state. It is often the case that the population is quite diverse
early on in the process, so crossover (like simulated annealing) frequently takes large steps in
the state space early in the search process and smaller steps later on when most individuals
are quite similar.
MUTATION Finally, in (e), each location is subject to random mutation with a small independent
probability. One digit was mutated in the first, third, and fourth offspring. In the 8-queens
problem, this corresponds to choosing a queen at random and moving it to a random square
in its column. Figure 4.8 describes an algorithm that implements all these steps.
Like stochastic beam search, genetic algorithms combine an uphill tendency with random exploration and exchange of information among parallel search threads. The primary
advantage, if any, of genetic algorithms comes from the crossover operation. Yet it can be
shown mathematically that, if the positions of the genetic code are permuted initially in a
random order, crossover conveys no advantage. Intuitively, the advantage comes from the
ability of crossover to combine large blocks of letters that have evolved independently to perform useful functions, thus raising the level of granularity at which the search operates. For
example, it could be that putting the first three queens in positions 2, 4, and 6 (where they do
not attack each other) constitutes a useful block that can be combined with other blocks to
construct a solution.
SCHEMA The theory of genetic algorithms explains how this works using the idea of a schema,
which is a substring in which some of the positions can be left unspecified. For example,
the schema 246***** describes all 8-queens states in which the first three queens are in
positions 2, 4, and 6, respectively. Strings that match the schema (such as 24613578) are
INSTANCE called instances of the schema. It can be shown that if the average fitness of the instances of
a schema is above the mean, then the number of instances of the schema within the population
will grow over time. Clearly, this effect is unlikely to be significant if adjacent bits are totally
unrelated to each other, because then there will be few contiguous blocks that provide a
consistent benefit. Genetic algorithms work best when schemata correspond to meaningful
components of a solution. For example, if the string is a representation of an antenna, then the
schemata may represent components of the antenna, such as reflectors and deflectors. A good
4 There are many variants of this selection rule. The method of culling, in which all individuals below a given
threshold are discarded, can be shown to converge faster than the random version (Baum et al., 1995).
5 It is here that the encoding matters. If a 24-bit encoding is used instead of 8 digits, then the crossover point
has a 2/3 chance of being in the middle of a digit, which results in an essentially arbitrary mutation of that digit.
Section 4.2. Local Search in Continuous Spaces 129
function GENETIC-ALGORITHM(population, FITNESS-FN) returns an individual
inputs: population, a set of individuals
FITNESS-FN, a function that measures the fitness of an individual
repeat
new population ← empty set
for i = 1 to SIZE(population) do
x ← RANDOM-SELECTION(population, FITNESS-FN)
y ← RANDOM-SELECTION(population, FITNESS-FN)
child ← REPRODUCE(x , y)
if (small random probability) then child ← MUTATE(child)
add child to new population
population ← new population
until some individual is fit enough, or enough time has elapsed
return the best individual in population, according to FITNESS-FN
function REPRODUCE(x , y) returns an individual
inputs: x , y, parent individuals
n ← LENGTH(x ); c ←random number from 1 to n
return APPEND(SUBSTRING(x , 1, c), SUBSTRING(y, c + 1, n))
Figure 4.8 A genetic algorithm. The algorithm is the same as the one diagrammed in
Figure 4.6, with one variation: in this more popular version, each mating of two parents
produces only one offspring, not two.
component is likely to be good in a variety of different designs. This suggests that successful
use of genetic algorithms requires careful engineering of the representation.
In practice, genetic algorithms have had a widespread impact on optimization problems,
such as circuit layout and job-shop scheduling. At present, it is not clear whether the appeal
of genetic algorithms arises from their performance or from their æsthetically pleasing origins
in the theory of evolution. Much work remains to be done to identify the conditions under
which genetic algorithms perform well.
4.2 LOCAL SEARCH IN CONTINUOUS SPACES
In Chapter 2, we explained the distinction between discrete and continuous environments,
pointing out that most real-world environments are continuous. Yet none of the algorithms
we have described (except for first-choice hill climbing and simulated annealing) can handle
continuous state and action spaces, because they have infinite branching factors. This section
provides a very brief introduction to some local search techniques for finding optimal solutions in continuous spaces. The literature on this topic is vast; many of the basic techniques
130 Chapter 4. Beyond Classical Search
EVOLUTION AND SEARCH
The theory of evolution was developed in Charles Darwin’s On the Origin of
Species by Means of Natural Selection (1859) and independently by Alfred Russel
Wallace (1858). The central idea is simple: variations occur in reproduction and
will be preserved in successive generations approximately in proportion to their
effect on reproductive fitness.
Darwin’s theory was developed with no knowledge of how the traits of organisms can be inherited and modified. The probabilistic laws governing these processes were first identified by Gregor Mendel (1866), a monk who experimented
with sweet peas. Much later, Watson and Crick (1953) identified the structure of the
DNA molecule and its alphabet, AGTC (adenine, guanine, thymine, cytosine). In
the standard model, variation occurs both by point mutations in the letter sequence
and by “crossover” (in which the DNA of an offspring is generated by combining
long sections of DNA from each parent).
The analogy to local search algorithms has already been described; the principal difference between stochastic beam search and evolution is the use of sexual reproduction, wherein successors are generated from multiple organisms rather than
just one. The actual mechanisms of evolution are, however, far richer than most
genetic algorithms allow. For example, mutations can involve reversals, duplications, and movement of large chunks of DNA; some viruses borrow DNA from one
organism and insert it in another; and there are transposable genes that do nothing
but copy themselves many thousands of times within the genome. There are even
genes that poison cells from potential mates that do not carry the gene, thereby increasing their own chances of replication. Most important is the fact that the genes
themselves encode the mechanisms whereby the genome is reproduced and translated into an organism. In genetic algorithms, those mechanisms are a separate
program that is not represented within the strings being manipulated.
Darwinian evolution may appear inefficient, having generated blindly some
1045 or so organisms without improving its search heuristics one iota. Fifty
years before Darwin, however, the otherwise great French naturalist Jean Lamarck
(1809) proposed a theory of evolution whereby traits acquired by adaptation during an organism’s lifetime would be passed on to its offspring. Such a process
would be effective but does not seem to occur in nature. Much later, James Baldwin (1896) proposed a superficially similar theory: that behavior learned during an
organism’s lifetime could accelerate the rate of evolution. Unlike Lamarck’s, Baldwin’s theory is entirely consistent with Darwinian evolution because it relies on selection pressures operating on individuals that have found local optima among the
set of possible behaviors allowed by their genetic makeup. Computer simulations
confirm that the “Baldwin effect” is real, once “ordinary” evolution has created
organisms whose internal performance measure correlates with actual fitness.
Section 4.2. Local Search in Continuous Spaces 131
originated in the 17th century, after the development of calculus by Newton and Leibniz.6 We
find uses for these techniques at several places in the book, including the chapters on learning,
vision, and robotics.
We begin with an example. Suppose we want to place three new airports anywhere
in Romania, such that the sum of squared distances from each city on the map (Figure 3.2)
to its nearest airport is minimized. The state space is then defined by the coordinates of
the airports: (x1, y1), (x2, y2), and (x3, y3). This is a six-dimensional space; we also say
VARIABLE that states are defined by six variables. (In general, states are defined by an n-dimensional
vector of variables, x.) Moving around in this space corresponds to moving one or more of
the airports on the map. The objective function f(x1, y1, x2, y2, x3, y3) is relatively easy to
compute for any particular state once we compute the closest cities. Let Ci be the set of
cities whose closest airport (in the current state) is airport i. Then, in the neighborhood of the
current state, where the Cis remain constant, we have
f(x1, y1, x2, y2, x3, y3) = 
3
i = 1

c∈Ci
(xi − xc)
2 + (yi − yc)
2 . (4.1)
This expression is correct locally, but not globally because the sets Ci are (discontinuous)
functions of the state.
DISCRETIZATION One way to avoid continuous problems is simply to discretize the neighborhood of each
state. For example, we can move only one airport at a time in either the x or y direction by
a fixed amount ±δ. With 6 variables, this gives 12 possible successors for each state. We
can then apply any of the local search algorithms described previously. We could also apply stochastic hill climbing and simulated annealing directly, without discretizing the space.
These algorithms choose successors randomly, which can be done by generating random vectors of length δ.
GRADIENT Many methods attempt to use the gradient of the landscape to find a maximum. The
gradient of the objective function is a vector ∇f that gives the magnitude and direction of the
steepest slope. For our problem, we have
∇f =
 ∂f
∂x1
, ∂f
∂y1
, ∂f
∂x2
, ∂f
∂y2
, ∂f
∂x3
, ∂f
∂y3

.
In some cases, we can find a maximum by solving the equation ∇f = 0. (This could be done,
for example, if we were placing just one airport; the solution is the arithmetic mean of all the
cities’ coordinates.) In many cases, however, this equation cannot be solved in closed form.
For example, with three airports, the expression for the gradient depends on what cities are
closest to each airport in the current state. This means we can compute the gradient locally
(but not globally); for example,
∂f
∂x1
= 2 
c∈C1
(xi − xc) . (4.2)
Given a locally correct expression for the gradient, we can perform steepest-ascent hill climb6 A basic knowledge of multivariate calculus and vector arithmetic is useful for reading this section.
132 Chapter 4. Beyond Classical Search
ing by updating the current state according to the formula
x ← x + α∇f(x) ,
STEP SIZE where α is a small constant often called the step size. In other cases, the objective function
might not be available in a differentiable form at all—for example, the value of a particular set
of airport locations might be determined by running some large-scale economic simulation
package. In those cases, we can calculate a so-called empirical gradient by evaluating the EMPIRICAL
GRADIENT
response to small increments and decrements in each coordinate. Empirical gradient search
is the same as steepest-ascent hill climbing in a discretized version of the state space.
Hidden beneath the phrase “α is a small constant” lies a huge variety of methods for
adjusting α. The basic problem is that, if α is too small, too many steps are needed; if α
LINE SEARCH is too large, the search could overshoot the maximum. The technique of line search tries to
overcome this dilemma by extending the current gradient direction—usually by repeatedly
doubling α—until f starts to decrease again. The point at which this occurs becomes the new
current state. There are several schools of thought about how the new direction should be
chosen at this point.
NEWTON–RAPHSON For many problems, the most effective algorithm is the venerable Newton–Raphson
method. This is a general technique for finding roots of functions—that is, solving equations
of the form g(x)=0. It works by computing a new estimate for the root x according to
Newton’s formula
x ← x − g(x)/g
(x) .
To find a maximum or minimum of f, we need to find x such that the gradient is zero (i.e.,
∇f(x) = 0). Thus, g(x) in Newton’s formula becomes ∇f(x), and the update equation can
be written in matrix–vector form as
x ← x − H−1
f (x)∇f(x) ,
HESSIAN where Hf (x) is the Hessian matrix of second derivatives, whose elements Hij are given
by ∂2f /∂xi∂xj . For our airport example, we can see from Equation (4.2) that Hf (x) is
particularly simple: the off-diagonal elements are zero and the diagonal elements for airport
i are just twice the number of cities in Ci. A moment’s calculation shows that one step of
the update moves airport i directly to the centroid of Ci, which is the minimum of the local
expression for f from Equation (4.1).7 For high-dimensional problems, however, computing
the n2 entries of the Hessian and inverting it may be expensive, so many approximate versions
of the Newton–Raphson method have been developed.
Local search methods suffer from local maxima, ridges, and plateaux in continuous
state spaces just as much as in discrete spaces. Random restarts and simulated annealing can
be used and are often helpful. High-dimensional continuous spaces are, however, big places
in which it is easy to get lost.
A final topic with which a passing acquaintance is useful is constrained optimization. CONSTRAINED
OPTIMIZATION
An optimization problem is constrained if solutions must satisfy some hard constraints on the
values of the variables. For example, in our airport-siting problem, we might constrain sites
7 In general, the Newton–Raphson update can be seen as fitting a quadratic surface to f at x and then moving
directly to the minimum of that surface—which is also the minimum of f if f is quadratic.
Section 4.3. Searching with Nondeterministic Actions 133
to be inside Romania and on dry land (rather than in the middle of lakes). The difficulty of
constrained optimization problems depends on the nature of the constraints and the objective
function. The best-known category is that of linear programming problems, in which con- LINEAR
PROGRAMMING
straints must be linear inequalities forming a convex set 8 CONVEX SET and the objective function is also
linear. The time complexity of linear programming is polynomial in the number of variables.
Linear programming is probably the most widely studied and broadly useful class of
optimization problems. It is a special case of the more general problem of convex optimization, which allows the constraint region to be any convex region and the objective to CONVEX
OPTIMIZATION
be any function that is convex within the constraint region. Under certain conditions, convex
optimization problems are also polynomially solvable and may be feasible in practice with
thousands of variables. Several important problems in machine learning and control theory
can be formulated as convex optimization problems (see Chapter 20).
4.3 SEARCHING WITH NONDETERMINISTIC ACTIONS
In Chapter 3, we assumed that the environment is fully observable and deterministic and that
the agent knows what the effects of each action are. Therefore, the agent can calculate exactly
which state results from any sequence of actions and always knows which state it is in. Its
percepts provide no new information after each action, although of course they tell the agent
the initial state.
When the environment is either partially observable or nondeterministic (or both), percepts become useful. In a partially observable environment, every percept helps narrow down
the set of possible states the agent might be in, thus making it easier for the agent to achieve
its goals. When the environment is nondeterministic, percepts tell the agent which of the possible outcomes of its actions has actually occurred. In both cases, the future percepts cannot
be determined in advance and the agent’s future actions will depend on those future percepts.
CONTINGENCY PLAN So the solution to a problem is not a sequence but a contingency plan (also known as a stratSTRATEGY egy) that specifies what to do depending on what percepts are received. In this section, we
examine the case of nondeterminism, deferring partial observability to Section 4.4.
4.3.1 The erratic vacuum world
As an example, we use the vacuum world, first introduced in Chapter 2 and defined as a
search problem in Section 3.2.1. Recall that the state space has eight states, as shown in
Figure 4.9. There are three actions—Left, Right, and Suck—and the goal is to clean up all
the dirt (states 7 and 8). If the environment is observable, deterministic, and completely
known, then the problem is trivially solvable by any of the algorithms in Chapter 3 and the
solution is an action sequence. For example, if the initial state is 1, then the action sequence
[Suck,Right,Suck] will reach a goal state, 8.
8 A set of points S is convex if the line joining any two points in S is also contained in S. A convex function is
one for which the space “above” it forms a convex set; by definition, convex functions have no local (as opposed
to global) minima.
134 Chapter 4. Beyond Classical Search
1 2
7 8
5 6
3 4
Figure 4.9 The eight possible states of the vacuum world; states 7 and 8 are goal states.
Now suppose that we introduce nondeterminism in the form of a powerful but erratic
vacuum cleaner. In the erratic vacuum world, the Suck action works as follows: ERRATIC VACUUM
WORLD
• When applied to a dirty square the action cleans the square and sometimes cleans up
dirt in an adjacent square, too.
• When applied to a clean square the action sometimes deposits dirt on the carpet.9
To provide a precise formulation of this problem, we need to generalize the notion of a transition model from Chapter 3. Instead of defining the transition model by a RESULT function
that returns a single state, we use a RESULTS function that returns a set of possible outcome
states. For example, in the erratic vacuum world, the Suck action in state 1 leads to a state in
the set {5, 7}—the dirt in the right-hand square may or may not be vacuumed up.
We also need to generalize the notion of a solution to the problem. For example, if we
start in state 1, there is no single sequence of actions that solves the problem. Instead, we
need a contingency plan such as the following:
[Suck, if State = 5 then [Right, Suck] else [ ]] . (4.3)
Thus, solutions for nondeterministic problems can contain nested if–then–else statements;
this means that they are trees rather than sequences. This allows the selection of actions
based on contingencies arising during execution. Many problems in the real, physical world
are contingency problems because exact prediction is impossible. For this reason, many
people keep their eyes open while walking around or driving.
9 We assume that most readers face similar problems and can sympathize with our agent. We apologize to
owners of modern, efficient home appliances who cannot take advantage of this pedagogical device.
Section 4.3. Searching with Nondeterministic Actions 135
4.3.2 AND–OR search trees
The next question is how to find contingent solutions to nondeterministic problems. As in
Chapter 3, we begin by constructing search trees, but here the trees have a different character.
In a deterministic environment, the only branching is introduced by the agent’s own choices
OR NODE in each state. We call these nodes OR nodes. In the vacuum world, for example, at an OR
node the agent chooses Left or Right or Suck. In a nondeterministic environment, branching
is also introduced by the environment’s choice of outcome for each action. We call these
AND NODE nodes AND nodes. For example, the Suck action in state 1 leads to a state in the set {5, 7},
so the agent would need to find a plan for state 5 and for state 7. These two kinds of nodes
AND–OR TREE alternate, leading to an AND–OR tree as illustrated in Figure 4.10.
A solution for an AND–OR search problem is a subtree that (1) has a goal node at every
leaf, (2) specifies one action at each of its OR nodes, and (3) includes every outcome branch
at each of its AND nodes. The solution is shown in bold lines in the figure; it corresponds
to the plan given in Equation (4.3). (The plan uses if–then–else notation to handle the AND
branches, but when there are more than two branches at a node, it might be better to use a case
Suck Left
Suck Right
Suck Right
6
GOAL
8
GOAL
7
1
5 2
1
LOOP
5
LOOP
5
LOOP
Left Suck
1
LOOP GOAL
8 4
Figure 4.10 The first two levels of the search tree for the erratic vacuum world. State
nodes are OR nodes where some action must be chosen. At the AND nodes, shown as circles,
every outcome must be handled, as indicated by the arc linking the outgoing branches. The
solution found is shown in bold lines.
136 Chapter 4. Beyond Classical Search
function AND-OR-GRAPH-SEARCH(problem) returns a conditional plan, or failure
OR-SEARCH(problem.INITIAL-STATE, problem, [ ])
function OR-SEARCH(state, problem, path) returns a conditional plan, or failure
if problem.GOAL-TEST(state) then return the empty plan
if state is on path then return failure
for each action in problem.ACTIONS(state) do
plan ← AND-SEARCH(RESULTS(state, action), problem, [state | path])
if plan = failure then return [action | plan]
return failure
function AND-SEARCH(states, problem, path) returns a conditional plan, or failure
for each si in states do
plani ← OR-SEARCH(si, problem, path)
if plani = failure then return failure
return [if s1 then plan1 else if s2 then plan2 else ... if sn−1 then plann−1 else plann]
Figure 4.11 An algorithm for searching AND–OR graphs generated by nondeterministic
environments. It returns a conditional plan that reaches a goal state in all circumstances. (The
notation [x | l] refers to the list formed by adding object x to the front of list l.)
construct.) Modifying the basic problem-solving agent shown in Figure 3.1 to execute contingent solutions of this kind is straightforward. One may also consider a somewhat different
agent design, in which the agent can act before it has found a guaranteed plan and deals with
INTERLEAVING some contingencies only as they arise during execution. This type of interleaving of search
and execution is also useful for exploration problems (see Section 4.5) and for game playing
(see Chapter 5).
Figure 4.11 gives a recursive, depth-first algorithm for AND–OR graph search. One
key aspect of the algorithm is the way in which it deals with cycles, which often arise in
nondeterministic problems (e.g., if an action sometimes has no effect or if an unintended
effect can be corrected). If the current state is identical to a state on the path from the root,
then it returns with failure. This doesn’t mean that there is no solution from the current state;
it simply means that if there is a noncyclic solution, it must be reachable from the earlier
incarnation of the current state, so the new incarnation can be discarded. With this check, we
ensure that the algorithm terminates in every finite state space, because every path must reach
a goal, a dead end, or a repeated state. Notice that the algorithm does not check whether the
current state is a repetition of a state on some other path from the root, which is important for
efficiency. Exercise 4.5 investigates this issue.
AND–OR graphs can also be explored by breadth-first or best-first methods. The concept
of a heuristic function must be modified to estimate the cost of a contingent solution rather
than a sequence, but the notion of admissibility carries over and there is an analog of the A∗
algorithm for finding optimal solutions. Pointers are given in the bibliographical notes at the
end of the chapter.
Section 4.3. Searching with Nondeterministic Actions 137
Suck Right
6
1
5 2
Right
Figure 4.12 Part of the search graph for the slippery vacuum world, where we have shown
(some) cycles explicitly. All solutions for this problem are cyclic plans because there is no
way to move reliably.
4.3.3 Try, try again
Consider the slippery vacuum world, which is identical to the ordinary (non-erratic) vacuum world except that movement actions sometimes fail, leaving the agent in the same location. For example, moving Right in state 1 leads to the state set {1, 2}. Figure 4.12 shows
part of the search graph; clearly, there are no longer any acyclic solutions from state 1, and
CYCLIC SOLUTION AND-OR-GRAPH-SEARCH would return with failure. There is, however, a cyclic solution,
LABEL which is to keep trying Right until it works. We can express this solution by adding a label to
denote some portion of the plan and using that label later instead of repeating the plan itself.
Thus, our cyclic solution is
[Suck, L1 : Right, if State = 5 then L1 else Suck] .
(A better syntax for the looping part of this plan would be “while State = 5 do Right.”)
In general a cyclic plan may be considered a solution provided that every leaf is a goal
state and that a leaf is reachable from every point in the plan. The modifications needed
to AND-OR-GRAPH-SEARCH are covered in Exercise 4.6. The key realization is that a loop
in the state space back to a state L translates to a loop in the plan back to the point where the
subplan for state L is executed.
Given the definition of a cyclic solution, an agent executing such a solution will eventually reach the goal provided that each outcome of a nondeterministic action eventually occurs.
Is this condition reasonable? It depends on the reason for the nondeterminism. If the action
rolls a die, then it’s reasonable to suppose that eventually a six will be rolled. If the action is
to insert a hotel card key into the door lock, but it doesn’t work the first time, then perhaps it
will eventually work, or perhaps one has the wrong key (or the wrong room!). After seven or
138 Chapter 4. Beyond Classical Search
eight tries, most people will assume the problem is with the key and will go back to the front
desk to get a new one. One way to understand this decision is to say that the initial problem
formulation (observable, nondeterministic) is abandoned in favor of a different formulation
(partially observable, deterministic) where the failure is attributed to an unobservable property of the key. We have more to say on this issue in Chapter 13.
4.4 SEARCHING WITH PARTIAL OBSERVATIONS
We now turn to the problem of partial observability, where the agent’s percepts do not suffice to pin down the exact state. As noted at the beginning of the previous section, if the
agent is in one of several possible states, then an action may lead to one of several possible
outcomes—even if the environment is deterministic. The key concept required for solving
BELIEF STATE partially observable problems is the belief state, representing the agent’s current belief about
the possible physical states it might be in, given the sequence of actions and percepts up to
that point. We begin with the simplest scenario for studying belief states, which is when the
agent has no sensors at all; then we add in partial sensing as well as nondeterministic actions.
4.4.1 Searching with no observation
When the agent’s percepts provide no information at all, we have what is called a sensorSENSORLESS less problem or sometimes a conformant problem. At first, one might think the sensorless
CONFORMANT agent has no hope of solving a problem if it has no idea what state it’s in; in fact, sensorless
problems are quite often solvable. Moreover, sensorless agents can be surprisingly useful,
primarily because they don’t rely on sensors working properly. In manufacturing systems,
for example, many ingenious methods have been developed for orienting parts correctly from
an unknown initial position by using a sequence of actions with no sensing at all. The high
cost of sensing is another reason to avoid it: for example, doctors often prescribe a broadspectrum antibiotic rather than using the contingent plan of doing an expensive blood test,
then waiting for the results to come back, and then prescribing a more specific antibiotic and
perhaps hospitalization because the infection has progressed too far.
We can make a sensorless version of the vacuum world. Assume that the agent knows
the geography of its world, but doesn’t know its location or the distribution of dirt. In that
case, its initial state could be any element of the set {1, 2, 3, 4, 5, 6, 7, 8}. Now, consider what
happens if it tries the action Right. This will cause it to be in one of the states {2, 4, 6, 8}—the
agent now has more information! Furthermore, the action sequence [Right,Suck] will always
end up in one of the states {4, 8}. Finally, the sequence [Right,Suck,Left,Suck] is guaranteed
COERCION to reach the goal state 7 no matter what the start state. We say that the agent can coerce the
world into state 7.
To solve sensorless problems, we search in the space of belief states rather than physical
states.10 Notice that in belief-state space, the problem is fully observable because the agent
10 In a fully observable environment, each belief state contains one physical state. Thus, we can view the algorithms in Chapter 3 as searching in a belief-state space of singleton belief states.
Section 4.4. Searching with Partial Observations 139
always knows its own belief state. Furthermore, the solution (if any) is always a sequence of
actions. This is because, as in the ordinary problems of Chapter 3, the percepts received after
each action are completely predictable—they’re always empty! So there are no contingencies
to plan for. This is true even if the environment is nondeterminstic.
It is instructive to see how the belief-state search problem is constructed. Suppose
the underlying physical problem P is defined by ACTIONSP , RESULTP , GOAL-TESTP , and
STEP-COSTP . Then we can define the corresponding sensorless problem as follows:
• Belief states: The entire belief-state space contains every possible set of physical states.
If P has N states, then the sensorless problem has up to 2N states, although many may
be unreachable from the initial state.
• Initial state: Typically the set of all states in P, although in some cases the agent will
have more knowledge than this.
• Actions: This is slightly tricky. Suppose the agent is in belief state b = {s1, s2}, but
ACTIONSP (s1) = ACTIONSP (s2); then the agent is unsure of which actions are legal.
If we assume that illegal actions have no effect on the environment, then it is safe to
take the union of all the actions in any of the physical states in the current belief state b:
ACTIONS(b) = 
s∈b
ACTIONSP (s) .
On the other hand, if an illegal action might be the end of the world, it is safer to allow
only the intersection, that is, the set of actions legal in all the states. For the vacuum
world, every state has the same legal actions, so both methods give the same result.
• Transition model: The agent doesn’t know which state in the belief state is the right
one; so as far as it knows, it might get to any of the states resulting from applying the
action to one of the physical states in the belief state. For deterministic actions, the set
of states that might be reached is
b = RESULT(b, a) = {s : s = RESULTP (s, a) and s ∈ b} . (4.4)
With deterministic actions, b is never larger than b. With nondeterminism, we have
b = RESULT(b, a) = {s : s ∈ RESULTSP (s, a) and s ∈ b}
= 
s∈b
RESULTSP (s, a) ,
which may be larger than b, as shown in Figure 4.13. The process of generating
the new belief state after the action is called the prediction step; the notation b PREDICTION  =
PREDICTP (b, a) will come in handy.
• Goal test: The agent wants a plan that is sure to work, which means that a belief state
satisfies the goal only if all the physical states in it satisfy GOAL-TESTP . The agent
may accidentally achieve the goal earlier, but it won’t know that it has done so.
• Path cost: This is also tricky. If the same action can have different costs in different
states, then the cost of taking an action in a given belief state could be one of several
values. (This gives rise to a new class of problems, which we explore in Exercise 4.9.)
For now we assume that the cost of an action is the same in all states and so can be
transferred directly from the underlying physical problem.
140 Chapter 4. Beyond Classical Search
2
4
1
3
2
4
1
3
1
3
(a) (b)
Figure 4.13 (a) Predicting the next belief state for the sensorless vacuum world with a
deterministic action, Right. (b) Prediction for the same belief state and action in the slippery
version of the sensorless vacuum world.
Figure 4.14 shows the reachable belief-state space for the deterministic, sensorless vacuum
world. There are only 12 reachable belief states out of 28 = 256 possible belief states.
The preceding definitions enable the automatic construction of the belief-state problem
formulation from the definition of the underlying physical problem. Once this is done, we
can apply any of the search algorithms of Chapter 3. In fact, we can do a little bit more
than that. In “ordinary” graph search, newly generated states are tested to see if they are
identical to existing states. This works for belief states, too; for example, in Figure 4.14, the
action sequence [Suck,Left,Suck] starting at the initial state reaches the same belief state as
[Right,Left,Suck], namely, {5, 7}. Now, consider the belief state reached by [Left], namely,
{1, 3, 5, 7}. Obviously, this is not identical to {5, 7}, but it is a superset. It is easy to prove
(Exercise 4.8) that if an action sequence is a solution for a belief state b, it is also a solution for
any subset of b. Hence, we can discard a path reaching {1, 3, 5, 7} if {5, 7} has already been
generated. Conversely, if {1, 3, 5, 7} has already been generated and found to be solvable,
then any subset, such as {5, 7}, is guaranteed to be solvable. This extra level of pruning may
dramatically improve the efficiency of sensorless problem solving.
Even with this improvement, however, sensorless problem-solving as we have described
it is seldom feasible in practice. The difficulty is not so much the vastness of the belief-state
space—even though it is exponentially larger than the underlying physical state space; in
most cases the branching factor and solution length in the belief-state space and physical
state space are not so different. The real difficulty lies with the size of each belief state. For
example, the initial belief state for the 10 × 10 vacuum world contains 100 × 2100 or around
1032 physical states—far too many if we use the atomic representation, which is an explicit
list of states.
One solution is to represent the belief state by some more compact description. In
English, we could say the agent knows “Nothing” in the initial state; after moving Left, we
could say, “Not in the rightmost column,” and so on. Chapter 7 explains how to do this in a
formal representation scheme. Another approach is to avoid the standard search algorithms,
which treat belief states as black boxes just like any other problem state. Instead, we can look
Section 4.4. Searching with Partial Observations 141
L
R
S
L
R
S
L R
S
R L
S
L
R
S
L R
S L
R
S
1 3 1
5 7
2 4
6 8
2 3
45 6
7 8
4 5
7 8
5 3
7
6 4
8
4
8
5
7
6
8
8 7
3
7
Figure 4.14 The reachable portion of the belief-state space for the deterministic, sensorless vacuum world. Each shaded box corresponds to a single belief state. At any given point,
the agent is in a particular belief state but does not know which physical state it is in. The
initial belief state (complete ignorance) is the top center box. Actions are represented by
labeled links. Self-loops are omitted for clarity.
inside the belief states and develop incremental belief-state search algorithms that build up INCREMENTAL
BELIEF-STATE
SEARCH
the solution one physical state at a time. For example, in the sensorless vacuum world, the
initial belief state is {1, 2, 3, 4, 5, 6, 7, 8}, and we have to find an action sequence that works
in all 8 states. We can do this by first finding a solution that works for state 1; then we check
if it works for state 2; if not, go back and find a different solution for state 1, and so on. Just
as an AND–OR search has to find a solution for every branch at an AND node, this algorithm
has to find a solution for every state in the belief state; the difference is that AND–OR search
can find a different solution for each branch, whereas an incremental belief-state search has
to find one solution that works for all the states.
The main advantage of the incremental approach is that it is typically able to detect
failure quickly—when a belief state is unsolvable, it is usually the case that a small subset of
the belief state, consisting of the first few states examined, is also unsolvable. In some cases,
142 Chapter 4. Beyond Classical Search
this leads to a speedup proportional to the size of the belief states, which may themselves be
as large as the physical state space itself.
Even the most efficient solution algorithm is not of much use when no solutions exist.
Many things just cannot be done without sensing. For example, the sensorless 8-puzzle is
impossible. On the other hand, a little bit of sensing can go a long way. For example, every
8-puzzle instance is solvable if just one square is visible—the solution involves moving each
tile in turn into the visible square and then keeping track of its location.
4.4.2 Searching with observations
For a general partially observable problem, we have to specify how the environment generates
percepts for the agent. For example, we might define the local-sensing vacuum world to be
one in which the agent has a position sensor and a local dirt sensor but has no sensor capable
of detecting dirt in other squares. The formal problem specification includes a PERCEPT(s)
function that returns the percept received in a given state. (If sensing is nondeterministic,
then we use a PERCEPTS function that returns a set of possible percepts.) For example, in the
local-sensing vacuum world, the PERCEPT in state 1 is [A, Dirty]. Fully observable problems
are a special case in which PERCEPT(s) = s for every state s, while sensorless problems are
a special case in which PERCEPT(s) = null.
When observations are partial, it will usually be the case that several states could have
produced any given percept. For example, the percept [A, Dirty] is produced by state 3 as
well as by state 1. Hence, given this as the initial percept, the initial belief state for the
local-sensing vacuum world will be {1, 3}. The ACTIONS, STEP-COST, and GOAL-TEST
are constructed from the underlying physical problem just as for sensorless problems, but the
transition model is a bit more complicated. We can think of transitions from one belief state
to the next for a particular action as occurring in three stages, as shown in Figure 4.15:
• The prediction stage is the same as for sensorless problems: given the action a in belief
state b, the predicted belief state is ˆb = PREDICT(b, a).
11
• The observation prediction stage determines the set of percepts o that could be observed in the predicted belief state:
POSSIBLE-PERCEPTS(ˆb) = {o : o = PERCEPT(s) and s ∈ ˆb} .
• The update stage determines, for each possible percept, the belief state that would
result from the percept. The new belief state bo is just the set of states in ˆb that could
have produced the percept:
bo = UPDATE(ˆb, o) = {s : o = PERCEPT(s) and s ∈ ˆb} .
Notice that each updated belief state bo can be no larger than the predicted belief state ˆb;
observations can only help reduce uncertainty compared to the sensorless case. Moreover, for deterministic sensing, the belief states for the different possible percepts will
be disjoint, forming a partition of the original predicted belief state.
11 Here, and throughout the book, the “hat” in ˆb means an estimated or predicted value for b.
Section 4.4. Searching with Partial Observations 143
2
4
4
1
2
4
1
3
2
1
3 3
(b)
(a)
4
2
1
3
Right
[A,Dirty]
[B,Dirty]
[B,Clean]
Right [B,Dirty]
[B,Clean]
Figure 4.15 Two example of transitions in local-sensing vacuum worlds. (a) In the deterministic world, Right is applied in the initial belief state, resulting in a new belief state
with two possible physical states; for those states, the possible percepts are [B, Dirty] and
[B, Clean], leading to two belief states, each of which is a singleton. (b) In the slippery
world, Right is applied in the initial belief state, giving a new belief state with four physical states; for those states, the possible percepts are [A, Dirty], [B, Dirty], and [B, Clean],
leading to three belief states as shown.
Putting these three stages together, we obtain the possible belief states resulting from a given
action and the subsequent possible percepts:
RESULTS(b, a) = {bo : bo = UPDATE(PREDICT(b, a), o) and
o ∈ POSSIBLE-PERCEPTS(PREDICT(b, a))} . (4.5)
Again, the nondeterminism in the partially observable problem comes from the inability
to predict exactly which percept will be received after acting; underlying nondeterminism in
the physical environment may contribute to this inability by enlarging the belief state at the
prediction stage, leading to more percepts at the observation stage.
4.4.3 Solving partially observable problems
The preceding section showed how to derive the RESULTS function for a nondeterministic
belief-state problem from an underlying physical problem and the PERCEPT function. Given
144 Chapter 4. Beyond Classical Search
7
5
1
3
2 4
Suck
[B,Dirty] [B,Clean]
Right
[A,Clean]
Figure 4.16 The first level of the AND–OR search tree for a problem in the local-sensing
vacuum world; Suck is the first step of the solution.
such a formulation, the AND–OR search algorithm of Figure 4.11 can be applied directly to
derive a solution. Figure 4.16 shows part of the search tree for the local-sensing vacuum
world, assuming an initial percept [A, Dirty]. The solution is the conditional plan
[Suck, Right, if Bstate = {6} then Suck else [ ]] .
Notice that, because we supplied a belief-state problem to the AND–OR search algorithm, it
returned a conditional plan that tests the belief state rather than the actual state. This is as it
should be: in a partially observable environment the agent won’t be able to execute a solution
that requires testing the actual state.
As in the case of standard search algorithms applied to sensorless problems, the AND–
OR search algorithm treats belief states as black boxes, just like any other states. One can
improve on this by checking for previously generated belief states that are subsets or supersets
of the current state, just as for sensorless problems. One can also derive incremental search
algorithms, analogous to those described for sensorless problems, that provide substantial
speedups over the black-box approach.
4.4.4 An agent for partially observable environments
The design of a problem-solving agent for partially observable environments is quite similar
to the simple problem-solving agent in Figure 3.1: the agent formulates a problem, calls a
search algorithm (such as AND-OR-GRAPH-SEARCH) to solve it, and executes the solution.
There are two main differences. First, the solution to a problem will be a conditional plan
rather than a sequence; if the first step is an if–then–else expression, the agent will need to
test the condition in the if-part and execute the then-part or the else-part accordingly. Second,
the agent will need to maintain its belief state as it performs actions and receives percepts.
This process resembles the prediction–observation–update process in Equation (4.5) but is
actually simpler because the percept is given by the environment rather than calculated by the
Section 4.4. Searching with Partial Observations 145
7
5
6
1 2
3
6
4
8
[A,Clean] Right 2 [B,Dirty]
7
5
Suck
Figure 4.17 Two prediction–update cycles of belief-state maintenance in the kindergarten
vacuum world with local sensing.
agent. Given an initial belief state b, an action a, and a percept o, the new belief state is:
b = UPDATE(PREDICT(b, a), o) . (4.6)
Figure 4.17 shows the belief state being maintained in the kindergarten vacuum world with
local sensing, wherein any square may become dirty at any time unless the agent is actively
cleaning it at that moment.12
In partially observable environments—which include the vast majority of real-world
environments—maintaining one’s belief state is a core function of any intelligent system.
MONITORING This function goes under various names, including monitoring, filtering and state estimaFILTERING tion. Equation (4.6) is called a recursive state estimator because it computes the new belief
STATE ESTIMATION
RECURSIVE
state from the previous one rather than by examining the entire percept sequence. If the agent
is not to “fall behind,” the computation has to happen as fast as percepts are coming in. As
the environment becomes more complex, the exact update computation becomes infeasible
and the agent will have to compute an approximate belief state, perhaps focusing on the implications of the percept for the aspects of the environment that are of current interest. Most
work on this problem has been done for stochastic, continuous-state environments with the
tools of probability theory, as explained in Chapter 15. Here we will show an example in a
discrete environment with detrministic sensors and nondeterministic actions.
LOCALIZATION The example concerns a robot with the task of localization: working out where it is,
given a map of the world and a sequence of percepts and actions. Our robot is placed in the
maze-like environment of Figure 4.18. The robot is equipped with four sonar sensors that
tell whether there is an obstacle—the outer wall or a black square in the figure—in each of
the four compass directions. We assume that the sensors give perfectly correct data, and that
the robot has a correct map of the enviornment. But unfortunately the robot’s navigational
system is broken, so when it executes a Move action, it moves randomly to one of the adjacent
squares. The robot’s task is to determine its current location.
Suppose the robot has just been switched on, so it does not know where it is. Thus its
initial belief state b consists of the set of all locations. The the robot receives the percept
12 The usual apologies to those who are unfamiliar with the effect of small children on the environment.
146 Chapter 4. Beyond Classical Search
(a) Possible locations of robot after E1 = NSW
(b) Possible locations of robot After E1 = NSW, E2 = NS
Figure 4.18 Possible positions of the robot, , (a) after one observation E1 = NSW and
(b) after a second observation E2 = NS. When sensors are noiseless and the transition model
is accurate, there are no other possible locations for the robot consistent with this sequence
of two observations.
NSW, meaning there are obstacles to the north, west, and south, and does an update using the
equation bo = UPDATE(b), yielding the 4 locations shown in Figure 4.18(a). You can inspect
the maze to see that those are the only four locations that yield the percept NWS.
Next the robot executes a Move action, but the result is nondeterministic. The new belief state, ba = PREDICT(bo, Move), contains all the locations that are one step away from the
locations in bo. When the second percept, NS, arrives, the robot does UPDATE(ba, NS) and
finds that the belief state has collapsed down to the single location shown in Figure 4.18(b).
That’s the only location that could be the result of
UPDATE(PREDICT(UPDATE(b, NSW ), Move), NS) .
With nondetermnistic actions the PREDICT step grows the belief state, but the UPDATE step
shrinks it back down—as long as the percepts provide some useful identifying information.
Sometimes the percepts don’t help much for localization: If there were one or more long
east-west corridors, then a robot could receive a long sequence of NS percepts, but never
know where in the corridor(s) it was.
Section 4.5. Online Search Agents and Unknown Environments 147
4.5 ONLINE SEARCH AGENTS AND UNKNOWN ENVIRONMENTS
OFFLINE SEARCH So far we have concentrated on agents that use offline search algorithms. They compute
a complete solution before setting foot in the real world and then execute the solution. In
contrast, an online search13 ONLINE SEARCH agent interleaves computation and action: first it takes an action,
then it observes the environment and computes the next action. Online search is a good idea
in dynamic or semidynamic domains—domains where there is a penalty for sitting around
and computing too long. Online search is also helpful in nondeterministic domains because
it allows the agent to focus its computational efforts on the contingencies that actually arise
rather than those that might happen but probably won’t. Of course, there is a tradeoff: the
more an agent plans ahead, the less often it will find itself up the creek without a paddle.
Online search is a necessary idea for unknown environments, where the agent does not
know what states exist or what its actions do. In this state of ignorance, the agent faces an
exploration problem and must use its actions as experiments in order to learn enough to EXPLORATION
PROBLEM
make deliberation worthwhile.
The canonical example of online search is a robot that is placed in a new building and
must explore it to build a map that it can use for getting from A to B. Methods for escaping
from labyrinths—required knowledge for aspiring heroes of antiquity—are also examples of
online search algorithms. Spatial exploration is not the only form of exploration, however.
Consider a newborn baby: it has many possible actions but knows the outcomes of none of
them, and it has experienced only a few of the possible states that it can reach. The baby’s
gradual discovery of how the world works is, in part, an online search process.
4.5.1 Online search problems
An online search problem must be solved by an agent executing actions, rather than by pure
computation. We assume a deterministic and fully observable environment (Chapter 17 relaxes these assumptions), but we stipulate that the agent knows only the following:
• ACTIONS(s), which returns a list of actions allowed in state s;
• The step-cost function c(s, a, s
)—note that this cannot be used until the agent knows
that s is the outcome; and
• GOAL-TEST(s).
Note in particular that the agent cannot determine RESULT(s, a) except by actually being
in s and doing a. For example, in the maze problem shown in Figure 4.19, the agent does
not know that going Up from (1,1) leads to (1,2); nor, having done that, does it know that
going Down will take it back to (1,1). This degree of ignorance can be reduced in some
applications—for example, a robot explorer might know how its movement actions work and
be ignorant only of the locations of obstacles.
13 The term “online” is commonly used in computer science to refer to algorithms that must process input data
as they are received rather than waiting for the entire input data set to become available.
148 Chapter 4. Beyond Classical Search
G
1 S
2
3
123
Figure 4.19 A simple maze problem. The agent starts at S and must reach G but knows
nothing of the environment.
S
G
S
G
A
A
S G
(a) (b)
Figure 4.20 (a) Two state spaces that might lead an online search agent into a dead end.
Any given agent will fail in at least one of these spaces. (b) A two-dimensional environment
that can cause an online search agent to follow an arbitrarily inefficient route to the goal.
Whichever choice the agent makes, the adversary blocks that route with another long, thin
wall, so that the path followed is much longer than the best possible path.
Finally, the agent might have access to an admissible heuristic function h(s) that estimates the distance from the current state to a goal state. For example, in Figure 4.19, the
agent might know the location of the goal and be able to use the Manhattan-distance heuristic.
Typically, the agent’s objective is to reach a goal state while minimizing cost. (Another
possible objective is simply to explore the entire environment.) The cost is the total path cost
of the path that the agent actually travels. It is common to compare this cost with the path
cost of the path the agent would follow if it knew the search space in advance—that is, the
actual shortest path (or shortest complete exploration). In the language of online algorithms,
COMPETITIVE RATIO this is called the competitive ratio; we would like it to be as small as possible.
Section 4.5. Online Search Agents and Unknown Environments 149
Although this sounds like a reasonable request, it is easy to see that the best achievable
IRREVERSIBLE competitive ratio is infinite in some cases. For example, if some actions are irreversible—
i.e., they lead to a state from which no action leads back to the previous state—the online
DEAD END search might accidentally reach a dead-end state from which no goal state is reachable. Perhaps the term “accidentally” is unconvincing—after all, there might be an algorithm that
happens not to take the dead-end path as it explores. Our claim, to be more precise, is that no
algorithm can avoid dead ends in all state spaces. Consider the two dead-end state spaces in
Figure 4.20(a). To an online search algorithm that has visited states S and A, the two state
spaces look identical, so it must make the same decision in both. Therefore, it will fail in
one of them. This is an example of an adversary argument—we can imagine an adversary ADVERSARY
ARGUMENT
constructing the state space while the agent explores it and putting the goals and dead ends
wherever it chooses.
Dead ends are a real difficulty for robot exploration—staircases, ramps, cliffs, one-way
streets, and all kinds of natural terrain present opportunities for irreversible actions. To make
SAFELY EXPLORABLE progress, we simply assume that the state space is safely explorable—that is, some goal state
is reachable from every reachable state. State spaces with reversible actions, such as mazes
and 8-puzzles, can be viewed as undirected graphs and are clearly safely explorable.
Even in safely explorable environments, no bounded competitive ratio can be guaranteed if there are paths of unbounded cost. This is easy to show in environments with irreversible actions, but in fact it remains true for the reversible case as well, as Figure 4.20(b)
shows. For this reason, it is common to describe the performance of online search algorithms
in terms of the size of the entire state space rather than just the depth of the shallowest goal.
4.5.2 Online search agents
After each action, an online agent receives a percept telling it what state it has reached; from
this information, it can augment its map of the environment. The current map is used to
decide where to go next. This interleaving of planning and action means that online search
algorithms are quite different from the offline search algorithms we have seen previously. For
example, offline algorithms such as A∗ can expand a node in one part of the space and then
immediately expand a node in another part of the space, because node expansion involves
simulated rather than real actions. An online algorithm, on the other hand, can discover
successors only for a node that it physically occupies. To avoid traveling all the way across
the tree to expand the next node, it seems better to expand nodes in a local order. Depth-first
search has exactly this property because (except when backtracking) the next node expanded
is a child of the previous node expanded.
An online depth-first search agent is shown in Figure 4.21. This agent stores its map
in a table, RESULT[s, a], that records the state resulting from executing action a in state s.
Whenever an action from the current state has not been explored, the agent tries that action.
The difficulty comes when the agent has tried all the actions in a state. In offline depth-first
search, the state is simply dropped from the queue; in an online search, the agent has to
backtrack physically. In depth-first search, this means going back to the state from which the
agent most recently entered the current state. To achieve that, the algorithm keeps a table that
150 Chapter 4. Beyond Classical Search
function ONLINE-DFS-AGENT(s
) returns an action
inputs: s
, a percept that identifies the current state
persistent: result, a table indexed by state and action, initially empty
untried, a table that lists, for each state, the actions not yet tried
unbacktracked, a table that lists, for each state, the backtracks not yet tried
s, a, the previous state and action, initially null
if GOAL-TEST(s
) then return stop
if s is a new state (not in untried) then untried[s
] ← ACTIONS(s
)
if s is not null then
result[s, a] ←s
add s to the front of unbacktracked[s
]
if untried[s
] is empty then
if unbacktracked[s
] is empty then return stop
else a ← an action b such that result[s
, b]=POP(unbacktracked[s
])
else a ← POP(untried[s
])
s ← s
return a
Figure 4.21 An online search agent that uses depth-first exploration. The agent is applicable only in state spaces in which every action can be “undone” by some other action.
lists, for each state, the predecessor states to which the agent has not yet backtracked. If the
agent has run out of states to which it can backtrack, then its search is complete.
We recommend that the reader trace through the progress of ONLINE-DFS-AGENT
when applied to the maze given in Figure 4.19. It is fairly easy to see that the agent will, in
the worst case, end up traversing every link in the state space exactly twice. For exploration,
this is optimal; for finding a goal, on the other hand, the agent’s competitive ratio could be
arbitrarily bad if it goes off on a long excursion when there is a goal right next to the initial
state. An online variant of iterative deepening solves this problem; for an environment that is
a uniform tree, the competitive ratio of such an agent is a small constant.
Because of its method of backtracking, ONLINE-DFS-AGENT works only in state
spaces where the actions are reversible. There are slightly more complex algorithms that
work in general state spaces, but no such algorithm has a bounded competitive ratio.
4.5.3 Online local search
Like depth-first search, hill-climbing search has the property of locality in its node expansions. In fact, because it keeps just one current state in memory, hill-climbing search is
already an online search algorithm! Unfortunately, it is not very useful in its simplest form
because it leaves the agent sitting at local maxima with nowhere to go. Moreover, random
restarts cannot be used, because the agent cannot transport itself to a new state.
RANDOM WALK Instead of random restarts, one might consider using a random walk to explore the
environment. A random walk simply selects at random one of the available actions from the
Section 4.5. Online Search Agents and Unknown Environments 151
S G
Figure 4.22 An environment in which a random walk will take exponentially many steps
to find the goal.
current state; preference can be given to actions that have not yet been tried. It is easy to
prove that a random walk will eventually find a goal or complete its exploration, provided
that the space is finite.14 On the other hand, the process can be very slow. Figure 4.22 shows
an environment in which a random walk will take exponentially many steps to find the goal
because, at each step, backward progress is twice as likely as forward progress. The example
is contrived, of course, but there are many real-world state spaces whose topology causes
these kinds of “traps” for random walks.
Augmenting hill climbing with memory rather than randomness turns out to be a more
effective approach. The basic idea is to store a “current best estimate” H(s) of the cost to
reach the goal from each state that has been visited. H(s) starts out being just the heuristic
estimate h(s) and is updated as the agent gains experience in the state space. Figure 4.23
shows a simple example in a one-dimensional state space. In (a), the agent seems to be
stuck in a flat local minimum at the shaded state. Rather than staying where it is, the agent
should follow what seems to be the best path to the goal given the current cost estimates for
its neighbors. The estimated cost to reach the goal through a neighbor s is the cost to get
to s plus the estimated cost to get to a goal from there—that is, c(s, a, s
) + H(s
). In the
example, there are two actions, with estimated costs 1+9 and 1+2, so it seems best to move
right. Now, it is clear that the cost estimate of 2 for the shaded state was overly optimistic.
Since the best move cost 1 and led to a state that is at least 2 steps from a goal, the shaded
state must be at least 3 steps from a goal, so its H should be updated accordingly, as shown
in Figure 4.23(b). Continuing this process, the agent will move back and forth twice more,
updating H each time and “flattening out” the local minimum until it escapes to the right.
An agent implementing this scheme, which is called learning real-time A∗ (LRTA∗ LRTA* ), is
shown in Figure 4.24. Like ONLINE-DFS-AGENT, it builds a map of the environment in
the result table. It updates the cost estimate for the state it has just left and then chooses the
“apparently best” move according to its current cost estimates. One important detail is that
actions that have not yet been tried in a state s are always assumed to lead immediately to the
goal with the least possible cost, namely h(s). This optimism under uncertainty encourages OPTIMISM UNDER
UNCERTAINTY
the agent to explore new, possibly promising paths.
An LRTA∗ agent is guaranteed to find a goal in any finite, safely explorable environment.
Unlike A∗, however, it is not complete for infinite state spaces—there are cases where it can be
led infinitely astray. It can explore an environment of n states in O(n2)steps in the worst case,
14 Random walks are complete on infinite one-dimensional and two-dimensional grids. On a three-dimensional
grid, the probability that the walk ever returns to the starting point is only about 0.3405 (Hughes, 1995).
152 Chapter 4. Beyond Classical Search
1
2 1 1 1 1 1 1
1 1 1 1 1 1 1
1 1 1 1 1 1 1
2
2
3
4
4
4
3
3
3
1 1 1 1 1 1 1 3
1 1 1 1 1 1 1 5
3
5
5
4
(a)
(b)
(c)
(d)
(e)
8 9
8
9
8 9
8
9
8 9
4 4
4 3
Figure 4.23 Five iterations of LRTA∗ on a one-dimensional state space. Each state is
labeled with H(s), the current cost estimate to reach a goal, and each link is labeled with its
step cost. The shaded state marks the location of the agent, and the updated cost estimates at
each iteration are circled.
function LRTA*-AGENT(s
) returns an action
inputs: s
, a percept that identifies the current state
persistent: result, a table, indexed by state and action, initially empty
H , a table of cost estimates indexed by state, initially empty
s, a, the previous state and action, initially null
if GOAL-TEST(s
) then return stop
if s is a new state (not in H ) then H [s
] ← h(s
)
if s is not null
result[s, a] ←s
H [s] ← min
b ∈ACTIONS(s)
LRTA*-COST(s, b, result[s, b],H )
a ← an action b in ACTIONS(s
) that minimizes LRTA*-COST(s
, b, result[s
, b],H )
s ← s
return a
function LRTA*-COST(s, a, s
,H ) returns a cost estimate
if s is undefined then return h(s)
else return c(s, a, s
) + H[s
]
Figure 4.24 LRTA*-AGENT selects an action according to the values of neighboring
states, which are updated as the agent moves about the state space.
Section 4.6. Summary 153
but often does much better. The LRTA∗ agent is just one of a large family of online agents that
one can define by specifying the action selection rule and the update rule in different ways.
We discuss this family, developed originally for stochastic environments, in Chapter 21.
4.5.4 Learning in online search
The initial ignorance of online search agents provides several opportunities for learning. First,
the agents learn a “map” of the environment—more precisely, the outcome of each action in
each state—simply by recording each of their experiences. (Notice that the assumption of
deterministic environments means that one experience is enough for each action.) Second,
the local search agents acquire more accurate estimates of the cost of each state by using local
updating rules, as in LRTA∗. In Chapter 21, we show that these updates eventually converge
to exact values for every state, provided that the agent explores the state space in the right
way. Once exact values are known, optimal decisions can be taken simply by moving to the
lowest-cost successor—that is, pure hill climbing is then an optimal strategy.
If you followed our suggestion to trace the behavior of ONLINE-DFS-AGENT in the
environment of Figure 4.19, you will have noticed that the agent is not very bright. For
example, after it has seen that the Up action goes from (1,1) to (1,2), the agent still has no
idea that the Down action goes back to (1,1) or that the Up action also goes from (2,1) to
(2,2), from (2,2) to (2,3), and so on. In general, we would like the agent to learn that Up
increases the y-coordinate unless there is a wall in the way, that Down reduces it, and so on.
For this to happen, we need two things. First, we need a formal and explicitly manipulable
representation for these kinds of general rules; so far, we have hidden the information inside
the black box called the RESULT function. Part III is devoted to this issue. Second, we need
algorithms that can construct suitable general rules from the specific observations made by
the agent. These are covered in Chapter 18.
4.6 SUMMARY
This chapter has examined search algorithms for problems beyond the “classical” case of
finding the shortest path to a goal in an observable, deterministic, discrete environment.
• Local search methods such as hill climbing operate on complete-state formulations,
keeping only a small number of nodes in memory. Several stochastic algorithms have
been developed, including simulated annealing, which returns optimal solutions when
given an appropriate cooling schedule.
• Many local search methods apply also to problems in continuous spaces. Linear programming and convex optimization problems obey certain restrictions on the shape
of the state space and the nature of the objective function, and admit polynomial-time
algorithms that are often extremely efficient in practice.
• A genetic algorithm is a stochastic hill-climbing search in which a large population of
states is maintained. New states are generated by mutation and by crossover, which
combines pairs of states from the population.
154 Chapter 4. Beyond Classical Search
• In nondeterministic environments, agents can apply AND–OR search to generate contingent plans that reach the goal regardless of which outcomes occur during execution.
• When the environment is partially observable, the belief state represents the set of
possible states that the agent might be in.
• Standard search algorithms can be applied directly to belief-state space to solve sensorless problems, and belief-state AND–OR search can solve general partially observable
problems. Incremental algorithms that construct solutions state-by-state within a belief
state are often more efficient.
• Exploration problems arise when the agent has no idea about the states and actions of
its environment. For safely explorable environments, online search agents can build a
map and find a goal if one exists. Updating heuristic estimates from experience provides
an effective method to escape from local minima.
BIBLIOGRAPHICAL AND HISTORICAL NOTES
Local search techniques have a long history in mathematics and computer science. Indeed,
the Newton–Raphson method (Newton, 1671; Raphson, 1690) can be seen as a very efficient local search method for continuous spaces in which gradient information is available.
Brent (1973) is a classic reference for optimization algorithms that do not require such information. Beam search, which we have presented as a local search algorithm, originated
as a bounded-width variant of dynamic programming for speech recognition in the HARPY
system (Lowerre, 1976). A related algorithm is analyzed in depth by Pearl (1984, Ch. 5).
The topic of local search was reinvigorated in the early 1990s by surprisingly good results for large constraint-satisfaction problems such as n-queens (Minton et al., 1992) and
logical reasoning (Selman et al., 1992) and by the incorporation of randomness, multiple
simultaneous searches, and other improvements. This renaissance of what Christos Papadimitriou has called “New Age” algorithms also sparked increased interest among theoretical
computer scientists (Koutsoupias and Papadimitriou, 1992; Aldous and Vazirani, 1994). In
TABU SEARCH the field of operations research, a variant of hill climbing called tabu search has gained popularity (Glover and Laguna, 1997). This algorithm maintains a tabu list of k previously visited
states that cannot be revisited; as well as improving efficiency when searching graphs, this list
can allow the algorithm to escape from some local minima. Another useful improvement on
hill climbing is the STAGE algorithm (Boyan and Moore, 1998). The idea is to use the local
maxima found by random-restart hill climbing to get an idea of the overall shape of the landscape. The algorithm fits a smooth surface to the set of local maxima and then calculates the
global maximum of that surface analytically. This becomes the new restart point. The algorithm has been shown to work in practice on hard problems. Gomes et al. (1998) showed that
the run times of systematic backtracking algorithms often have a heavy-tailed distribution, HEAVY-TAILED
DISTRIBUTION
which means that the probability of a very long run time is more than would be predicted if
the run times were exponentially distributed. When the run time distribution is heavy-tailed,
random restarts find a solution faster, on average, than a single run to completion.
Bibliographical and Historical Notes 155
Simulated annealing was first described by Kirkpatrick et al. (1983), who borrowed
directly from the Metropolis algorithm (which is used to simulate complex systems in
physics (Metropolis et al., 1953) and was supposedly invented at a Los Alamos dinner party).
Simulated annealing is now a field in itself, with hundreds of papers published every year.
Finding optimal solutions in continuous spaces is the subject matter of several fields,
including optimization theory, optimal control theory, and the calculus of variations. The
basic techniques are explained well by Bishop (1995); Press et al. (2007) cover a wide range
of algorithms and provide working software.
As Andrew Moore points out, researchers have taken inspiration for search and optimization algorithms from a wide variety of fields of study: metallurgy (simulated annealing),
biology (genetic algorithms), economics (market-based algorithms), entomology (ant colony
optimization), neurology (neural networks), animal behavior (reinforcement learning), mountaineering (hill climbing), and others.
Linear programming (LP) was first studied systematically by the Russian mathematician Leonid Kantorovich (1939). It was one of the first applications of computers; the simplex algorithm (Dantzig, 1949) is still used despite worst-case exponential complexity. Karmarkar (1984) developed the far more efficient family of interior-point methods, which was
shown to have polynomial complexity for the more general class of convex optimization problems by Nesterov and Nemirovski (1994). Excellent introductions to convex optimization are
provided by Ben-Tal and Nemirovski (2001) and Boyd and Vandenberghe (2004).
Work by Sewall Wright (1931) on the concept of a fitness landscape was an important precursor to the development of genetic algorithms. In the 1950s, several statisticians,
including Box (1957) and Friedman (1959), used evolutionary techniques for optimization
problems, but it wasn’t until Rechenberg (1965) introduced evolution strategies to solve op- EVOLUTION
STRATEGY
timization problems for airfoils that the approach gained popularity. In the 1960s and 1970s,
John Holland (1975) championed genetic algorithms, both as a useful tool and as a method
to expand our understanding of adaptation, biological or otherwise (Holland, 1995). The arARTIFICIAL LIFE tificial life movement (Langton, 1995) takes this idea one step further, viewing the products
of genetic algorithms as organisms rather than solutions to problems. Work in this field by
Hinton and Nowlan (1987) and Ackley and Littman (1991) has done much to clarify the implications of the Baldwin effect. For general background on evolution, we recommend Smith
and Szathm´ary (1999), Ridley (2004), and Carroll (2007).
Most comparisons of genetic algorithms to other approaches (especially stochastic hill
climbing) have found that the genetic algorithms are slower to converge (O’Reilly and Oppacher, 1994; Mitchell et al., 1996; Juels and Wattenberg, 1996; Baluja, 1997). Such findings
are not universally popular within the GA community, but recent attempts within that community to understand population-based search as an approximate form of Bayesian learning
(see Chapter 20) might help close the gap between the field and its critics (Pelikan et al.,
1999). The theory of quadratic dynamical systems may also explain the performance of
GAs (Rabani et al., 1998). See Lohn et al. (2001) for an example of GAs applied to antenna
design, and Renner and Ekart (2003) for an application to computer-aided design.
The field of genetic programming is closely related to genetic algorithms. The princi- GENETIC
PROGRAMMING
pal difference is that the representations that are mutated and combined are programs rather
156 Chapter 4. Beyond Classical Search
than bit strings. The programs are represented in the form of expression trees; the expressions
can be in a standard language such as Lisp or can be specially designed to represent circuits,
robot controllers, and so on. Crossover involves splicing together subtrees rather than substrings. This form of mutation guarantees that the offspring are well-formed expressions,
which would not be the case if programs were manipulated as strings.
Interest in genetic programming was spurred by John Koza’s work (Koza, 1992, 1994),
but it goes back at least to early experiments with machine code by Friedberg (1958) and
with finite-state automata by Fogel et al. (1966). As with genetic algorithms, there is debate
about the effectiveness of the technique. Koza et al. (1999) describe experiments in the use
of genetic programming to design circuit devices.
The journals Evolutionary Computation and IEEE Transactions on Evolutionary Computation cover genetic algorithms and genetic programming; articles are also found in Complex Systems, Adaptive Behavior, and Artificial Life. The main conference is the Genetic
and Evolutionary Computation Conference (GECCO). Good overview texts on genetic algorithms are given by Mitchell (1996), Fogel (2000), and Langdon and Poli (2002), and by the
free online book by Poli et al. (2008).
The unpredictability and partial observability of real environments were recognized
early on in robotics projects that used planning techniques, including Shakey (Fikes et al.,
1972) and FREDDY (Michie, 1974). The problems received more attention after the publication of McDermott’s (1978a) influential article, Planning and Acting.
The first work to make explicit use of AND–OR trees seems to have been Slagle’s SAINT
program for symbolic integration, mentioned in Chapter 1. Amarel (1967) applied the idea
to propositional theorem proving, a topic discussed in Chapter 7, and introduced a search
algorithm similar to AND-OR-GRAPH-SEARCH. The algorithm was further developed and
formalized by Nilsson (1971), who also described AO∗—which, as its name suggests, finds
optimal solutions given an admissible heuristic. AO∗ was analyzed and improved by Martelli
and Montanari (1973). AO∗ is a top-down algorithm; a bottom-up generalization of A∗ is
A∗LD, for A∗ Lightest Derivation (Felzenszwalb and McAllester, 2007). Interest in AND–OR
search has undergone a revival in recent years, with new algorithms for finding cyclic solutions (Jimenez and Torras, 2000; Hansen and Zilberstein, 2001) and new techniques inspired
by dynamic programming (Bonet and Geffner, 2005).
The idea of transforming partially observable problems into belief-state problems originated with Astrom (1965) for the much more complex case of probabilistic uncertainty (see
Chapter 17). Erdmann and Mason (1988) studied the problem of robotic manipulation without sensors, using a continuous form of belief-state search. They showed that it was possible
to orient a part on a table from an arbitrary initial position by a well-designed sequence of tilting actions. More practical methods, based on a series of precisely oriented diagonal barriers
across a conveyor belt, use the same algorithmic insights (Wiegley et al., 1996).
The belief-state approach was reinvented in the context of sensorless and partially observable search problems by Genesereth and Nourbakhsh (1993). Additional work was done
on sensorless problems in the logic-based planning community (Goldman and Boddy, 1996;
Smith and Weld, 1998). This work has emphasized concise representations for belief states,
as explained in Chapter 11. Bonet and Geffner (2000) introduced the first effective heuristics
Exercises 157
for belief-state search; these were refined by Bryce et al. (2006). The incremental approach
to belief-state search, in which solutions are constructed incrementally for subsets of states
within each belief state, was studied in the planning literature by Kurien et al. (2002); several
new incremental algorithms were introduced for nondeterministic, partially observable problems by Russell and Wolfe (2005). Additional references for planning in stochastic, partially
observable environments appear in Chapter 17.
Algorithms for exploring unknown state spaces have been of interest for many centuries.
Depth-first search in a maze can be implemented by keeping one’s left hand on the wall; loops
can be avoided by marking each junction. Depth-first search fails with irreversible actions;
EULERIAN GRAPH the more general problem of exploring Eulerian graphs (i.e., graphs in which each node has
equal numbers of incoming and outgoing edges) was solved by an algorithm due to Hierholzer
(1873). The first thorough algorithmic study of the exploration problem for arbitrary graphs
was carried out by Deng and Papadimitriou (1990), who developed a completely general
algorithm but showed that no bounded competitive ratio is possible for exploring a general
graph. Papadimitriou and Yannakakis (1991) examined the question of finding paths to a goal
in geometric path-planning environments (where all actions are reversible). They showed that
a small competitive ratio is achievable with square obstacles, but with general rectangular
obstacles no bounded ratio can be achieved. (See Figure 4.20.)
The LRTA∗ algorithm was developed by Korf (1990) as part of an investigation into
REAL-TIME SEARCH real-time search for environments in which the agent must act after searching for only a
fixed amount of time (a common situation in two-player games). LRTA∗ is in fact a special
case of reinforcement learning algorithms for stochastic environments (Barto et al., 1995). Its
policy of optimism under uncertainty—always head for the closest unvisited state—can result
in an exploration pattern that is less efficient in the uninformed case than simple depth-first
search (Koenig, 2000). Dasgupta et al. (1994) show that online iterative deepening search is
optimally efficient for finding a goal in a uniform tree with no heuristic information. Several informed variants on the LRTA∗ theme have been developed with different methods for
searching and updating within the known portion of the graph (Pemberton and Korf, 1992).
As yet, there is no good understanding of how to find goals with optimal efficiency when
using heuristic information.
EXERCISES
4.1 Give the name of the algorithm that results from each of the following special cases:
a. Local beam search with k = 1.
b. Local beam search with one initial state and no limit on the number of states retained.
c. Simulated annealing with T = 0 at all times (and omitting the termination test).
d. Simulated annealing with T = ∞ at all times.
e. Genetic algorithm with population size N = 1.
158 Chapter 4. Beyond Classical Search
4.2 Exercise 3.16 considers the problem of building railway tracks under the assumption
that pieces fit exactly with no slack. Now consider the real problem, in which pieces don’t
fit exactly but allow for up to 10 degrees of rotation to either side of the “proper” alignment.
Explain how to formulate the problem so it could be solved by simulated annealing.
4.3 In this exercise, we explore the use of local search methods to solve TSPs of the type
defined in Exercise 3.30.
a. Implement and test a hill-climbing method to solve TSPs. Compare the results with optimal solutions obtained from the A∗ algorithm with the MST heuristic (Exercise 3.30).
b. Repeat part (a) using a genetic algorithm instead of hill climbing. You may want to
consult Larra˜naga et al. (1999) for some suggestions for representations.
4.4 Generate a large number of 8-puzzle and 8-queens instances and solve them (where possible) by hill climbing (steepest-ascent and first-choice variants), hill climbing with random
restart, and simulated annealing. Measure the search cost and percentage of solved problems
and graph these against the optimal solution cost. Comment on your results.
4.5 The AND-OR-GRAPH-SEARCH algorithm in Figure 4.11 checks for repeated states
only on the path from the root to the current state. Suppose that, in addition, the algorithm
were to store every visited state and check against that list. (See BREADTH-FIRST-SEARCH
in Figure 3.11 for an example.) Determine the information that should be stored and how the
algorithm should use that information when a repeated state is found. (Hint: You will need to
distinguish at least between states for which a successful subplan was constructed previously
and states for which no subplan could be found.) Explain how to use labels, as defined in
Section 4.3.3, to avoid having multiple copies of subplans.
4.6 Explain precisely how to modify the AND-OR-GRAPH-SEARCH algorithm to generate
a cyclic plan if no acyclic plan exists. You will need to deal with three issues: labeling the plan
steps so that a cyclic plan can point back to an earlier part of the plan, modifying OR-SEARCH
so that it continues to look for acyclic plans after finding a cyclic plan, and augmenting the
plan representation to indicate whether a plan is cyclic. Show how your algorithm works on
(a) the slippery vacuum world, and (b) the slippery, erratic vacuum world. You might wish to
use a computer implementation to check your results.
4.7 In Section 4.4.1 we introduced belief states to solve sensorless search problems. A
sequence of actions solves a sensorless problem if it maps every physical state in the initial
belief state b to a goal state. Suppose the agent knows h∗(s), the true optimal cost of solving
the physical state s in the fully observable problem, for every state s in b. Find an admissible
heuristic h(b) for the sensorless problem in terms of these costs, and prove its admissibilty.
Comment on the accuracy of this heuristic on the sensorless vacuum problem of Figure 4.14.
How well does A∗ perform?
4.8 This exercise explores subset–superset relations between belief states in sensorless or
partially observable environments.
a. Prove that if an action sequence is a solution for a belief state b, it is also a solution for
any subset of b. Can anything be said about supersets of b?
Exercises 159
b. Explain in detail how to modify graph search for sensorless problems to take advantage
of your answers in (a).
c. Explain in detail how to modify AND–OR search for partially observable problems,
beyond the modifications you describe in (b).
4.9 On page 139 it was assumed that a given action would have the same cost when executed in any physical state within a given belief state. (This leads to a belief-state search
problem with well-defined step costs.) Now consider what happens when the assumption
does not hold. Does the notion of optimality still make sense in this context, or does it require
modification? Consider also various possible definitions of the “cost” of executing an action
in a belief state; for example, we could use the minimum of the physical costs; or the maximum; or a cost interval with the lower bound being the minimum cost and the upper bound
being the maximum; or just keep the set of all possible costs for that action. For each of these,
explore whether A∗ (with modifications if necessary) can return optimal solutions.
4.10 Consider the sensorless version of the erratic vacuum world. Draw the belief-state
space reachable from the initial belief state {1, 2, 3, 4, 5, 6, 7, 8}, and explain why the problem
is unsolvable.
4.11 We can turn the navigation problem in Exercise 3.7 into an environment as follows:
• The percept will be a list of the positions, relative to the agent, of the visible vertices.
The percept does not include the position of the robot! The robot must learn its own position from the map; for now, you can assume that each location has a different “view.”
• Each action will be a vector describing a straight-line path to follow. If the path is
unobstructed, the action succeeds; otherwise, the robot stops at the point where its
path first intersects an obstacle. If the agent returns a zero motion vector and is at the
goal (which is fixed and known), then the environment teleports the agent to a random
location (not inside an obstacle).
• The performance measure charges the agent 1 point for each unit of distance traversed
and awards 1000 points each time the goal is reached.
a. Implement this environment and a problem-solving agent for it. After each teleportation, the agent will need to formulate a new problem, which will involve discovering its
current location.
b. Document your agent’s performance (by having the agent generate suitable commentary
as it moves around) and report its performance over 100 episodes.
c. Modify the environment so that 30% of the time the agent ends up at an unintended
destination (chosen randomly from the other visible vertices if any; otherwise, no move
at all). This is a crude model of the motion errors of a real robot. Modify the agent
so that when such an error is detected, it finds out where it is and then constructs a
plan to get back to where it was and resume the old plan. Remember that sometimes
getting back to where it was might also fail! Show an example of the agent successfully
overcoming two successive motion errors and still reaching the goal.
160 Chapter 4. Beyond Classical Search
d. Now try two different recovery schemes after an error: (1) head for the closest vertex on
the original route; and (2) replan a route to the goal from the new location. Compare the
performance of the three recovery schemes. Would the inclusion of search costs affect
the comparison?
e. Now suppose that there are locations from which the view is identical. (For example,
suppose the world is a grid with square obstacles.) What kind of problem does the agent
now face? What do solutions look like?
4.12 Suppose that an agent is in a 3 × 3 maze environment like the one shown in Figure 4.19. The agent knows that its initial location is (1,1), that the goal is at (3,3), and that the
actions Up, Down, Left, Right have their usual effects unless blocked by a wall. The agent
does not know where the internal walls are. In any given state, the agent perceives the set of
legal actions; it can also tell whether the state is one it has visited before.
a. Explain how this online search problem can be viewed as an offline search in belief-state
space, where the initial belief state includes all possible environment configurations.
How large is the initial belief state? How large is the space of belief states?
b. How many distinct percepts are possible in the initial state?
c. Describe the first few branches of a contingency plan for this problem. How large
(roughly) is the complete plan?
Notice that this contingency plan is a solution for every possible environment fitting the given
description. Therefore, interleaving of search and execution is not strictly necessary even in
unknown environments.
4.13 In this exercise, we examine hill climbing in the context of robot navigation, using the
environment in Figure 3.31 as an example.
a. Repeat Exercise 4.11 using hill climbing. Does your agent ever get stuck in a local
minimum? Is it possible for it to get stuck with convex obstacles?
b. Construct a nonconvex polygonal environment in which the agent gets stuck.
c. Modify the hill-climbing algorithm so that, instead of doing a depth-1 search to decide
where to go next, it does a depth-k search. It should find the best k-step path and do
one step along it, and then repeat the process.
d. Is there some k for which the new algorithm is guaranteed to escape from local minima?
e. Explain how LRTA∗ enables the agent to escape from local minima in this case.
4.14 Like DFS, online DFS is incomplete for reversible state spaces with infinite paths. For
example, suppose that states are points on the infinite two-dimensional grid and actions are
unit vectors (1, 0), (0, 1), (−1, 0), (0, −1), tried in that order. Show that online DFS starting
at (0, 0) will not reach (1, −1). Suppose the agent can observe, in addition to its current
state, all successor states and the actions that would lead to them. Write an algorithm that
is complete even for bidirected state spaces with infinite paths. What states does it visit in
reaching (1, −1)?
5 ADVERSARIAL SEARCH
In which we examine the problems that arise when we try to plan ahead in a world
where other agents are planning against us.
5.1 GAMES
Chapter 2 introduced multiagent environments, in which each agent needs to consider the
actions of other agents and how they affect its own welfare. The unpredictability of these
other agents can introduce contingencies into the agent’s problem-solving process, as discussed in Chapter 4. In this chapter we cover competitive environments, in which the agents’
GAME goals are in conflict, giving rise to adversarial search problems—often known as games.
Mathematical game theory, a branch of economics, views any multiagent environment
as a game, provided that the impact of each agent on the others is “significant,” regardless
of whether the agents are cooperative or competitive.1 In AI, the most common games are
of a rather specialized kind—what game theorists call deterministic, turn-taking, two-player,
ZERO-SUM GAMES zero-sum games of perfect information (such as chess). In our terminology, this means
PERFECT
INFORMATION deterministic, fully observable environments in which two agents act alternately and in which
the utility values at the end of the game are always equal and opposite. For example, if one
player wins a game of chess, the other player necessarily loses. It is this opposition between
the agents’ utility functions that makes the situation adversarial.
Games have engaged the intellectual faculties of humans—sometimes to an alarming
degree—for as long as civilization has existed. For AI researchers, the abstract nature of
games makes them an appealing subject for study. The state of a game is easy to represent,
and agents are usually restricted to a small number of actions whose outcomes are defined by
precise rules. Physical games, such as croquet and ice hockey, have much more complicated
descriptions, a much larger range of possible actions, and rather imprecise rules defining
the legality of actions. With the exception of robot soccer, these physical games have not
attracted much interest in the AI community.
1 Environments with very many agents are often viewed as economies rather than games.
161
162 Chapter 5. Adversarial Search
Games, unlike most of the toy problems studied in Chapter 3, are interesting because
they are too hard to solve. For example, chess has an average branching factor of about 35,
and games often go to 50 moves by each player, so the search tree has about 35100 or 10154
nodes (although the search graph has “only” about 1040 distinct nodes). Games, like the real
world, therefore require the ability to make some decision even when calculating the optimal
decision is infeasible. Games also penalize inefficiency severely. Whereas an implementation
of A∗ search that is half as efficient will simply take twice as long to run to completion, a chess
program that is half as efficient in using its available time probably will be beaten into the
ground, other things being equal. Game-playing research has therefore spawned a number of
interesting ideas on how to make the best possible use of time.
We begin with a definition of the optimal move and an algorithm for finding it. We
PRUNING then look at techniques for choosing a good move when time is limited. Pruning allows us
to ignore portions of the search tree that make no difference to the final choice, and heuristic
evaluation functions allow us to approximate the true utility of a state without doing a complete search. Section 5.5 discusses games such as backgammon that include an element of
chance; we also discuss bridge, which includes elements of imperfect information because IMPERFECT
INFORMATION
not all cards are visible to each player. Finally, we look at how state-of-the-art game-playing
programs fare against human opposition and at directions for future developments.
We first consider games with two players, whom we call MAX and MIN for reasons that
will soon become obvious. MAX moves first, and then they take turns moving until the game
is over. At the end of the game, points are awarded to the winning player and penalties are
given to the loser. A game can be formally defined as a kind of search problem with the
following elements:
• S0: The initial state, which specifies how the game is set up at the start.
• PLAYER(s): Defines which player has the move in a state.
• ACTIONS(s): Returns the set of legal moves in a state.
• RESULT(s, a): The transition model, which defines the result of a move.
TERMINAL TEST • TERMINAL-TEST(s): A terminal test, which is true when the game is over and false
TERMINAL STATES otherwise. States where the game has ended are called terminal states.
• UTILITY(s, p): A utility function (also called an objective function or payoff function),
defines the final numeric value for a game that ends in terminal state s for a player p. In
chess, the outcome is a win, loss, or draw, with values +1, 0, or 1
2 . Some games have a
wider variety of possible outcomes; the payoffs in backgammon range from 0 to +192.
A zero-sum game is (confusingly) defined as one where the total payoff to all players
is the same for every instance of the game. Chess is zero-sum because every game has
payoff of either 0+1, 1+0 or 1
2 + 1
2 . “Constant-sum” would have been a better term,
but zero-sum is traditional and makes sense if you imagine each player is charged an
entry fee of 1
2 .
GAME TREE The initial state, ACTIONS function, and RESULT function define the game tree for the
game—a tree where the nodes are game states and the edges are moves. Figure 5.1 shows
part of the game tree for tic-tac-toe (noughts and crosses). From the initial state, MAX has
nine possible moves. Play alternates between MAX’s placing an X and MIN’s placing an O
Section 5.2. Optimal Decisions in Games 163
until we reach leaf nodes corresponding to terminal states such that one player has three in
a row or all the squares are filled. The number on each leaf node indicates the utility value
of the terminal state from the point of view of MAX; high values are assumed to be good for
MAX and bad for MIN (which is how the players get their names).
For tic-tac-toe the game tree is relatively small—fewer than 9! = 362, 880 terminal
nodes. But for chess there are over 1040 nodes, so the game tree is best thought of as a
theoretical construct that we cannot realize in the physical world. But regardless of the size
SEARCH TREE of the game tree, it is MAX’s job to search for a good move. We use the term search tree for a
tree that is superimposed on the full game tree, and examines enough nodes to allow a player
to determine what move to make.
X X
X X
X
X
X
X X
X X
O
X O O
O
X O X O
X
. . . . . . . . . . . .
. . .
. . .
. . .
X X
–1 0 +1
X X
X O X
X X O X X O
O
O
X
X X O
O O
OOX X
MAX (X)
MIN (O)
MAX (X)
MIN (O)
TERMINAL
Utility
Figure 5.1 A (partial) game tree for the game of tic-tac-toe. The top node is the initial
state, and MAX moves first, placing an X in an empty square. We show part of the tree, giving
alternating moves by MIN (O) and MAX (X), until we eventually reach terminal states, which
can be assigned utilities according to the rules of the game.
5.2 OPTIMAL DECISIONS IN GAMES
In a normal search problem, the optimal solution would be a sequence of actions leading to
a goal state—a terminal state that is a win. In adversarial search, MIN has something to say
STRATEGY about it. MAX therefore must find a contingent strategy, which specifies MAX’s move in
the initial state, then MAX’s moves in the states resulting from every possible response by
164 Chapter 5. Adversarial Search
MAX A
BCD
3 12 8 2 4 6 14 5 2
3 22
3
a1 a2
a3
b1
b2
b3 c1
c2
c3 d1
d2
d3
MIN
Figure 5.2 A two-ply game tree. The  nodes are “MAX nodes,” in which it is MAX’s
turn to move, and the  nodes are “MIN nodes.” The terminal nodes show the utility values
for MAX; the other nodes are labeled with their minimax values. MAX’s best move at the root
is a1, because it leads to the state with the highest minimax value, and MIN’s best reply is b1,
because it leads to the state with the lowest minimax value.
MIN, then MAX’s moves in the states resulting from every possible response by MIN to those
moves, and so on. This is exactly analogous to the AND–OR search algorithm (Figure 4.11)
with MAX playing the role of OR and MIN equivalent to AND. Roughly speaking, an optimal
strategy leads to outcomes at least as good as any other strategy when one is playing an
infallible opponent. We begin by showing how to find this optimal strategy.
Even a simple game like tic-tac-toe is too complex for us to draw the entire game tree
on one page, so we will switch to the trivial game in Figure 5.2. The possible moves for MAX
at the root node are labeled a1, a2, and a3. The possible replies to a1 for MIN are b1, b2,
b3, and so on. This particular game ends after one move each by MAX and MIN. (In game
parlance, we say that this tree is one move deep, consisting of two half-moves, each of which
PLY is called a ply.) The utilities of the terminal states in this game range from 2 to 14.
MINIMAX VALUE Given a game tree, the optimal strategy can be determined from the minimax value
of each node, which we write as MINIMAX(n). The minimax value of a node is the utility
(for MAX) of being in the corresponding state, assuming that both players play optimally
from there to the end of the game. Obviously, the minimax value of a terminal state is just
its utility. Furthermore, given a choice, MAX prefers to move to a state of maximum value,
whereas MIN prefers a state of minimum value. So we have the following:
MINIMAX(s) =
⎧
⎨
⎩
UTILITY(s) if TERMINAL-TEST(s)
maxa∈Actions(s) MINIMAX(RESULT(s, a)) if PLAYER(s) = MAX
mina∈Actions(s) MINIMAX(RESULT(s, a)) if PLAYER(s) = MIN
Let us apply these definitions to the game tree in Figure 5.2. The terminal nodes on the bottom
level get their utility values from the game’s UTILITY function. The first MIN node, labeled
B, has three successor states with values 3, 12, and 8, so its minimax value is 3. Similarly,
the other two MIN nodes have minimax value 2. The root node is a MAX node; its successor
states have minimax values 3, 2, and 2; so it has a minimax value of 3. We can also identify
Section 5.2. Optimal Decisions in Games 165
MINIMAX DECISION the minimax decision at the root: action a1 is the optimal choice for MAX because it leads to
the state with the highest minimax value.
This definition of optimal play for MAX assumes that MIN also plays optimally—it
maximizes the worst-case outcome for MAX. What if MIN does not play optimally? Then it is
easy to show (Exercise 5.7) that MAX will do even better. Other strategies against suboptimal
opponents may do better than the minimax strategy, but these strategies necessarily do worse
against optimal opponents.
5.2.1 The minimax algorithm
MINIMAX ALGORITHM The minimax algorithm (Figure 5.3) computes the minimax decision from the current state.
It uses a simple recursive computation of the minimax values of each successor state, directly
implementing the defining equations. The recursion proceeds all the way down to the leaves
of the tree, and then the minimax values are backed up through the tree as the recursion
unwinds. For example, in Figure 5.2, the algorithm first recurses down to the three bottomleft nodes and uses the UTILITY function on them to discover that their values are 3, 12, and
8, respectively. Then it takes the minimum of these values, 3, and returns it as the backedup value of node B. A similar process gives the backed-up values of 2 for C and 2 for D.
Finally, we take the maximum of 3, 2, and 2 to get the backed-up value of 3 for the root node.
The minimax algorithm performs a complete depth-first exploration of the game tree.
If the maximum depth of the tree is m and there are b legal moves at each point, then the
time complexity of the minimax algorithm is O(b m). The space complexity is O(bm) for an
algorithm that generates all actions at once, or O(m) for an algorithm that generates actions
one at a time (see page 87). For real games, of course, the time cost is totally impractical,
but this algorithm serves as the basis for the mathematical analysis of games and for more
practical algorithms.
5.2.2 Optimal decisions in multiplayer games
Many popular games allow more than two players. Let us examine how to extend the minimax
idea to multiplayer games. This is straightforward from the technical viewpoint, but raises
some interesting new conceptual issues.
First, we need to replace the single value for each node with a vector of values. For
example, in a three-player game with players A, B, and C, a vector vA, vB, vC is associated
with each node. For terminal states, this vector gives the utility of the state from each player’s
viewpoint. (In two-player, zero-sum games, the two-element vector can be reduced to a single
value because the values are always opposite.) The simplest way to implement this is to have
the UTILITY function return a vector of utilities.
Now we have to consider nonterminal states. Consider the node marked X in the game
tree shown in Figure 5.4. In that state, player C chooses what to do. The two choices lead
to terminal states with utility vectors vA = 1, vB = 2, vC = 6 and vA = 4, vB = 2, vC = 3.
Since 6 is bigger than 3, C should choose the first move. This means that if state X is reached,
subsequent play will lead to a terminal state with utilities vA = 1, vB = 2, vC = 6. Hence,
the backed-up value of X is this vector. The backed-up value of a node n is always the utility
166 Chapter 5. Adversarial Search
function MINIMAX-DECISION(state) returns an action
return arg maxa ∈ ACTIONS(s) MIN-VALUE(RESULT(state, a))
function MAX-VALUE(state) returns a utility value
if TERMINAL-TEST(state) then return UTILITY(state)
v ← −∞
for each a in ACTIONS(state) do
v ← MAX(v, MIN-VALUE(RESULT(s, a)))
return v
function MIN-VALUE(state) returns a utility value
if TERMINAL-TEST(state) then return UTILITY(state)
v ← ∞
for each a in ACTIONS(state) do
v ← MIN(v, MAX-VALUE(RESULT(s, a)))
return v
Figure 5.3 An algorithm for calculating minimax decisions. It returns the action corresponding to the best possible move, that is, the move that leads to the outcome with the
best utility, under the assumption that the opponent plays to minimize utility. The functions
MAX-VALUE and MIN-VALUE go through the whole game tree, all the way to the leaves,
to determine the backed-up value of a state. The notation argmaxa ∈ S f(a) computes the
element a of set S that has the maximum value of f(a).
to move
A
B
C
A
(1, 2, 6) (4, 2, 3) (6, 1, 2) (7, 4,1) (5,1,1) (1, 5, 2) (7, 7,1) (5, 4, 5)
(1, 2, 6) (6, 1, 2) (1, 5, 2) (5, 4, 5)
(1, 2, 6) (1, 5, 2)
(1, 2, 6)
X
Figure 5.4 The first three plies of a game tree with three players (A, B, C). Each node is
labeled with values from the viewpoint of each player. The best move is marked at the root.
vector of the successor state with the highest value for the player choosing at n. Anyone
who plays multiplayer games, such as Diplomacy, quickly becomes aware that much more
ALLIANCE is going on than in two-player games. Multiplayer games usually involve alliances, whether
formal or informal, among the players. Alliances are made and broken as the game proceeds.
How are we to understand such behavior? Are alliances a natural consequence of optimal
strategies for each player in a multiplayer game? It turns out that they can be. For example,
Section 5.3. Alpha–Beta Pruning 167
suppose A and B are in weak positions and C is in a stronger position. Then it is often
optimal for both A and B to attack C rather than each other, lest C destroy each of them
individually. In this way, collaboration emerges from purely selfish behavior. Of course,
as soon as C weakens under the joint onslaught, the alliance loses its value, and either A
or B could violate the agreement. In some cases, explicit alliances merely make concrete
what would have happened anyway. In other cases, a social stigma attaches to breaking an
alliance, so players must balance the immediate advantage of breaking an alliance against the
long-term disadvantage of being perceived as untrustworthy. See Section 17.5 for more on
these complications.
If the game is not zero-sum, then collaboration can also occur with just two players.
Suppose, for example, that there is a terminal state with utilities vA = 1000, vB = 1000 and
that 1000 is the highest possible utility for each player. Then the optimal strategy is for both
players to do everything possible to reach this state—that is, the players will automatically
cooperate to achieve a mutually desirable goal.
5.3 ALPHA–BETA PRUNING
The problem with minimax search is that the number of game states it has to examine is
exponential in the depth of the tree. Unfortunately, we can’t eliminate the exponent, but it
turns out we can effectively cut it in half. The trick is that it is possible to compute the correct
minimax decision without looking at every node in the game tree. That is, we can borrow the
idea of pruning from Chapter 3 to eliminate large parts of the tree from consideration. The
particular technique we examine is called alpha–beta pruning. When applied to a standard ALPHA–BETA
PRUNING
minimax tree, it returns the same move as minimax would, but prunes away branches that
cannot possibly influence the final decision.
Consider again the two-ply game tree from Figure 5.2. Let’s go through the calculation
of the optimal decision once more, this time paying careful attention to what we know at
each point in the process. The steps are explained in Figure 5.5. The outcome is that we can
identify the minimax decision without ever evaluating two of the leaf nodes.
Another way to look at this is as a simplification of the formula for MINIMAX. Let the
two unevaluated successors of node C in Figure 5.5 have values x and y. Then the value of
the root node is given by
MINIMAX(root) = max(min(3, 12, 8), min(2, x, y), min(14, 5, 2))
= max(3, min(2, x, y), 2)
= max(3, z, 2) where z = min(2, x, y) ≤ 2
= 3.
In other words, the value of the root and hence the minimax decision are independent of the
values of the pruned leaves x and y.
Alpha–beta pruning can be applied to trees of any depth, and it is often possible to
prune entire subtrees rather than just leaves. The general principle is this: consider a node n
168 Chapter 5. Adversarial Search
(a) (b)
(c) (d)
(e) (f)
3 3 12
3 12 8 3 12 8 2
3 12 8 2 14 3 12 8 2 14 5 2
A
B
A
B
A
BCD
A
BCD
A
B
A
B C
[−∞, +∞] [−∞, +∞]
[3, +∞] [3, +∞]
[3, 14] [3, 3]
[−∞, 2]
[−∞, 2] [2, 2]
[3, 3]
[3, 3] [3, 3]
[3, 3]
[−∞, 3] [−∞, 3]
[−∞, 2] [−∞, 14]
Figure 5.5 Stages in the calculation of the optimal decision for the game tree in Figure 5.2.
At each point, we show the range of possible values for each node. (a) The first leaf below B
has the value 3. Hence, B, which is a MIN node, has a value of at most 3. (b) The second leaf
below B has a value of 12; MIN would avoid this move, so the value of B is still at most 3.
(c) The third leaf below B has a value of 8; we have seen all B’s successor states, so the
value of B is exactly 3. Now, we can infer that the value of the root is at least 3, because
MAX has a choice worth 3 at the root. (d) The first leaf below C has the value 2. Hence,
C, which is a MIN node, has a value of at most 2. But we know that B is worth 3, so MAX
would never choose C. Therefore, there is no point in looking at the other successor states
of C. This is an example of alpha–beta pruning. (e) The first leaf below D has the value 14,
so D is worth at most 14. This is still higher than MAX’s best alternative (i.e., 3), so we need
to keep exploring D’s successor states. Notice also that we now have bounds on all of the
successors of the root, so the root’s value is also at most 14. (f) The second successor of D
is worth 5, so again we need to keep exploring. The third successor is worth 2, so now D is
worth exactly 2. MAX’s decision at the root is to move to B, giving a value of 3.
somewhere in the tree (see Figure 5.6), such that Player has a choice of moving to that node.
If Player has a better choice m either at the parent node of n or at any choice point further up,
then n will never be reached in actual play. So once we have found out enough about n (by
examining some of its descendants) to reach this conclusion, we can prune it.
Remember that minimax search is depth-first, so at any one time we just have to consider the nodes along a single path in the tree. Alpha–beta pruning gets its name from the
following two parameters that describe bounds on the backed-up values that appear anywhere
along the path:
Section 5.3. Alpha–Beta Pruning 169
Player
Opponent
Player
Opponent
m
n
•
•
•
Figure 5.6 The general case for alpha–beta pruning. If m is better than n for Player, we
will never get to n in play.
α = the value of the best (i.e., highest-value) choice we have found so far at any choice point
along the path for MAX.
β = the value of the best (i.e., lowest-value) choice we have found so far at any choice point
along the path for MIN.
Alpha–beta search updates the values of α and β as it goes along and prunes the remaining
branches at a node (i.e., terminates the recursive call) as soon as the value of the current
node is known to be worse than the current α or β value for MAX or MIN, respectively. The
complete algorithm is given in Figure 5.7. We encourage you to trace its behavior when
applied to the tree in Figure 5.5.
5.3.1 Move ordering
The effectiveness of alpha–beta pruning is highly dependent on the order in which the states
are examined. For example, in Figure 5.5(e) and (f), we could not prune any successors of D
at all because the worst successors (from the point of view of MIN) were generated first. If
the third successor of D had been generated first, we would have been able to prune the other
two. This suggests that it might be worthwhile to try to examine first the successors that are
likely to be best.
If this can be done,2 then it turns out that alpha–beta needs to examine only O(bm/2)
nodes to pick the best move, instead of O(bm) for minimax. This means that the effective
branching factor becomes √
b instead of b—for chess, about 6 instead of 35. Put another
way, alpha–beta can solve a tree roughly twice as deep as minimax in the same amount of
time. If successors are examined in random order rather than best-first, the total number of
nodes examined will be roughly O(b3m/4) for moderate b. For chess, a fairly simple ordering
function (such as trying captures first, then threats, then forward moves, and then backward
moves) gets you to within about a factor of 2 of the best-case O(bm/2) result.
2 Obviously, it cannot be done perfectly; otherwise, the ordering function could be used to play a perfect game!
170 Chapter 5. Adversarial Search
function ALPHA-BETA-SEARCH(state) returns an action
v ← MAX-VALUE(state,−∞,+∞)
return the action in ACTIONS(state) with value v
function MAX-VALUE(state,α, β) returns a utility value
if TERMINAL-TEST(state) then return UTILITY(state)
v ← −∞
for each a in ACTIONS(state) do
v ← MAX(v, MIN-VALUE(RESULT(s,a),α, β))
if v ≥ β then return v
α ← MAX(α, v)
return v
function MIN-VALUE(state,α, β) returns a utility value
if TERMINAL-TEST(state) then return UTILITY(state)
v ← +∞
for each a in ACTIONS(state) do
v ← MIN(v, MAX-VALUE(RESULT(s,a) ,α, β))
if v ≤ α then return v
β ← MIN(β, v)
return v
Figure 5.7 The alpha–beta search algorithm. Notice that these routines are the same as
the MINIMAX functions in Figure 5.3, except for the two lines in each of MIN-VALUE and
MAX-VALUE that maintain α and β (and the bookkeeping to pass these parameters along).
Adding dynamic move-ordering schemes, such as trying first the moves that were found
to be best in the past, brings us quite close to the theoretical limit. The past could be the
previous move—often the same threats remain—or it could come from previous exploration
of the current move. One way to gain information from the current move is with iterative
deepening search. First, search 1 ply deep and record the best path of moves. Then search
1 ply deeper, but use the recorded path to inform move ordering. As we saw in Chapter 3,
iterative deepening on an exponential game tree adds only a constant fraction to the total
search time, which can be more than made up from better move ordering. The best moves are
KILLER MOVES often called killer moves and to try them first is called the killer move heuristic.
In Chapter 3, we noted that repeated states in the search tree can cause an exponential
increase in search cost. In many games, repeated states occur frequently because of transpoTRANSPOSITION sitions—different permutations of the move sequence that end up in the same position. For
example, if White has one move, a1, that can be answered by Black with b1 and an unrelated move a2 on the other side of the board that can be answered by b2, then the sequences
[a1, b1, a2, b2] and [a2, b2, a1, b1] both end up in the same position. It is worthwhile to store
the evaluation of the resulting position in a hash table the first time it is encountered so that
we don’t have to recompute it on subsequent occurrences. The hash table of previously seen
positions is traditionally called a transposition table; it is essentially identical to the explored TRANSPOSITION
TABLE
Section 5.4. Imperfect Real-Time Decisions 171
list in GRAPH-SEARCH (Section 3.3). Using a transposition table can have a dramatic effect,
sometimes as much as doubling the reachable search depth in chess. On the other hand, if we
are evaluating a million nodes per second, at some point it is not practical to keep all of them
in the transposition table. Various strategies have been used to choose which nodes to keep
and which to discard.
5.4 IMPERFECT REAL-TIME DECISIONS
The minimax algorithm generates the entire game search space, whereas the alpha–beta algorithm allows us to prune large parts of it. However, alpha–beta still has to search all the way
to terminal states for at least a portion of the search space. This depth is usually not practical,
because moves must be made in a reasonable amount of time—typically a few minutes at
most. Claude Shannon’s paper Programming a Computer for Playing Chess (1950) proposed
instead that programs should cut off the search earlier and apply a heuristic evaluation function to states in the search, effectively turning nonterminal nodes into terminal leaves. In EVALUATION
FUNCTION
other words, the suggestion is to alter minimax or alpha–beta in two ways: replace the utility
function by a heuristic evaluation function EVAL, which estimates the position’s utility, and
CUTOFF TEST replace the terminal test by a cutoff test that decides when to apply EVAL. That gives us the
following for heuristic minimax for state s and maximum depth d:
H-MINIMAX(s, d) =
⎧
⎨
⎩
EVAL(s) if CUTOFF-TEST(s, d)
maxa∈Actions(s) H-MINIMAX(RESULT(s, a), d + 1) if PLAYER(s) = MAX
mina∈Actions(s) H-MINIMAX(RESULT(s, a), d + 1) if PLAYER(s) = MIN.
5.4.1 Evaluation functions
An evaluation function returns an estimate of the expected utility of the game from a given
position, just as the heuristic functions of Chapter 3 return an estimate of the distance to
the goal. The idea of an estimator was not new when Shannon proposed it. For centuries,
chess players (and aficionados of other games) have developed ways of judging the value of
a position because humans are even more limited in the amount of search they can do than
are computer programs. It should be clear that the performance of a game-playing program
depends strongly on the quality of its evaluation function. An inaccurate evaluation function
will guide an agent toward positions that turn out to be lost. How exactly do we design good
evaluation functions?
First, the evaluation function should order the terminal states in the same way as the
true utility function: states that are wins must evaluate better than draws, which in turn must
be better than losses. Otherwise, an agent using the evaluation function might err even if it
can see ahead all the way to the end of the game. Second, the computation must not take
too long! (The whole point is to search faster.) Third, for nonterminal states, the evaluation
function should be strongly correlated with the actual chances of winning.
172 Chapter 5. Adversarial Search
One might well wonder about the phrase “chances of winning.” After all, chess is not a
game of chance: we know the current state with certainty, and no dice are involved. But if the
search must be cut off at nonterminal states, then the algorithm will necessarily be uncertain
about the final outcomes of those states. This type of uncertainty is induced by computational,
rather than informational, limitations. Given the limited amount of computation that the
evaluation function is allowed to do for a given state, the best it can do is make a guess about
the final outcome.
Let us make this idea more concrete. Most evaluation functions work by calculating
various features of the state—for example, in chess, we would have features for the number
of white pawns, black pawns, white queens, black queens, and so on. The features, taken
together, define various categories or equivalence classes of states: the states in each category
have the same values for all the features. For example, one category contains all two-pawn
vs. one-pawn endgames. Any given category, generally speaking, will contain some states
that lead to wins, some that lead to draws, and some that lead to losses. The evaluation
function cannot know which states are which, but it can return a single value that reflects the
proportion of states with each outcome. For example, suppose our experience suggests that
72% of the states encountered in the two-pawns vs. one-pawn category lead to a win (utility
+1); 20% to a loss (0), and 8% to a draw (1/2). Then a reasonable evaluation for states in
EXPECTED VALUE the category is the expected value: (0.72 × +1) + (0.20 × 0) + (0.08 × 1/2) = 0.76. In
principle, the expected value can be determined for each category, resulting in an evaluation
function that works for any state. As with terminal states, the evaluation function need not
return actual expected values as long as the ordering of the states is the same.
In practice, this kind of analysis requires too many categories and hence too much
experience to estimate all the probabilities of winning. Instead, most evaluation functions
compute separate numerical contributions from each feature and then combine them to find
MATERIAL VALUE the total value. For example, introductory chess books give an approximate material value
for each piece: each pawn is worth 1, a knight or bishop is worth 3, a rook 5, and the queen 9.
Other features such as “good pawn structure” and “king safety” might be worth half a pawn,
say. These feature values are then simply added up to obtain the evaluation of the position.
A secure advantage equivalent to a pawn gives a substantial likelihood of winning, and
a secure advantage equivalent to three pawns should give almost certain victory, as illustrated
in Figure 5.8(a). Mathematically, this kind of evaluation function is called a weighted linear
function because it can be expressed as WEIGHTED LINEAR
FUNCTION
EVAL(s) = w1f1(s) + w2f2(s) + ··· + wnfn(s) = n
i=1
wifi(s) ,
where each wi is a weight and each fi is a feature of the position. For chess, the fi could be
the numbers of each kind of piece on the board, and the wi could be the values of the pieces
(1 for pawn, 3 for bishop, etc.).
Adding up the values of features seems like a reasonable thing to do, but in fact it
involves a strong assumption: that the contribution of each feature is independent of the
values of the other features. For example, assigning the value 3 to a bishop ignores the fact
that bishops are more powerful in the endgame, when they have a lot of space to maneuver.
Section 5.4. Imperfect Real-Time Decisions 173
(a) White to move (b) White to move
Figure 5.8 Two chess positions that differ only in the position of the rook at lower right.
In (a), Black has an advantage of a knight and two pawns, which should be enough to win
the game. In (b), White will capture the queen, giving it an advantage that should be strong
enough to win.
For this reason, current programs for chess and other games also use nonlinear combinations
of features. For example, a pair of bishops might be worth slightly more than twice the value
of a single bishop, and a bishop is worth more in the endgame (that is, when the move number
feature is high or the number of remaining pieces feature is low).
The astute reader will have noticed that the features and weights are not part of the rules
of chess! They come from centuries of human chess-playing experience. In games where this
kind of experience is not available, the weights of the evaluation function can be estimated
by the machine learning techniques of Chapter 18. Reassuringly, applying these techniques
to chess has confirmed that a bishop is indeed worth about three pawns.
5.4.2 Cutting off search
The next step is to modify ALPHA-BETA-SEARCH so that it will call the heuristic EVAL
function when it is appropriate to cut off the search. We replace the two lines in Figure 5.7
that mention TERMINAL-TEST with the following line:
if CUTOFF-TEST(state, depth) then return EVAL(state)
We also must arrange for some bookkeeping so that the current depth is incremented on each
recursive call. The most straightforward approach to controlling the amount of search is to set
a fixed depth limit so that CUTOFF-TEST(state, depth) returns true for all depth greater than
some fixed depth d. (It must also return true for all terminal states, just as TERMINAL-TEST
did.) The depth d is chosen so that a move is selected within the allocated time. A more
robust approach is to apply iterative deepening. (See Chapter 3.) When time runs out, the
program returns the move selected by the deepest completed search. As a bonus, iterative
deepening also helps with move ordering.
174 Chapter 5. Adversarial Search
These simple approaches can lead to errors due to the approximate nature of the evaluation function. Consider again the simple evaluation function for chess based on material
advantage. Suppose the program searches to the depth limit, reaching the position in Figure 5.8(b), where Black is ahead by a knight and two pawns. It would report this as the
heuristic value of the state, thereby declaring that the state is a probable win by Black. But
White’s next move captures Black’s queen with no compensation. Hence, the position is
really won for White, but this can be seen only by looking ahead one more ply.
Obviously, a more sophisticated cutoff test is needed. The evaluation function should be
QUIESCENCE applied only to positions that are quiescent—that is, unlikely to exhibit wild swings in value
in the near future. In chess, for example, positions in which favorable captures can be made
are not quiescent for an evaluation function that just counts material. Nonquiescent positions
can be expanded further until quiescent positions are reached. This extra search is called a
quiescence search; sometimes it is restricted to consider only certain types of moves, such QUIESCENCE
SEARCH
as capture moves, that will quickly resolve the uncertainties in the position.
HORIZON EFFECT The horizon effect is more difficult to eliminate. It arises when the program is facing
an opponent’s move that causes serious damage and is ultimately unavoidable, but can be
temporarily avoided by delaying tactics. Consider the chess game in Figure 5.9. It is clear
that there is no way for the black bishop to escape. For example, the white rook can capture
it by moving to h1, then a1, then a2; a capture at depth 6 ply. But Black does have a sequence
of moves that pushes the capture of the bishop “over the horizon.” Suppose Black searches
to depth 8 ply. Most moves by Black will lead to the eventual capture of the bishop, and thus
will be marked as “bad” moves. But Black will consider checking the white king with the
pawn at e4. This will lead to the king capturing the pawn. Now Black will consider checking
again, with the pawn at f5, leading to another pawn capture. That takes up 4 ply, and from
there the remaining 4 ply is not enough to capture the bishop. Black thinks that the line of
play has saved the bishop at the price of two pawns, when actually all it has done is push the
inevitable capture of the bishop beyond the horizon that Black can see.
One strategy to mitigate the horizon effect is the singular extension, a move that is SINGULAR
EXTENSION
“clearly better” than all other moves in a given position. Once discovered anywhere in the
tree in the course of a search, this singular move is remembered. When the search reaches the
normal depth limit, the algorithm checks to see if the singular extension is a legal move; if it
is, the algorithm allows the move to be considered. This makes the tree deeper, but because
there will be few singular extensions, it does not add many total nodes to the tree.
5.4.3 Forward pruning
So far, we have talked about cutting off search at a certain level and about doing alpha–
beta pruning that provably has no effect on the result (at least with respect to the heuristic
FORWARD PRUNING evaluation values). It is also possible to do forward pruning, meaning that some moves at
a given node are pruned immediately without further consideration. Clearly, most humans
playing chess consider only a few moves from each position (at least consciously). One
BEAM SEARCH approach to forward pruning is beam search: on each ply, consider only a “beam” of the n
best moves (according to the evaluation function) rather than considering all possible moves.
Section 5.4. Imperfect Real-Time Decisions 175
a b c d e f g h
1
2
3
4
5
6
7
8
Figure 5.9 The horizon effect. With Black to move, the black bishop is surely doomed.
But Black can forestall that event by checking the white king with its pawns, forcing the king
to capture the pawns. This pushes the inevitable loss of the bishop over the horizon, and thus
the pawn sacrifices are seen by the search algorithm as good moves rather than bad ones.
Unfortunately, this approach is rather dangerous because there is no guarantee that the best
move will not be pruned away.
The PROBCUT, or probabilistic cut, algorithm (Buro, 1995) is a forward-pruning version of alpha–beta search that uses statistics gained from prior experience to lessen the chance
that the best move will be pruned. Alpha–beta search prunes any node that is provably outside the current (α, β) window. PROBCUT also prunes nodes that are probably outside the
window. It computes this probability by doing a shallow search to compute the backed-up
value v of a node and then using past experience to estimate how likely it is that a score of v
at depth d in the tree would be outside (α, β). Buro applied this technique to his Othello program, LOGISTELLO, and found that a version of his program with PROBCUT beat the regular
version 64% of the time, even when the regular version was given twice as much time.
Combining all the techniques described here results in a program that can play creditable chess (or other games). Let us assume we have implemented an evaluation function for
chess, a reasonable cutoff test with a quiescence search, and a large transposition table. Let
us also assume that, after months of tedious bit-bashing, we can generate and evaluate around
a million nodes per second on the latest PC, allowing us to search roughly 200 million nodes
per move under standard time controls (three minutes per move). The branching factor for
chess is about 35, on average, and 355 is about 50 million, so if we used minimax search,
we could look ahead only about five plies. Though not incompetent, such a program can be
fooled easily by an average human chess player, who can occasionally plan six or eight plies
ahead. With alpha–beta search we get to about 10 plies, which results in an expert level of
play. Section 5.8 describes additional pruning techniques that can extend the effective search
depth to roughly 14 plies. To reach grandmaster status we would need an extensively tuned
evaluation function and a large database of optimal opening and endgame moves.
176 Chapter 5. Adversarial Search
5.4.4 Search versus lookup
Somehow it seems like overkill for a chess program to start a game by considering a tree of a
billion game states, only to conclude that it will move its pawn to e4. Books describing good
play in the opening and endgame in chess have been available for about a century (Tattersall,
1911). It is not surprising, therefore, that many game-playing programs use table lookup
rather than search for the opening and ending of games.
For the openings, the computer is mostly relying on the expertise of humans. The best
advice of human experts on how to play each opening is copied from books and entered into
tables for the computer’s use. However, computers can also gather statistics from a database
of previously played games to see which opening sequences most often lead to a win. In
the early moves there are few choices, and thus much expert commentary and past games on
which to draw. Usually after ten moves we end up in a rarely seen position, and the program
must switch from table lookup to search.
Near the end of the game there are again fewer possible positions, and thus more chance
to do lookup. But here it is the computer that has the expertise: computer analysis of
endgames goes far beyond anything achieved by humans. A human can tell you the general strategy for playing a king-and-rook-versus-king (KRK) endgame: reduce the opposing
king’s mobility by squeezing it toward one edge of the board, using your king to prevent the
opponent from escaping the squeeze. Other endings, such as king, bishop, and knight versus
king (KBNK), are difficult to master and have no succinct strategy description. A computer,
POLICY on the other hand, can completely solve the endgame by producing a policy, which is a mapping from every possible state to the best move in that state. Then we can just look up the best
move rather than recompute it anew. How big will the KBNK lookup table be? It turns out
there are 462 ways that two kings can be placed on the board without being adjacent. After
the kings are placed, there are 62 empty squares for the bishop, 61 for the knight, and two
possible players to move next, so there are just 462 × 62 × 61 × 2=3, 494, 568 possible
RETROGRADE positions. Some of these are checkmates; mark them as such in a table. Then do a retrograde
minimax search: reverse the rules of chess to do unmoves rather than moves. Any move by
White that, no matter what move Black responds with, ends up in a position marked as a win,
must also be a win. Continue this search until all 3,494,568 positions are resolved as win,
loss, or draw, and you have an infallible lookup table for all KBNK endgames.
Using this technique and a tour de force of optimization tricks, Ken Thompson (1986,
1996) and Lewis Stiller (1992, 1996) solved all chess endgames with up to five pieces and
some with six pieces, making them available on the Internet. Stiller discovered one case
where a forced mate existed but required 262 moves; this caused some consternation because
the rules of chess require a capture or pawn move to occur within 50 moves. Later work by
Marc Bourzutschky and Yakov Konoval (Bourzutschky, 2006) solved all pawnless six-piece
and some seven-piece endgames; there is a KQNKRBN endgame that with best play requires
517 moves until a capture, which then leads to a mate.
If we could extend the chess endgame tables from 6 pieces to 32, then White would
know on the opening move whether it would be a win, loss, or draw. This has not happened
so far for chess, but it has happened for checkers, as explained in the historical notes section.
Section 5.5. Stochastic Games 177
5.5 STOCHASTIC GAMES
In real life, many unpredictable external events can put us into unforeseen situations. Many
games mirror this unpredictability by including a random element, such as the throwing of
STOCHASTIC GAMES dice. We call these stochastic games. Backgammon is a typical game that combines luck
and skill. Dice are rolled at the beginning of a player’s turn to determine the legal moves. In
the backgammon position of Figure 5.10, for example, White has rolled a 6–5 and has four
possible moves.
1234 5 6 7 8 9 10 11 12
24 23 22 21 20 19 18 17 16 15 14 13
0
25
Figure 5.10 A typical backgammon position. The goal of the game is to move all one’s
pieces off the board. White moves clockwise toward 25, and Black moves counterclockwise
toward 0. A piece can move to any position unless multiple opponent pieces are there; if there
is one opponent, it is captured and must start over. In the position shown, White has rolled
6–5 and must choose among four legal moves: (5–10,5–11), (5–11,19–24), (5–10,10–16),
and (5–11,11–16), where the notation (5–11,11–16) means move one piece from position 5
to 11, and then move a piece from 11 to 16.
Although White knows what his or her own legal moves are, White does not know what
Black is going to roll and thus does not know what Black’s legal moves will be. That means
White cannot construct a standard game tree of the sort we saw in chess and tic-tac-toe. A
CHANCE NODES game tree in backgammon must include chance nodes in addition to MAX and MIN nodes.
Chance nodes are shown as circles in Figure 5.11. The branches leading from each chance
node denote the possible dice rolls; each branch is labeled with the roll and its probability.
There are 36 ways to roll two dice, each equally likely; but because a 6–5 is the same as a 5–6,
there are only 21 distinct rolls. The six doubles (1–1 through 6–6) each have a probability of
1/36, so we say P(1–1)=1/36. The other 15 distinct rolls each have a 1/18 probability.
178 Chapter 5. Adversarial Search
CHANCE
MIN
MAX
CHANCE
MAX
. . .
. . .
B
1
. . .
1,1
1/36
1,2
1/18
TERMINAL
1,2
1/18
... ...
... ... ...
... ...
1,1
1/36
...
... ... ... ...
...
C
. . .
1/18
6,5 6,6
1/36
1/18
6,5 6,6
1/36
2 –1 –1 1
Figure 5.11 Schematic game tree for a backgammon position.
The next step is to understand how to make correct decisions. Obviously, we still want
to pick the move that leads to the best position. However, positions do not have definite
EXPECTED VALUE minimax values. Instead, we can only calculate the expected value of a position: the average
over all possible outcomes of the chance nodes.
This leads us to generalize the minimax value for deterministic games to an expectiminimax value for games with chance nodes. Terminal nodes and MAX and MIN nodes (for EXPECTIMINIMAX
VALUE
which the dice roll is known) work exactly the same way as before. For chance nodes we
compute the expected value, which is the sum of the value over all outcomes, weighted by
the probability of each chance action:
EXPECTIMINIMAX(s) =
⎧
⎪⎪⎨
⎪⎪⎩
UTILITY(s) if TERMINAL-TEST(s)
maxa EXPECTIMINIMAX(RESULT(s, a)) if PLAYER(s) = MAX
min
 a EXPECTIMINIMAX(RESULT(s, a)) if PLAYER(s) = MIN
r P(r)EXPECTIMINIMAX(RESULT(s, r)) if PLAYER(s) = CHANCE
where r represents a possible dice roll (or other chance event) and RESULT(s, r) is the same
state as s, with the additional fact that the result of the dice roll is r.
5.5.1 Evaluation functions for games of chance
As with minimax, the obvious approximation to make with expectiminimax is to cut the
search off at some point and apply an evaluation function to each leaf. One might think that
evaluation functions for games such as backgammon should be just like evaluation functions
Section 5.5. Stochastic Games 179
for chess—they just need to give higher scores to better positions. But in fact, the presence of
chance nodes means that one has to be more careful about what the evaluation values mean.
Figure 5.12 shows what happens: with an evaluation function that assigns the values [1, 2,
3, 4] to the leaves, move a1 is best; with values [1, 20, 30, 400], move a2 is best. Hence,
the program behaves totally differently if we make a change in the scale of some evaluation
values! It turns out that to avoid this sensitivity, the evaluation function must be a positive
linear transformation of the probability of winning from a position (or, more generally, of the
expected utility of the position). This is an important and general property of situations in
which uncertainty is involved, and we discuss it further in Chapter 16.
CHANCE
MIN
MAX
2 23 3 1 14 4
2 3 14
.9 .1 .9 .1
2.1 1.3
20 20 30 30 1 1 400 400
20 30 1 400
.9 .1 .9 .1
21 40.9
a1 a2 a1 a2
Figure 5.12 An order-preserving transformation on leaf values changes the best move.
If the program knew in advance all the dice rolls that would occur for the rest of the
game, solving a game with dice would be just like solving a game without dice, which minimax does in O(bm) time, where b is the branching factor and m is the maximum depth of the
game tree. Because expectiminimax is also considering all the possible dice-roll sequences,
it will take O(bmnm), where n is the number of distinct rolls.
Even if the search depth is limited to some small depth d, the extra cost compared with
that of minimax makes it unrealistic to consider looking ahead very far in most games of
chance. In backgammon n is 21 and b is usually around 20, but in some situations can be as
high as 4000 for dice rolls that are doubles. Three plies is probably all we could manage.
Another way to think about the problem is this: the advantage of alpha–beta is that
it ignores future developments that just are not going to happen, given best play. Thus, it
concentrates on likely occurrences. In games with dice, there are no likely sequences of
moves, because for those moves to take place, the dice would first have to come out the right
way to make them legal. This is a general problem whenever uncertainty enters the picture:
the possibilities are multiplied enormously, and forming detailed plans of action becomes
pointless because the world probably will not play along.
It may have occurred to you that something like alpha–beta pruning could be applied
180 Chapter 5. Adversarial Search
to game trees with chance nodes. It turns out that it can. The analysis for MIN and MAX
nodes is unchanged, but we can also prune chance nodes, using a bit of ingenuity. Consider
the chance node C in Figure 5.11 and what happens to its value as we examine and evaluate
its children. Is it possible to find an upper bound on the value of C before we have looked
at all its children? (Recall that this is what alpha–beta needs in order to prune a node and its
subtree.) At first sight, it might seem impossible because the value of C is the average of its
children’s values, and in order to compute the average of a set of numbers, we must look at
all the numbers. But if we put bounds on the possible values of the utility function, then we
can arrive at bounds for the average without looking at every number. For example, say that
all utility values are between −2 and +2; then the value of leaf nodes is bounded, and in turn
we can place an upper bound on the value of a chance node without looking at all its children.
An alternative is to do Monte Carlo simulation to evaluate a position. Start with MONTE CARLO
SIMULATION
an alpha–beta (or other) search algorithm. From a start position, have the algorithm play
thousands of games against itself, using random dice rolls. In the case of backgammon, the
resulting win percentage has been shown to be a good approximation of the value of the
position, even if the algorithm has an imperfect heuristic and is searching only a few plies
ROLLOUT (Tesauro, 1995). For games with dice, this type of simulation is called a rollout.
5.6 PARTIALLY OBSERVABLE GAMES
Chess has often been described as war in miniature, but it lacks at least one major characteristic of real wars, namely, partial observability. In the “fog of war,” the existence and
disposition of enemy units is often unknown until revealed by direct contact. As a result,
warfare includes the use of scouts and spies to gather information and the use of concealment
and bluff to confuse the enemy. Partially observable games share these characteristics and
are thus qualitatively different from the games described in the preceding sections.
5.6.1 Kriegspiel: Partially observable chess
In deterministic partially observable games, uncertainty about the state of the board arises entirely from lack of access to the choices made by the opponent. This class includes children’s
games such as Battleships (where each player’s ships are placed in locations hidden from the
opponent but do not move) and Stratego (where piece locations are known but piece types are
KRIEGSPIEL hidden). We will examine the game of Kriegspiel, a partially observable variant of chess in
which pieces can move but are completely invisible to the opponent.
The rules of Kriegspiel are as follows: White and Black each see a board containing
only their own pieces. A referee, who can see all the pieces, adjudicates the game and periodically makes announcements that are heard by both players. On his turn, White proposes to
the referee any move that would be legal if there were no black pieces. If the move is in fact
not legal (because of the black pieces), the referee announces “illegal.” In this case, White
may keep proposing moves until a legal one is found—and learns more about the location of
Black’s pieces in the process. Once a legal move is proposed, the referee announces one or
Section 5.6. Partially Observable Games 181
more of the following: “Capture on square X” if there is a capture, and “Check by D” if the
black king is in check, where D is the direction of the check, and can be one of “Knight,”
“Rank,” “File,” “Long diagonal,” or “Short diagonal.” (In case of discovered check, the referee may make two “Check” announcements.) If Black is checkmated or stalemated, the
referee says so; otherwise, it is Black’s turn to move.
Kriegspiel may seem terrifyingly impossible, but humans manage it quite well and computer programs are beginning to catch up. It helps to recall the notion of a belief state as
defined in Section 4.4 and illustrated in Figure 4.14—the set of all logically possible board
states given the complete history of percepts to date. Initially, White’s belief state is a singleton because Black’s pieces haven’t moved yet. After White makes a move and Black responds, White’s belief state contains 20 positions because Black has 20 replies to any White
move. Keeping track of the belief state as the game progresses is exactly the problem of state
estimation, for which the update step is given in Equation (4.6). We can map Kriegspiel
state estimation directly onto the partially observable, nondeterministic framework of Section 4.4 if we consider the opponent as the source of nondeterminism; that is, the RESULTS
of White’s move are composed from the (predictable) outcome of White’s own move and the
unpredictable outcome given by Black’s reply.3
Given a current belief state, White may ask, “Can I win the game?” For a partially
observable game, the notion of a strategy is altered; instead of specifying a move to make
for each possible move the opponent might make, we need a move for every possible percept
sequence that might be received. For Kriegspiel, a winning strategy, or guaranteed checkmate, is one that, for each possible percept sequence, leads to an actual checkmate for every GUARANTEED
CHECKMATE
possible board state in the current belief state, regardless of how the opponent moves. With
this definition, the opponent’s belief state is irrelevant—the strategy has to work even if the
opponent can see all the pieces. This greatly simplifies the computation. Figure 5.13 shows
part of a guaranteed checkmate for the KRK (king and rook against king) endgame. In this
case, Black has just one piece (the king), so a belief state for White can be shown in a single
board by marking each possible position of the Black king.
The general AND-OR search algorithm can be applied to the belief-state space to find
guaranteed checkmates, just as in Section 4.4. The incremental belief-state algorithm mentioned in that section often finds midgame checkmates up to depth 9—probably well beyond
the abilities of human players.
In addition to guaranteed checkmates, Kriegspiel admits an entirely new concept that
makes no sense in fully observable games: probabilistic checkmate. Such checkmates are PROBABILISTIC
CHECKMATE
still required to work in every board state in the belief state; they are probabilistic with respect
to randomization of the winning player’s moves. To get the basic idea, consider the problem
of finding a lone black king using just the white king. Simply by moving randomly, the
white king will eventually bump into the black king even if the latter tries to avoid this fate,
since Black cannot keep guessing the right evasive moves indefinitely. In the terminology of
probability theory, detection occurs with probability 1. The KBNK endgame—king, bishop
3 Sometimes, the belief state will become too large to represent just as a list of board states, but we will ignore
this issue for now; Chapters 7 and 8 suggest methods for compactly representing very large belief states.
182 Chapter 5. Adversarial Search
a
1
2
3
4
b c d
Kc3 ?
“OK” “Illegal”
Rc3 ?
“OK” “Check”
Figure 5.13 Part of a guaranteed checkmate in the KRK endgame, shown on a reduced
board. In the initial belief state, Black’s king is in one of three possible locations. By a
combination of probing moves, the strategy narrows this down to one. Completion of the
checkmate is left as an exercise.
and knight against king—is won in this sense; White presents Black with an infinite random
sequence of choices, for one of which Black will guess incorrectly and reveal his position,
leading to checkmate. The KBBK endgame, on the other hand, is won with probability 1− .
White can force a win only by leaving one of his bishops unprotected for one move. If
Black happens to be in the right place and captures the bishop (a move that would lose if the
bishops are protected), the game is drawn. White can choose to make the risky move at some
randomly chosen point in the middle of a very long sequence, thus reducing  to an arbitrarily
small constant, but cannot reduce  to zero.
It is quite rare that a guaranteed or probabilistic checkmate can be found within any
reasonable depth, except in the endgame. Sometimes a checkmate strategy works for some of
the board states in the current belief state but not others. Trying such a strategy may succeed,
leading to an accidental checkmate—accidental in the sense that White could not know that ACCIDENTAL
CHECKMATE
it would be checkmate—if Black’s pieces happen to be in the right places. (Most checkmates
in games between humans are of this accidental nature.) This idea leads naturally to the
question of how likely it is that a given strategy will win, which leads in turn to the question
of how likely it is that each board state in the current belief state is the true board state.
Section 5.6. Partially Observable Games 183
One’s first inclination might be to propose that all board states in the current belief state
are equally likely—but this can’t be right. Consider, for example, White’s belief state after
Black’s first move of the game. By definition (assuming that Black plays optimally), Black
must have played an optimal move, so all board states resulting from suboptimal moves ought
to be assigned zero probability. This argument is not quite right either, because each player’s
goal is not just to move pieces to the right squares but also to minimize the information that
the opponent has about their location. Playing any predictable “optimal” strategy provides
the opponent with information. Hence, optimal play in partially observable games requires
a willingness to play somewhat randomly. (This is why restaurant hygiene inspectors do
random inspection visits.) This means occasionally selecting moves that may seem “intrinsically” weak—but they gain strength from their very unpredictability, because the opponent is
unlikely to have prepared any defense against them.
From these considerations, it seems that the probabilities associated with the board
states in the current belief state can only be calculated given an optimal randomized strategy; in turn, computing that strategy seems to require knowing the probabilities of the various states the board might be in. This conundrum can be resolved by adopting the gametheoretic notion of an equilibrium solution, which we pursue further in Chapter 17. An
equilibrium specifies an optimal randomized strategy for each player. Computing equilibria is prohibitively expensive, however, even for small games, and is out of the question for
Kriegspiel. At present, the design of effective algorithms for general Kriegspiel play is an
open research topic. Most systems perform bounded-depth lookahead in their own beliefstate space, ignoring the opponent’s belief state. Evaluation functions resemble those for the
observable game but include a component for the size of the belief state—smaller is better!
5.6.2 Card games
Card games provide many examples of stochastic partial observability, where the missing
information is generated randomly. For example, in many games, cards are dealt randomly at
the beginning of the game, with each player receiving a hand that is not visible to the other
players. Such games include bridge, whist, hearts, and some forms of poker.
At first sight, it might seem that these card games are just like dice games: the cards are
dealt randomly and determine the moves available to each player, but all the “dice” are rolled
at the beginning! Even though this analogy turns out to be incorrect, it suggests an effective
algorithm: consider all possible deals of the invisible cards; solve each one as if it were a
fully observable game; and then choose the move that has the best outcome averaged over all
the deals. Suppose that each deal s occurs with probability P(s); then the move we want is
argmax a

s
P(s) MINIMAX(RESULT(s, a)) . (5.1)
Here, we run exact MINIMAX if computationally feasible; otherwise, we run H-MINIMAX.
Now, in most card games, the number of possible deals is rather large. For example,
in bridge play, each player sees just two of the four hands; there are two unseen hands of 13
cards each, so the number of deals is 26
13 = 10, 400, 600. Solving even one deal is quite
difficult, so solving ten million is out of the question. Instead, we resort to a Monte Carlo
184 Chapter 5. Adversarial Search
approximation: instead of adding up all the deals, we take a random sample of N deals,
where the probability of deal s appearing in the sample is proportional to P(s):
argmax a
1
N

N
i = 1
MINIMAX(RESULT(si, a)) . (5.2)
(Notice that P(s) does not appear explicitly in the summation, because the samples are already drawn according to P(s).) As N grows large, the sum over the random sample tends
to the exact value, but even for fairly small N—say, 100 to 1,000—the method gives a good
approximation. It can also be applied to deterministic games such as Kriegspiel, given some
reasonable estimate of P(s).
For games like whist and hearts, where there is no bidding or betting phase before play
commences, each deal will be equally likely and so the values of P(s) are all equal. For
bridge, play is preceded by a bidding phase in which each team indicates how many tricks it
expects to win. Since players bid based on the cards they hold, the other players learn more
about the probability of each deal. Taking this into account in deciding how to play the hand
is tricky, for the reasons mentioned in our description of Kriegspiel: players may bid in such
a way as to minimize the information conveyed to their opponents. Even so, the approach is
quite effective for bridge, as we show in Section 5.7.
The strategy described in Equations 5.1 and 5.2 is sometimes called averaging over
clairvoyance because it assumes that the game will become observable to both players immediately after the first move. Despite its intuitive appeal, the strategy can lead one astray.
Consider the following story:
Day 1: Road A leads to a heap of gold; Road B leads to a fork. Take the left fork and
you’ll find a bigger heap of gold, but take the right fork and you’ll be run over by a bus.
Day 2: Road A leads to a heap of gold; Road B leads to a fork. Take the right fork and
you’ll find a bigger heap of gold, but take the left fork and you’ll be run over by a bus.
Day 3: Road A leads to a heap of gold; Road B leads to a fork. One branch of the
fork leads to a bigger heap of gold, but take the wrong fork and you’ll be hit by a bus.
Unfortunately you don’t know which fork is which.
Averaging over clairvoyance leads to the following reasoning: on Day 1, B is the right choice;
on Day 2, B is the right choice; on Day 3, the situation is the same as either Day 1 or Day 2,
so B must still be the right choice.
Now we can see how averaging over clairvoyance fails: it does not consider the belief
state that the agent will be in after acting. A belief state of total ignorance is not desirable, especially when one possibility is certain death. Because it assumes that every future state will
automatically be one of perfect knowledge, the approach never selects actions that gather information (like the first move in Figure 5.13); nor will it choose actions that hide information
from the opponent or provide information to a partner because it assumes that they already
know the information; and it will never bluff in poker,4 BLUFF because it assumes the opponent can
see its cards. In Chapter 17, we show how to construct algorithms that do all these things by
virtue of solving the true partially observable decision problem.
4 Bluffing—betting as if one’s hand is good, even when it’s not—is a core part of poker strategy.
Section 5.7. State-of-the-Art Game Programs 185
5.7 STATE-OF-THE-ART GAME PROGRAMS
In 1965, the Russian mathematician Alexander Kronrod called chess “the Drosophila of artificial intelligence.” John McCarthy disagrees: whereas geneticists use fruit flies to make
discoveries that apply to biology more broadly, AI has used chess to do the equivalent of
breeding very fast fruit flies. Perhaps a better analogy is that chess is to AI as Grand Prix
motor racing is to the car industry: state-of-the-art game programs are blindingly fast, highly
optimized machines that incorporate the latest engineering advances, but they aren’t much
use for doing the shopping or driving off-road. Nonetheless, racing and game-playing generate excitement and a steady stream of innovations that have been adopted by the wider
community. In this section we look at what it takes to come out on top in various games.
CHESS Chess: IBM’s DEEP BLUE chess program, now retired, is well known for defeating world
champion Garry Kasparov in a widely publicized exhibition match. Deep Blue ran on a parallel computer with 30 IBM RS/6000 processors doing alpha–beta search. The unique part
was a configuration of 480 custom VLSI chess processors that performed move generation
and move ordering for the last few levels of the tree, and evaluated the leaf nodes. Deep Blue
searched up to 30 billion positions per move, reaching depth 14 routinely. The key to its
success seems to have been its ability to generate singular extensions beyond the depth limit
for sufficiently interesting lines of forcing/forced moves. In some cases the search reached a
depth of 40 plies. The evaluation function had over 8000 features, many of them describing
highly specific patterns of pieces. An “opening book” of about 4000 positions was used, as
well as a database of 700,000 grandmaster games from which consensus recommendations
could be extracted. The system also used a large endgame database of solved positions containing all positions with five pieces and many with six pieces. This database had the effect
of substantially extending the effective search depth, allowing Deep Blue to play perfectly in
some cases even when it was many moves away from checkmate.
The success of DEEP BLUE reinforced the widely held belief that progress in computer
game-playing has come primarily from ever-more-powerful hardware—a view encouraged
by IBM. But algorithmic improvements have allowed programs running on standard PCs
to win World Computer Chess Championships. A variety of pruning heuristics are used to
reduce the effective branching factor to less than 3 (compared with the actual branching factor
NULL MOVE of about 35). The most important of these is the null move heuristic, which generates a good
lower bound on the value of a position, using a shallow search in which the opponent gets
to move twice at the beginning. This lower bound often allows alpha–beta pruning without
FUTILITY PRUNING the expense of a full-depth search. Also important is futility pruning, which helps decide in
advance which moves will cause a beta cutoff in the successor nodes.
HYDRA can be seen as the successor to DEEP BLUE. HYDRA runs on a 64-processor
cluster with 1 gigabyte per processor and with custom hardware in the form of FPGA (Field
Programmable Gate Array) chips. HYDRA reaches 200 million evaluations per second, about
the same as Deep Blue, but HYDRA reaches 18 plies deep rather than just 14 because of
aggressive use of the null move heuristic and forward pruning.
186 Chapter 5. Adversarial Search
RYBKA, winner of the 2008 and 2009 World Computer Chess Championships, is considered the strongest current computer player. It uses an off-the-shelf 8-core 3.2 GHz Intel
Xeon processor, but little is known about the design of the program. RYBKA’s main advantage appears to be its evaluation function, which has been tuned by its main developer,
International Master Vasik Rajlich, and at least three other grandmasters.
The most recent matches suggest that the top computer chess programs have pulled
ahead of all human contenders. (See the historical notes for details.)
CHECKERS Checkers: Jonathan Schaeffer and colleagues developed CHINOOK, which runs on regular
PCs and uses alpha–beta search. Chinook defeated the long-running human champion in an
abbreviated match in 1990, and since 2007 CHINOOK has been able to play perfectly by using
alpha–beta search combined with a database of 39 trillion endgame positions.
OTHELLO Othello, also called Reversi, is probably more popular as a computer game than as a board
game. It has a smaller search space than chess, usually 5 to 15 legal moves, but evaluation
expertise had to be developed from scratch. In 1997, the LOGISTELLO program (Buro, 2002)
defeated the human world champion, Takeshi Murakami, by six games to none. It is generally
acknowledged that humans are no match for computers at Othello.
BACKGAMMON Backgammon: Section 5.5 explained why the inclusion of uncertainty from dice rolls makes
deep search an expensive luxury. Most work on backgammon has gone into improving the
evaluation function. Gerry Tesauro (1992) combined reinforcement learning with neural
networks to develop a remarkably accurate evaluator that is used with a search to depth 2
or 3. After playing more than a million training games against itself, Tesauro’s program,
TD-GAMMON, is competitive with top human players. The program’s opinions on the opening moves of the game have in some cases radically altered the received wisdom.
GO Go is the most popular board game in Asia. Because the board is 19 × 19 and moves are
allowed into (almost) every empty square, the branching factor starts at 361, which is too
daunting for regular alpha–beta search methods. In addition, it is difficult to write an evaluation function because control of territory is often very unpredictable until the endgame.
Therefore the top programs, such as MOGO, avoid alpha–beta search and instead use Monte
Carlo rollouts. The trick is to decide what moves to make in the course of the rollout. There is
no aggressive pruning; all moves are possible. The UCT (upper confidence bounds on trees)
method works by making random moves in the first few iterations, and over time guiding
the sampling process to prefer moves that have led to wins in previous samples. Some tricks
are added, including knowledge-based rules that suggest particular moves whenever a given
pattern is detected and limited local search to decide tactical questions. Some programs also
include special techniques from combinatorial game theory to analyze endgames. These COMBINATORIAL
GAME THEORY
techniques decompose a position into sub-positions that can be analyzed separately and then
combined (Berlekamp and Wolfe, 1994; M¨uller, 2003). The optimal solutions obtained in
this way have surprised many professional Go players, who thought they had been playing
optimally all along. Current Go programs play at the master level on a reduced 9 × 9 board,
but are still at advanced amateur level on a full board.
BRIDGE Bridge is a card game of imperfect information: a player’s cards are hidden from the other
players. Bridge is also a multiplayer game with four players instead of two, although the
Section 5.8. Alternative Approaches 187
players are paired into two teams. As in Section 5.6, optimal play in partially observable
games like bridge can include elements of information gathering, communication, and careful
weighing of probabilities. Many of these techniques are used in the Bridge Baron program
(Smith et al., 1998), which won the 1997 computer bridge championship. While it does
not play optimally, Bridge Baron is one of the few successful game-playing systems to use
complex, hierarchical plans (see Chapter 11) involving high-level ideas, such as finessing and
squeezing, that are familiar to bridge players.
The GIB program (Ginsberg, 1999) won the 2000 computer bridge championship quite
decisively using the Monte Carlo method. Since then, other winning programs have followed
GIB’s lead. GIB’s major innovation is using explanation-based generalization to compute
EXPLANATIONBASED
GENERALIZATION
and cache general rules for optimal play in various standard classes of situations rather than
evaluating each situation individually. For example, in a situation where one player has the
cards A-K-Q-J-4-3-2 of one suit and another player has 10-9-8-7-6-5, there are 7 × 6 = 42
ways that the first player can lead from that suit and the second player can follow. But GIB
treats these situations as just two: the first player can lead either a high card or a low card;
the exact cards played don’t matter. With this optimization (and a few others), GIB can solve
a 52-card, fully observable deal exactly in about a second. GIB’s tactical accuracy makes up
for its inability to reason about information. It finished 12th in a field of 35 in the par contest
(involving just play of the hand, not bidding) at the 1998 human world championship, far
exceeding the expectations of many human experts.
There are several reasons why GIB plays at expert level with Monte Carlo simulation,
whereas Kriegspiel programs do not. First, GIB’s evaluation of the fully observable version
of the game is exact, searching the full game tree, while Kriegspiel programs rely on inexact
heuristics. But far more important is the fact that in bridge, most of the uncertainty in the
partially observable information comes from the randomness of the deal, not from the adversarial play of the opponent. Monte Carlo simulation handles randomness well, but does not
always handle strategy well, especially when the strategy involves the value of information.
SCRABBLE Scrabble: Most people think the hard part about Scrabble is coming up with good words, but
given the official dictionary, it turns out to be rather easy to program a move generator to find
the highest-scoring move (Gordon, 1994). That doesn’t mean the game is solved, however:
merely taking the top-scoring move each turn results in a good but not expert player. The
problem is that Scrabble is both partially observable and stochastic: you don’t know what
letters the other player has or what letters you will draw next. So playing Scrabble well
combines the difficulties of backgammon and bridge. Nevertheless, in 2006, the QUACKLE
program defeated the former world champion, David Boys, 3–2.
5.8 ALTERNATIVE APPROACHES
Because calculating optimal decisions in games is intractable in most cases, all algorithms
must make some assumptions and approximations. The standard approach, based on minimax, evaluation functions, and alpha–beta, is just one way to do this. Probably because it has
188 Chapter 5. Adversarial Search
MAX
99 1000 1000 1000 100 101 102 100
MIN 99 100
Figure 5.14 A two-ply game tree for which heuristic minimax may make an error.
been worked on for so long, the standard approach dominates other methods in tournament
play. Some believe that this has caused game playing to become divorced from the mainstream of AI research: the standard approach no longer provides much room for new insight
into general questions of decision making. In this section, we look at the alternatives.
First, let us consider heuristic minimax. It selects an optimal move in a given search
tree provided that the leaf node evaluations are exactly correct. In reality, evaluations are
usually crude estimates of the value of a position and can be considered to have large errors
associated with them. Figure 5.14 shows a two-ply game tree for which minimax suggests
taking the right-hand branch because 100 > 99. That is the correct move if the evaluations
are all correct. But of course the evaluation function is only approximate. Suppose that
the evaluation of each node has an error that is independent of other nodes and is randomly
distributed with mean zero and standard deviation of σ. Then when σ = 5, the left-hand
branch is actually better 71% of the time, and 58% of the time when σ = 2. The intuition
behind this is that the right-hand branch has four nodes that are close to 99; if an error in
the evaluation of any one of the four makes the right-hand branch slip below 99, then the
left-hand branch is better.
In reality, circumstances are actually worse than this because the error in the evaluation
function is not independent. If we get one node wrong, the chances are high that nearby nodes
in the tree will also be wrong. The fact that the node labeled 99 has siblings labeled 1000
suggests that in fact it might have a higher true value. We can use an evaluation function
that returns a probability distribution over possible values, but it is difficult to combine these
distributions properly, because we won’t have a good model of the very strong dependencies
that exist between the values of sibling nodes
Next, we consider the search algorithm that generates the tree. The aim of an algorithm
designer is to specify a computation that runs quickly and yields a good move. The alpha–beta
algorithm is designed not just to select a good move but also to calculate bounds on the values
of all the legal moves. To see why this extra information is unnecessary, consider a position
in which there is only one legal move. Alpha–beta search still will generate and evaluate a
large search tree, telling us that the only move is the best move and assigning it a value. But
since we have to make the move anyway, knowing the move’s value is useless. Similarly, if
there is one obviously good move and several moves that are legal but lead to a quick loss, we
Section 5.9. Summary 189
would not want alpha–beta to waste time determining a precise value for the lone good move.
Better to just make the move quickly and save the time for later. This leads to the idea of the
utility of a node expansion. A good search algorithm should select node expansions of high
utility—that is, ones that are likely to lead to the discovery of a significantly better move. If
there are no node expansions whose utility is higher than their cost (in terms of time), then
the algorithm should stop searching and make a move. Notice that this works not only for
clear-favorite situations but also for the case of symmetrical moves, for which no amount of
search will show that one move is better than another.
METAREASONING This kind of reasoning about what computations to do is called metareasoning (reasoning about reasoning). It applies not just to game playing but to any kind of reasoning
at all. All computations are done in the service of trying to reach better decisions, all have
costs, and all have some likelihood of resulting in a certain improvement in decision quality.
Alpha–beta incorporates the simplest kind of metareasoning, namely, a theorem to the effect
that certain branches of the tree can be ignored without loss. It is possible to do much better.
In Chapter 16, we see how these ideas can be made precise and implementable.
Finally, let us reexamine the nature of search itself. Algorithms for heuristic search
and for game playing generate sequences of concrete states, starting from the initial state
and then applying an evaluation function. Clearly, this is not how humans play games. In
chess, one often has a particular goal in mind—for example, trapping the opponent’s queen—
and can use this goal to selectively generate plausible plans for achieving it. This kind of
goal-directed reasoning or planning sometimes eliminates combinatorial search altogether.
David Wilkins’ (1980) PARADISE is the only program to have used goal-directed reasoning
successfully in chess: it was capable of solving some chess problems requiring an 18-move
combination. As yet there is no good understanding of how to combine the two kinds of
algorithms into a robust and efficient system, although Bridge Baron might be a step in the
right direction. A fully integrated system would be a significant achievement not just for
game-playing research but also for AI research in general, because it would be a good basis
for a general intelligent agent.
5.9 SUMMARY
We have looked at a variety of games to understand what optimal play means and to understand how to play well in practice. The most important ideas are as follows:
• A game can be defined by the initial state (how the board is set up), the legal actions
in each state, the result of each action, a terminal test (which says when the game is
over), and a utility function that applies to terminal states.
• In two-player zero-sum games with perfect information, the minimax algorithm can
select optimal moves by a depth-first enumeration of the game tree.
• The alpha–beta search algorithm computes the same optimal move as minimax, but
achieves much greater efficiency by eliminating subtrees that are provably irrelevant.
• Usually, it is not feasible to consider the whole game tree (even with alpha–beta), so we
190 Chapter 5. Adversarial Search
need to cut the search off at some point and apply a heuristic evaluation function that
estimates the utility of a state.
• Many game programs precompute tables of best moves in the opening and endgame so
that they can look up a move rather than search.
• Games of chance can be handled by an extension to the minimax algorithm that evaluates a chance node by taking the average utility of all its children, weighted by the
probability of each child.
• Optimal play in games of imperfect information, such as Kriegspiel and bridge, requires reasoning about the current and future belief states of each player. A simple
approximation can be obtained by averaging the value of an action over each possible
configuration of missing information.
• Programs have bested even champion human players at games such as chess, checkers,
and Othello. Humans retain the edge in several games of imperfect information, such
as poker, bridge, and Kriegspiel, and in games with very large branching factors and
little good heuristic knowledge, such as Go.
BIBLIOGRAPHICAL AND HISTORICAL NOTES
The early history of mechanical game playing was marred by numerous frauds. The most
notorious of these was Baron Wolfgang von Kempelen’s (1734–1804) “The Turk,” a supposed
chess-playing automaton that defeated Napoleon before being exposed as a magician’s trick
cabinet housing a human chess expert (see Levitt, 2000). It played from 1769 to 1854. In
1846, Charles Babbage (who had been fascinated by the Turk) appears to have contributed
the first serious discussion of the feasibility of computer chess and checkers (Morrison and
Morrison, 1961). He did not understand the exponential complexity of search trees, claiming
“the combinations involved in the Analytical Engine enormously surpassed any required,
even by the game of chess.” Babbage also designed, but did not build, a special-purpose
machine for playing tic-tac-toe. The first true game-playing machine was built around 1890
by the Spanish engineer Leonardo Torres y Quevedo. It specialized in the “KRK” (king and
rook vs. king) chess endgame, guaranteeing a win with king and rook from any position.
The minimax algorithm is traced to a 1912 paper by Ernst Zermelo, the developer of
modern set theory. The paper unfortunately contained several errors and did not describe minimax correctly. On the other hand, it did lay out the ideas of retrograde analysis and proposed
(but did not prove) what became known as Zermelo’s theorem: that chess is determined—
White can force a win or Black can or it is a draw; we just don’t know which. Zermelo says
that should we eventually know, “Chess would of course lose the character of a game at all.”
A solid foundation for game theory was developed in the seminal work Theory of Games
and Economic Behavior (von Neumann and Morgenstern, 1944), which included an analysis
showing that some games require strategies that are randomized (or otherwise unpredictable).
See Chapter 17 for more information.
Bibliographical and Historical Notes 191
John McCarthy conceived the idea of alpha–beta search in 1956, although he did not
publish it. The NSS chess program (Newell et al., 1958) used a simplified version of alpha–
beta; it was the first chess program to do so. Alpha–beta pruning was described by Hart and
Edwards (1961) and Hart et al. (1972). Alpha–beta was used by the “Kotok–McCarthy” chess
program written by a student of John McCarthy (Kotok, 1962). Knuth and Moore (1975)
proved the correctness of alpha–beta and analysed its time complexity. Pearl (1982b) shows
alpha–beta to be asymptotically optimal among all fixed-depth game-tree search algorithms.
Several attempts have been made to overcome the problems with the “standard approach” that were outlined in Section 5.8. The first nonexhaustive heuristic search algorithm
with some theoretical grounding was probably B∗ (Berliner, 1979), which attempts to maintain interval bounds on the possible value of a node in the game tree rather than giving it
a single point-valued estimate. Leaf nodes are selected for expansion in an attempt to refine the top-level bounds until one move is “clearly best.” Palay (1985) extends the B∗ idea
using probability distributions on values in place of intervals. David McAllester’s (1988)
conspiracy number search expands leaf nodes that, by changing their values, could cause
the program to prefer a new move at the root. MGSS∗ (Russell and Wefald, 1989) uses the
decision-theoretic techniques of Chapter 16 to estimate the value of expanding each leaf in
terms of the expected improvement in decision quality at the root. It outplayed an alpha–
beta algorithm at Othello despite searching an order of magnitude fewer nodes. The MGSS∗
approach is, in principle, applicable to the control of any form of deliberation.
Alpha–beta search is in many ways the two-player analog of depth-first branch-andbound, which is dominated by A∗ in the single-agent case. The SSS∗ algorithm (Stockman,
1979) can be viewed as a two-player A∗ and never expands more nodes than alpha–beta to
reach the same decision. The memory requirements and computational overhead of the queue
make SSS∗ in its original form impractical, but a linear-space version has been developed
from the RBFS algorithm (Korf and Chickering, 1996). Plaat et al. (1996) developed a new
view of SSS∗ as a combination of alpha–beta and transposition tables, showing how to overcome the drawbacks of the original algorithm and developing a new variant called MTD(f)
that has been adopted by a number of top programs.
D. F. Beal (1980) and Dana Nau (1980, 1983) studied the weaknesses of minimax applied to approximate evaluations. They showed that under certain assumptions about the distribution of leaf values in the tree, minimaxing can yield values at the root that are actually less
reliable than the direct use of the evaluation function itself. Pearl’s book Heuristics (1984)
partially explains this apparent paradox and analyzes many game-playing algorithms. Baum
and Smith (1997) propose a probability-based replacement for minimax, showing that it results in better choices in certain games. The expectiminimax algorithm was proposed by
Donald Michie (1966). Bruce Ballard (1983) extended alpha–beta pruning to cover trees
with chance nodes and Hauk (2004) reexamines this work and provides empirical results.
Koller and Pfeffer (1997) describe a system for completely solving partially observable games. The system is quite general, handling games whose optimal strategy requires
randomized moves and games that are more complex than those handled by any previous
system. Still, it can’t handle games as complex as poker, bridge, and Kriegspiel. Frank
et al. (1998) describe several variants of Monte Carlo search, including one where MIN has
192 Chapter 5. Adversarial Search
complete information but MAX does not. Among deterministic, partially observable games,
Kriegspiel has received the most attention. Ferguson demonstrated hand-derived randomized strategies for winning Kriegspiel with a bishop and knight (1992) or two bishops (1995)
against a king. The first Kriegspiel programs concentrated on finding endgame checkmates
and performed AND–OR search in belief-state space (Sakuta and Iida, 2002; Bolognesi and
Ciancarini, 2003). Incremental belief-state algorithms enabled much more complex midgame
checkmates to be found (Russell and Wolfe, 2005; Wolfe and Russell, 2007), but efficient
state estimation remains the primary obstacle to effective general play (Parker et al., 2005).
Chess was one of the first tasks undertaken in AI, with early efforts by many of the pioneers of computing, including Konrad Zuse in 1945, Norbert Wiener in his book Cybernetics
(1948), and Alan Turing in 1950 (see Turing et al., 1953). But it was Claude Shannon’s
article Programming a Computer for Playing Chess (1950) that had the most complete set
of ideas, describing a representation for board positions, an evaluation function, quiescence
search, and some ideas for selective (nonexhaustive) game-tree search. Slater (1950) and the
commentators on his article also explored the possibilities for computer chess play.
D. G. Prinz (1952) completed a program that solved chess endgame problems but did
not play a full game. Stan Ulam and a group at the Los Alamos National Lab produced a
program that played chess on a 6 × 6 board with no bishops (Kister et al., 1957). It could
search 4 plies deep in about 12 minutes. Alex Bernstein wrote the first documented program
to play a full game of standard chess (Bernstein and Roberts, 1958).5
The first computer chess match featured the Kotok–McCarthy program from MIT (Kotok, 1962) and the ITEP program written in the mid-1960s at Moscow’s Institute of Theoretical and Experimental Physics (Adelson-Velsky et al., 1970). This intercontinental match
was played by telegraph. It ended with a 3–1 victory for the ITEP program in 1967. The first
chess program to compete successfully with humans was MIT’s MACHACK-6 (Greenblatt
et al., 1967). Its Elo rating of approximately 1400 was well above the novice level of 1000.
The Fredkin Prize, established in 1980, offered awards for progressive milestones in
chess play. The $5,000 prize for the first program to achieve a master rating went to BELLE
(Condon and Thompson, 1982), which achieved a rating of 2250. The $10,000 prize for the
first program to achieve a USCF (United States Chess Federation) rating of 2500 (near the
grandmaster level) was awarded to DEEP THOUGHT (Hsu et al., 1990) in 1989. The grand
prize, $100,000, went to DEEP BLUE (Campbell et al., 2002; Hsu, 2004) for its landmark
victory over world champion Garry Kasparov in a 1997 exhibition match. Kasparov wrote:
The decisive game of the match was Game 2, which left a scar in my memory ... we saw
something that went well beyond our wildest expectations of how well a computer would
be able to foresee the long-term positional consequences of its decisions. The machine
refused to move to a position that had a decisive short-term advantage—showing a very
human sense of danger. (Kasparov, 1997)
Probably the most complete description of a modern chess program is provided by Ernst
Heinz (2000), whose DARKTHOUGHT program was the highest-ranked noncommercial PC
program at the 1999 world championships.
5 A Russian program, BESM may have predated Bernstein’s program.
Bibliographical and Historical Notes 193
(a) (b)
Figure 5.15 Pioneers in computer chess: (a) Herbert Simon and Allen Newell, developers
of the NSS program (1958); (b) John McCarthy and the Kotok–McCarthy program on an
IBM 7090 (1967).
In recent years, chess programs are pulling ahead of even the world’s best humans.
In 2004–2005 HYDRA defeated grand master Evgeny Vladimirov 3.5–0.5, world champion
Ruslan Ponomariov 2–0, and seventh-ranked Michael Adams 5.5–0.5. In 2006, DEEP FRITZ
beat world champion Vladimir Kramnik 4–2, and in 2007 RYBKA defeated several grand
masters in games in which it gave odds (such as a pawn) to the human players. As of 2009,
the highest Elo rating ever recorded was Kasparov’s 2851. HYDRA (Donninger and Lorenz,
2004) is rated somewhere between 2850 and 3000, based mostly on its trouncing of Michael
Adams. The RYBKA program is rated between 2900 and 3100, but this is based on a small
number of games and is not considered reliable. Ross (2004) shows how human players have
learned to exploit some of the weaknesses of the computer programs.
Checkers was the first of the classic games fully played by a computer. Christopher
Strachey (1952) wrote the first working program for checkers. Beginning in 1952, Arthur
Samuel of IBM, working in his spare time, developed a checkers program that learned its
own evaluation function by playing itself thousands of times (Samuel, 1959, 1967). We
describe this idea in more detail in Chapter 21. Samuel’s program began as a novice but
after only a few days’ self-play had improved itself beyond Samuel’s own level. In 1962 it
defeated Robert Nealy, a champion at “blind checkers,” through an error on his part. When
one considers that Samuel’s computing equipment (an IBM 704) had 10,000 words of main
memory, magnetic tape for long-term storage, and a .000001 GHz processor, the win remains
a great accomplishment.
The challenge started by Samuel was taken up by Jonathan Schaeffer of the University
of Alberta. His CHINOOK program came in second in the 1990 U.S. Open and earned the
right to challenge for the world championship. It then ran up against a problem, in the form
of Marion Tinsley. Dr. Tinsley had been world champion for over 40 years, losing only
three games in all that time. In the first match against CHINOOK, Tinsley suffered his fourth
194 Chapter 5. Adversarial Search
and fifth losses, but won the match 20.5–18.5. A rematch at the 1994 world championship
ended prematurely when Tinsley had to withdraw for health reasons. CHINOOK became the
official world champion. Schaeffer kept on building on his database of endgames, and in
2007 “solved” checkers (Schaeffer et al., 2007; Schaeffer, 2008). This had been predicted by
Richard Bellman (1965). In the paper that introduced the dynamic programming approach
to retrograde analysis, he wrote, “In checkers, the number of possible moves in any given
situation is so small that we can confidently expect a complete digital computer solution to
the problem of optimal play in this game.” Bellman did not, however, fully appreciate the
size of the checkers game tree. There are about 500 quadrillion positions. After 18 years
of computation on a cluster of 50 or more machines, Jonathan Schaeffer’s team completed
an endgame table for all checkers positions with 10 or fewer pieces: over 39 trillion entries.
From there, they were able to do forward alpha–beta search to derive a policy that proves
that checkers is in fact a draw with best play by both sides. Note that this is an application
of bidirectional search (Section 3.4.6). Building an endgame table for all of checkers would
be impractical: it would require a billion gigabytes of storage. Searching without any table
would also be impractical: the search tree has about 847 positions, and would take thousands
of years to search with today’s technology. Only a combination of clever search, endgame
data, and a drop in the price of processors and memory could solve checkers. Thus, checkers
joins Qubic (Patashnik, 1980), Connect Four (Allis, 1988), and Nine-Men’s Morris (Gasser,
1998) as games that have been solved by computer analysis.
Backgammon, a game of chance, was analyzed mathematically by Gerolamo Cardano
(1663), but only taken up for computer play in the late 1970s, first with the BKG program (Berliner, 1980b); it used a complex, manually constructed evaluation function and
searched only to depth 1. It was the first program to defeat a human world champion at a major classic game (Berliner, 1980a). Berliner readily acknowledged that BKG was very lucky
with the dice. Gerry Tesauro’s (1995) TD-GAMMON played consistently at world champion
level. The BGBLITZ program was the winner of the 2008 Computer Olympiad.
Go is a deterministic game, but the large branching factor makes it challeging. The key
issues and early literature in computer Go are summarized by Bouzy and Cazenave (2001) and
M¨uller (2002). Up to 1997 there were no competent Go programs. Now the best programs
play most of their moves at the master level; the only problem is that over the course of a
game they usually make at least one serious blunder that allows a strong opponent to win.
Whereas alpha–beta search reigns in most games, many recent Go programs have adopted
Monte Carlo methods based on the UCT (upper confidence bounds on trees) scheme (Kocsis
and Szepesvari, 2006). The strongest Go program as of 2009 is Gelly and Silver’s MOGO
(Wang and Gelly, 2007; Gelly and Silver, 2008). In August 2008, MOGO scored a surprising
win against top professional Myungwan Kim, albeit with MOGO receiving a handicap of
nine stones (about the equivalent of a queen handicap in chess). Kim estimated MOGO’s
strength at 2–3 dan, the low end of advanced amateur. For this match, MOGO was run on
an 800-processor 15 teraflop supercomputer (1000 times Deep Blue). A few weeks later,
MOGO, with only a five-stone handicap, won against a 6-dan professional. In the 9 × 9 form
of Go, MOGO is at approximately the 1-dan professional level. Rapid advances are likely
as experimentation continues with new forms of Monte Carlo search. The Computer Go
Exercises 195
Newsletter, published by the Computer Go Association, describes current developments.
Bridge: Smith et al. (1998) report on how their planning-based program won the 1998
computer bridge championship, and (Ginsberg, 2001) describes how his GIB program, based
on Monte Carlo simulation, won the following computer championship and did surprisingly
well against human players and standard book problem sets. From 2001–2007, the computer
bridge championship was won five times by JACK and twice by WBRIDGE5. Neither has
had academic articles explaining their structure, but both are rumored to use the Monte Carlo
technique, which was first proposed for bridge by Levy (1989).
Scrabble: A good description of a top program, MAVEN, is given by its creator, Brian
Sheppard (2002). Generating the highest-scoring move is described by Gordon (1994), and
modeling opponents is covered by Richards and Amir (2007).
Soccer (Kitano et al., 1997b; Visser et al., 2008) and billiards (Lam and Greenspan,
2008; Archibald et al., 2009) and other stochastic games with a continuous space of actions
are beginning to attract attention in AI, both in simulation and with physical robot players.
Computer game competitions occur annually, and papers appear in a variety of venues.
The rather misleadingly named conference proceedings Heuristic Programming in Artificial
Intelligence report on the Computer Olympiads, which include a wide variety of games. The
General Game Competition (Love et al., 2006) tests programs that must learn to play an unknown game given only a logical description of the rules of the game. There are also several
edited collections of important papers on game-playing research (Levy, 1988a, 1988b; Marsland and Schaeffer, 1990). The International Computer Chess Association (ICCA), founded
in 1977, publishes the ICGA Journal (formerly the ICCA Journal). Important papers have
been published in the serial anthology Advances in Computer Chess, starting with Clarke
(1977). Volume 134 of the journal Artificial Intelligence (2002) contains descriptions of
state-of-the-art programs for chess, Othello, Hex, shogi, Go, backgammon, poker, Scrabble,
and other games. Since 1998, a biennial Computers and Games conference has been held.
EXERCISES
5.1 Suppose you have an oracle, OM(s), that correctly predicts the opponent’s move in
any state. Using this, formulate the definition of a game as a (single-agent) search problem.
Describe an algorithm for finding the optimal move.
5.2 Consider the problem of solving two 8-puzzles.
a. Give a complete problem formulation in the style of Chapter 3.
b. How large is the reachable state space? Give an exact numerical expression.
c. Suppose we make the problem adversarial as follows: the two players take turns moving; a coin is flipped to determine the puzzle on which to make a move in that turn; and
the winner is the first to solve one puzzle. Which algorithm can be used to choose a
move in this setting?
d. Give an informal proof that someone will eventually win if both play perfectly.
196 Chapter 5. Adversarial Search
(b)
(a) a
f
e
b c d
bd
cd ad
ce cf cc ae af ac
de df
dd dd
? ? ? ? ?
P E
Figure 5.16 (a) A map where the cost of every edge is 1. Initially the pursuer P is at node
b and the evader E is at node d. (b) A partial game tree for this map. Each node is labeled
with the P, E positions. P moves first. Branches marked “?” have yet to be explored.
5.3 Imagine that, in Exercise 3.3, one of the friends wants to avoid the other. The problem
PURSUIT–EVASION then becomes a two-player pursuit–evasion game. We assume now that the players take
turns moving. The game ends only when the players are on the same node; the terminal
payoff to the pursuer is minus the total time taken. (The evader “wins” by never losing.) An
example is shown in Figure 5.16.
a. Copy the game tree and mark the values of the terminal nodes.
b. Next to each internal node, write the strongest fact you can infer about its value (a
number, one or more inequalities such as “≥ 14”, or a “?”).
c. Beneath each question mark, write the name of the node reached by that branch.
d. Explain how a bound on the value of the nodes in (c) can be derived from consideration
of shortest-path lengths on the map, and derive such bounds for these nodes. Remember
the cost to get to each leaf as well as the cost to solve it.
e. Now suppose that the tree as given, with the leaf bounds from (d), is evaluated from left
to right. Circle those “?” nodes that would not need to be expanded further, given the
bounds from part (d), and cross out those that need not be considered at all.
f. Can you prove anything in general about who wins the game on a map that is a tree?
Exercises 197
5.4 Describe and implement state descriptions, move generators, terminal tests, utility functions, and evaluation functions for one or more of the following stochastic games: Monopoly,
Scrabble, bridge play with a given contract, or Texas hold’em poker.
5.5 Describe and implement a real-time, multiplayer game-playing environment, where
time is part of the environment state and players are given fixed time allocations.
5.6 Discuss how well the standard approach to game playing would apply to games such as
tennis, pool, and croquet, which take place in a continuous physical state space.
5.7 Prove the following assertion: For every game tree, the utility obtained by MAX using
minimax decisions against a suboptimal MIN will be never be lower than the utility obtained
playing against an optimal MIN. Can you come up with a game tree in which MAX can do
still better using a suboptimal strategy against a suboptimal MIN?
A B
1 4 2 3
Figure 5.17 The starting position of a simple game. Player A moves first. The two players
take turns moving, and each player must move his token to an open adjacent space in either
direction. If the opponent occupies an adjacent space, then a player may jump over the
opponent to the next open space if any. (For example, if A is on 3 and B is on 2, then A may
move back to 1.) The game ends when one player reaches the opposite end of the board. If
player A reaches space 4 first, then the value of the game to A is +1; if player B reaches
space 1 first, then the value of the game to A is −1.
5.8 Consider the two-player game described in Figure 5.17.
a. Draw the complete game tree, using the following conventions:
• Write each state as (sA, sB), where sA and sB denote the token locations.
• Put each terminal state in a square box and write its game value in a circle.
• Put loop states (states that already appear on the path to the root) in double square
boxes. Since their value is unclear, annotate each with a “?” in a circle.
b. Now mark each node with its backed-up minimax value (also in a circle). Explain how
you handled the “?” values and why.
c. Explain why the standard minimax algorithm would fail on this game tree and briefly
sketch how you might fix it, drawing on your answer to (b). Does your modified algorithm give optimal decisions for all games with loops?
d. This 4-square game can be generalized to n squares for any n > 2. Prove that A wins
if n is even and loses if n is odd.
5.9 This problem exercises the basic concepts of game playing, using tic-tac-toe (noughts
and crosses) as an example. We define Xn as the number of rows, columns, or diagonals
198 Chapter 5. Adversarial Search
with exactly n X’s and no O’s. Similarly, On is the number of rows, columns, or diagonals
with just n O’s. The utility function assigns +1 to any position with X3 = 1 and −1 to any
position with O3 = 1. All other terminal positions have utility 0. For nonterminal positions,
we use a linear evaluation function defined as Eval(s)=3X2(s)+X1(s)−(3O2(s)+O1(s)).
a. Approximately how many possible games of tic-tac-toe are there?
b. Show the whole game tree starting from an empty board down to depth 2 (i.e., one X
and one O on the board), taking symmetry into account.
c. Mark on your tree the evaluations of all the positions at depth 2.
d. Using the minimax algorithm, mark on your tree the backed-up values for the positions
at depths 1 and 0, and use those values to choose the best starting move.
e. Circle the nodes at depth 2 that would not be evaluated if alpha–beta pruning were
applied, assuming the nodes are generated in the optimal order for alpha–beta pruning.
5.10 Consider the family of generalized tic-tac-toe games, defined as follows. Each particular game is specified by a set S of squares and a collection W of winning positions. Each
winning position is a subset of S. For example, in standard tic-tac-toe, S is a set of 9 squares
and W is a collection of 8 subsets of W: the three rows, the three columns, and the two diagonals. In other respects, the game is identical to standard tic-tac-toe. Starting from an empty
board, players alternate placing their marks on an empty square. A player who marks every
square in a winning position wins the game. It is a tie if all squares are marked and neither
player has won.
a. Let N = |S|, the number of squares. Give an upper bound on the number of nodes in
the complete game tree for generalized tic-tac-toe as a function of N.
b. Give a lower bound on the size of the game tree for the worst case, where W = { }.
c. Propose a plausible evaluation function that can be used for any instance of generalized
tic-tac-toe. The function may depend on S and W.
d. Assume that it is possible to generate a new board and check whether it is a winning
position in 100N machine instructions and assume a 2 gigahertz processor. Ignore
memory limitations. Using your estimate in (a), roughly how large a game tree can be
completely solved by alpha–beta in a second of CPU time? a minute? an hour?
5.11 Develop a general game-playing program, capable of playing a variety of games.
a. Implement move generators and evaluation functions for one or more of the following
games: Kalah, Othello, checkers, and chess.
b. Construct a general alpha–beta game-playing agent.
c. Compare the effect of increasing search depth, improving move ordering, and improving the evaluation function. How close does your effective branching factor come to the
ideal case of perfect move ordering?
d. Implement a selective search algorithm, such as B* (Berliner, 1979), conspiracy number
search (McAllester, 1988), or MGSS* (Russell and Wefald, 1989) and compare its
performance to A*.
Exercises 199
n1
n2
nj
Figure 5.18 Situation when considering whether to prune node nj .
5.12 Describe how the minimax and alpha–beta algorithms change for two-player, nonzero-sum games in which each player has a distinct utility function and both utility functions
are known to both players. If there are no constraints on the two terminal utilities, is it possible
for any node to be pruned by alpha–beta? What if the player’s utility functions on any state
differ by at most a constant k, making the game almost cooperative?
5.13 Develop a formal proof of correctness for alpha–beta pruning. To do this, consider the
situation shown in Figure 5.18. The question is whether to prune node nj , which is a maxnode and a descendant of node n1. The basic idea is to prune it if and only if the minimax
value of n1 can be shown to be independent of the value of nj .
a. Mode n1 takes on the minimum value among its children: n1 = min(n2, n21,...,n2b2 ).
Find a similar expression for n2 and hence an expression for n1 in terms of nj .
b. Let li be the minimum (or maximum) value of the nodes to the left of node ni at depth i,
whose minimax value is already known. Similarly, let ri be the minimum (or maximum)
value of the unexplored nodes to the right of ni at depth i. Rewrite your expression for
n1 in terms of the li and ri values.
c. Now reformulate the expression to show that in order to affect n1, nj must not exceed
a certain bound derived from the li values.
d. Repeat the process for the case where nj is a min-node.
5.14 Prove that alpha–beta pruning takes time O(2m/2) with optimal move ordering, where
m is the maximum depth of the game tree.
5.15 Suppose you have a chess program that can evaluate 10 million nodes per second.
Decide on a compact representation of a game state for storage in a transposition table. About
how many entries can you fit in a 2-gigabyte in-memory table? Will that be enough for the
200 Chapter 5. Adversarial Search
0.5 0.5 0.5 0.5
2 2 1 2 0 2 -1 0
Figure 5.19 The complete game tree for a trivial game with chance nodes.
three minutes of search allocated for one move? How many table lookups can you do in the
time it would take to do one evaluation? Now suppose the transposition table is stored on
disk. About how many evaluations could you do in the time it takes to do one disk seek with
standard disk hardware?
5.16 This question considers pruning in games with chance nodes. Figure 5.19 shows the
complete game tree for a trivial game. Assume that the leaf nodes are to be evaluated in leftto-right order, and that before a leaf node is evaluated, we know nothing about its value—the
range of possible values is −∞ to ∞.
a. Copy the figure, mark the value of all the internal nodes, and indicate the best move at
the root with an arrow.
b. Given the values of the first six leaves, do we need to evaluate the seventh and eighth
leaves? Given the values of the first seven leaves, do we need to evaluate the eighth
leaf? Explain your answers.
c. Suppose the leaf node values are known to lie between –2 and 2 inclusive. After the
first two leaves are evaluated, what is the value range for the left-hand chance node?
d. Circle all the leaves that need not be evaluated under the assumption in (c).
5.17 Implement the expectiminimax algorithm and the *-alpha–beta algorithm, which is
described by Ballard (1983), for pruning game trees with chance nodes. Try them on a game
such as backgammon and measure the pruning effectiveness of *-alpha–beta.
5.18 Prove that with a positive linear transformation of leaf values (i.e., transforming a
value x to ax + b where a > 0), the choice of move remains unchanged in a game tree, even
when there are chance nodes.
5.19 Consider the following procedure for choosing moves in games with chance nodes:
• Generate some dice-roll sequences (say, 50) down to a suitable depth (say, 8).
• With known dice rolls, the game tree becomes deterministic. For each dice-roll sequence, solve the resulting deterministic game tree using alpha–beta.
Exercises 201
• Use the results to estimate the value of each move and to choose the best.
Will this procedure work well? Why (or why not)?
5.20 In the following, a “max” tree consists only of max nodes, whereas an “expectimax”
tree consists of a max node at the root with alternating layers of chance and max nodes. At
chance nodes, all outcome probabilities are nonzero. The goal is to find the value of the root
with a bounded-depth search. For each of (a)–(f), either give an example or explain why this
is impossible.
a. Assuming that leaf values are finite but unbounded, is pruning (as in alpha–beta) ever
possible in a max tree?
b. Is pruning ever possible in an expectimax tree under the same conditions?
c. If leaf values are all nonnegative, is pruning ever possible in a max tree? Give an
example, or explain why not.
d. If leaf values are all nonnegative, is pruning ever possible in an expectimax tree? Give
an example, or explain why not.
e. If leaf values are all in the range [0, 1], is pruning ever possible in a max tree? Give an
example, or explain why not.
f. If leaf values are all in the range [0, 1], is pruning ever possible in an expectimax tree?
g. Consider the outcomes of a chance node in an expectimax tree. Which of the following
evaluation orders is most likely to yield pruning opportunities?
(i) Lowest probability first
(ii) Highest probability first
(iii) Doesn’t make any difference
5.21 Which of the following are true and which are false? Give brief explanations.
a. In a fully observable, turn-taking, zero-sum game between two perfectly rational players, it does not help the first player to know what strategy the second player is using—
that is, what move the second player will make, given the first player’s move.
b. In a partially observable, turn-taking, zero-sum game between two perfectly rational
players, it does not help the first player to know what move the second player will
make, given the first player’s move.
c. A perfectly rational backgammon agent never loses.
5.22 Consider carefully the interplay of chance events and partial information in each of the
games in Exercise 5.4.
a. For which is the standard expectiminimax model appropriate? Implement the algorithm
and run it in your game-playing agent, with appropriate modifications to the gameplaying environment.
b. For which would the scheme described in Exercise 5.19 be appropriate?
c. Discuss how you might deal with the fact that in some of the games, the players do not
have the same knowledge of the current state.
6 CONSTRAINT
SATISFACTION PROBLEMS
In which we see how treating states as more than just little black boxes leads to the
invention of a range of powerful new search methods and a deeper understanding
of problem structure and complexity.
Chapters 3 and 4 explored the idea that problems can be solved by searching in a space of
states. These states can be evaluated by domain-specific heuristics and tested to see whether
they are goal states. From the point of view of the search algorithm, however, each state is
atomic, or indivisible—a black box with no internal structure.
This chapter describes a way to solve a wide variety of problems more efficiently. We
use a factored representation for each state: a set of variables, each of which has a value.
A problem is solved when each variable has a value that satisfies all the constraints on the
variable. A problem described this way is called a constraint satisfaction problem, or CSP. CONSTRAINT
SATISFACTION
PROBLEM
CSP search algorithms take advantage of the structure of states and use general-purpose
rather than problem-specific heuristics to enable the solution of complex problems. The main
idea is to eliminate large portions of the search space all at once by identifying variable/value
combinations that violate the constraints.
6.1 DEFINING CONSTRAINT SATISFACTION PROBLEMS
A constraint satisfaction problem consists of three components, X, D, and C:
X is a set of variables, {X1,...,Xn}.
D is a set of domains, {D1,...,Dn}, one for each variable.
C is a set of constraints that specify allowable combinations of values.
Each domain Di consists of a set of allowable values, {v1,...,vk} for variable Xi. Each
constraint Ci consists of a pair scope, rel, where scope is a tuple of variables that participate
in the constraint and rel is a relation that defines the values that those variables can take on. A
relation can be represented as an explicit list of all tuples of values that satisfy the constraint,
or as an abstract relation that supports two operations: testing if a tuple is a member of the
relation and enumerating the members of the relation. For example, if X1 and X2 both have
202
Section 6.1. Defining Constraint Satisfaction Problems 203
the domain {A,B}, then the constraint saying the two variables must have different values
can be written as (X1, X2), [(A, B),(B,A)] or as (X1, X2), X1 = X2.
To solve a CSP, we need to define a state space and the notion of a solution. Each
ASSIGNMENT state in a CSP is defined by an assignment of values to some or all of the variables, {Xi =
vi CONSISTENT , Xj = vj ,...}. An assignment that does not violate any constraints is called a consistent
or legal assignment. A complete assignment is one in which every variable is assigned, and COMPLETE
ASSIGNMENT
SOLUTION a solution to a CSP is a consistent, complete assignment. A partial assignment is one that PARTIAL
ASSIGNMENT assigns values to only some of the variables.
6.1.1 Example problem: Map coloring
Suppose that, having tired of Romania, we are looking at a map of Australia showing each
of its states and territories (Figure 6.1(a)). We are given the task of coloring each region
either red, green, or blue in such a way that no neighboring regions have the same color. To
formulate this as a CSP, we define the variables to be the regions
X = {WA, NT, Q, NSW ,V, SA, T} .
The domain of each variable is the set Di = {red, green, blue}. The constraints require
neighboring regions to have distinct colors. Since there are nine places where regions border,
there are nine constraints:
C = {SA = WA, SA = NT, SA = Q, SA = NSW , SA = V,
WA = NT, NT = Q, Q = NSW , NSW = V } .
Here we are using abbreviations; SA = WA is a shortcut for (SA,WA), SA = WA, where
SA = WA can be fully enumerated in turn as
{(red, green),(red, blue),(green, red),(green, blue),(blue, red),(blue, green)} .
There are many possible solutions to this problem, such as
{WA = red, NT = green, Q = red, NSW = green, V = red, SA = blue, T = red }.
CONSTRAINT GRAPH It can be helpful to visualize a CSP as a constraint graph, as shown in Figure 6.1(b). The
nodes of the graph correspond to variables of the problem, and a link connects any two variables that participate in a constraint.
Why formulate a problem as a CSP? One reason is that the CSPs yield a natural representation for a wide variety of problems; if you already have a CSP-solving system, it is
often easier to solve a problem using it than to design a custom solution using another search
technique. In addition, CSP solvers can be faster than state-space searchers because the CSP
solver can quickly eliminate large swatches of the search space. For example, once we have
chosen {SA = blue} in the Australia problem, we can conclude that none of the five neighboring variables can take on the value blue. Without taking advantage of constraint propagation,
a search procedure would have to consider 35 = 243 assignments for the five neighboring
variables; with constraint propagation we never have to consider blue as a value, so we have
only 25 = 32 assignments to look at, a reduction of 87%.
In regular state-space search we can only ask: is this specific state a goal? No? What
about this one? With CSPs, once we find out that a partial assignment is not a solution, we can
204 Chapter 6. Constraint Satisfaction Problems
Western
Australia
Northern
Territory
South
Australia
Queensland
New
South
Wales
Victoria
Tasmania
WA
NT
SA
Q
NSW
V
T
(a) (b)
Figure 6.1 (a) The principal states and territories of Australia. Coloring this map can
be viewed as a constraint satisfaction problem (CSP). The goal is to assign colors to each
region so that no neighboring regions have the same color. (b) The map-coloring problem
represented as a constraint graph.
immediately discard further refinements of the partial assignment. Furthermore, we can see
why the assignment is not a solution—we see which variables violate a constraint—so we can
focus attention on the variables that matter. As a result, many problems that are intractable
for regular state-space search can be solved quickly when formulated as a CSP.
6.1.2 Example problem: Job-shop scheduling
Factories have the problem of scheduling a day’s worth of jobs, subject to various constraints.
In practice, many of these problems are solved with CSP techniques. Consider the problem of
scheduling the assembly of a car. The whole job is composed of tasks, and we can model each
task as a variable, where the value of each variable is the time that the task starts, expressed
as an integer number of minutes. Constraints can assert that one task must occur before
another—for example, a wheel must be installed before the hubcap is put on—and that only
so many tasks can go on at once. Constraints can also specify that a task takes a certain
amount of time to complete.
We consider a small part of the car assembly, consisting of 15 tasks: install axles (front
and back), affix all four wheels (right and left, front and back), tighten nuts for each wheel,
affix hubcaps, and inspect the final assembly. We can represent the tasks with 15 variables:
X = {AxleF , AxleB,Wheel RF ,Wheel LF ,Wheel RB,Wheel LB, NutsRF ,
NutsLF , NutsRB, NutsLB, CapRF , CapLF , CapRB, CapLB,Inspect} .
The value of each variable is the time that the task starts. Next we represent precedence
constraints between individual tasks. Whenever a task T1 must occur before task T2, and PRECEDENCE
CONSTRAINTS
task T1 takes duration d1 to complete, we add an arithmetic constraint of the form
T1 + d1 ≤ T2 .
Section 6.1. Defining Constraint Satisfaction Problems 205
In our example, the axles have to be in place before the wheels are put on, and it takes 10
minutes to install an axle, so we write
AxleF + 10 ≤ Wheel RF ; AxleF + 10 ≤ Wheel LF ;
AxleB + 10 ≤ Wheel RB; AxleB + 10 ≤ Wheel LB .
Next we say that, for each wheel, we must affix the wheel (which takes 1 minute), then tighten
the nuts (2 minutes), and finally attach the hubcap (1 minute, but not represented yet):
Wheel RF + 1 ≤ NutsRF ; NutsRF + 2 ≤ CapRF ;
Wheel LF + 1 ≤ NutsLF ; NutsLF + 2 ≤ CapLF ;
Wheel RB + 1 ≤ NutsRB; NutsRB + 2 ≤ CapRB;
Wheel LB + 1 ≤ NutsLB; NutsLB + 2 ≤ CapLB .
Suppose we have four workers to install wheels, but they have to share one tool that helps put
the axle in place. We need a disjunctive constraint to say that AxleF and AxleB must not DISJUNCTIVE
CONSTRAINT
overlap in time; either one comes first or the other does:
(AxleF + 10 ≤ AxleB) or (AxleB + 10 ≤ AxleF ) .
This looks like a more complicated constraint, combining arithmetic and logic. But it still
reduces to a set of pairs of values that AxleF and AxleF can take on.
We also need to assert that the inspection comes last and takes 3 minutes. For every
variable except Inspect we add a constraint of the form X + dX ≤ Inspect. Finally, suppose
there is a requirement to get the whole assembly done in 30 minutes. We can achieve that by
limiting the domain of all variables:
Di = {1, 2, 3,..., 27} .
This particular problem is trivial to solve, but CSPs have been applied to job-shop scheduling problems like this with thousands of variables. In some cases, there are complicated
constraints that are difficult to specify in the CSP formalism, and more advanced planning
techniques are used, as discussed in Chapter 11.
6.1.3 Variations on the CSP formalism
DISCRETE DOMAIN The simplest kind of CSP involves variables that have discrete, finite domains. MapFINITE DOMAIN coloring problems and scheduling with time limits are both of this kind. The 8-queens problem described in Chapter 3 can also be viewed as a finite-domain CSP, where the variables
Q1,...,Q8 are the positions of each queen in columns 1,..., 8 and each variable has the
domain Di = {1, 2, 3, 4, 5, 6, 7, 8}.
INFINITE A discrete domain can be infinite, such as the set of integers or strings. (If we didn’t put
a deadline on the job-scheduling problem, there would be an infinite number of start times
for each variable.) With infinite domains, it is no longer possible to describe constraints by
enumerating all allowed combinations of values. Instead, a constraint language must be CONSTRAINT
LANGUAGE
used that understands constraints such as T1 + d1 ≤ T2 directly, without enumerating the
set of pairs of allowable values for (T1, T2). Special solution algorithms (which we do not
discuss here) exist for linear constraints on integer variables—that is, constraints, such as LINEAR
CONSTRAINTS
the one just given, in which each variable appears only in linear form. It can be shown that
no algorithm exists for solving general nonlinear constraints on integer variables. NONLINEAR
CONSTRAINTS
206 Chapter 6. Constraint Satisfaction Problems
Constraint satisfaction problems with continuous domains are common in the real CONTINUOUS
DOMAINS
world and are widely studied in the field of operations research. For example, the scheduling
of experiments on the Hubble Space Telescope requires very precise timing of observations;
the start and finish of each observation and maneuver are continuous-valued variables that
must obey a variety of astronomical, precedence, and power constraints. The best-known
category of continuous-domain CSPs is that of linear programming problems, where constraints must be linear equalities or inequalities. Linear programming problems can be solved
in time polynomial in the number of variables. Problems with different types of constraints
and objective functions have also been studied—quadratic programming, second-order conic
programming, and so on.
In addition to examining the types of variables that can appear in CSPs, it is useful to
UNARY CONSTRAINT look at the types of constraints. The simplest type is the unary constraint, which restricts
the value of a single variable. For example, in the map-coloring problem it could be the case
that South Australians won’t tolerate the color green; we can express that with the unary
constraint (SA), SA = green
BINARY CONSTRAINT A binary constraint relates two variables. For example, SA = NSW is a binary
constraint. A binary CSP is one with only binary constraints; it can be represented as a
constraint graph, as in Figure 6.1(b).
We can also describe higher-order constraints, such as asserting that the value of Y is
between X and Z, with the ternary constraint Between(X, Y, Z).
A constraint involving an arbitrary number of variables is called a global constraint. GLOBAL
CONSTRAINT
(The name is traditional but confusing because it need not involve all the variables in a problem). One of the most common global constraints is Alldiff , which says that all of the
variables involved in the constraint must have different values. In Sudoku problems (see
Section 6.2.6), all variables in a row or column must satisfy an Alldiff constraint. AnCRYPTARITHMETIC other example is provided by cryptarithmetic puzzles. (See Figure 6.2(a).) Each letter in a
cryptarithmetic puzzle represents a different digit. For the case in Figure 6.2(a), this would
be represented as the global constraint Alldiff (F, T, U, W, R, O). The addition constraints
on the four columns of the puzzle can be written as the following n-ary constraints:
O + O = R + 10 · C10
C10 + W + W = U + 10 · C100
C100 + T + T = O + 10 · C1000
C1000 = F ,
where C10, C100, and C1000 are auxiliary variables representing the digit carried over into the
tens, hundreds, or thousands column. These constraints can be represented in a constraint
hypergraph, such as the one shown in Figure 6.2(b). A hypergraph consists of ordinary nodes CONSTRAINT
HYPERGRAPH
(the circles in the figure) and hypernodes (the squares), which represent n-ary constraints.
Alternatively, as Exercise 6.6 asks you to prove, every finite-domain constraint can be
reduced to a set of binary constraints if enough auxiliary variables are introduced, so we could
transform any CSP into one with only binary constraints; this makes the algorithms simpler.
DUAL GRAPH Another way to convert an n-ary CSP to a binary one is the dual graph transformation: create
a new graph in which there will be one variable for each constraint in the original graph, and
Section 6.1. Defining Constraint Satisfaction Problems 207
(a)
F T U W R O
(b)
+
F
T
T
O
W
W
U
O
O
R
C3 C2 C1
Figure 6.2 (a) A cryptarithmetic problem. Each letter stands for a distinct digit; the aim is
to find a substitution of digits for letters such that the resulting sum is arithmetically correct,
with the added restriction that no leading zeroes are allowed. (b) The constraint hypergraph
for the cryptarithmetic problem, showing the Alldiff constraint (square box at the top) as
well as the column addition constraints (four square boxes in the middle). The variables C1,
C2, and C3 represent the carry digits for the three columns.
one binary constraint for each pair of constraints in the original graph that share variables. For
example, if the original graph has variables {X, Y, Z} and constraints (X, Y, Z), C1 and
(X, Y ), C2 then the dual graph would have variables {C1, C2} with the binary constraint
(X, Y ), R1, where (X, Y ) are the shared variables and R1 is a new relation that defines the
constraint between the shared variables, as specified by the original C1 and C2.
There are however two reasons why we might prefer a global constraint such as Alldiff
rather than a set of binary constraints. First, it is easier and less error-prone to write the
problem description using Alldiff . Second, it is possible to design special-purpose inference
algorithms for global constraints that are not available for a set of more primitive constraints.
We describe these inference algorithms in Section 6.2.5.
The constraints we have described so far have all been absolute constraints, violation of
which rules out a potential solution. Many real-world CSPs include preference constraints PREFERENCE
CONSTRAINTS
indicating which solutions are preferred. For example, in a university class-scheduling problem there are absolute constraints that no professor can teach two classes at the same time.
But we also may allow preference constraints: Prof. R might prefer teaching in the morning,
whereas Prof. N prefers teaching in the afternoon. A schedule that has Prof. R teaching at
2 p.m. would still be an allowable solution (unless Prof. R happens to be the department chair)
but would not be an optimal one. Preference constraints can often be encoded as costs on individual variable assignments—for example, assigning an afternoon slot for Prof. R costs
2 points against the overall objective function, whereas a morning slot costs 1. With this
formulation, CSPs with preferences can be solved with optimization search methods, either
path-based or local. We call such a problem a constraint optimization problem, or COP. CONSTRAINT
OPTIMIZATION
PROBLEM
Linear programming problems do this kind of optimization.
208 Chapter 6. Constraint Satisfaction Problems
6.2 CONSTRAINT PROPAGATION: INFERENCE IN CSPS
In regular state-space search, an algorithm can do only one thing: search. In CSPs there is a
choice: an algorithm can search (choose a new variable assignment from several possibilities)
INFERENCE or do a specific type of inference called constraint propagation: using the constraints to
CONSTRAINT
PROPAGATION reduce the number of legal values for a variable, which in turn can reduce the legal values
for another variable, and so on. Constraint propagation may be intertwined with search, or it
may be done as a preprocessing step, before search starts. Sometimes this preprocessing can
solve the whole problem, so no search is required at all.
The key idea is local consistency. If we treat each variable as a node in a graph (see LOCAL
CONSISTENCY
Figure 6.1(b)) and each binary constraint as an arc, then the process of enforcing local consistency in each part of the graph causes inconsistent values to be eliminated throughout the
graph. There are different types of local consistency, which we now cover in turn.
6.2.1 Node consistency
NODE CONSISTENCY A single variable (corresponding to a node in the CSP network) is node-consistent if all
the values in the variable’s domain satisfy the variable’s unary constraints. For example,
in the variant of the Australia map-coloring problem (Figure 6.1) where South Australians
dislike green, the variable SA starts with domain {red, green, blue}, and we can make it
node consistent by eliminating green, leaving SA with the reduced domain {red, blue}. We
say that a network is node-consistent if every variable in the network is node-consistent.
It is always possible to eliminate all the unary constraints in a CSP by running node
consistency. It is also possible to transform all n-ary constraints into binary ones (see Exercise 6.6). Because of this, it is common to define CSP solvers that work with only binary
constraints; we make that assumption for the rest of this chapter, except where noted.
6.2.2 Arc consistency
ARC CONSISTENCY A variable in a CSP is arc-consistent if every value in its domain satisfies the variable’s
binary constraints. More formally, Xi is arc-consistent with respect to another variable Xj if
for every value in the current domain Di there is some value in the domain Dj that satisfies
the binary constraint on the arc (Xi, Xj ). A network is arc-consistent if every variable is arc
consistent with every other variable. For example, consider the constraint Y = X2 where the
domain of both X and Y is the set of digits. We can write this constraint explicitly as
(X, Y ), {(0, 0),(1, 1),(2, 4),(3, 9))} .
To make X arc-consistent with respect to Y , we reduce X’s domain to {0, 1, 2, 3}. If we
also make Y arc-consistent with respect to X, then Y ’s domain becomes {0, 1, 4, 9} and the
whole CSP is arc-consistent.
On the other hand, arc consistency can do nothing for the Australia map-coloring problem. Consider the following inequality constraint on (SA,WA):
{(red, green),(red, blue),(green, red),(green, blue),(blue, red),(blue, green)} .
Section 6.2. Constraint Propagation: Inference in CSPs 209
function AC-3(csp) returns false if an inconsistency is found and true otherwise
inputs: csp, a binary CSP with components (X, D, C)
local variables: queue, a queue of arcs, initially all the arcs in csp
while queue is not empty do
(Xi, Xj )← REMOVE-FIRST(queue)
if REVISE(csp, Xi, Xj ) then
if size of Di = 0 then return false
for each Xk in Xi.NEIGHBORS - {Xj} do
add (Xk, Xi) to queue
return true
function REVISE(csp, Xi, Xj ) returns true iff we revise the domain of Xi
revised ← false
for each x in Di do
if no value y in Dj allows (x ,y) to satisfy the constraint between Xi and Xj then
delete x from Di
revised ← true
return revised
Figure 6.3 The arc-consistency algorithm AC-3. After applying AC-3, either every arc
is arc-consistent, or some variable has an empty domain, indicating that the CSP cannot be
solved. The name “AC-3” was used by the algorithm’s inventor (Mackworth, 1977) because
it’s the third version developed in the paper.
No matter what value you choose for SA (or for WA), there is a valid value for the other
variable. So applying arc consistency has no effect on the domains of either variable.
The most popular algorithm for arc consistency is called AC-3 (see Figure 6.3). To
make every variable arc-consistent, the AC-3 algorithm maintains a queue of arcs to consider.
(Actually, the order of consideration is not important, so the data structure is really a set, but
tradition calls it a queue.) Initially, the queue contains all the arcs in the CSP. AC-3 then pops
off an arbitrary arc (Xi, Xj ) from the queue and makes Xi arc-consistent with respect to Xj .
If this leaves Di unchanged, the algorithm just moves on to the next arc. But if this revises
Di (makes the domain smaller), then we add to the queue all arcs (Xk, Xi) where Xk is a
neighbor of Xi. We need to do that because the change in Di might enable further reductions
in the domains of Dk, even if we have previously considered Xk. If Di is revised down to
nothing, then we know the whole CSP has no consistent solution, and AC-3 can immediately
return failure. Otherwise, we keep checking, trying to remove values from the domains of
variables until no more arcs are in the queue. At that point, we are left with a CSP that is
equivalent to the original CSP—they both have the same solutions—but the arc-consistent
CSP will in most cases be faster to search because its variables have smaller domains.
The complexity of AC-3 can be analyzed as follows. Assume a CSP with n variables,
each with domain size at most d, and with c binary constraints (arcs). Each arc (Xk, Xi) can
be inserted in the queue only d times because Xi has at most d values to delete. Checking
210 Chapter 6. Constraint Satisfaction Problems
consistency of an arc can be done in O(d2) time, so we get O(cd3) total worst-case time.1
It is possible to extend the notion of arc consistency to handle n-ary rather than just
binary constraints; this is called generalized arc consistency or sometimes hyperarc consistency, depending on the author. A variable Xi is generalized arc consistent with respect to GENERALIZED ARC
CONSISTENT
an n-ary constraint if for every value v in the domain of Xi there exists a tuple of values that
is a member of the constraint, has all its values taken from the domains of the corresponding
variables, and has its Xi component equal to v. For example, if all variables have the domain {0, 1, 2, 3}, then to make the variable X consistent with the constraint X<Y <Z,
we would have to eliminate 2 and 3 from the domain of X because the constraint cannot be
satisfied when X is 2 or 3.
6.2.3 Path consistency
Arc consistency can go a long way toward reducing the domains of variables, sometimes
finding a solution (by reducing every domain to size 1) and sometimes finding that the CSP
cannot be solved (by reducing some domain to size 0). But for other networks, arc consistency
fails to make enough inferences. Consider the map-coloring problem on Australia, but with
only two colors allowed, red and blue. Arc consistency can do nothing because every variable
is already arc consistent: each can be red with blue at the other end of the arc (or vice versa).
But clearly there is no solution to the problem: because Western Australia, Northern Territory
and South Australia all touch each other, we need at least three colors for them alone.
Arc consistency tightens down the domains (unary constraints) using the arcs (binary
constraints). To make progress on problems like map coloring, we need a stronger notion of
PATH CONSISTENCY consistency. Path consistency tightens the binary constraints by using implicit constraints
that are inferred by looking at triples of variables.
A two-variable set {Xi, Xj} is path-consistent with respect to a third variable Xm if,
for every assignment {Xi = a, Xj = b} consistent with the constraints on {Xi, Xj}, there is
an assignment to Xm that satisfies the constraints on {Xi, Xm} and {Xm, Xj}. This is called
path consistency because one can think of it as looking at a path from Xi to Xj with Xm in
the middle.
Let’s see how path consistency fares in coloring the Australia map with two colors. We
will make the set {WA, SA} path consistent with respect to NT. We start by enumerating the
consistent assignments to the set. In this case, there are only two: {WA = red, SA = blue}
and {WA = blue, SA = red}. We can see that with both of these assignments NT can be
neither red nor blue (because it would conflict with either WA or SA). Because there is no
valid choice for NT, we eliminate both assignments, and we end up with no valid assignments
for {WA, SA}. Therefore, we know that there can be no solution to this problem. The PC-2
algorithm (Mackworth, 1977) achieves path consistency in much the same way that AC-3
achieves arc consistency. Because it is so similar, we do not show it here.
1 The AC-4 algorithm (Mohr and Henderson, 1986) runs in O(cd2) worst-case time but can be slower than AC-3
on average cases. See Exercise 6.13.
Section 6.2. Constraint Propagation: Inference in CSPs 211
6.2.4 K-consistency
K-CONSISTENCY Stronger forms of propagation can be defined with the notion of k-consistency. A CSP is
k-consistent if, for any set of k − 1 variables and for any consistent assignment to those
variables, a consistent value can always be assigned to any kth variable. 1-consistency says
that, given the empty set, we can make any set of one variable consistent: this is what we
called node consistency. 2-consistency is the same as arc consistency. For binary constraint
networks, 3-consistency is the same as path consistency.
A CSP is strongly k-consistent if it is k-consistent and is also (k − 1)-consistent, STRONGLY
K-CONSISTENT
(k − 2)-consistent, ... all the way down to 1-consistent. Now suppose we have a CSP with
n nodes and make it strongly n-consistent (i.e., strongly k-consistent for k = n). We can
then solve the problem as follows: First, we choose a consistent value for X1. We are then
guaranteed to be able to choose a value for X2 because the graph is 2-consistent, for X3
because it is 3-consistent, and so on. For each variable Xi, we need only search through the d
values in the domain to find a value consistent with X1,...,Xi−1. We are guaranteed to find
a solution in time O(n2d). Of course, there is no free lunch: any algorithm for establishing
n-consistency must take time exponential in n in the worst case. Worse, n-consistency also
requires space that is exponential in n. The memory issue is even more severe than the time.
In practice, determining the appropriate level of consistency checking is mostly an empirical
science. It can be said practitioners commonly compute 2-consistency and less commonly
3-consistency.
6.2.5 Global constraints
Remember that a global constraint is one involving an arbitrary number of variables (but not
necessarily all variables). Global constraints occur frequently in real problems and can be
handled by special-purpose algorithms that are more efficient than the general-purpose methods described so far. For example, the Alldiff constraint says that all the variables involved
must have distinct values (as in the cryptarithmetic problem above and Sudoku puzzles below). One simple form of inconsistency detection for Alldiff constraints works as follows:
if m variables are involved in the constraint, and if they have n possible distinct values altogether, and m>n, then the constraint cannot be satisfied.
This leads to the following simple algorithm: First, remove any variable in the constraint that has a singleton domain, and delete that variable’s value from the domains of the
remaining variables. Repeat as long as there are singleton variables. If at any point an empty
domain is produced or there are more variables than domain values left, then an inconsistency
has been detected.
This method can detect the inconsistency in the assignment {WA = red, NSW = red}
for Figure 6.1. Notice that the variables SA, NT, and Q are effectively connected by an
Alldiff constraint because each pair must have two different colors. After applying AC-3
with the partial assignment, the domain of each variable is reduced to {green, blue}. That
is, we have three variables and only two colors, so the Alldiff constraint is violated. Thus,
a simple consistency procedure for a higher-order constraint is sometimes more effective
than applying arc consistency to an equivalent set of binary constraints. There are more
212 Chapter 6. Constraint Satisfaction Problems
complex inference algorithms for Alldiff (see van Hoeve and Katriel, 2006) that propagate
more constraints but are more computationally expensive to run.
Another important higher-order constraint is the resource constraint, sometimes called RESOURCE
CONSTRAINT
the atmost constraint. For example, in a scheduling problem, let P1,...,P4 denote the
numbers of personnel assigned to each of four tasks. The constraint that no more than 10
personnel are assigned in total is written as Atmost(10, P1, P2, P3, P4). We can detect an
inconsistency simply by checking the sum of the minimum values of the current domains;
for example, if each variable has the domain {3, 4, 5, 6}, the Atmost constraint cannot be
satisfied. We can also enforce consistency by deleting the maximum value of any domain if it
is not consistent with the minimum values of the other domains. Thus, if each variable in our
example has the domain {2, 3, 4, 5, 6}, the values 5 and 6 can be deleted from each domain.
For large resource-limited problems with integer values—such as logistical problems
involving moving thousands of people in hundreds of vehicles—it is usually not possible to
represent the domain of each variable as a large set of integers and gradually reduce that set by
consistency-checking methods. Instead, domains are represented by upper and lower bounds
and are managed by bounds propagation. For example, in an airline-scheduling problem, BOUNDS
PROPAGATION
let’s suppose there are two flights, F1 and F2, for which the planes have capacities 165 and
385, respectively. The initial domains for the numbers of passengers on each flight are then
D1 = [0, 165] and D2 = [0, 385] .
Now suppose we have the additional constraint that the two flights together must carry 420
people: F1 + F2 = 420. Propagating bounds constraints, we reduce the domains to
D1 = [35, 165] and D2 = [255, 385] .
We say that a CSP is bounds consistent if for every variable X, and for both the lower- BOUNDS
CONSISTENT
bound and upper-bound values of X, there exists some value of Y that satisfies the constraint
between X and Y for every variable Y . This kind of bounds propagation is widely used in
practical constraint problems.
6.2.6 Sudoku example
SUDOKU The popular Sudoku puzzle has introduced millions of people to constraint satisfaction problems, although they may not recognize it. A Sudoku board consists of 81 squares, some of
which are initially filled with digits from 1 to 9. The puzzle is to fill in all the remaining
squares such that no digit appears twice in any row, column, or 3 × 3 box (see Figure 6.4). A
row, column, or box is called a unit.
The Sudoku puzzles that are printed in newspapers and puzzle books have the property
that there is exactly one solution. Although some can be tricky to solve by hand, taking tens
of minutes, even the hardest Sudoku problems yield to a CSP solver in less than 0.1 second.
A Sudoku puzzle can be considered a CSP with 81 variables, one for each square. We
use the variable names A1 through A9 for the top row (left to right), down to I1 through I9
for the bottom row. The empty squares have the domain {1, 2, 3, 4, 5, 6, 7, 8, 9} and the prefilled squares have a domain consisting of a single value. In addition, there are 27 different
Section 6.2. Constraint Propagation: Inference in CSPs 213
326
9 35 1
18 64
81 29
7 8
67 82
26 95
8 23 9
513
326
9 35 1
18 64
81 29
7 8
67 82
26 95
8 23 9
513
48 9 1 57
67 4 82
25 7 93
54 3 76
2956413
13 9 45
37 8 14
14 5 76
69 4 7 82
123456789
A
B
C
D
E
F
G
H
 I
A
B
C
D
E
F
G
H
 I
123456789
(a) (b)
Figure 6.4 (a) A Sudoku puzzle and (b) its solution.
Alldiff constraints: one for each row, column, and box of 9 squares.
Alldiff (A1, A2, A3, A4, A5, A6, A7, A8, A9)
Alldiff (B1, B2, B3, B4, B5, B6, B7, B8, B9)
···
Alldiff (A1, B1, C1, D1, E1, F1, G1, H1, I1)
Alldiff (A2, B2, C2, D2, E2, F2, G2, H2, I2)
···
Alldiff (A1, A2, A3, B1, B2, B3, C1, C2, C3)
Alldiff (A4, A5, A6, B4, B5, B6, C4, C5, C6)
···
Let us see how far arc consistency can take us. Assume that the Alldiff constraints have been
expanded into binary constraints (such as A1 = A2 ) so that we can apply the AC-3 algorithm
directly. Consider variable E6 from Figure 6.4(a)—the empty square between the 2 and the
8 in the middle box. From the constraints in the box, we can remove not only 2 and 8 but also
1 and 7 from E6’s domain. From the constraints in its column, we can eliminate 5, 6, 2, 8,
9, and 3. That leaves E6 with a domain of {4}; in other words, we know the answer for E6.
Now consider variable I6—the square in the bottom middle box surrounded by 1, 3, and 3.
Applying arc consistency in its column, we eliminate 5, 6, 2, 4 (since we now know E6 must
be 4), 8, 9, and 3. We eliminate 1 by arc consistency with I5 , and we are left with only the
value 7 in the domain of I6. Now there are 8 known values in column 6, so arc consistency
can infer that A6 must be 1. Inference continues along these lines, and eventually, AC-3 can
solve the entire puzzle—all the variables have their domains reduced to a single value, as
shown in Figure 6.4(b).
Of course, Sudoku would soon lose its appeal if every puzzle could be solved by a
214 Chapter 6. Constraint Satisfaction Problems
mechanical application of AC-3, and indeed AC-3 works only for the easiest Sudoku puzzles.
Slightly harder ones can be solved by PC-2, but at a greater computational cost: there are
255,960 different path constraints to consider in a Sudoku puzzle. To solve the hardest puzzles
and to make efficient progress, we will have to be more clever.
Indeed, the appeal of Sudoku puzzles for the human solver is the need to be resourceful
in applying more complex inference strategies. Aficionados give them colorful names, such
as “naked triples.” That strategy works as follows: in any unit (row, column or box), find
three squares that each have a domain that contains the same three numbers or a subset of
those numbers. For example, the three domains might be {1, 8}, {3, 8}, and {1, 3, 8}. From
that we don’t know which square contains 1, 3, or 8, but we do know that the three numbers
must be distributed among the three squares. Therefore we can remove 1, 3, and 8 from the
domains of every other square in the unit.
It is interesting to note how far we can go without saying much that is specific to Sudoku. We do of course have to say that there are 81 variables, that their domains are the digits
1 to 9, and that there are 27 Alldiff constraints. But beyond that, all the strategies—arc consistency, path consistency, etc.—apply generally to all CSPs, not just to Sudoku problems.
Even naked triples is really a strategy for enforcing consistency of Alldiff constraints and
has nothing to do with Sudoku per se. This is the power of the CSP formalism: for each new
problem area, we only need to define the problem in terms of constraints; then the general
constraint-solving mechanisms can take over.
6.3 BACKTRACKING SEARCH FOR CSPS
Sudoku problems are designed to be solved by inference over constraints. But many other
CSPs cannot be solved by inference alone; there comes a time when we must search for a
solution. In this section we look at backtracking search algorithms that work on partial assignments; in the next section we look at local search algorithms over complete assignments.
We could apply a standard depth-limited search (from Chapter 3). A state would be a
partial assignment, and an action would be adding var = value to the assignment. But for a
CSP with n variables of domain size d, we quickly notice something terrible: the branching
factor at the top level is nd because any of d values can be assigned to any of n variables. At
the next level, the branching factor is (n − 1)d, and so on for n levels. We generate a tree
with n! · dn leaves, even though there are only dn possible complete assignments!
Our seemingly reasonable but naive formulation ignores crucial property common to
COMMUTATIVITY all CSPs: commutativity. A problem is commutative if the order of application of any given
set of actions has no effect on the outcome. CSPs are commutative because when assigning
values to variables, we reach the same partial assignment regardless of order. Therefore, we
need only consider a single variable at each node in the search tree. For example, at the root
node of a search tree for coloring the map of Australia, we might make a choice between
SA = red, SA = green, and SA = blue, but we would never choose between SA = red and
WA = blue. With this restriction, the number of leaves is dn, as we would hope.
Section 6.3. Backtracking Search for CSPs 215
function BACKTRACKING-SEARCH(csp) returns a solution, or failure
return BACKTRACK({ }, csp)
function BACKTRACK(assignment, csp) returns a solution, or failure
if assignment is complete then return assignment
var ← SELECT-UNASSIGNED-VARIABLE(csp)
for each value in ORDER-DOMAIN-VALUES(var , assignment, csp) do
if value is consistent with assignment then
add {var = value} to assignment
inferences ← INFERENCE(csp, var , value)
if inferences = failure then
add inferences to assignment
result ← BACKTRACK(assignment, csp)
if result = failure then
return result
remove {var = value} and inferences from assignment
return failure
Figure 6.5 A simple backtracking algorithm for constraint satisfaction problems. The algorithm is modeled on the recursive depth-first search of Chapter 3. By varying the functions
SELECT-UNASSIGNED-VARIABLE and ORDER-DOMAIN-VALUES, we can implement the
general-purpose heuristics discussed in the text. The function INFERENCE can optionally be
used to impose arc-, path-, or k-consistency, as desired. If a value choice leads to failure
(noticed either by INFERENCE or by BACKTRACK), then value assignments (including those
made by INFERENCE) are removed from the current assignment and a new value is tried.
The term backtracking search is used for a depth-first search that chooses values for BACKTRACKING
SEARCH
one variable at a time and backtracks when a variable has no legal values left to assign. The
algorithm is shown in Figure 6.5. It repeatedly chooses an unassigned variable, and then tries
all values in the domain of that variable in turn, trying to find a solution. If an inconsistency is
detected, then BACKTRACK returns failure, causing the previous call to try another value. Part
of the search tree for the Australia problem is shown in Figure 6.6, where we have assigned
variables in the order WA, NT, Q, . . .. Because the representation of CSPs is standardized,
there is no need to supply BACKTRACKING-SEARCH with a domain-specific initial state,
action function, transition model, or goal test.
Notice that BACKTRACKING-SEARCH keeps only a single representation of a state and
alters that representation rather than creating new ones, as described on page 87.
In Chapter 3 we improved the poor performance of uninformed search algorithms by
supplying them with domain-specific heuristic functions derived from our knowledge of the
problem. It turns out that we can solve CSPs efficiently without such domain-specific knowledge. Instead, we can add some sophistication to the unspecified functions in Figure 6.5,
using them to address the following questions:
1. Which variable should be assigned next (SELECT-UNASSIGNED-VARIABLE), and in
what order should its values be tried (ORDER-DOMAIN-VALUES)?
216 Chapter 6. Constraint Satisfaction Problems
WA=red WA=green WA=blue
WA=red
NT=blue
WA=red
NT=green
WA=red
NT=green
Q=red
WA=red
NT=green
Q=blue
Figure 6.6 Part of the search tree for the map-coloring problem in Figure 6.1.
2. What inferences should be performed at each step in the search (INFERENCE)?
3. When the search arrives at an assignment that violates a constraint, can the search avoid
repeating this failure?
The subsections that follow answer each of these questions in turn.
6.3.1 Variable and value ordering
The backtracking algorithm contains the line
var ← SELECT-UNASSIGNED-VARIABLE(csp) .
The simplest strategy for SELECT-UNASSIGNED-VARIABLE is to choose the next unassigned
variable in order, {X1, X2,...}. This static variable ordering seldom results in the most efficient search. For example, after the assignments for WA = red and NT = green in Figure 6.6,
there is only one possible value for SA, so it makes sense to assign SA = blue next rather than
assigning Q. In fact, after SA is assigned, the choices for Q, NSW , and V are all forced. This
intuitive idea—choosing the variable with the fewest “legal” values—is called the minimumremaining-values (MRV) heuristic. It also has been called the “most constrained variable” or MINIMUMREMAINING-VALUES
“fail-first” heuristic, the latter because it picks a variable that is most likely to cause a failure
soon, thereby pruning the search tree. If some variable X has no legal values left, the MRV
heuristic will select X and failure will be detected immediately—avoiding pointless searches
through other variables. The MRV heuristic usually performs better than a random or static
ordering, sometimes by a factor of 1,000 or more, although the results vary widely depending
on the problem.
The MRV heuristic doesn’t help at all in choosing the first region to color in Australia,
DEGREE HEURISTIC because initially every region has three legal colors. In this case, the degree heuristic comes
in handy. It attempts to reduce the branching factor on future choices by selecting the variable that is involved in the largest number of constraints on other unassigned variables. In
Figure 6.1, SA is the variable with highest degree, 5; the other variables have degree 2 or 3,
except for T, which has degree 0. In fact, once SA is chosen, applying the degree heuristic solves the problem without any false steps—you can choose any consistent color at each
choice point and still arrive at a solution with no backtracking. The minimum-remaining-
Section 6.3. Backtracking Search for CSPs 217
values heuristic is usually a more powerful guide, but the degree heuristic can be useful as a
tie-breaker.
Once a variable has been selected, the algorithm must decide on the order in which to
examine its values. For this, the least-constraining-value heuristic can be effective in some LEASTCONSTRAININGVALUE
cases. It prefers the value that rules out the fewest choices for the neighboring variables in
the constraint graph. For example, suppose that in Figure 6.1 we have generated the partial
assignment with WA = red and NT = green and that our next choice is for Q. Blue would
be a bad choice because it eliminates the last legal value left for Q’s neighbor, SA. The
least-constraining-value heuristic therefore prefers red to blue. In general, the heuristic is
trying to leave the maximum flexibility for subsequent variable assignments. Of course, if we
are trying to find all the solutions to a problem, not just the first one, then the ordering does
not matter because we have to consider every value anyway. The same holds if there are no
solutions to the problem.
Why should variable selection be fail-first, but value selection be fail-last? It turns out
that, for a wide variety of problems, a variable ordering that chooses a variable with the
minimum number of remaining values helps minimize the number of nodes in the search tree
by pruning larger parts of the tree earlier. For value ordering, the trick is that we only need
one solution; therefore it makes sense to look for the most likely values first. If we wanted to
enumerate all solutions rather than just find one, then value ordering would be irrelevant.
6.3.2 Interleaving search and inference
So far we have seen how AC-3 and other algorithms can infer reductions in the domain of
variables before we begin the search. But inference can be even more powerful in the course
of a search: every time we make a choice of a value for a variable, we have a brand-new
opportunity to infer new domain reductions on the neighboring variables.
One of the simplest forms of inference is called forward checking. Whenever a vari- FORWARD
CHECKING
able X is assigned, the forward-checking process establishes arc consistency for it: for each
unassigned variable Y that is connected to X by a constraint, delete from Y ’s domain any
value that is inconsistent with the value chosen for X. Because forward checking only does
arc consistency inferences, there is no reason to do forward checking if we have already done
arc consistency as a preprocessing step.
Figure 6.7 shows the progress of backtracking search on the Australia CSP with forward checking. There are two important points to notice about this example. First, notice
that after WA = red and Q = green are assigned, the domains of NT and SA are reduced
to a single value; we have eliminated branching on these variables altogether by propagating information from WA and Q. A second point to notice is that after V = blue, the domain of SA is empty. Hence, forward checking has detected that the partial assignment
{WA = red, Q = green, V = blue} is inconsistent with the constraints of the problem, and
the algorithm will therefore backtrack immediately.
For many problems the search will be more effective if we combine the MRV heuristic with forward checking. Consider Figure 6.7 after assigning {WA = red}. Intuitively, it
seems that that assignment constrains its neighbors, NT and SA, so we should handle those
218 Chapter 6. Constraint Satisfaction Problems
Initial domains
After WA=red
After Q=green
After V=blue
R G B
R
R B
R G B
R G B
B
R G B
R G B
R G B
R
R
R
R G B
B
B
G B
R G B
G
G
R G B
R G B
B
G B
R G B
R G B
R G B
R G B
WA T NT Q NSW V SA
Figure 6.7 The progress of a map-coloring search with forward checking. WA = red
is assigned first; then forward checking deletes red from the domains of the neighboring
variables NT and SA. After Q = green is assigned, green is deleted from the domains of
NT, SA, and NSW . After V = blue is assigned, blue is deleted from the domains of NSW
and SA, leaving SA with no legal values.
variables next, and then all the other variables will fall into place. That’s exactly what happens with MRV: NT and SA have two values, so one of them is chosen first, then the other,
then Q, NSW , and V in order. Finally T still has three values, and any one of them works.
We can view forward checking as an efficient way to incrementally compute the information
that the MRV heuristic needs to do its job.
Although forward checking detects many inconsistencies, it does not detect all of them.
The problem is that it makes the current variable arc-consistent, but doesn’t look ahead and
make all the other variables arc-consistent. For example, consider the third row of Figure 6.7.
It shows that when WA is red and Q is green, both NT and SA are forced to be blue. Forward
checking does not look far enough ahead to notice that this is an inconsistency: NT and SA
are adjacent and so cannot have the same value.
The algorithm called MAC (for Maintaining Arc Consistency (MAC)) detects this MAINTAINING ARC
CONSISTENCY (MAC)
inconsistency. After a variable Xi is assigned a value, the INFERENCE procedure calls AC-3,
but instead of a queue of all arcs in the CSP, we start with only the arcs (Xj , Xi) for all
Xj that are unassigned variables that are neighbors of Xi. From there, AC-3 does constraint
propagation in the usual way, and if any variable has its domain reduced to the empty set, the
call to AC-3 fails and we know to backtrack immediately. We can see that MAC is strictly
more powerful than forward checking because forward checking does the same thing as MAC
on the initial arcs in MAC’s queue; but unlike MAC, forward checking does not recursively
propagate constraints when changes are made to the domains of variables.
6.3.3 Intelligent backtracking: Looking backward
The BACKTRACKING-SEARCH algorithm in Figure 6.5 has a very simple policy for what to
do when a branch of the search fails: back up to the preceding variable and try a different
value for it. This is called chronological backtracking because the most recent decision CHRONOLOGICAL
BACKTRACKING
point is revisited. In this subsection, we consider better possibilities.
Consider what happens when we apply simple backtracking in Figure 6.1 with a fixed
variable ordering Q, NSW , V , T, SA, WA, NT. Suppose we have generated the partial
assignment {Q = red, NSW = green, V = blue, T = red}. When we try the next variable,
SA, we see that every value violates a constraint. We back up to T and try a new color for
Section 6.3. Backtracking Search for CSPs 219
Tasmania! Obviously this is silly—recoloring Tasmania cannot possibly resolve the problem
with South Australia.
A more intelligent approach to backtracking is to backtrack to a variable that might fix
the problem—a variable that was responsible for making one of the possible values of SA
impossible. To do this, we will keep track of a set of assignments that are in conflict with
some value for SA. The set (in this case {Q = red, NSW = green, V = blue, }), is called the
CONFLICT SET conflict set for SA. The backjumping method backtracks to the most recent assignment in
BACKJUMPING the conflict set; in this case, backjumping would jump over Tasmania and try a new value
for V . This method is easily implemented by a modification to BACKTRACK such that it
accumulates the conflict set while checking for a legal value to assign. If no legal value is
found, the algorithm should return the most recent element of the conflict set along with the
failure indicator.
The sharp-eyed reader will have noticed that forward checking can supply the conflict
set with no extra work: whenever forward checking based on an assignment X = x deletes a
value from Y ’s domain, it should add X = x to Y ’s conflict set. If the last value is deleted
from Y ’s domain, then the assignments in the conflict set of Y are added to the conflict set
of X. Then, when we get to Y , we know immediately where to backtrack if needed.
The eagle-eyed reader will have noticed something odd: backjumping occurs when
every value in a domain is in conflict with the current assignment; but forward checking
detects this event and prevents the search from ever reaching such a node! In fact, it can be
shown that every branch pruned by backjumping is also pruned by forward checking. Hence,
simple backjumping is redundant in a forward-checking search or, indeed, in a search that
uses stronger consistency checking, such as MAC.
Despite the observations of the preceding paragraph, the idea behind backjumping remains a good one: to backtrack based on the reasons for failure. Backjumping notices failure
when a variable’s domain becomes empty, but in many cases a branch is doomed long before
this occurs. Consider again the partial assignment {WA = red, NSW = red} (which, from
our earlier discussion, is inconsistent). Suppose we try T = red next and then assign NT, Q,
V , SA. We know that no assignment can work for these last four variables, so eventually we
run out of values to try at NT. Now, the question is, where to backtrack? Backjumping cannot
work, because NT does have values consistent with the preceding assigned variables—NT
doesn’t have a complete conflict set of preceding variables that caused it to fail. We know,
however, that the four variables NT, Q, V , and SA, taken together, failed because of a set of
preceding variables, which must be those variables that directly conflict with the four. This
leads to a deeper notion of the conflict set for a variable such as NT: it is that set of preceding variables that caused NT, together with any subsequent variables, to have no consistent
solution. In this case, the set is WA and NSW , so the algorithm should backtrack to NSW
and skip over Tasmania. A backjumping algorithm that uses conflict sets defined in this way
is called conflict-directed backjumping. CONFLICT-DIRECTED
BACKJUMPING
We must now explain how these new conflict sets are computed. The method is in
fact quite simple. The “terminal” failure of a branch of the search always occurs because a
variable’s domain becomes empty; that variable has a standard conflict set. In our example,
SA fails, and its conflict set is (say) {WA, NT, Q}. We backjump to Q, and Q absorbs
220 Chapter 6. Constraint Satisfaction Problems
the conflict set from SA (minus Q itself, of course) into its own direct conflict set, which is
{NT, NSW }; the new conflict set is {WA, NT, NSW }. That is, there is no solution from
Q onward, given the preceding assignment to {WA, NT, NSW }. Therefore, we backtrack
to NT, the most recent of these. NT absorbs {WA, NT, NSW }−{NT} into its own
direct conflict set {WA}, giving {WA, NSW } (as stated in the previous paragraph). Now
the algorithm backjumps to NSW , as we would hope. To summarize: let Xj be the current
variable, and let conf (Xj ) be its conflict set. If every possible value for Xj fails, backjump
to the most recent variable Xi in conf (Xj ), and set
conf (Xi) ← conf (Xi) ∪ conf (Xj ) − {Xi} .
When we reach a contradiction, backjumping can tell us how far to back up, so we don’t
waste time changing variables that won’t fix the problem. But we would also like to avoid
running into the same problem again. When the search arrives at a contradiction, we know
that some subset of the conflict set is responsible for the problem. Constraint learning is the CONSTRAINT
LEARNING
idea of finding a minimum set of variables from the conflict set that causes the problem. This
NO-GOOD set of variables, along with their corresponding values, is called a no-good. We then record
the no-good, either by adding a new constraint to the CSP or by keeping a separate cache of
no-goods.
For example, consider the state {WA = red, NT = green, Q = blue} in the bottom
row of Figure 6.6. Forward checking can tell us this state is a no-good because there is no
valid assignment to SA. In this particular case, recording the no-good would not help, because
once we prune this branch from the search tree, we will never encounter this combination
again. But suppose that the search tree in Figure 6.6 were actually part of a larger search tree
that started by first assigning values for V and T. Then it would be worthwhile to record
{WA = red, NT = green, Q = blue} as a no-good because we are going to run into the
same problem again for each possible set of assignments to V and T.
No-goods can be effectively used by forward checking or by backjumping. Constraint
learning is one of the most important techniques used by modern CSP solvers to achieve
efficiency on complex problems.
6.4 LOCAL SEARCH FOR CSPS
Local search algorithms (see Section 4.1) turn out to be effective in solving many CSPs. They
use a complete-state formulation: the initial state assigns a value to every variable, and the
search changes the value of one variable at a time. For example, in the 8-queens problem (see
Figure 4.3), the initial state might be a random configuration of 8 queens in 8 columns, and
each step moves a single queen to a new position in its column. Typically, the initial guess
violates several constraints. The point of local search is to eliminate the violated constraints.2
In choosing a new value for a variable, the most obvious heuristic is to select the value
MIN-CONFLICTS that results in the minimum number of conflicts with other variables—the min-conflicts
2 Local search can easily be extended to constraint optimization problems (COPs). In that case, all the techniques
for hill climbing and simulated annealing can be applied to optimize the objective function.
Section 6.4. Local Search for CSPs 221
function MIN-CONFLICTS(csp, max steps) returns a solution or failure
inputs: csp, a constraint satisfaction problem
max steps, the number of steps allowed before giving up
current ← an initial complete assignment for csp
for i = 1 to max steps do
if current is a solution for csp then return current
var ← a randomly chosen conflicted variable from csp.VARIABLES
value ← the value v for var that minimizes CONFLICTS(var , v, current, csp)
set var = value in current
return failure
Figure 6.8 The MIN-CONFLICTS algorithm for solving CSPs by local search. The initial
state may be chosen randomly or by a greedy assignment process that chooses a minimalconflict value for each variable in turn. The CONFLICTS function counts the number of
constraints violated by a particular value, given the rest of the current assignment.
2
2
1
2
3
1
2
3
3
2
3
2
3
0
Figure 6.9 A two-step solution using min-conflicts for an 8-queens problem. At each
stage, a queen is chosen for reassignment in its column. The number of conflicts (in this
case, the number of attacking queens) is shown in each square. The algorithm moves the
queen to the min-conflicts square, breaking ties randomly.
heuristic. The algorithm is shown in Figure 6.8 and its application to an 8-queens problem is
diagrammed in Figure 6.9.
Min-conflicts is surprisingly effective for many CSPs. Amazingly, on the n-queens
problem, if you don’t count the initial placement of queens, the run time of min-conflicts is
roughly independent of problem size. It solves even the million-queens problem in an average of 50 steps (after the initial assignment). This remarkable observation was the stimulus
leading to a great deal of research in the 1990s on local search and the distinction between
easy and hard problems, which we take up in Chapter 7. Roughly speaking, n-queens is
easy for local search because solutions are densely distributed throughout the state space.
Min-conflicts also works well for hard problems. For example, it has been used to schedule
observations for the Hubble Space Telescope, reducing the time taken to schedule a week of
observations from three weeks (!) to around 10 minutes.
222 Chapter 6. Constraint Satisfaction Problems
All the local search techniques from Section 4.1 are candidates for application to CSPs,
and some of those have proved especially effective. The landscape of a CSP under the minconflicts heuristic usually has a series of plateaux. There may be millions of variable assignments that are only one conflict away from a solution. Plateau search—allowing sideways moves to another state with the same score—can help local search find its way off this
plateau. This wandering on the plateau can be directed with tabu search: keeping a small
list of recently visited states and forbidding the algorithm to return to those states. Simulated
annealing can also be used to escape from plateaux.
Another technique, called constraint weighting, can help concentrate the search on the CONSTRAINT
WEIGHTING
important constraints. Each constraint is given a numeric weight, Wi, initially all 1. At each
step of the search, the algorithm chooses a variable/value pair to change that will result in the
lowest total weight of all violated constraints. The weights are then adjusted by incrementing
the weight of each constraint that is violated by the current assignment. This has two benefits:
it adds topography to plateaux, making sure that it is possible to improve from the current
state, and it also, over time, adds weight to the constraints that are proving difficult to solve.
Another advantage of local search is that it can be used in an online setting when the
problem changes. This is particularly important in scheduling problems. A week’s airline
schedule may involve thousands of flights and tens of thousands of personnel assignments,
but bad weather at one airport can render the schedule infeasible. We would like to repair the
schedule with a minimum number of changes. This can be easily done with a local search
algorithm starting from the current schedule. A backtracking search with the new set of
constraints usually requires much more time and might find a solution with many changes
from the current schedule.
6.5 THE STRUCTURE OF PROBLEMS
In this section, we examine ways in which the structure of the problem, as represented by
the constraint graph, can be used to find solutions quickly. Most of the approaches here also
apply to other problems besides CSPs, such as probabilistic reasoning. After all, the only way
we can possibly hope to deal with the real world is to decompose it into many subproblems.
Looking again at the constraint graph for Australia (Figure 6.1(b), repeated as Figure 6.12(a)),
one fact stands out: Tasmania is not connected to the mainland.3 Intuitively, it is obvious that
coloring Tasmania and coloring the mainland are independent subproblems—any solution INDEPENDENT
SUBPROBLEMS
for the mainland combined with any solution for Tasmania yields a solution for the whole
map. Independence can be ascertained simply by finding connected components of the CONNECTED
COMPONENT
constraint graph. Each component corresponds to a subproblem CSPi. If assignment Si is
a solution of CSPi, then 
i Si is a solution of 
i CSPi. Why is this important? Consider
the following: suppose each CSPi has c variables from the total of n variables, where c is
a constant. Then there are n/c subproblems, each of which takes at most dc work to solve,
3 A careful cartographer or patriotic Tasmanian might object that Tasmania should not be colored the same as
its nearest mainland neighbor, to avoid the impression that it might be part of that state.
Section 6.5. The Structure of Problems 223
where d is the size of the domain. Hence, the total work is O(dcn/c), which is linear in n;
without the decomposition, the total work is O(dn), which is exponential in n. Let’s make
this more concrete: dividing a Boolean CSP with 80 variables into four subproblems reduces
the worst-case solution time from the lifetime of the universe down to less than a second.
Completely independent subproblems are delicious, then, but rare. Fortunately, some
other graph structures are also easy to solve. For example, a constraint graph is a tree when
any two variables are connected by only one path. We show that any tree-structured CSP can
be solved in time linear in the number of variables.4 The key is a new notion of consistency,
called directed arc consistency or DAC. A CSP is defined to be directed arc-consistent under DIRECTED ARC
CONSISTENCY
an ordering of variables X1, X2,...,Xn if and only if every Xi is arc-consistent with each
Xj for j>i.
To solve a tree-structured CSP, first pick any variable to be the root of the tree, and
choose an ordering of the variables such that each variable appears after its parent in the tree.
TOPOLOGICAL SORT Such an ordering is called a topological sort. Figure 6.10(a) shows a sample tree and (b)
shows one possible ordering. Any tree with n nodes has n−1 arcs, so we can make this graph
directed arc-consistent in O(n) steps, each of which must compare up to d possible domain
values for two variables, for a total time of O(nd2). Once we have a directed arc-consistent
graph, we can just march down the list of variables and choose any remaining value. Since
each link from a parent to its child is arc consistent, we know that for any value we choose for
the parent, there will be a valid value left to choose for the child. That means we won’t have
to backtrack; we can move linearly through the variables. The complete algorithm is shown
in Figure 6.11.
A
C
B D
E
F
(a)
A C B DEF
(b)
Figure 6.10 (a) The constraint graph of a tree-structured CSP. (b) A linear ordering of the
variables consistent with the tree with A as the root. This is known as a topological sort of
the variables.
Now that we have an efficient algorithm for trees, we can consider whether more general
constraint graphs can be reduced to trees somehow. There are two primary ways to do this,
one based on removing nodes and one based on collapsing nodes together.
The first approach involves assigning values to some variables so that the remaining
variables form a tree. Consider the constraint graph for Australia, shown again in Figure 6.12(a). If we could delete South Australia, the graph would become a tree, as in (b).
Fortunately, we can do this (in the graph, not the continent) by fixing a value for SA and
4 Sadly, very few regions of the world have tree-structured maps, although Sulawesi comes close.
224 Chapter 6. Constraint Satisfaction Problems
function TREE-CSP-SOLVER(csp) returns a solution, or failure
inputs: csp, a CSP with components X, D, C
n ← number of variables in X
assignment ←an empty assignment
root ← any variable in X
X ← TOPOLOGICALSORT(X , root)
for j = n down to 2 do
MAKE-ARC-CONSISTENT(PARENT(Xj), Xj )
if it cannot be made consistent then return failure
for i = 1 to n do
assignment[Xi] ←any consistent value from Di
if there is no consistent value then return failure
return assignment
Figure 6.11 The TREE-CSP-SOLVER algorithm for solving tree-structured CSPs. If the
CSP has a solution, we will find it in linear time; if not, we will detect a contradiction.
WA
NT
SA
Q
NSW
V
T
WA
NT
Q
NSW
V
T
(a) (b)
Figure 6.12 (a) The original constraint graph from Figure 6.1. (b) The constraint graph
after the removal of SA.
deleting from the domains of the other variables any values that are inconsistent with the
value chosen for SA.
Now, any solution for the CSP after SA and its constraints are removed will be consistent with the value chosen for SA. (This works for binary CSPs; the situation is more
complicated with higher-order constraints.) Therefore, we can solve the remaining tree with
the algorithm given above and thus solve the whole problem. Of course, in the general case
(as opposed to map coloring), the value chosen for SA could be the wrong one, so we would
need to try each possible value. The general algorithm is as follows:
Section 6.5. The Structure of Problems 225
1. Choose a subset S of the CSP’s variables such that the constraint graph becomes a tree
CYCLE CUTSET after removal of S. S is called a cycle cutset.
2. For each possible assignment to the variables in S that satisfies all constraints on S,
(a) remove from the domains of the remaining variables any values that are inconsistent with the assignment for S, and
(b) If the remaining CSP has a solution, return it together with the assignment for S.
If the cycle cutset has size c, then the total run time is O(dc · (n − c)d2): we have to try each
of the dc combinations of values for the variables in S, and for each combination we must
solve a tree problem of size n − c. If the graph is “nearly a tree,” then c will be small and the
savings over straight backtracking will be huge. In the worst case, however, c can be as large
as (n − 2). Finding the smallest cycle cutset is NP-hard, but several efficient approximation
algorithms are known. The overall algorithmic approach is called cutset conditioning; it CUTSET
CONDITIONING
comes up again in Chapter 14, where it is used for reasoning about probabilities.
The second approach is based on constructing a tree decomposition of the constraint TREE
DECOMPOSITION
graph into a set of connected subproblems. Each subproblem is solved independently, and the
resulting solutions are then combined. Like most divide-and-conquer algorithms, this works
well if no subproblem is too large. Figure 6.13 shows a tree decomposition of the mapcoloring problem into five subproblems. A tree decomposition must satisfy the following
three requirements:
• Every variable in the original problem appears in at least one of the subproblems.
• If two variables are connected by a constraint in the original problem, they must appear
together (along with the constraint) in at least one of the subproblems.
• If a variable appears in two subproblems in the tree, it must appear in every subproblem
along the path connecting those subproblems.
The first two conditions ensure that all the variables and constraints are represented in the
decomposition. The third condition seems rather technical, but simply reflects the constraint
that any given variable must have the same value in every subproblem in which it appears;
the links joining subproblems in the tree enforce this constraint. For example, SA appears in
all four of the connected subproblems in Figure 6.13. You can verify from Figure 6.12 that
this decomposition makes sense.
We solve each subproblem independently; if any one has no solution, we know the entire problem has no solution. If we can solve all the subproblems, then we attempt to construct
a global solution as follows. First, we view each subproblem as a “mega-variable” whose domain is the set of all solutions for the subproblem. For example, the leftmost subproblem in
Figure 6.13 is a map-coloring problem with three variables and hence has six solutions—one
is {WA = red, SA = blue, NT = green}. Then, we solve the constraints connecting the
subproblems, using the efficient algorithm for trees given earlier. The constraints between
subproblems simply insist that the subproblem solutions agree on their shared variables. For
example, given the solution {WA = red, SA = blue, NT = green} for the first subproblem,
the only consistent solution for the next subproblem is {SA = blue, NT = green, Q = red}.
A given constraint graph admits many tree decompositions; in choosing a decompoTREE WIDTH sition, the aim is to make the subproblems as small as possible. The tree width of a tree
226 Chapter 6. Constraint Satisfaction Problems
T
WA
NT
SA
NT
SA
Q
SA
Q
NSW
SA NSW
V
Figure 6.13 A tree decomposition of the constraint graph in Figure 6.12(a).
decomposition of a graph is one less than the size of the largest subproblem; the tree width
of the graph itself is defined to be the minimum tree width among all its tree decompositions.
If a graph has tree width w and we are given the corresponding tree decomposition, then the
problem can be solved in O(ndw+1) time. Hence, CSPs with constraint graphs of bounded
tree width are solvable in polynomial time. Unfortunately, finding the decomposition with
minimal tree width is NP-hard, but there are heuristic methods that work well in practice.
So far, we have looked at the structure of the constraint graph. There can be important
structure in the values of variables as well. Consider the map-coloring problem with n colors.
For every consistent solution, there is actually a set of n! solutions formed by permuting the
color names. For example, on the Australia map we know that WA, NT, and SA must all have
different colors, but there are 3! = 6 ways to assign the three colors to these three regions.
VALUE SYMMETRY This is called value symmetry. We would like to reduce the search space by a factor of
n! by breaking the symmetry. We do this by introducing a symmetry-breaking constraint. SYMMETRYBREAKING
CONSTRAINT
For our example, we might impose an arbitrary ordering constraint, NT < SA < WA, that
requires the three values to be in alphabetical order. This constraint ensures that only one of
the n! solutions is possible: {NT = blue, SA = green,WA = red}.
For map coloring, it was easy to find a constraint that eliminates the symmetry, and
in general it is possible to find constraints that eliminate all but one symmetric solution in
polynomial time, but it is NP-hard to eliminate all symmetry among intermediate sets of
values during search. In practice, breaking value symmetry has proved to be important and
effective on a wide range of problems.
Section 6.6. Summary 227
6.6 SUMMARY
• Constraint satisfaction problems (CSPs) represent a state with a set of variable/value
pairs and represent the conditions for a solution by a set of constraints on the variables.
Many important real-world problems can be described as CSPs.
• A number of inference techniques use the constraints to infer which variable/value pairs
are consistent and which are not. These include node, arc, path, and k-consistency.
• Backtracking search, a form of depth-first search, is commonly used for solving CSPs.
Inference can be interwoven with search.
• The minimum-remaining-values and degree heuristics are domain-independent methods for deciding which variable to choose next in a backtracking search. The leastconstraining-value heuristic helps in deciding which value to try first for a given
variable. Backtracking occurs when no legal assignment can be found for a variable.
Conflict-directed backjumping backtracks directly to the source of the problem.
• Local search using the min-conflicts heuristic has also been applied to constraint satisfaction problems with great success.
• The complexity of solving a CSP is strongly related to the structure of its constraint
graph. Tree-structured problems can be solved in linear time. Cutset conditioning can
reduce a general CSP to a tree-structured one and is quite efficient if a small cutset can
be found. Tree decomposition techniques transform the CSP into a tree of subproblems
and are efficient if the tree width of the constraint graph is small.
BIBLIOGRAPHICAL AND HISTORICAL NOTES
The earliest work related to constraint satisfaction dealt largely with numerical constraints.
Equational constraints with integer domains were studied by the Indian mathematician Brahmagupta in the seventh century; they are often called Diophantine equations, after the Greek DIOPHANTINE
EQUATIONS
mathematician Diophantus (c. 200–284), who actually considered the domain of positive rationals. Systematic methods for solving linear equations by variable elimination were studied
by Gauss (1829); the solution of linear inequality constraints goes back to Fourier (1827).
Finite-domain constraint satisfaction problems also have a long history. For example,
GRAPH COLORING graph coloring (of which map coloring is a special case) is an old problem in mathematics.
The four-color conjecture (that every planar graph can be colored with four or fewer colors)
was first made by Francis Guthrie, a student of De Morgan, in 1852. It resisted solution—
despite several published claims to the contrary—until a proof was devised by Appel and
Haken (1977) (see the book Four Colors Suffice (Wilson, 2004)). Purists were disappointed
that part of the proof relied on a computer, so Georges Gonthier (2008), using the COQ
theorem prover, derived a formal proof that Appel and Haken’s proof was correct.
Specific classes of constraint satisfaction problems occur throughout the history of
computer science. One of the most influential early examples was the SKETCHPAD sys-
228 Chapter 6. Constraint Satisfaction Problems
tem (Sutherland, 1963), which solved geometric constraints in diagrams and was the forerunner of modern drawing programs and CAD tools. The identification of CSPs as a general
class is due to Ugo Montanari (1974). The reduction of higher-order CSPs to purely binary
CSPs with auxiliary variables (see Exercise 6.6) is due originally to the 19th-century logician
Charles Sanders Peirce. It was introduced into the CSP literature by Dechter (1990b) and
was elaborated by Bacchus and van Beek (1998). CSPs with preferences among solutions are
studied widely in the optimization literature; see Bistarelli et al. (1997) for a generalization
of the CSP framework to allow for preferences. The bucket-elimination algorithm (Dechter,
1999) can also be applied to optimization problems.
Constraint propagation methods were popularized by Waltz’s (1975) success on polyhedral line-labeling problems for computer vision. Waltz showed that, in many problems,
propagation completely eliminates the need for backtracking. Montanari (1974) introduced
the notion of constraint networks and propagation by path consistency. Alan Mackworth
(1977) proposed the AC-3 algorithm for enforcing arc consistency as well as the general idea
of combining backtracking with some degree of consistency enforcement. AC-4, a more
efficient arc-consistency algorithm, was developed by Mohr and Henderson (1986). Soon after Mackworth’s paper appeared, researchers began experimenting with the tradeoff between
the cost of consistency enforcement and the benefits in terms of search reduction. Haralick
and Elliot (1980) favored the minimal forward-checking algorithm described by McGregor
(1979), whereas Gaschnig (1979) suggested full arc-consistency checking after each variable assignment—an algorithm later called MAC by Sabin and Freuder (1994). The latter
paper provides somewhat convincing evidence that, on harder CSPs, full arc-consistency
checking pays off. Freuder (1978, 1982) investigated the notion of k-consistency and its
relationship to the complexity of solving CSPs. Apt (1999) describes a generic algorithmic
framework within which consistency propagation algorithms can be analyzed, and Bessi`ere
(2006) presents a current survey.
Special methods for handling higher-order or global constraints were developed first
within the context of constraint logic programming. Marriott and Stuckey (1998) provide
excellent coverage of research in this area. The Alldiff constraint was studied by Regin
(1994), Stergiou and Walsh (1999), and van Hoeve (2001). Bounds constraints were incorporated into constraint logic programming by Van Hentenryck et al. (1998). A survey of global
constraints is provided by van Hoeve and Katriel (2006).
Sudoku has become the most widely known CSP and was described as such by Simonis
(2005). Agerbeck and Hansen (2008) describe some of the strategies and show that Sudoku
on an n2 × n2 board is in the class of NP-hard problems. Reeson et al. (2007) show an
interactive solver based on CSP techniques.
The idea of backtracking search goes back to Golomb and Baumert (1965), and its
application to constraint satisfaction is due to Bitner and Reingold (1975), although they trace
the basic algorithm back to the 19th century. Bitner and Reingold also introduced the MRV
heuristic, which they called the most-constrained-variable heuristic. Brelaz (1979) used the
degree heuristic as a tiebreaker after applying the MRV heuristic. The resulting algorithm,
despite its simplicity, is still the best method for k-coloring arbitrary graphs. Haralick and
Elliot (1980) proposed the least-constraining-value heuristic.
Bibliographical and Historical Notes 229
The basic backjumping method is due to John Gaschnig (1977, 1979). Kondrak and
van Beek (1997) showed that this algorithm is essentially subsumed by forward checking.
Conflict-directed backjumping was devised by Prosser (1993). The most general and powerful form of intelligent backtracking was actually developed very early on by Stallman and
Sussman (1977). Their technique of dependency-directed backtracking led to the develop- DEPENDENCYDIRECTED
BACKTRACKING
ment of truth maintenance systems (Doyle, 1979), which we discuss in Section 12.6.2. The
connection between the two areas is analyzed by de Kleer (1989).
The work of Stallman and Sussman also introduced the idea of constraint learning,
in which partial results obtained by search can be saved and reused later in the search. The
BACKMARKING idea was formalized Dechter (1990a). Backmarking (Gaschnig, 1979) is a particularly simple method in which consistent and inconsistent pairwise assignments are saved and used
to avoid rechecking constraints. Backmarking can be combined with conflict-directed backjumping; Kondrak and van Beek (1997) present a hybrid algorithm that provably subsumes
either method taken separately. The method of dynamic backtracking (Ginsberg, 1993) re- DYNAMIC
BACKTRACKING
tains successful partial assignments from later subsets of variables when backtracking over
an earlier choice that does not invalidate the later success.
Empirical studies of several randomized backtracking methods were done by Gomes
et al. (2000) and Gomes and Selman (2001). Van Beek (2006) surveys backtracking.
Local search in constraint satisfaction problems was popularized by the work of Kirkpatrick et al. (1983) on simulated annealing (see Chapter 4), which is widely used for scheduling problems. The min-conflicts heuristic was first proposed by Gu (1989) and was developed
independently by Minton et al. (1992). Sosic and Gu (1994) showed how it could be applied
to solve the 3,000,000 queens problem in less than a minute. The astounding success of
local search using min-conflicts on the n-queens problem led to a reappraisal of the nature
and prevalence of “easy” and “hard” problems. Peter Cheeseman et al. (1991) explored the
difficulty of randomly generated CSPs and discovered that almost all such problems either
are trivially easy or have no solutions. Only if the parameters of the problem generator are
set in a certain narrow range, within which roughly half of the problems are solvable, do we
find “hard” problem instances. We discuss this phenomenon further in Chapter 7. Konolige
(1994) showed that local search is inferior to backtracking search on problems with a certain
degree of local structure; this led to work that combined local search and inference, such as
that by Pinkas and Dechter (1995). Hoos and Tsang (2006) survey local search techniques.
Work relating the structure and complexity of CSPs originates with Freuder (1985), who
showed that search on arc consistent trees works without any backtracking. A similar result,
with extensions to acyclic hypergraphs, was developed in the database community (Beeri
et al., 1983). Bayardo and Miranker (1994) present an algorithm for tree-structured CSPs
that runs in linear time without any preprocessing.
Since those papers were published, there has been a great deal of progress in developing
more general results relating the complexity of solving a CSP to the structure of its constraint
graph. The notion of tree width was introduced by the graph theorists Robertson and Seymour
(1986). Dechter and Pearl (1987, 1989), building on the work of Freuder, applied a related
notion (which they called induced width) to constraint satisfaction problems and developed
the tree decomposition approach sketched in Section 6.5. Drawing on this work and on results
230 Chapter 6. Constraint Satisfaction Problems
from database theory, Gottlob et al. (1999a, 1999b) developed a notion, hypertree width, that
is based on the characterization of the CSP as a hypergraph. In addition to showing that any
CSP with hypertree width w can be solved in time O(nw+1 log n), they also showed that
hypertree width subsumes all previously defined measures of “width” in the sense that there
are cases where the hypertree width is bounded and the other measures are unbounded.
Interest in look-back approaches to backtracking was rekindled by the work of Bayardo
and Schrag (1997), whose RELSAT algorithm combined constraint learning and backjumping
and was shown to outperform many other algorithms of the time. This led to AND/OR
search algorithms applicable to both CSPs and probabilistic reasoning (Dechter and Mateescu, 2007). Brown et al. (1988) introduce the idea of symmetry breaking in CSPs, and
Gent et al. (2006) give a recent survey.
The field of distributed constraint satisfaction looks at solving CSPs when there is a DISTRIBUTED
CONSTRAINT
SATISFACTION
collection of agents, each of which controls a subset of the constraint variables. There have
been annual workshops on this problem since 2000, and good coverage elsewhere (Collin
et al., 1999; Pearce et al., 2008; Shoham and Leyton-Brown, 2009).
Comparing CSP algorithms is mostly an empirical science: few theoretical results show
that one algorithm dominates another on all problems; instead, we need to run experiments
to see which algorithms perform better on typical instances of problems. As Hooker (1995)
points out, we need to be careful to distinguish between competitive testing—as occurs in
competitions among algorithms based on run time—and scientific testing, whose goal is to
identify the properties of an algorithm that determine its efficacy on a class of problems.
The recent textbooks by Apt (2003) and Dechter (2003), and the collection by Rossi
et al. (2006) are excellent resources on constraint processing. There are several good earlier
surveys, including those by Kumar (1992), Dechter and Frost (2002), and Bartak (2001); and
the encyclopedia articles by Dechter (1992) and Mackworth (1992). Pearson and Jeavons
(1997) survey tractable classes of CSPs, covering both structural decomposition methods
and methods that rely on properties of the domains or constraints themselves. Kondrak and
van Beek (1997) give an analytical survey of backtracking search algorithms, and Bacchus
and van Run (1995) give a more empirical survey. Constraint programming is covered in the
books by Apt (2003) and Fruhwirth and Abdennadher (2003). Several interesting applications
are described in the collection edited by Freuder and Mackworth (1994). Papers on constraint
satisfaction appear regularly in Artificial Intelligence and in the specialist journal Constraints.
The primary conference venue is the International Conference on Principles and Practice of
Constraint Programming, often called CP.
EXERCISES
6.1 How many solutions are there for the map-coloring problem in Figure 6.1? How many
solutions if four colors are allowed? Two colors?
6.2 Consider the problem of placing k knights on an n × n chessboard such that no two
knights are attacking each other, where k is given and k ≤ n2.
Exercises 231
a. Choose a CSP formulation. In your formulation, what are the variables?
b. What are the possible values of each variable?
c. What sets of variables are constrained, and how?
d. Now consider the problem of putting as many knights as possible on the board without any attacks. Explain how to solve this with local search by defining appropriate
ACTIONS and RESULT functions and a sensible objective function.
6.3 Consider the problem of constructing (not solving) crossword puzzles:5 fitting words
into a rectangular grid. The grid, which is given as part of the problem, specifies which
squares are blank and which are shaded. Assume that a list of words (i.e., a dictionary)
is provided and that the task is to fill in the blank squares by using any subset of the list.
Formulate this problem precisely in two ways:
a. As a general search problem. Choose an appropriate search algorithm and specify a
heuristic function. Is it better to fill in blanks one letter at a time or one word at a time?
b. As a constraint satisfaction problem. Should the variables be words or letters?
Which formulation do you think will be better? Why?
6.4 Give precise formulations for each of the following as constraint satisfaction problems:
a. Rectilinear floor-planning: find non-overlapping places in a large rectangle for a number
of smaller rectangles.
b. Class scheduling: There is a fixed number of professors and classrooms, a list of classes
to be offered, and a list of possible time slots for classes. Each professor has a set of
classes that he or she can teach.
c. Hamiltonian tour: given a network of cities connected by roads, choose an order to visit
all cities in a country without repeating any.
6.5 Solve the cryptarithmetic problem in Figure 6.2 by hand, using the strategy of backtracking with forward checking and the MRV and least-constraining-value heuristics.
6.6 Show how a single ternary constraint such as “A + B = C” can be turned into three
binary constraints by using an auxiliary variable. You may assume finite domains. (Hint:
Consider a new variable that takes on values that are pairs of other values, and consider
constraints such as “X is the first element of the pair Y .”) Next, show how constraints with
more than three variables can be treated similarly. Finally, show how unary constraints can be
eliminated by altering the domains of variables. This completes the demonstration that any
CSP can be transformed into a CSP with only binary constraints.
6.7 Consider the following logic puzzle: In five houses, each with a different color, live five
persons of different nationalities, each of whom prefers a different brand of candy, a different
drink, and a different pet. Given the following facts, the questions to answer are “Where does
the zebra live, and in which house do they drink water?”
5 Ginsberg et al. (1990) discuss several methods for constructing crossword puzzles. Littman et al. (1999) tackle
the harder problem of solving them.
232 Chapter 6. Constraint Satisfaction Problems
The Englishman lives in the red house.
The Spaniard owns the dog.
The Norwegian lives in the first house on the left.
The green house is immediately to the right of the ivory house.
The man who eats Hershey bars lives in the house next to the man with the fox.
Kit Kats are eaten in the yellow house.
The Norwegian lives next to the blue house.
The Smarties eater owns snails.
The Snickers eater drinks orange juice.
The Ukrainian drinks tea.
The Japanese eats Milky Ways.
Kit Kats are eaten in a house next to the house where the horse is kept.
Coffee is drunk in the green house.
Milk is drunk in the middle house.
Discuss different representations of this problem as a CSP. Why would one prefer one representation over another?
6.8 Consider the graph with 8 nodes A1, A2, A3, A4, H, T, F1, F2. Ai is connected to
Ai+1 for all i, each Ai is connected to H, H is connected to T, and T is connected to each
Fi. Find a 3-coloring of this graph by hand using the following strategy: backtracking with
conflict-directed backjumping, the variable order A1, H, A4, F1, A2, F2, A3, T, and the
value order R, G, B.
6.9 Explain why it is a good heuristic to choose the variable that is most constrained but the
value that is least constraining in a CSP search.
6.10 Generate random instances of map-coloring problems as follows: scatter n points on
the unit square; select a point X at random, connect X by a straight line to the nearest point
Y such that X is not already connected to Y and the line crosses no other line; repeat the
previous step until no more connections are possible. The points represent regions on the
map and the lines connect neighbors. Now try to find k-colorings of each map, for both
k = 3 and k = 4, using min-conflicts, backtracking, backtracking with forward checking, and
backtracking with MAC. Construct a table of average run times for each algorithm for values
of n up to the largest you can manage. Comment on your results.
6.11 Use the AC-3 algorithm to show that arc consistency can detect the inconsistency of
the partial assignment {WA = green, V = red} for the problem shown in Figure 6.1.
6.12 What is the worst-case complexity of running AC-3 on a tree-structured CSP?
6.13 AC-3 puts back on the queue every arc (Xk, Xi) whenever any value is deleted from
the domain of Xi, even if each value of Xk is consistent with several remaining values of Xi.
Suppose that, for every arc (Xk, Xi), we keep track of the number of remaining values of Xi
that are consistent with each value of Xk. Explain how to update these numbers efficiently
and hence show that arc consistency can be enforced in total time O(n2d2).
Exercises 233
6.14 The TREE-CSP-SOLVER (Figure 6.10) makes arcs consistent starting at the leaves and
working backwards towards the root. Why does it do that? What would happen if it went in
the opposite direction?
6.15 We introduced Sudoku as a CSP to be solved by search over partial assignments because that is the way people generally undertake solving Sudoku problems. It is also possible,
of course, to attack these problems with local search over complete assignments. How well
would a local solver using the min-conflicts heuristic do on Sudoku problems?
6.16 Define in your own words the terms constraint, backtracking search, arc consistency,
backjumping, min-conflicts, and cycle cutset.
6.17 Suppose that a graph is known to have a cycle cutset of no more than k nodes. Describe
a simple algorithm for finding a minimal cycle cutset whose run time is not much more than
O(nk) for a CSP with n variables. Search the literature for methods for finding approximately
minimal cycle cutsets in time that is polynomial in the size of the cutset. Does the existence
of such algorithms make the cycle cutset method practical?
7 LOGICAL AGENTS
In which we design agents that can form representations of a complex world, use a
process of inference to derive new representations about the world, and use these
new representations to deduce what to do.
Humans, it seems, know things; and what they know helps them do things. These are
not empty statements. They make strong claims about how the intelligence of humans is
REASONING achieved—not by purely reflex mechanisms but by processes of reasoning that operate on
REPRESENTATION internal representations of knowledge. In AI, this approach to intelligence is embodied in
knowledge-based agents. KNOWLEDGE-BASED
AGENTS
The problem-solving agents of Chapters 3 and 4 know things, but only in a very limited,
inflexible sense. For example, the transition model for the 8-puzzle—knowledge of what the
actions do—is hidden inside the domain-specific code of the RESULT function. It can be
used to predict the outcome of actions but not to deduce that two tiles cannot occupy the
same space or that states with odd parity cannot be reached from states with even parity. The
atomic representations used by problem-solving agents are also very limiting. In a partially
observable environment, an agent’s only choice for representing what it knows about the
current state is to list all possible concrete states—a hopeless prospect in large environments.
Chapter 6 introduced the idea of representing states as assignments of values to variables; this is a step in the right direction, enabling some parts of the agent to work in a
domain-independent way and allowing for more efficient algorithms. In this chapter and
LOGIC those that follow, we take this step to its logical conclusion, so to speak—we develop logic
as a general class of representations to support knowledge-based agents. Such agents can
combine and recombine information to suit myriad purposes. Often, this process can be quite
far removed from the needs of the moment—as when a mathematician proves a theorem or
an astronomer calculates the earth’s life expectancy. Knowledge-based agents can accept new
tasks in the form of explicitly described goals; they can achieve competence quickly by being
told or learning new knowledge about the environment; and they can adapt to changes in the
environment by updating the relevant knowledge.
We begin in Section 7.1 with the overall agent design. Section 7.2 introduces a simple new environment, the wumpus world, and illustrates the operation of a knowledge-based
agent without going into any technical detail. Then we explain the general principles of logic
234
Section 7.1. Knowledge-Based Agents 235
in Section 7.3 and the specifics of propositional logic in Section 7.4. While less expressive
than first-order logic (Chapter 8), propositional logic illustrates all the basic concepts of
logic; it also comes with well-developed inference technologies, which we describe in sections 7.5 and 7.6. Finally, Section 7.7 combines the concept of knowledge-based agents with
the technology of propositional logic to build some simple agents for the wumpus world.
7.1 KNOWLEDGE-BASED AGENTS
KNOWLEDGE BASE The central component of a knowledge-based agent is its knowledge base, or KB. A knowlSENTENCE edge base is a set of sentences. (Here “sentence” is used as a technical term. It is related
but not identical to the sentences of English and other natural languages.) Each sentence is
expressed in a language called a knowledge representation language and represents some KNOWLEDGE
REPRESENTATION
LANGUAGE
AXIOM assertion about the world. Sometimes we dignify a sentence with the name axiom, when the
sentence is taken as given without being derived from other sentences.
There must be a way to add new sentences to the knowledge base and a way to query
what is known. The standard names for these operations are TELL and ASK, respectively.
INFERENCE Both operations may involve inference—that is, deriving new sentences from old. Inference
must obey the requirement that when one ASKs a question of the knowledge base, the answer
should follow from what has been told (or TELLed) to the knowledge base previously. Later
in this chapter, we will be more precise about the crucial word “follow.” For now, take it to
mean that the inference process should not make things up as it goes along.
Figure 7.1 shows the outline of a knowledge-based agent program. Like all our agents,
it takes a percept as input and returns an action. The agent maintains a knowledge base, KB,
which may initially contain some background knowledge. BACKGROUND
KNOWLEDGE
Each time the agent program is called, it does three things. First, it TELLs the knowledge base what it perceives. Second, it ASKs the knowledge base what action it should
perform. In the process of answering this query, extensive reasoning may be done about
the current state of the world, about the outcomes of possible action sequences, and so on.
Third, the agent program TELLs the knowledge base which action was chosen, and the agent
executes the action.
The details of the representation language are hidden inside three functions that implement the interface between the sensors and actuators on one side and the core representation
and reasoning system on the other. MAKE-PERCEPT-SENTENCE constructs a sentence asserting that the agent perceived the given percept at the given time. MAKE-ACTION-QUERY
constructs a sentence that asks what action should be done at the current time. Finally,
MAKE-ACTION-SENTENCE constructs a sentence asserting that the chosen action was executed. The details of the inference mechanisms are hidden inside TELL and ASK. Later
sections will reveal these details.
The agent in Figure 7.1 appears quite similar to the agents with internal state described
in Chapter 2. Because of the definitions of TELL and ASK, however, the knowledge-based
agent is not an arbitrary program for calculating actions. It is amenable to a description at
236 Chapter 7. Logical Agents
function KB-AGENT(percept) returns an action
persistent: KB, a knowledge base
t, a counter, initially 0, indicating time
TELL(KB, MAKE-PERCEPT-SENTENCE(percept,t))
action ← ASK(KB, MAKE-ACTION-QUERY(t))
TELL(KB, MAKE-ACTION-SENTENCE(action,t))
t ← t + 1
return action
Figure 7.1 A generic knowledge-based agent. Given a percept, the agent adds the percept
to its knowledge base, asks the knowledge base for the best action, and tells the knowledge
base that it has in fact taken that action.
KNOWLEDGE LEVEL the knowledge level, where we need specify only what the agent knows and what its goals
are, in order to fix its behavior. For example, an automated taxi might have the goal of
taking a passenger from San Francisco to Marin County and might know that the Golden
Gate Bridge is the only link between the two locations. Then we can expect it to cross the
Golden Gate Bridge because it knows that that will achieve its goal. Notice that this analysis
is independent of how the taxi works at the implementation level. It doesn’t matter whether IMPLEMENTATION
LEVEL
its geographical knowledge is implemented as linked lists or pixel maps, or whether it reasons
by manipulating strings of symbols stored in registers or by propagating noisy signals in a
network of neurons.
A knowledge-based agent can be built simply by TELLing it what it needs to know.
Starting with an empty knowledge base, the agent designer can TELL sentences one by one
DECLARATIVE until the agent knows how to operate in its environment. This is called the declarative approach to system building. In contrast, the procedural approach encodes desired behaviors
directly as program code. In the 1970s and 1980s, advocates of the two approaches engaged
in heated debates. We now understand that a successful agent often combines both declarative
and procedural elements in its design, and that declarative knowledge can often be compiled
into more efficient procedural code.
We can also provide a knowledge-based agent with mechanisms that allow it to learn
for itself. These mechanisms, which are discussed in Chapter 18, create general knowledge
about the environment from a series of percepts. A learning agent can be fully autonomous.
7.2 THE WUMPUS WORLD
In this section we describe an environment in which knowledge-based agents can show their
WUMPUS WORLD worth. The wumpus world is a cave consisting of rooms connected by passageways. Lurking
somewhere in the cave is the terrible wumpus, a beast that eats anyone who enters its room.
The wumpus can be shot by an agent, but the agent has only one arrow. Some rooms contain
Section 7.2. The Wumpus World 237
bottomless pits that will trap anyone who wanders into these rooms (except for the wumpus,
which is too big to fall in). The only mitigating feature of this bleak environment is the
possibility of finding a heap of gold. Although the wumpus world is rather tame by modern
computer game standards, it illustrates some important points about intelligence.
A sample wumpus world is shown in Figure 7.2. The precise definition of the task
environment is given, as suggested in Section 2.3, by the PEAS description:
• Performance measure: +1000 for climbing out of the cave with the gold, –1000 for
falling into a pit or being eaten by the wumpus, –1 for each action taken and –10 for
using up the arrow. The game ends either when the agent dies or when the agent climbs
out of the cave.
• Environment: A 4 × 4 grid of rooms. The agent always starts in the square labeled
[1,1], facing to the right. The locations of the gold and the wumpus are chosen randomly, with a uniform distribution, from the squares other than the start square. In
addition, each square other than the start can be a pit, with probability 0.2.
• Actuators: The agent can move Forward, TurnLeft by 90◦, or TurnRight by 90◦. The
agent dies a miserable death if it enters a square containing a pit or a live wumpus. (It
is safe, albeit smelly, to enter a square with a dead wumpus.) If an agent tries to move
forward and bumps into a wall, then the agent does not move. The action Grab can be
used to pick up the gold if it is in the same square as the agent. The action Shoot can
be used to fire an arrow in a straight line in the direction the agent is facing. The arrow
continues until it either hits (and hence kills) the wumpus or hits a wall. The agent has
only one arrow, so only the first Shoot action has any effect. Finally, the action Climb
can be used to climb out of the cave, but only from square [1,1].
• Sensors: The agent has five sensors, each of which gives a single bit of information:
– In the square containing the wumpus and in the directly (not diagonally) adjacent
squares, the agent will perceive a Stench.
– In the squares directly adjacent to a pit, the agent will perceive a Breeze.
– In the square where the gold is, the agent will perceive a Glitter.
– When an agent walks into a wall, it will perceive a Bump.
– When the wumpus is killed, it emits a woeful Scream that can be perceived anywhere in the cave.
The percepts will be given to the agent program in the form of a list of five symbols;
for example, if there is a stench and a breeze, but no glitter, bump, or scream, the agent
program will get [Stench, Breeze, None, None, None].
We can characterize the wumpus environment along the various dimensions given in Chapter 2. Clearly, it is discrete, static, and single-agent. (The wumpus doesn’t move, fortunately.)
It is sequential, because rewards may come only after many actions are taken. It is partially
observable, because some aspects of the state are not directly perceivable: the agent’s location, the wumpus’s state of health, and the availability of an arrow. As for the locations
of the pits and the wumpus: we could treat them as unobserved parts of the state that happen to be immutable—in which case, the transition model for the environment is completely
238 Chapter 7. Logical Agents
PIT
1234
1
2
3
4
START
Stench
Stench
Breeze
Gold
PIT
PIT
Breeze
Breeze
Breeze
Breeze
Breeze
Stench
Figure 7.2 A typical wumpus world. The agent is in the bottom left corner, facing right.
known; or we could say that the transition model itself is unknown because the agent doesn’t
know which Forward actions are fatal—in which case, discovering the locations of pits and
wumpus completes the agent’s knowledge of the transition model.
For an agent in the environment, the main challenge is its initial ignorance of the configuration of the environment; overcoming this ignorance seems to require logical reasoning.
In most instances of the wumpus world, it is possible for the agent to retrieve the gold safely.
Occasionally, the agent must choose between going home empty-handed and risking death to
find the gold. About 21% of the environments are utterly unfair, because the gold is in a pit
or surrounded by pits.
Let us watch a knowledge-based wumpus agent exploring the environment shown in
Figure 7.2. We use an informal knowledge representation language consisting of writing
down symbols in a grid (as in Figures 7.3 and 7.4).
The agent’s initial knowledge base contains the rules of the environment, as described
previously; in particular, it knows that it is in [1,1] and that [1,1] is a safe square; we denote
that with an “A” and “OK,” respectively, in square [1,1].
The first percept is [None, None, None, None, None], from which the agent can conclude that its neighboring squares, [1,2] and [2,1], are free of dangers—they are OK. Figure 7.3(a) shows the agent’s state of knowledge at this point.
A cautious agent will move only into a square that it knows to be OK. Let us suppose
the agent decides to move forward to [2,1]. The agent perceives a breeze (denoted by “B”) in
[2,1], so there must be a pit in a neighboring square. The pit cannot be in [1,1], by the rules of
the game, so there must be a pit in [2,2] or [3,1] or both. The notation “P?” in Figure 7.3(b)
indicates a possible pit in those squares. At this point, there is only one known square that is
OK and that has not yet been visited. So the prudent agent will turn around, go back to [1,1],
and then proceed to [1,2].
The agent perceives a stench in [1,2], resulting in the state of knowledge shown in
Figure 7.4(a). The stench in [1,2] means that there must be a wumpus nearby. But the
Section 7.2. The Wumpus World 239
A
B
G
P
S
W
 = Agent
 = Breeze
 = Glitter, Gold
 = Pit
 = Stench
 = Wumpus
OK = Safe square
V = Visited
A
OK
 1,1 2,1 3,1 4,1
 1,2 2,2 3,2 4,2
 1,3 2,3 3,3 4,3
 1,4 2,4 3,4 4,4
OK OK
B
P?
A P?
OK OK
OK
 1,1 2,1 3,1 4,1
 1,2 2,2 3,2 4,2
 1,3 2,3 3,3 4,3
 1,4 2,4 3,4 4,4
V
(a) (b)
Figure 7.3 The first step taken by the agent in the wumpus world. (a) The initial situation, after percept [None, None, None, None, None]. (b) After one move, with percept
[None, Breeze, None, None, None].
B P! B
A
OK OK
OK
 1,1 2,1 3,1 4,1
 1,2 2,2 3,2 4,2
 1,3 2,3 3,3 4,3
 1,4 2,4 3,4 4,4
V
OK
W!
V
P!
A
OK OK
OK
 1,1 2,1 3,1 4,1
 1,2 2,2 3,2 4,2
 1,3 2,3 3,3 4,3
 1,4 2,4 3,4 4,4
V
S
OK
W!
V
V V
B
S G
P?
P?
(a) (b)
S
A
B
G
P
S
W
 = Agent
 = Breeze
 = Glitter, Gold
 = Pit
 = Stench
 = Wumpus
OK = Safe square
V = Visited
Figure 7.4 Two later stages in the progress of the agent. (a) After the third move,
with percept [Stench, None, None, None, None]. (b) After the fifth move, with percept
[Stench, Breeze, Glitter , None, None].
wumpus cannot be in [1,1], by the rules of the game, and it cannot be in [2,2] (or the agent
would have detected a stench when it was in [2,1]). Therefore, the agent can infer that the
wumpus is in [1,3]. The notation W! indicates this inference. Moreover, the lack of a breeze
in [1,2] implies that there is no pit in [2,2]. Yet the agent has already inferred that there must
be a pit in either [2,2] or [3,1], so this means it must be in [3,1]. This is a fairly difficult
inference, because it combines knowledge gained at different times in different places and
relies on the lack of a percept to make one crucial step.
240 Chapter 7. Logical Agents
The agent has now proved to itself that there is neither a pit nor a wumpus in [2,2], so it
is OK to move there. We do not show the agent’s state of knowledge at [2,2]; we just assume
that the agent turns and moves to [2,3], giving us Figure 7.4(b). In [2,3], the agent detects a
glitter, so it should grab the gold and then return home.
Note that in each case for which the agent draws a conclusion from the available information, that conclusion is guaranteed to be correct if the available information is correct.
This is a fundamental property of logical reasoning. In the rest of this chapter, we describe
how to build logical agents that can represent information and draw conclusions such as those
described in the preceding paragraphs.
7.3 LOGIC
This section summarizes the fundamental concepts of logical representation and reasoning.
These beautiful ideas are independent of any of logic’s particular forms. We therefore postpone the technical details of those forms until the next section, using instead the familiar
example of ordinary arithmetic.
In Section 7.1, we said that knowledge bases consist of sentences. These sentences
SYNTAX are expressed according to the syntax of the representation language, which specifies all the
sentences that are well formed. The notion of syntax is clear enough in ordinary arithmetic:
“x + y = 4” is a well-formed sentence, whereas “x4y+ =” is not.
SEMANTICS A logic must also define the semantics or meaning of sentences. The semantics defines
TRUTH the truth of each sentence with respect to each possible world. For example, the semantics
POSSIBLE WORLD for arithmetic specifies that the sentence “x + y = 4” is true in a world where x is 2 and y
is 2, but false in a world where x is 1 and y is 1. In standard logics, every sentence must be
either true or false in each possible world—there is no “in between.”1
MODEL When we need to be precise, we use the term model in place of “possible world.”
Whereas possible worlds might be thought of as (potentially) real environments that the agent
might or might not be in, models are mathematical abstractions, each of which simply fixes
the truth or falsehood of every relevant sentence. Informally, we may think of a possible world
as, for example, having x men and y women sitting at a table playing bridge, and the sentence
x + y = 4 is true when there are four people in total. Formally, the possible models are just
all possible assignments of real numbers to the variables x and y. Each such assignment fixes
the truth of any sentence of arithmetic whose variables are x and y. If a sentence α is true in
SATISFACTION model m, we say that m satisfies α or sometimes m is a model of α. We use the notation
M(α) to mean the set of all models of α.
Now that we have a notion of truth, we are ready to talk about logical reasoning. This
ENTAILMENT involves the relation of logical entailment between sentences—the idea that a sentence follows logically from another sentence. In mathematical notation, we write
α |= β
1 Fuzzy logic, discussed in Chapter 14, allows for degrees of truth.
Section 7.3. Logic 241
123
1
2 PIT
123
1
2 PIT
123
1
2 PIT PIT
PIT
123
1
2 PIT
PIT
123
1
2
PIT
123
1
2 PIT
PIT
123
1
2 PIT PIT
123
1
2
KB α1
Breeze
Breeze
Breeze
Breeze
Breeze
Breeze
Breeze
Breeze
123
1
2 PIT
123
1
2 PIT
123
1
2 PIT PIT
PIT
123
1
2 PIT
PIT
123
1
2
PIT
123
1
2 PIT
PIT
123
1
2 PIT PIT
123
1
2
KB
Breeze
α2
Breeze
Breeze
Breeze
Breeze
Breeze
Breeze
Breeze
(a) (b)
Figure 7.5 Possible models for the presence of pits in squares [1,2], [2,2], and [3,1]. The
KB corresponding to the observations of nothing in [1,1] and a breeze in [2,1] is shown by
the solid line. (a) Dotted line shows models of α1 (no pit in [1,2]). (b) Dotted line shows
models of α2 (no pit in [2,2]).
to mean that the sentence α entails the sentence β. The formal definition of entailment is this:
α |= β if and only if, in every model in which α is true, β is also true. Using the notation just
introduced, we can write
α |= β if and only if M(α) ⊆ M(β) .
(Note the direction of the ⊆ here: if α |= β, then α is a stronger assertion than β: it rules out
more possible worlds.) The relation of entailment is familiar from arithmetic; we are happy
with the idea that the sentence x = 0 entails the sentence xy = 0. Obviously, in any model
where x is zero, it is the case that xy is zero (regardless of the value of y).
We can apply the same kind of analysis to the wumpus-world reasoning example given
in the preceding section. Consider the situation in Figure 7.3(b): the agent has detected
nothing in [1,1] and a breeze in [2,1]. These percepts, combined with the agent’s knowledge
of the rules of the wumpus world, constitute the KB. The agent is interested (among other
things) in whether the adjacent squares [1,2], [2,2], and [3,1] contain pits. Each of the three
squares might or might not contain a pit, so (for the purposes of this example) there are 23 = 8
possible models. These eight models are shown in Figure 7.5.2
The KB can be thought of as a set of sentences or as a single sentence that asserts all
the individual sentences. The KB is false in models that contradict what the agent knows—
for example, the KB is false in any model in which [1,2] contains a pit, because there is
no breeze in [1,1]. There are in fact just three models in which the KB is true, and these are
2 Although the figure shows the models as partial wumpus worlds, they are really nothing more than assignments
of true and false to the sentences “there is a pit in [1,2]” etc. Models, in the mathematical sense, do not need to
have ’orrible ’airy wumpuses in them.
242 Chapter 7. Logical Agents
shown surrounded by a solid line in Figure 7.5. Now let us consider two possible conclusions:
α1 = “There is no pit in [1,2].”
α2 = “There is no pit in [2,2].”
We have surrounded the models of α1 and α2 with dotted lines in Figures 7.5(a) and 7.5(b),
respectively. By inspection, we see the following:
in every model in which KB is true, α1 is also true.
Hence, KB |= α1: there is no pit in [1,2]. We can also see that
in some models in which KB is true, α2 is false.
Hence, KB |= α2: the agent cannot conclude that there is no pit in [2,2]. (Nor can it conclude
that there is a pit in [2,2].)3
The preceding example not only illustrates entailment but also shows how the definition
LOGICAL INFERENCE of entailment can be applied to derive conclusions—that is, to carry out logical inference.
MODEL CHECKING The inference algorithm illustrated in Figure 7.5 is called model checking, because it enumerates all possible models to check that α is true in all models in which KB is true, that is,
that M(KB) ⊆ M(α).
In understanding entailment and inference, it might help to think of the set of all consequences of KB as a haystack and of α as a needle. Entailment is like the needle being in the
haystack; inference is like finding it. This distinction is embodied in some formal notation: if
an inference algorithm i can derive α from KB, we write
KB i α ,
which is pronounced “α is derived from KB by i” or “i derives α from KB.”
SOUND An inference algorithm that derives only entailed sentences is called sound or truthTRUTH-PRESERVING preserving. Soundness is a highly desirable property. An unsound inference procedure essentially makes things up as it goes along—it announces the discovery of nonexistent needles.
It is easy to see that model checking, when it is applicable,4 is a sound procedure.
COMPLETENESS The property of completeness is also desirable: an inference algorithm is complete if
it can derive any sentence that is entailed. For real haystacks, which are finite in extent,
it seems obvious that a systematic examination can always decide whether the needle is in
the haystack. For many knowledge bases, however, the haystack of consequences is infinite,
and completeness becomes an important issue.5 Fortunately, there are complete inference
procedures for logics that are sufficiently expressive to handle many knowledge bases.
We have described a reasoning process whose conclusions are guaranteed to be true
in any world in which the premises are true; in particular, if KB is true in the real world,
then any sentence α derived from KB by a sound inference procedure is also true in the real
world. So, while an inference process operates on “syntax”—internal physical configurations
such as bits in registers or patterns of electrical blips in brains—the process corresponds
3 The agent can calculate the probability that there is a pit in [2,2]; Chapter 13 shows how.
4 Model checking works if the space of models is finite—for example, in wumpus worlds of fixed size. For
arithmetic, on the other hand, the space of models is infinite: even if we restrict ourselves to the integers, there
are infinitely many pairs of values for x and y in the sentence x + y = 4.
5 Compare with the case of infinite search spaces in Chapter 3, where depth-first search is not complete.
Section 7.4. Propositional Logic: A Very Simple Logic 243
Follows
Sentences Sentence Semantics
Entails
Semantics
Representation
World
Aspects of the
 real world
Aspect of the
 real world
Figure 7.6 Sentences are physical configurations of the agent, and reasoning is a process
of constructing new physical configurations from old ones. Logical reasoning should ensure that the new configurations represent aspects of the world that actually follow from the
aspects that the old configurations represent.
to the real-world relationship whereby some aspect of the real world is the case6 by virtue
of other aspects of the real world being the case. This correspondence between world and
representation is illustrated in Figure 7.6.
GROUNDING The final issue to consider is grounding—the connection between logical reasoning
processes and the real environment in which the agent exists. In particular, how do we know
that KB is true in the real world? (After all, KB is just “syntax” inside the agent’s head.)
This is a philosophical question about which many, many books have been written. (See
Chapter 26.) A simple answer is that the agent’s sensors create the connection. For example,
our wumpus-world agent has a smell sensor. The agent program creates a suitable sentence
whenever there is a smell. Then, whenever that sentence is in the knowledge base, it is
true in the real world. Thus, the meaning and truth of percept sentences are defined by the
processes of sensing and sentence construction that produce them. What about the rest of the
agent’s knowledge, such as its belief that wumpuses cause smells in adjacent squares? This
is not a direct representation of a single percept, but a general rule—derived, perhaps, from
perceptual experience but not identical to a statement of that experience. General rules like
this are produced by a sentence construction process called learning, which is the subject
of Part V. Learning is fallible. It could be the case that wumpuses cause smells except on
February 29 in leap years, which is when they take their baths. Thus, KB may not be true in
the real world, but with good learning procedures, there is reason for optimism.
7.4 PROPOSITIONAL LOGIC:AVERY SIMPLE LOGIC
We now present a simple but powerful logic called propositional logic. We cover the syntax PROPOSITIONAL
LOGIC
of propositional logic and its semantics—the way in which the truth of sentences is determined. Then we look at entailment—the relation between a sentence and another sentence
that follows from it—and see how this leads to a simple algorithm for logical inference. Everything takes place, of course, in the wumpus world.
6 As Wittgenstein (1922) put it in his famous Tractatus: “The world is everything that is the case.”
244 Chapter 7. Logical Agents
7.4.1 Syntax
ATOMIC SENTENCES The syntax of propositional logic defines the allowable sentences. The atomic sentences
consist of a single proposition symbol. Each such symbol stands for a proposition that can PROPOSITION
SYMBOL
be true or false. We use symbols that start with an uppercase letter and may contain other
letters or subscripts, for example: P, Q, R, W1,3 and North. The names are arbitrary but
are often chosen to have some mnemonic value—we use W1,3 to stand for the proposition
that the wumpus is in [1,3]. (Remember that symbols such as W1,3 are atomic, i.e., W, 1,
and 3 are not meaningful parts of the symbol.) There are two proposition symbols with fixed
meanings: True is the always-true proposition and False is the always-false proposition.
Complex sentences are constructed from simpler sentences, using parentheses and logical COMPLEX
SENTENCES
connectives. There are five connectives in common use: LOGICAL
CONNECTIVES
NEGATION ¬ (not). A sentence such as ¬W1,3 is called the negation of W1,3. A literal is either an
LITERAL atomic sentence (a positive literal) or a negated atomic sentence (a negative literal).
∧ (and). A sentence whose main connective is ∧, such as W1,3 ∧ P3,1, is called a conCONJUNCTION junction; its parts are the conjuncts. (The ∧ looks like an “A” for “And.”)
DISJUNCTION ∨ (or). A sentence using ∨, such as (W1,3∧P3,1)∨W2,2, is a disjunction of the disjuncts
(W1,3 ∧ P3,1) and W2,2. (Historically, the ∨ comes from the Latin “vel,” which means
“or.” For most people, it is easier to remember ∨ as an upside-down ∧.)
IMPLICATION ⇒ (implies). A sentence such as (W1,3∧P3,1) ⇒ ¬W2,2 is called an implication (or conPREMISE ditional). Its premise or antecedent is (W1,3 ∧P3,1), and its conclusion or consequent
CONCLUSION is ¬W2,2. Implications are also known as rules or if–then statements. The implication
RULES symbol is sometimes written in other books as ⊃ or →.
BICONDITIONAL ⇔ (if and only if). The sentence W1,3 ⇔ ¬W2,2 is a biconditional. Some other books
write this as ≡.
Sentence → AtomicSentence | ComplexSentence
AtomicSentence → True | False | P | Q | R | ...
ComplexSentence → ( Sentence ) | [ Sentence ]
| ¬ Sentence
| Sentence ∧ Sentence
| Sentence ∨ Sentence
| Sentence ⇒ Sentence
| Sentence ⇔ Sentence
OPERATOR PRECEDENCE : ¬, ∧, ∨, ⇒, ⇔
Figure 7.7 A BNF (Backus–Naur Form) grammar of sentences in propositional logic,
along with operator precedences, from highest to lowest.
Section 7.4. Propositional Logic: A Very Simple Logic 245
Figure 7.7 gives a formal grammar of propositional logic; see page 1060 if you are not
familiar with the BNF notation. The BNF grammar by itself is ambiguous; a sentence with
several operators can be parsed by the grammar in multiple ways. To eliminate the ambiguity
we define a precedence for each operator. The “not” operator (¬) has the highest precedence,
which means that in the sentence ¬A ∧ B the ¬ binds most tightly, giving us the equivalent
of (¬A)∧B rather than ¬(A∧B). (The notation for ordinary arithmetic is the same: −2+4
is 2, not –6.) When in doubt, use parentheses to make sure of the right interpretation. Square
brackets mean the same thing as parentheses; the choice of square brackets or parentheses is
solely to make it easier for a human to read a sentence.
7.4.2 Semantics
Having specified the syntax of propositional logic, we now specify its semantics. The semantics defines the rules for determining the truth of a sentence with respect to a particular
TRUTH VALUE model. In propositional logic, a model simply fixes the truth value—true or false—for every proposition symbol. For example, if the sentences in the knowledge base make use of the
proposition symbols P1,2, P2,2, and P3,1, then one possible model is
m1 = {P1,2 = false, P2,2 = false, P3,1 = true} .
With three proposition symbols, there are 23 = 8 possible models—exactly those depicted
in Figure 7.5. Notice, however, that the models are purely mathematical objects with no
necessary connection to wumpus worlds. P1,2 is just a symbol; it might mean “there is a pit
in [1,2]” or “I’m in Paris today and tomorrow.”
The semantics for propositional logic must specify how to compute the truth value of
any sentence, given a model. This is done recursively. All sentences are constructed from
atomic sentences and the five connectives; therefore, we need to specify how to compute the
truth of atomic sentences and how to compute the truth of sentences formed with each of the
five connectives. Atomic sentences are easy:
• True is true in every model and False is false in every model.
• The truth value of every other proposition symbol must be specified directly in the
model. For example, in the model m1 given earlier, P1,2 is false.
For complex sentences, we have five rules, which hold for any subsentences P and Q in any
model m (here “iff” means “if and only if”):
• ¬P is true iff P is false in m.
• P ∧ Q is true iff both P and Q are true in m.
• P ∨ Q is true iff either P or Q is true in m.
• P ⇒ Q is true unless P is true and Q is false in m.
• P ⇔ Q is true iff P and Q are both true or both false in m.
TRUTH TABLE The rules can also be expressed with truth tables that specify the truth value of a complex
sentence for each possible assignment of truth values to its components. Truth tables for the
five connectives are given in Figure 7.8. From these tables, the truth value of any sentence s
can be computed with respect to any model m by a simple recursive evaluation. For example,
246 Chapter 7. Logical Agents
P Q ¬P P ∧ Q P ∨ Q P ⇒ Q P ⇔ Q
false false true false false true true
false true true false true true false
true false false false true false false
true true false true true true true
Figure 7.8 Truth tables for the five logical connectives. To use the table to compute, for
example, the value of P ∨ Q when P is true and Q is false, first look on the left for the row
where P is true and Q is false (the third row). Then look in that row under the P ∨Q column
to see the result: true.
the sentence ¬P1,2 ∧ (P2,2 ∨ P3,1), evaluated in m1, gives true ∧ (false ∨ true) = true ∧
true = true. Exercise 7.3 asks you to write the algorithm PL-TRUE?(s, m), which computes
the truth value of a propositional logic sentence s in a model m.
The truth tables for “and,” “or,” and “not” are in close accord with our intuitions about
the English words. The main point of possible confusion is that P ∨ Q is true when P is true
or Q is true or both. A different connective, called “exclusive or” (“xor” for short), yields
false when both disjuncts are true.7 There is no consensus on the symbol for exclusive or;
some choices are ∨˙ or = or ⊕.
The truth table for ⇒ may not quite fit one’s intuitive understanding of “P implies Q”
or “if P then Q.” For one thing, propositional logic does not require any relation of causation
or relevance between P and Q. The sentence “5 is odd implies Tokyo is the capital of Japan”
is a true sentence of propositional logic (under the normal interpretation), even though it is
a decidedly odd sentence of English. Another point of confusion is that any implication is
true whenever its antecedent is false. For example, “5 is even implies Sam is smart” is true,
regardless of whether Sam is smart. This seems bizarre, but it makes sense if you think of
“P ⇒ Q” as saying, “If P is true, then I am claiming that Q is true. Otherwise I am making
no claim.” The only way for this sentence to be false is if P is true but Q is false.
The biconditional, P ⇔ Q, is true whenever both P ⇒ Q and Q ⇒ P are true. In
English, this is often written as “P if and only if Q.” Many of the rules of the wumpus world
are best written using ⇔. For example, a square is breezy if a neighboring square has a pit,
and a square is breezy only if a neighboring square has a pit. So we need a biconditional,
B1,1 ⇔ (P1,2 ∨ P2,1) ,
where B1,1 means that there is a breeze in [1,1].
7.4.3 A simple knowledge base
Now that we have defined the semantics for propositional logic, we can construct a knowledge
base for the wumpus world. We focus first on the immutable aspects of the wumpus world,
leaving the mutable aspects for a later section. For now, we need the following symbols for
each [x, y] location:
7 Latin has a separate word, aut, for exclusive or.
Section 7.4. Propositional Logic: A Very Simple Logic 247
Px,y is true if there is a pit in [x, y].
Wx,y is true if there is a wumpus in [x, y], dead or alive.
Bx,y is true if the agent perceives a breeze in [x, y].
Sx,y is true if the agent perceives a stench in [x, y].
The sentences we write will suffice to derive ¬P1,2 (there is no pit in [1,2]), as was done
informally in Section 7.3. We label each sentence Ri so that we can refer to them:
• There is no pit in [1,1]:
R1 : ¬P1,1 .
• A square is breezy if and only if there is a pit in a neighboring square. This has to be
stated for each square; for now, we include just the relevant squares:
R2 : B1,1 ⇔ (P1,2 ∨ P2,1) .
R3 : B2,1 ⇔ (P1,1 ∨ P2,2 ∨ P3,1) .
• The preceding sentences are true in all wumpus worlds. Now we include the breeze
percepts for the first two squares visited in the specific world the agent is in, leading up
to the situation in Figure 7.3(b).
R4 : ¬B1,1 .
R5 : B2,1 .
7.4.4 A simple inference procedure
Our goal now is to decide whether KB |= α for some sentence α. For example, is ¬P1,2
entailed by our KB? Our first algorithm for inference is a model-checking approach that is a
direct implementation of the definition of entailment: enumerate the models, and check that
α is true in every model in which KB is true. Models are assignments of true or false to
every proposition symbol. Returning to our wumpus-world example, the relevant proposition symbols are B1,1, B2,1, P1,1, P1,2, P2,1, P2,2, and P3,1. With seven symbols, there are
27 = 128 possible models; in three of these, KB is true (Figure 7.9). In those three models,
¬P1,2 is true, hence there is no pit in [1,2]. On the other hand, P2,2 is true in two of the three
models and false in one, so we cannot yet tell whether there is a pit in [2,2].
Figure 7.9 reproduces in a more precise form the reasoning illustrated in Figure 7.5. A
general algorithm for deciding entailment in propositional logic is shown in Figure 7.10. Like
the BACKTRACKING-SEARCH algorithm on page 215, TT-ENTAILS? performs a recursive
enumeration of a finite space of assignments to symbols. The algorithm is sound because it
implements directly the definition of entailment, and complete because it works for any KB
and α and always terminates—there are only finitely many models to examine.
Of course, “finitely many” is not always the same as “few.” If KB and α contain n
symbols in all, then there are 2n models. Thus, the time complexity of the algorithm is
O(2n). (The space complexity is only O(n) because the enumeration is depth-first.) Later in
this chapter we show algorithms that are much more efficient in many cases. Unfortunately,
propositional entailment is co-NP-complete (i.e., probably no easier than NP-complete—see
Appendix A), so every known inference algorithm for propositional logic has a worst-case
complexity that is exponential in the size of the input.
248 Chapter 7. Logical Agents
B1,1 B2,1 P1,1 P1,2 P2,1 P2,2 P3,1 R1 R2 R3 R4 R5 KB
false false false false false false false true true true true false false
false false false false false false true true true false true false false
.
.
. .
.
. .
.
. .
.
. .
.
. .
.
. .
.
. .
.
. .
.
. .
.
. .
.
. .
.
. .
.
.
false true false false false false false true true false true true false
false true false false false false true true true true true true true
false true false false false true false true true true true true true
false true false false false true true true true true true true true
false true false false true false false true false false true true false
.
.
. .
.
. .
.
. .
.
. .
.
. .
.
. .
.
. .
.
. .
.
. .
.
. .
.
. .
.
. .
.
.
true true true true true true true false true true false true false
Figure 7.9 A truth table constructed for the knowledge base given in the text. KB is true
if R1 through R5 are true, which occurs in just 3 of the 128 rows (the ones underlined in the
right-hand column). In all 3 rows, P1,2 is false, so there is no pit in [1,2]. On the other hand,
there might (or might not) be a pit in [2,2].
function TT-ENTAILS?(KB,α) returns true or false
inputs: KB, the knowledge base, a sentence in propositional logic
α, the query, a sentence in propositional logic
symbols ← a list of the proposition symbols in KB and α
return TT-CHECK-ALL(KB,α, symbols, { })
function TT-CHECK-ALL(KB,α, symbols , model) returns true or false
if EMPTY?(symbols) then
if PL-TRUE?(KB, model) then return PL-TRUE?(α, model)
else return true // when KB is false, always return true
else do
P ← FIRST(symbols)
rest ← REST(symbols)
return (TT-CHECK-ALL(KB,α, rest, model ∪ {P = true})
and
TT-CHECK-ALL(KB,α, rest, model ∪ {P = false }))
Figure 7.10 A truth-table enumeration algorithm for deciding propositional entailment.
(TT stands for truth table.) PL-TRUE? returns true if a sentence holds within a model. The
variable model represents a partial model—an assignment to some of the symbols. The keyword “and” is used here as a logical operation on its two arguments, returning true or false.
Section 7.5. Propositional Theorem Proving 249
(α ∧ β) ≡ (β ∧ α) commutativity of ∧
(α ∨ β) ≡ (β ∨ α) commutativity of ∨
((α ∧ β) ∧ γ) ≡ (α ∧ (β ∧ γ)) associativity of ∧
((α ∨ β) ∨ γ) ≡ (α ∨ (β ∨ γ)) associativity of ∨
¬(¬α) ≡ α double-negation elimination
(α ⇒ β) ≡ (¬β ⇒ ¬α) contraposition
(α ⇒ β) ≡ (¬α ∨ β) implication elimination
(α ⇔ β) ≡ ((α ⇒ β) ∧ (β ⇒ α)) biconditional elimination
¬(α ∧ β) ≡ (¬α ∨ ¬β) De Morgan
¬(α ∨ β) ≡ (¬α ∧ ¬β) De Morgan
(α ∧ (β ∨ γ)) ≡ ((α ∧ β) ∨ (α ∧ γ)) distributivity of ∧ over ∨
(α ∨ (β ∧ γ)) ≡ ((α ∨ β) ∧ (α ∨ γ)) distributivity of ∨ over ∧
Figure 7.11 Standard logical equivalences. The symbols α, β, and γ stand for arbitrary
sentences of propositional logic.
7.5 PROPOSITIONAL THEOREM PROVING
So far, we have shown how to determine entailment by model checking: enumerating models
and showing that the sentence must hold in all models. In this section, we show how entailTHEOREM PROVING ment can be done by theorem proving—applying rules of inference directly to the sentences
in our knowledge base to construct a proof of the desired sentence without consulting models.
If the number of models is large but the length of the proof is short, then theorem proving can
be more efficient than model checking.
Before we plunge into the details of theorem-proving algorithms, we will need some
additional concepts related to entailment. The first concept is logical equivalence: two sen- LOGICAL
EQUIVALENCE
tences α and β are logically equivalent if they are true in the same set of models. We write
this as α ≡ β. For example, we can easily show (using truth tables) that P ∧ Q and Q ∧ P
are logically equivalent; other equivalences are shown in Figure 7.11. These equivalences
play much the same role in logic as arithmetic identities do in ordinary mathematics. An
alternative definition of equivalence is as follows: any two sentences α and β are equivalent
only if each of them entails the other:
α ≡ β if and only if α |= β and β |= α .
VALIDITY The second concept we will need is validity. A sentence is valid if it is true in all models. For
TAUTOLOGY example, the sentence P ∨ ¬P is valid. Valid sentences are also known as tautologies—they
are necessarily true. Because the sentence True is true in all models, every valid sentence
is logically equivalent to True. What good are valid sentences? From our definition of
entailment, we can derive the deduction theorem, which was known to the ancient Greeks: DEDUCTION
THEOREM
For any sentences α and β, α |= β if and only if the sentence (α ⇒ β) is valid.
(Exercise 7.5 asks for a proof.) Hence, we can decide if α |= β by checking that (α ⇒ β) is
true in every model—which is essentially what the inference algorithm in Figure 7.10 does—
250 Chapter 7. Logical Agents
or by proving that (α ⇒ β) is equivalent to True. Conversely, the deduction theorem states
that every valid implication sentence describes a legitimate inference.
SATISFIABILITY The final concept we will need is satisfiability. A sentence is satisfiable if it is true
in, or satisfied by, some model. For example, the knowledge base given earlier, (R1 ∧ R2 ∧
R3 ∧ R4 ∧ R5), is satisfiable because there are three models in which it is true, as shown
in Figure 7.9. Satisfiability can be checked by enumerating the possible models until one is
found that satisfies the sentence. The problem of determining the satisfiability of sentences
SAT in propositional logic—the SAT problem—was the first problem proved to be NP-complete.
Many problems in computer science are really satisfiability problems. For example, all the
constraint satisfaction problems in Chapter 6 ask whether the constraints are satisfiable by
some assignment.
Validity and satisfiability are of course connected: α is valid iff ¬α is unsatisfiable;
contrapositively, α is satisfiable iff ¬α is not valid. We also have the following useful result:
α |= β if and only if the sentence (α ∧ ¬β) is unsatisfiable.
Proving β from α by checking the unsatisfiability of (α ∧ ¬β) corresponds exactly to the
standard mathematical proof technique of reductio ad absurdum (literally, “reduction to an REDUCTIO AD
ABSURDUM
REFUTATION absurd thing”). It is also called proof by refutation or proof by contradiction. One assumes a
CONTRADICTION sentence β to be false and shows that this leads to a contradiction with known axioms α. This
contradiction is exactly what is meant by saying that the sentence (α ∧ ¬β) is unsatisfiable.
7.5.1 Inference and proofs
INFERENCE RULES This section covers inference rules that can be applied to derive a proof—a chain of concluPROOF sions that leads to the desired goal. The best-known rule is called Modus Ponens (Latin for
MODUS PONENS mode that affirms) and is written
α ⇒ β, α
β .
The notation means that, whenever any sentences of the form α ⇒ β and α are given, then
the sentence β can be inferred. For example, if (WumpusAhead ∧WumpusAlive) ⇒ Shoot
and (WumpusAhead ∧ WumpusAlive) are given, then Shoot can be inferred.
AND-ELIMINATION Another useful inference rule is And-Elimination, which says that, from a conjunction,
any of the conjuncts can be inferred:
α ∧ β
α .
For example, from (WumpusAhead ∧ WumpusAlive), WumpusAlive can be inferred.
By considering the possible truth values of α and β, one can show easily that Modus
Ponens and And-Elimination are sound once and for all. These rules can then be used in
any particular instances where they apply, generating sound inferences without the need for
enumerating models.
All of the logical equivalences in Figure 7.11 can be used as inference rules. For example, the equivalence for biconditional elimination yields the two inference rules
α ⇔ β
(α ⇒ β) ∧ (β ⇒ α) and (α ⇒ β) ∧ (β ⇒ α)
α ⇔ β .
Section 7.5. Propositional Theorem Proving 251
Not all inference rules work in both directions like this. For example, we cannot run Modus
Ponens in the opposite direction to obtain α ⇒ β and α from β.
Let us see how these inference rules and equivalences can be used in the wumpus world.
We start with the knowledge base containing R1 through R5 and show how to prove ¬P1,2,
that is, there is no pit in [1,2]. First, we apply biconditional elimination to R2 to obtain
R6 : (B1,1 ⇒ (P1,2 ∨ P2,1)) ∧ ((P1,2 ∨ P2,1) ⇒ B1,1) .
Then we apply And-Elimination to R6 to obtain
R7 : ((P1,2 ∨ P2,1) ⇒ B1,1) .
Logical equivalence for contrapositives gives
R8 : (¬B1,1 ⇒ ¬(P1,2 ∨ P2,1)) .
Now we can apply Modus Ponens with R8 and the percept R4 (i.e., ¬B1,1), to obtain
R9 : ¬(P1,2 ∨ P2,1) .
Finally, we apply De Morgan’s rule, giving the conclusion
R10 : ¬P1,2 ∧ ¬P2,1 .
That is, neither [1,2] nor [2,1] contains a pit.
We found this proof by hand, but we can apply any of the search algorithms in Chapter 3
to find a sequence of steps that constitutes a proof. We just need to define a proof problem as
follows:
• INITIAL STATE: the initial knowledge base.
• ACTIONS: the set of actions consists of all the inference rules applied to all the sentences that match the top half of the inference rule.
• RESULT: the result of an action is to add the sentence in the bottom half of the inference
rule.
• GOAL: the goal is a state that contains the sentence we are trying to prove.
Thus, searching for proofs is an alternative to enumerating models. In many practical cases
finding a proof can be more efficient because the proof can ignore irrelevant propositions, no
matter how many of them there are. For example, the proof given earlier leading to ¬P1,2 ∧
¬P2,1 does not mention the propositions B2,1, P1,1, P2,2, or P3,1. They can be ignored
because the goal proposition, P1,2, appears only in sentence R2; the other propositions in R2
appear only in R4 and R2; so R1, R3, and R5 have no bearing on the proof. The same would
hold even if we added a million more sentences to the knowledge base; the simple truth-table
algorithm, on the other hand, would be overwhelmed by the exponential explosion of models.
MONOTONICITY One final property of logical systems is monotonicity, which says that the set of entailed sentences can only increase as information is added to the knowledge base.8 For any
sentences α and β,
if KB |= α then KB ∧ β |= α .
8 Nonmonotonic logics, which violate the monotonicity property, capture a common property of human reasoning: changing one’s mind. They are discussed in Section 12.6.
252 Chapter 7. Logical Agents
For example, suppose the knowledge base contains the additional assertion β stating that there
are exactly eight pits in the world. This knowledge might help the agent draw additional conclusions, but it cannot invalidate any conclusion α already inferred—such as the conclusion
that there is no pit in [1,2]. Monotonicity means that inference rules can be applied whenever
suitable premises are found in the knowledge base—the conclusion of the rule must follow
regardless of what else is in the knowledge base.
7.5.2 Proof by resolution
We have argued that the inference rules covered so far are sound, but we have not discussed
the question of completeness for the inference algorithms that use them. Search algorithms
such as iterative deepening search (page 89) are complete in the sense that they will find
any reachable goal, but if the available inference rules are inadequate, then the goal is not
reachable—no proof exists that uses only those inference rules. For example, if we removed
the biconditional elimination rule, the proof in the preceding section would not go through.
The current section introduces a single inference rule, resolution, that yields a complete
inference algorithm when coupled with any complete search algorithm.
We begin by using a simple version of the resolution rule in the wumpus world. Let us
consider the steps leading up to Figure 7.4(a): the agent returns from [2,1] to [1,1] and then
goes to [1,2], where it perceives a stench, but no breeze. We add the following facts to the
knowledge base:
R11 : ¬B1,2 .
R12 : B1,2 ⇔ (P1,1 ∨ P2,2 ∨ P1,3) .
By the same process that led to R10 earlier, we can now derive the absence of pits in [2,2]
and [1,3] (remember that [1,1] is already known to be pitless):
R13 : ¬P2,2 .
R14 : ¬P1,3 .
We can also apply biconditional elimination to R3, followed by Modus Ponens with R5, to
obtain the fact that there is a pit in [1,1], [2,2], or [3,1]:
R15 : P1,1 ∨ P2,2 ∨ P3,1 .
Now comes the first application of the resolution rule: the literal ¬P2,2 in R13 resolves with
RESOLVENT the literal P2,2 in R15 to give the resolvent
R16 : P1,1 ∨ P3,1 .
In English; if there’s a pit in one of [1,1], [2,2], and [3,1] and it’s not in [2,2], then it’s in [1,1]
or [3,1]. Similarly, the literal ¬P1,1 in R1 resolves with the literal P1,1 in R16 to give
R17 : P3,1 .
In English: if there’s a pit in [1,1] or [3,1] and it’s not in [1,1], then it’s in [3,1]. These last
UNIT RESOLUTION two inference steps are examples of the unit resolution inference rule,
1 ∨···∨ k, m
1 ∨···∨ i−1 ∨ i+1 ∨···∨ k
,
where each  is a literal and i and m are complementary literals (i.e., one is the negation COMPLEMENTARY
LITERALS
Section 7.5. Propositional Theorem Proving 253
CLAUSE of the other). Thus, the unit resolution rule takes a clause—a disjunction of literals—and a
literal and produces a new clause. Note that a single literal can be viewed as a disjunction of
UNIT CLAUSE one literal, also known as a unit clause.
RESOLUTION The unit resolution rule can be generalized to the full resolution rule,
1 ∨···∨ k, m1 ∨···∨ mn
1 ∨···∨ i−1 ∨ i+1 ∨···∨ k ∨ m1 ∨···∨ mj−1 ∨ mj+1 ∨···∨ mn
,
where i and mj are complementary literals. This says that resolution takes two clauses and
produces a new clause containing all the literals of the two original clauses except the two
complementary literals. For example, we have
P1,1 ∨ P3,1, ¬P1,1 ∨ ¬P2,2
P3,1 ∨ ¬P2,2
.
There is one more technical aspect of the resolution rule: the resulting clause should contain
only one copy of each literal.9 FACTORING The removal of multiple copies of literals is called factoring.
For example, if we resolve (A ∨ B) with (A ∨ ¬B), we obtain (A ∨ A), which is reduced to
just A.
The soundness of the resolution rule can be seen easily by considering the literal i that
is complementary to literal mj in the other clause. If i is true, then mj is false, and hence
m1 ∨···∨ mj−1 ∨ mj+1 ∨···∨ mn must be true, because m1 ∨···∨ mn is given. If i is
false, then 1 ∨···∨ i−1 ∨ i+1 ∨···∨ k must be true because 1 ∨···∨ k is given. Now
i is either true or false, so one or other of these conclusions holds—exactly as the resolution
rule states.
What is more surprising about the resolution rule is that it forms the basis for a family
of complete inference procedures. A resolution-based theorem prover can, for any sentences
α and β in propositional logic, decide whether α |= β. The next two subsections explain
how resolution accomplishes this.
Conjunctive normal form
The resolution rule applies only to clauses (that is, disjunctions of literals), so it would seem
to be relevant only to knowledge bases and queries consisting of clauses. How, then, can
it lead to a complete inference procedure for all of propositional logic? The answer is that
every sentence of propositional logic is logically equivalent to a conjunction of clauses. A
sentence expressed as a conjunction of clauses is said to be in conjunctive normal form or CONJUNCTIVE
NORMAL FORM
CNF (see Figure 7.14). We now describe a procedure for converting to CNF. We illustrate
the procedure by converting the sentence B1,1 ⇔ (P1,2 ∨ P2,1) into CNF. The steps are as
follows:
1. Eliminate ⇔, replacing α ⇔ β with (α ⇒ β) ∧ (β ⇒ α).
(B1,1 ⇒ (P1,2 ∨ P2,1)) ∧ ((P1,2 ∨ P2,1) ⇒ B1,1) .
2. Eliminate ⇒, replacing α ⇒ β with ¬α ∨ β:
(¬B1,1 ∨ P1,2 ∨ P2,1) ∧ (¬(P1,2 ∨ P2,1) ∨ B1,1) .
9 If a clause is viewed as a set of literals, then this restriction is automatically respected. Using set notation for
clauses makes the resolution rule much cleaner, at the cost of introducing additional notation.
254 Chapter 7. Logical Agents
3. CNF requires ¬ to appear only in literals, so we “move ¬ inwards” by repeated application of the following equivalences from Figure 7.11:
¬(¬α) ≡ α (double-negation elimination)
¬(α ∧ β) ≡ (¬α ∨ ¬β) (De Morgan)
¬(α ∨ β) ≡ (¬α ∧ ¬β) (De Morgan)
In the example, we require just one application of the last rule:
(¬B1,1 ∨ P1,2 ∨ P2,1) ∧ ((¬P1,2 ∧ ¬P2,1) ∨ B1,1) .
4. Now we have a sentence containing nested ∧ and ∨ operators applied to literals. We
apply the distributivity law from Figure 7.11, distributing ∨ over ∧ wherever possible.
(¬B1,1 ∨ P1,2 ∨ P2,1) ∧ (¬P1,2 ∨ B1,1) ∧ (¬P2,1 ∨ B1,1) .
The original sentence is now in CNF, as a conjunction of three clauses. It is much harder to
read, but it can be used as input to a resolution procedure.
A resolution algorithm
Inference procedures based on resolution work by using the principle of proof by contradiction introduced on page 250. That is, to show that KB |= α, we show that (KB ∧ ¬α) is
unsatisfiable. We do this by proving a contradiction.
A resolution algorithm is shown in Figure 7.12. First, (KB ∧ ¬α) is converted into
CNF. Then, the resolution rule is applied to the resulting clauses. Each pair that contains
complementary literals is resolved to produce a new clause, which is added to the set if it is
not already present. The process continues until one of two things happens:
• there are no new clauses that can be added, in which case KB does not entail α; or,
• two clauses resolve to yield the empty clause, in which case KB entails α.
The empty clause—a disjunction of no disjuncts—is equivalent to False because a disjunction
is true only if at least one of its disjuncts is true. Another way to see that an empty clause
represents a contradiction is to observe that it arises only from resolving two complementary
unit clauses such as P and ¬P.
We can apply the resolution procedure to a very simple inference in the wumpus world.
When the agent is in [1,1], there is no breeze, so there can be no pits in neighboring squares.
The relevant knowledge base is
KB = R2 ∧ R4 = (B1,1 ⇔ (P1,2 ∨ P2,1)) ∧ ¬B1,1
and we wish to prove α which is, say, ¬P1,2. When we convert (KB ∧ ¬α) into CNF, we
obtain the clauses shown at the top of Figure 7.13. The second row of the figure shows
clauses obtained by resolving pairs in the first row. Then, when P1,2 is resolved with ¬P1,2,
we obtain the empty clause, shown as a small square. Inspection of Figure 7.13 reveals that
many resolution steps are pointless. For example, the clause B1,1 ∨¬B1,1∨P1,2 is equivalent
to True ∨ P1,2 which is equivalent to True. Deducing that True is true is not very helpful.
Therefore, any clause in which two complementary literals appear can be discarded.
Section 7.5. Propositional Theorem Proving 255
function PL-RESOLUTION(KB,α) returns true or false
inputs: KB, the knowledge base, a sentence in propositional logic
α, the query, a sentence in propositional logic
clauses ← the set of clauses in the CNF representation of KB ∧ ¬α
new ←{}
loop do
for each pair of clauses Ci, Cj in clauses do
resolvents ← PL-RESOLVE(Ci, Cj )
if resolvents contains the empty clause then return true
new ← new ∪ resolvents
if new ⊆ clauses then return false
clauses ← clauses ∪new
Figure 7.12 A simple resolution algorithm for propositional logic. The function
PL-RESOLVE returns the set of all possible clauses obtained by resolving its two inputs.
¬P2,1 B1,1 ¬B1,1 P1,2 P2,1 ¬P1,2 B1,1 ¬B1,1 P1,2
¬B1,1 P1,2 B1,1 P1,2 P2,1 ¬P2,1 ¬B1,1 P2,1 B1,1 P1,2 P2,1 ¬P1,2 ¬P2,1 ¬P1,2
^ ^ ^
^ ^ ^ ^ ^ ^ ^ ^
^
Figure 7.13 Partial application of PL-RESOLUTION to a simple inference in the wumpus
world. ¬P1,2 is shown to follow from the first four clauses in the top row.
Completeness of resolution
To conclude our discussion of resolution, we now show why PL-RESOLUTION is complete.
To do this, we introduce the resolution closure RC (S) of a set of clauses S, which is the set RESOLUTION
CLOSURE
of all clauses derivable by repeated application of the resolution rule to clauses in S or their
derivatives. The resolution closure is what PL-RESOLUTION computes as the final value of
the variable clauses. It is easy to see that RC (S) must be finite, because there are only finitely
many distinct clauses that can be constructed out of the symbols P1,...,Pk that appear in S.
(Notice that this would not be true without the factoring step that removes multiple copies of
literals.) Hence, PL-RESOLUTION always terminates.
The completeness theorem for resolution in propositional logic is called the ground
resolution theorem:
GROUND
RESOLUTION
THEOREM
If a set of clauses is unsatisfiable, then the resolution closure of those clauses
contains the empty clause.
This theorem is proved by demonstrating its contrapositive: if the closure RC(S) does not
256 Chapter 7. Logical Agents
contain the empty clause, then S is satisfiable. In fact, we can construct a model for S with
suitable truth values for P1,...,Pk. The construction procedure is as follows:
For i from 1 to k,
– If a clause in RC(S) contains the literal ¬Pi and all its other literals are false under
the assignment chosen for P1,...,Pi−1, then assign false to Pi.
– Otherwise, assign true to Pi.
This assignment to P1,...,Pk is a model of S. To see this, assume the opposite—that, at
some stage i in the sequence, assigning symbol Pi causes some clause C to become false.
For this to happen, it must be the case that all the other literals in C must already have been
falsified by assignments to P1,...,Pi−1. Thus, C must now look like either (false ∨ false ∨
··· false∨Pi) or like (false∨false∨··· false∨¬Pi). If just one of these two is in RC(S), then
the algorithm will assign the appropriate truth value to Pi to make C true, so C can only be
falsified if both of these clauses are in RC(S). Now, since RC(S) is closed under resolution,
it will contain the resolvent of these two clauses, and that resolvent will have all of its literals
already falsified by the assignments to P1,...,Pi−1. This contradicts our assumption that
the first falsified clause appears at stage i. Hence, we have proved that the construction never
falsifies a clause in RC(S); that is, it produces a model of RC(S) and thus a model of S
itself (since S is contained in RC(S)).
7.5.3 Horn clauses and definite clauses
The completeness of resolution makes it a very important inference method. In many practical
situations, however, the full power of resolution is not needed. Some real-world knowledge
bases satisfy certain restrictions on the form of sentences they contain, which enables them
to use a more restricted and efficient inference algorithm.
DEFINITE CLAUSE One such restricted form is the definite clause, which is a disjunction of literals of
which exactly one is positive. For example, the clause (¬L1,1 ∨ ¬Breeze ∨ B1,1) is a definite
clause, whereas (¬B1,1 ∨ P1,2 ∨ P2,1) is not.
HORN CLAUSE Slightly more general is the Horn clause, which is a disjunction of literals of which at
most one is positive. So all definite clauses are Horn clauses, as are clauses with no positive
GOAL CLAUSES literals; these are called goal clauses. Horn clauses are closed under resolution: if you resolve
two Horn clauses, you get back a Horn clause.
Knowledge bases containing only definite clauses are interesting for three reasons:
1. Every definite clause can be written as an implication whose premise is a conjunction
of positive literals and whose conclusion is a single positive literal. (See Exercise 7.13.)
For example, the definite clause (¬L1,1 ∨ ¬Breeze ∨ B1,1) can be written as the implication (L1,1 ∧ Breeze) ⇒ B1,1. In the implication form, the sentence is easier to
understand: it says that if the agent is in [1,1] and there is a breeze, then [1,1] is breezy.
BODY In Horn form, the premise is called the body and the conclusion is called the head. A
HEAD sentence consisting of a single positive literal, such as L1,1, is called a fact. It too can
FACT be written in implication form as True ⇒ L1,1, but it is simpler to write just L1,1.
Section 7.5. Propositional Theorem Proving 257
CNFSentence → Clause1 ∧···∧ Clausen
Clause → Literal 1 ∨···∨ Literalm
Literal → Symbol | ¬Symbol
Symbol → P | Q | R | ...
HornClauseForm → DefiniteClauseForm | GoalClauseForm
DefiniteClauseForm → (Symbol 1 ∧···∧ Symboll) ⇒ Symbol
GoalClauseForm → (Symbol 1 ∧···∧ Symboll) ⇒ False
Figure 7.14 A grammar for conjunctive normal form, Horn clauses, and definite clauses.
A clause such as A ∧ B ⇒ C is still a definite clause when it is written as ¬A ∨ ¬B ∨ C,
but only the former is considered the canonical form for definite clauses. One more class is
the k-CNF sentence, which is a CNF sentence where each clause has at most k literals.
FORWARD-CHAINING 2. Inference with Horn clauses can be done through the forward-chaining and backwardchaining algorithms, which we explain next. Both of these algorithms are natural, BACKWARDCHAINING
in that the inference steps are obvious and easy for humans to follow. This type of
inference is the basis for logic programming, which is discussed in Chapter 9.
3. Deciding entailment with Horn clauses can be done in time that is linear in the size of
the knowledge base—a pleasant surprise.
7.5.4 Forward and backward chaining
The forward-chaining algorithm PL-FC-ENTAILS?(KB, q) determines if a single proposition symbol q—the query—is entailed by a knowledge base of definite clauses. It begins
from known facts (positive literals) in the knowledge base. If all the premises of an implication are known, then its conclusion is added to the set of known facts. For example, if L1,1
and Breeze are known and (L1,1 ∧ Breeze) ⇒ B1,1 is in the knowledge base, then B1,1 can
be added. This process continues until the query q is added or until no further inferences can
be made. The detailed algorithm is shown in Figure 7.15; the main point to remember is that
it runs in linear time.
The best way to understand the algorithm is through an example and a picture. Figure 7.16(a) shows a simple knowledge base of Horn clauses with A and B as known facts.
Figure 7.16(b) shows the same knowledge base drawn as an AND–OR graph (see Chapter 4). In AND–OR graphs, multiple links joined by an arc indicate a conjunction—every
link must be proved—while multiple links without an arc indicate a disjunction—any link
can be proved. It is easy to see how forward chaining works in the graph. The known leaves
(here, A and B) are set, and inference propagates up the graph as far as possible. Wherever a conjunction appears, the propagation waits until all the conjuncts are known before
proceeding. The reader is encouraged to work through the example in detail.
258 Chapter 7. Logical Agents
function PL-FC-ENTAILS?(KB, q) returns true or false
inputs: KB, the knowledge base, a set of propositional definite clauses
q, the query, a proposition symbol
count ← a table, where count[c] is the number of symbols in c’s premise
inferred ← a table, where inferred[s] is initially false for all symbols
agenda ←a queue of symbols, initially symbols known to be true in KB
while agenda is not empty do
p ← POP(agenda)
if p = q then return true
if inferred[p] = false then
inferred[p] ←true
for each clause c in KB where p is in c.PREMISE do
decrement count[c]
if count[c]=0 then add c.CONCLUSION to agenda
return false
Figure 7.15 The forward-chaining algorithm for propositional logic. The agenda keeps
track of symbols known to be true but not yet “processed.” The count table keeps track of
how many premises of each implication are as yet unknown. Whenever a new symbol p from
the agenda is processed, the count is reduced by one for each implication in whose premise
p appears (easily identified in constant time with appropriate indexing.) If a count reaches
zero, all the premises of the implication are known, so its conclusion can be added to the
agenda. Finally, we need to keep track of which symbols have been processed; a symbol that
is already in the set of inferred symbols need not be added to the agenda again. This avoids
redundant work and prevents loops caused by implications such as P ⇒ Q and Q ⇒ P.
It is easy to see that forward chaining is sound: every inference is essentially an application of Modus Ponens. Forward chaining is also complete: every entailed atomic sentence
will be derived. The easiest way to see this is to consider the final state of the inferred table
FIXED POINT (after the algorithm reaches a fixed point where no new inferences are possible). The table
contains true for each symbol inferred during the process, and false for all other symbols.
We can view the table as a logical model; moreover, every definite clause in the original KB is
true in this model. To see this, assume the opposite, namely that some clause a1∧...∧ak ⇒ b
is false in the model. Then a1 ∧ ... ∧ ak must be true in the model and b must be false in
the model. But this contradicts our assumption that the algorithm has reached a fixed point!
We can conclude, therefore, that the set of atomic sentences inferred at the fixed point defines
a model of the original KB. Furthermore, any atomic sentence q that is entailed by the KB
must be true in all its models and in this model in particular. Hence, every entailed atomic
sentence q must be inferred by the algorithm.
DATA-DRIVEN Forward chaining is an example of the general concept of data-driven reasoning—that
is, reasoning in which the focus of attention starts with the known data. It can be used within
an agent to derive conclusions from incoming percepts, often without a specific query in
mind. For example, the wumpus agent might TELL its percepts to the knowledge base using
Section 7.6. Effective Propositional Model Checking 259
P ⇒ Q
L ∧ M ⇒ P
B ∧ L ⇒ M
A ∧ P ⇒ L
A ∧ B ⇒ L
A
B
Q
P
M
L
A B
(a) (b)
Figure 7.16 (a) A set of Horn clauses. (b) The corresponding AND–OR graph.
an incremental forward-chaining algorithm in which new facts can be added to the agenda to
initiate new inferences. In humans, a certain amount of data-driven reasoning occurs as new
information arrives. For example, if I am indoors and hear rain starting to fall, it might occur
to me that the picnic will be canceled. Yet it will probably not occur to me that the seventeenth
petal on the largest rose in my neighbor’s garden will get wet; humans keep forward chaining
under careful control, lest they be swamped with irrelevant consequences.
The backward-chaining algorithm, as its name suggests, works backward from the
query. If the query q is known to be true, then no work is needed. Otherwise, the algorithm
finds those implications in the knowledge base whose conclusion is q. If all the premises of
one of those implications can be proved true (by backward chaining), then q is true. When
applied to the query Q in Figure 7.16, it works back down the graph until it reaches a set of
known facts, A and B, that forms the basis for a proof. The algorithm is essentially identical
to the AND-OR-GRAPH-SEARCH algorithm in Figure 4.11. As with forward chaining, an
efficient implementation runs in linear time.
Backward chaining is a form of goal-directed reasoning. It is useful for answering GOAL-DIRECTED
REASONING
specific questions such as “What shall I do now?” and “Where are my keys?” Often, the cost
of backward chaining is much less than linear in the size of the knowledge base, because the
process touches only relevant facts.
7.6 EFFECTIVE PROPOSITIONAL MODEL CHECKING
In this section, we describe two families of efficient algorithms for general propositional
inference based on model checking: One approach based on backtracking search, and one
on local hill-climbing search. These algorithms are part of the “technology” of propositional
logic. This section can be skimmed on a first reading of the chapter.
260 Chapter 7. Logical Agents
The algorithms we describe are for checking satisfiability: the SAT problem. (As noted
earlier, testing entailment, α |= β, can be done by testing unsatisfiability of α ∧ ¬β.) We
have already noted the connection between finding a satisfying model for a logical sentence
and finding a solution for a constraint satisfaction problem, so it is perhaps not surprising that
the two families of algorithms closely resemble the backtracking algorithms of Section 6.3
and the local search algorithms of Section 6.4. They are, however, extremely important in
their own right because so many combinatorial problems in computer science can be reduced
to checking the satisfiability of a propositional sentence. Any improvement in satisfiability
algorithms has huge consequences for our ability to handle complexity in general.
7.6.1 A complete backtracking algorithm
The first algorithm we consider is often called the Davis–Putnam algorithm, after the sem- DAVIS–PUTNAM
ALGORITHM
inal paper by Martin Davis and Hilary Putnam (1960). The algorithm is in fact the version
described by Davis, Logemann, and Loveland (1962), so we will call it DPLL after the initials of all four authors. DPLL takes as input a sentence in conjunctive normal form—a set
of clauses. Like BACKTRACKING-SEARCH and TT-ENTAILS?, it is essentially a recursive,
depth-first enumeration of possible models. It embodies three improvements over the simple
scheme of TT-ENTAILS?:
• Early termination: The algorithm detects whether the sentence must be true or false,
even with a partially completed model. A clause is true if any literal is true, even if
the other literals do not yet have truth values; hence, the sentence as a whole could be
judged true even before the model is complete. For example, the sentence (A ∨ B) ∧
(A ∨ C) is true if A is true, regardless of the values of B and C. Similarly, a sentence
is false if any clause is false, which occurs when each of its literals is false. Again, this
can occur long before the model is complete. Early termination avoids examination of
entire subtrees in the search space.
PURE SYMBOL • Pure symbol heuristic: A pure symbol is a symbol that always appears with the same
“sign” in all clauses. For example, in the three clauses (A ∨ ¬B), (¬B ∨ ¬C), and
(C ∨ A), the symbol A is pure because only the positive literal appears, B is pure
because only the negative literal appears, and C is impure. It is easy to see that if
a sentence has a model, then it has a model with the pure symbols assigned so as to
make their literals true, because doing so can never make a clause false. Note that, in
determining the purity of a symbol, the algorithm can ignore clauses that are already
known to be true in the model constructed so far. For example, if the model contains
B = false, then the clause (¬B ∨ ¬C) is already true, and in the remaining clauses C
appears only as a positive literal; therefore C becomes pure.
• Unit clause heuristic: A unit clause was defined earlier as a clause with just one literal. In the context of DPLL, it also means clauses in which all literals but one are
already assigned false by the model. For example, if the model contains B = true,
then (¬B ∨ ¬C) simplifies to ¬C, which is a unit clause. Obviously, for this clause
to be true, C must be set to false. The unit clause heuristic assigns all such symbols
before branching on the remainder. One important consequence of the heuristic is that
Section 7.6. Effective Propositional Model Checking 261
function DPLL-SATISFIABLE?(s) returns true or false
inputs: s, a sentence in propositional logic
clauses ← the set of clauses in the CNF representation of s
symbols ← a list of the proposition symbols in s
return DPLL(clauses, symbols, { })
function DPLL(clauses, symbols, model) returns true or false
if every clause in clauses is true in model then return true
if some clause in clauses is false in model then return false
P, value ← FIND-PURE-SYMBOL(symbols, clauses, model)
if P is non-null then return DPLL(clauses, symbols – P, model ∪ {P=value})
P, value ← FIND-UNIT-CLAUSE(clauses, model)
if P is non-null then return DPLL(clauses, symbols – P, model ∪ {P=value})
P ← FIRST(symbols); rest ← REST(symbols)
return DPLL(clauses, rest, model ∪ {P=true}) or
DPLL(clauses, rest, model ∪ {P=false}))
Figure 7.17 The DPLL algorithm for checking satisfiability of a sentence in propositional
logic. The ideas behind FIND-PURE-SYMBOL and FIND-UNIT-CLAUSE are described in
the text; each returns a symbol (or null) and the truth value to assign to that symbol. Like
TT-ENTAILS?, DPLL operates over partial models.
any attempt to prove (by refutation) a literal that is already in the knowledge base will
succeed immediately (Exercise 7.23). Notice also that assigning one unit clause can
create another unit clause—for example, when C is set to false, (C ∨ A) becomes a
unit clause, causing true to be assigned to A. This “cascade” of forced assignments
UNIT PROPAGATION is called unit propagation. It resembles the process of forward chaining with definite
clauses, and indeed, if the CNF expression contains only definite clauses then DPLL
essentially replicates forward chaining. (See Exercise 7.24.)
The DPLL algorithm is shown in Figure 7.17, which gives the the essential skeleton of the
search process.
What Figure 7.17 does not show are the tricks that enable SAT solvers to scale up to
large problems. It is interesting that most of these tricks are in fact rather general, and we
have seen them before in other guises:
1. Component analysis (as seen with Tasmania in CSPs): As DPLL assigns truth values
to variables, the set of clauses may become separated into disjoint subsets, called components, that share no unassigned variables. Given an efficient way to detect when this
occurs, a solver can gain considerable speed by working on each component separately.
2. Variable and value ordering (as seen in Section 6.3.1 for CSPs): Our simple implementation of DPLL uses an arbitrary variable ordering and always tries the value true
before false. The degree heuristic (see page 216) suggests choosing the variable that
appears most frequently over all remaining clauses.
262 Chapter 7. Logical Agents
3. Intelligent backtracking (as seen in Section 6.3 for CSPs): Many problems that cannot be solved in hours of run time with chronological backtracking can be solved in
seconds with intelligent backtracking that backs up all the way to the relevant point of
conflict. All SAT solvers that do intelligent backtracking use some form of conflict
clause learning to record conflicts so that they won’t be repeated later in the search.
Usually a limited-size set of conflicts is kept, and rarely used ones are dropped.
4. Random restarts (as seen on page 124 for hill-climbing): Sometimes a run appears not
to be making progress. In this case, we can start over from the top of the search tree,
rather than trying to continue. After restarting, different random choices (in variable
and value selection) are made. Clauses that are learned in the first run are retained after
the restart and can help prune the search space. Restarting does not guarantee that a
solution will be found faster, but it does reduce the variance on the time to solution.
5. Clever indexing (as seen in many algorithms): The speedup methods used in DPLL
itself, as well as the tricks used in modern solvers, require fast indexing of such things
as “the set of clauses in which variable Xi appears as a positive literal.” This task is
complicated by the fact that the algorithms are interested only in the clauses that have
not yet been satisfied by previous assignments to variables, so the indexing structures
must be updated dynamically as the computation proceeds.
With these enhancements, modern solvers can handle problems with tens of millions of variables. They have revolutionized areas such as hardware verification and security protocol
verification, which previously required laborious, hand-guided proofs.
7.6.2 Local search algorithms
We have seen several local search algorithms so far in this book, including HILL-CLIMBING
(page 122) and SIMULATED-ANNEALING (page 126). These algorithms can be applied directly to satisfiability problems, provided that we choose the right evaluation function. Because the goal is to find an assignment that satisfies every clause, an evaluation function that
counts the number of unsatisfied clauses will do the job. In fact, this is exactly the measure
used by the MIN-CONFLICTS algorithm for CSPs (page 221). All these algorithms take steps
in the space of complete assignments, flipping the truth value of one symbol at a time. The
space usually contains many local minima, to escape from which various forms of randomness are required. In recent years, there has been a great deal of experimentation to find a
good balance between greediness and randomness.
One of the simplest and most effective algorithms to emerge from all this work is called
WALKSAT (Figure 7.18). On every iteration, the algorithm picks an unsatisfied clause and
picks a symbol in the clause to flip. It chooses randomly between two ways to pick which
symbol to flip: (1) a “min-conflicts” step that minimizes the number of unsatisfied clauses in
the new state and (2) a “random walk” step that picks the symbol randomly.
When WALKSAT returns a model, the input sentence is indeed satisfiable, but when
it returns failure, there are two possible causes: either the sentence is unsatisfiable or we
need to give the algorithm more time. If we set max flips = ∞ and p > 0, WALKSAT will
eventually return a model (if one exists), because the random-walk steps will eventually hit
Section 7.6. Effective Propositional Model Checking 263
function WALKSAT(clauses, p, max flips) returns a satisfying model or failure
inputs: clauses, a set of clauses in propositional logic
p, the probability of choosing to do a “random walk” move, typically around 0.5
max flips, number of flips allowed before giving up
model ← a random assignment of true/false to the symbols in clauses
for i = 1 to max flips do
if model satisfies clauses then return model
clause ← a randomly selected clause from clauses that is false in model
with probability p flip the value in model of a randomly selected symbol from clause
else flip whichever symbol in clause maximizes the number of satisfied clauses
return failure
Figure 7.18 The WALKSAT algorithm for checking satisfiability by randomly flipping
the values of variables. Many versions of the algorithm exist.
upon the solution. Alas, if max flips is infinity and the sentence is unsatisfiable, then the
algorithm never terminates!
For this reason, WALKSAT is most useful when we expect a solution to exist—for example, the problems discussed in Chapters 3 and 6 usually have solutions. On the other hand,
WALKSAT cannot always detect unsatisfiability, which is required for deciding entailment.
For example, an agent cannot reliably use WALKSAT to prove that a square is safe in the
wumpus world. Instead, it can say, “I thought about it for an hour and couldn’t come up with
a possible world in which the square isn’t safe.” This may be a good empirical indicator that
the square is safe, but it’s certainly not a proof.
7.6.3 The landscape of random SAT problems
Some SAT problems are harder than others. Easy problems can be solved by any old algorithm, but because we know that SAT is NP-complete, at least some problem instances must
require exponential run time. In Chapter 6, we saw some surprising discoveries about certain
kinds of problems. For example, the n-queens problem—thought to be quite tricky for backtracking search algorithms—turned out to be trivially easy for local search methods, such as
min-conflicts. This is because solutions are very densely distributed in the space of assignments, and any initial assignment is guaranteed to have a solution nearby. Thus, n-queens is
UNDERCONSTRAINED easy because it is underconstrained.
When we look at satisfiability problems in conjunctive normal form, an underconstrained problem is one with relatively few clauses constraining the variables. For example,
here is a randomly generated 3-CNF sentence with five symbols and five clauses:
(¬D ∨ ¬B ∨ C) ∧ (B ∨ ¬A ∨ ¬C) ∧ (¬C ∨ ¬B ∨ E)
∧ (E ∨ ¬D ∨ B) ∧ (B ∨ E ∨ ¬C) .
Sixteen of the 32 possible assignments are models of this sentence, so, on average, it would
take just two random guesses to find a model. This is an easy satisfiability problem, as are
264 Chapter 7. Logical Agents
most such underconstrained problems. On the other hand, an overconstrained problem has
many clauses relative to the number of variables and is likely to have no solutions.
To go beyond these basic intuitions, we must define exactly how random sentences
are generated. The notation CNFk(m, n) denotes a k-CNF sentence with m clauses and n
symbols, where the clauses are chosen uniformly, independently, and without replacement
from among all clauses with k different literals, which are positive or negative at random. (A
symbol may not appear twice in a clause, nor may a clause appear twice in a sentence.)
Given a source of random sentences, we can measure the probability of satisfiability.
Figure 7.19(a) plots the probability for CNF3(m, 50), that is, sentences with 50 variables
and 3 literals per clause, as a function of the clause/symbol ratio, m/n. As we expect, for
small m/n the probability of satisfiability is close to 1, and at large m/n the probability
is close to 0. The probability drops fairly sharply around m/n = 4.3. Empirically, we find
that the “cliff” stays in roughly the same place (for k = 3) and gets sharper and sharper as n
increases. Theoretically, the satisfiability threshold conjecture says that for every k ≥ 3, SATISFIABILITY
THRESHOLD
CONJECTURE
there is a threshold ratio rk such that, as n goes to infinity, the probability that CNFk(n, rn)
is satisfiable becomes 1 for all values of r below the threshold, and 0 for all values above.
The conjecture remains unproven.
0
0.2
0.4
0.6
0.8
1
0 1 2 3 4 5 6 7 8
P(satisfiable)
Clause/symbol ratio m/n
0
200
400
600
800
1000
1200
1400
1600
1800
2000
0 1 2 3 4 5 6 7 8
Runtime
Clause/symbol ratio m/n
DPLL
WalkSAT
(a) (b)
Figure 7.19 (a) Graph showing the probability that a random 3-CNF sentence with n = 50
symbols is satisfiable, as a function of the clause/symbol ratio m/n. (b) Graph of the median
run time (measured in number of recursive calls to DPLL, a good proxy) on random 3-CNF
sentences. The most difficult problems have a clause/symbol ratio of about 4.3.
Now that we have a good idea where the satisfiable and unsatisfiable problems are, the
next question is, where are the hard problems? It turns out that they are also often at the
threshold value. Figure 7.19(b) shows that 50-symbol problems at the threshold value of 4.3
are about 20 times more difficult to solve than those at a ratio of 3.3. The underconstrained
problems are easiest to solve (because it is so easy to guess a solution); the overconstrained
problems are not as easy as the underconstrained, but still are much easier than the ones right
at the threshold.
Section 7.7. Agents Based on Propositional Logic 265
7.7 AGENTS BASED ON PROPOSITIONAL LOGIC
In this section, we bring together what we have learned so far in order to construct wumpus
world agents that use propositional logic. The first step is to enable the agent to deduce, to the
extent possible, the state of the world given its percept history. This requires writing down a
complete logical model of the effects of actions. We also show how the agent can keep track of
the world efficiently without going back into the percept history for each inference. Finally,
we show how the agent can use logical inference to construct plans that are guaranteed to
achieve its goals.
7.7.1 The current state of the world
As stated at the beginning of the chapter, a logical agent operates by deducing what to do
from a knowledge base of sentences about the world. The knowledge base is composed of
axioms—general knowledge about how the world works—and percept sentences obtained
from the agent’s experience in a particular world. In this section, we focus on the problem of
deducing the current state of the wumpus world—where am I, is that square safe, and so on.
We began collecting axioms in Section 7.4.3. The agent knows that the starting square
contains no pit (¬P1,1) and no wumpus (¬W1,1). Furthermore, for each square, it knows that
the square is breezy if and only if a neighboring square has a pit; and a square is smelly if and
only if a neighboring square has a wumpus. Thus, we include a large collection of sentences
of the following form:
B1,1 ⇔ (P1,2 ∨ P2,1)
S1,1 ⇔ (W1,2 ∨ W2,1)
···
The agent also knows that there is exactly one wumpus. This is expressed in two parts. First,
we have to say that there is at least one wumpus:
W1,1 ∨ W1,2 ∨···∨ W4,3 ∨ W4,4 .
Then, we have to say that there is at most one wumpus. For each pair of locations, we add a
sentence saying that at least one of them must be wumpus-free:
¬W1,1 ∨ ¬W1,2
¬W1,1 ∨ ¬W1,3
···
¬W4,3 ∨ ¬W4,4 .
So far, so good. Now let’s consider the agent’s percepts. If there is currently a stench, one
might suppose that a proposition Stench should be added to the knowledge base. This is not
quite right, however: if there was no stench at the previous time step, then ¬Stench would already be asserted, and the new assertion would simply result in a contradiction. The problem
is solved when we realize that a percept asserts something only about the current time. Thus,
if the time step (as supplied to MAKE-PERCEPT-SENTENCE in Figure 7.1) is 4, then we add
266 Chapter 7. Logical Agents
Stench4 to the knowledge base, rather than Stench—neatly avoiding any contradiction with
¬Stench3. The same goes for the breeze, bump, glitter, and scream percepts.
The idea of associating propositions with time steps extends to any aspect of the world
that changes over time. For example, the initial knowledge base includes L0
1,1—the agent is in
square [1, 1] at time 0—as well as FacingEast 0, HaveArrow0, and WumpusAlive0. We use
FLUENT the word fluent (from the Latin fluens, flowing) to refer an aspect of the world that changes.
“Fluent” is a synonym for “state variable,” in the sense described in the discussion of factored
representations in Section 2.4.7 on page 57. Symbols associated with permanent aspects of
the world do not need a time superscript and are sometimes called atemporal variables. ATEMPORAL
VARIABLE
We can connect stench and breeze percepts directly to the properties of the squares
where they are experienced through the location fluent as follows.10 For any time step t and
any square [x, y], we assert
Lt
x,y ⇒ (Breezet ⇔ Bx,y)
Lt
x,y ⇒ (Stencht ⇔ Sx,y) .
Now, of course, we need axioms that allow the agent to keep track of fluents such as Lt
x,y.
These fluents change as the result of actions taken by the agent, so, in the terminology of
Chapter 3, we need to write down the transition model of the wumpus world as a set of
logical sentences.
First, we need proposition symbols for the occurrences of actions. As with percepts,
these symbols are indexed by time; thus, Forward 0 means that the agent executes the Forward
action at time 0. By convention, the percept for a given time step happens first, followed by
the action for that time step, followed by a transition to the next time step.
EFFECT AXIOM To describe how the world changes, we can try writing effect axioms that specify the
outcome of an action at the next time step. For example, if the agent is at location [1, 1] facing
east at time 0 and goes Forward, the result is that the agent is in square [2, 1] and no longer
is in [1, 1]:
L0
1,1 ∧ FacingEast 0 ∧ Forward 0 ⇒ (L1
2,1 ∧ ¬L1
1,1) . (7.1)
We would need one such sentence for each possible time step, for each of the 16 squares,
and each of the four orientations. We would also need similar sentences for the other actions:
Grab, Shoot, Climb, TurnLeft, and TurnRight.
Let us suppose that the agent does decide to move Forward at time 0 and asserts this
fact into its knowledge base. Given the effect axiom in Equation (7.1), combined with the
initial assertions about the state at time 0, the agent can now deduce that it is in [2, 1]. That
is, ASK(KB, L1
2,1) = true. So far, so good. Unfortunately, the news elsewhere is less good:
if we ASK(KB, HaveArrow1), the answer is false, that is, the agent cannot prove it still
has the arrow; nor can it prove it doesn’t have it! The information has been lost because the
effect axiom fails to state what remains unchanged as the result of an action. The need to do
this gives rise to the frame problem.
11 FRAME PROBLEM One possible solution to the frame problem would
10 Section 7.4.3 conveniently glossed over this requirement.
11 The name “frame problem” comes from “frame of reference” in physics—the assumed stationary background
with respect to which motion is measured. It also has an analogy to the frames of a movie, in which normally
most of the background stays constant while changes occur in the foreground.
Section 7.7. Agents Based on Propositional Logic 267
FRAME AXIOM be to add frame axioms explicitly asserting all the propositions that remain the same. For
example, for each time t we would have
Forward t ⇒ (HaveArrowt ⇔ HaveArrowt+1)
Forward t ⇒ (WumpusAlivet ⇔ WumpusAlivet+1)
···
where we explicitly mention every proposition that stays unchanged from time t to time
t + 1 under the action Forward . Although the agent now knows that it still has the arrow
after moving forward and that the wumpus hasn’t died or come back to life, the proliferation
of frame axioms seems remarkably inefficient. In a world with m different actions and n
fluents, the set of frame axioms will be of size O(mn). This specific manifestation of the
frame problem is sometimes called the representational frame problem. Historically, the REPRESENTATIONAL
FRAME PROBLEM
problem was a significant one for AI researchers; we explore it further in the notes at the end
of the chapter.
The representational frame problem is significant because the real world has very many
fluents, to put it mildly. Fortunately for us humans, each action typically changes no more
LOCALITY than some small number k of those fluents—the world exhibits locality. Solving the representational frame problem requires defining the transition model with a set of axioms of size INFERENTIAL FRAME
PROBLEM O(mk) rather than size O(mn). There is also an inferential frame problem: the problem
of projecting forward the results of a t step plan of action in time O(kt) rather than O(nt).
The solution to the problem involves changing one’s focus from writing axioms about
actions to writing axioms about fluents. Thus, for each fluent F, we will have an axiom that
defines the truth value of Ft+1 in terms of fluents (including F itself) at time t and the actions
that may have occurred at time t. Now, the truth value of Ft+1 can be set in one of two ways:
either the action at time t causes F to be true at t + 1, or F was already true at time t and the
action at time t does not cause it to be false. An axiom of this form is called a successor-state
axiom and has this schema: SUCCESSOR-STATE
AXIOM
Ft+1 ⇔ ActionCausesFt ∨ (Ft ∧ ¬ActionCausesNotFt
) .
One of the simplest successor-state axioms is the one for HaveArrow. Because there is no
action for reloading, the ActionCausesFt part goes away and we are left with
HaveArrowt+1 ⇔ (HaveArrowt ∧ ¬Shoott
) . (7.2)
For the agent’s location, the successor-state axioms are more elaborate. For example, Lt+1
1,1
is true if either (a) the agent moved Forward from [1, 2] when facing south, or from [2, 1]
when facing west; or (b) Lt
1,1 was already true and the action did not cause movement (either
because the action was not Forward or because the action bumped into a wall). Written out
in propositional logic, this becomes
Lt+1
1,1 ⇔ (Lt
1,1 ∧ (¬Forward t ∨ Bumpt+1))
∨ (Lt
1,2 ∧ (Southt ∧ Forward t
)) (7.3)
∨ (Lt
2,1 ∧ (Westt ∧ Forwardt
)) .
Exercise 7.26 asks you to write out axioms for the remaining wumpus world fluents.
268 Chapter 7. Logical Agents
Given a complete set of successor-state axioms and the other axioms listed at the beginning of this section, the agent will be able to ASK and answer any answerable question about
the current state of the world. For example, in Section 7.2 the initial sequence of percepts and
actions is
¬Stench0 ∧ ¬Breeze0 ∧ ¬Glitter 0 ∧ ¬Bump0 ∧ ¬Scream0 ; Forward 0
¬Stench1 ∧ Breeze1 ∧ ¬Glitter 1 ∧ ¬Bump1 ∧ ¬Scream1 ; TurnRight1
¬Stench2 ∧ Breeze2 ∧ ¬Glitter 2 ∧ ¬Bump2 ∧ ¬Scream2 ; TurnRight2
¬Stench3 ∧ Breeze3 ∧ ¬Glitter 3 ∧ ¬Bump3 ∧ ¬Scream3 ; Forward 3
¬Stench4 ∧ ¬Breeze4 ∧ ¬Glitter 4 ∧ ¬Bump4 ∧ ¬Scream4 ; TurnRight4
¬Stench5 ∧ ¬Breeze5 ∧ ¬Glitter 5 ∧ ¬Bump5 ∧ ¬Scream5 ; Forward 5
Stench6 ∧ ¬Breeze6 ∧ ¬Glitter 6 ∧ ¬Bump6 ∧ ¬Scream6
At this point, we have ASK(KB, L6
1,2) = true, so the agent knows where it is. Moreover,
ASK(KB, W1,3) = true and ASK(KB, P3,1) = true, so the agent has found the wumpus and
one of the pits. The most important question for the agent is whether a square is OK to move
into, that is, the square contains no pit nor live wumpus. It’s convenient to add axioms for
this, having the form
OKt
x,y ⇔ ¬Px,y ∧ ¬(Wx,y ∧ WumpusAlivet
) .
Finally, ASK(KB, OK6
2,2) = true, so the square [2, 2] is OK to move into. In fact, given a
sound and complete inference algorithm such as DPLL, the agent can answer any answerable
question about which squares are OK—and can do so in just a few milliseconds for small-tomedium wumpus worlds.
Solving the representational and inferential frame problems is a big step forward, but
a pernicious problem remains: we need to confirm that all the necessary preconditions of an
action hold for it to have its intended effect. We said that the Forward action moves the agent
ahead unless there is a wall in the way, but there are many other unusual exceptions that could
cause the action to fail: the agent might trip and fall, be stricken with a heart attack, be carried
away by giant bats, etc. Specifying all these exceptions is called the qualification problem. QUALIFICATION
PROBLEM
There is no complete solution within logic; system designers have to use good judgment in
deciding how detailed they want to be in specifying their model, and what details they want
to leave out. We will see in Chapter 13 that probability theory allows us to summarize all the
exceptions without explicitly naming them.
7.7.2 A hybrid agent
The ability to deduce various aspects of the state of the world can be combined fairly straightforwardly with condition–action rules and with problem-solving algorithms from Chapters 3
HYBRID AGENT and 4 to produce a hybrid agent for the wumpus world. Figure 7.20 shows one possible way
to do this. The agent program maintains and updates a knowledge base as well as a current
plan. The initial knowledge base contains the atemporal axioms—those that don’t depend
on t, such as the axiom relating the breeziness of squares to the presence of pits. At each
time step, the new percept sentence is added along with all the axioms that depend on t, such
Section 7.7. Agents Based on Propositional Logic 269
as the successor-state axioms. (The next section explains why the agent doesn’t need axioms
for future time steps.) Then, the agent uses logical inference, by ASKing questions of the
knowledge base, to work out which squares are safe and which have yet to be visited.
The main body of the agent program constructs a plan based on a decreasing priority of
goals. First, if there is a glitter, the program constructs a plan to grab the gold, follow a route
back to the initial location, and climb out of the cave. Otherwise, if there is no current plan,
the program plans a route to the closest safe square that it has not visited yet, making sure
the route goes through only safe squares. Route planning is done with A∗ search, not with
ASK. If there are no safe squares to explore, the next step—if the agent still has an arrow—is
to try to make a safe square by shooting at one of the possible wumpus locations. These are
determined by asking where ASK(KB,¬Wx,y) is false—that is, where it is not known that
there is not a wumpus. The function PLAN-SHOT (not shown) uses PLAN-ROUTE to plan a
sequence of actions that will line up this shot. If this fails, the program looks for a square to
explore that is not provably unsafe—that is, a square for which ASK(KB,¬OKt
x,y) returns
false. If there is no such square, then the mission is impossible and the agent retreats to [1, 1]
and climbs out of the cave.
7.7.3 Logical state estimation
The agent program in Figure 7.20 works quite well, but it has one major weakness: as time
goes by, the computational expense involved in the calls to ASK goes up and up. This happens
mainly because the required inferences have to go back further and further in time and involve
more and more proposition symbols. Obviously, this is unsustainable—we cannot have an
agent whose time to process each percept grows in proportion to the length of its life! What
we really need is a constant update time—that is, independent of t. The obvious answer is to
CACHING save, or cache, the results of inference, so that the inference process at the next time step can
build on the results of earlier steps instead of having to start again from scratch.
As we saw in Section 4.4, the past history of percepts and all their ramifications can
be replaced by the belief state—that is, some representation of the set of all possible current
states of the world.12 The process of updating the belief state as new percepts arrive is called
state estimation. Whereas in Section 4.4 the belief state was an explicit list of states, here
we can use a logical sentence involving the proposition symbols associated with the current
time step, as well as the atemporal symbols. For example, the logical sentence
WumpusAlive1 ∧ L1
2,1 ∧ B2,1 ∧ (P3,1 ∨ P2,2) (7.4)
represents the set of all states at time 1 in which the wumpus is alive, the agent is at [2, 1],
that square is breezy, and there is a pit in [3, 1] or [2, 2] or both.
Maintaining an exact belief state as a logical formula turns out not to be easy. If there
are n fluent symbols for time t, then there are 2n possible states—that is, assignments of truth
values to those symbols. Now, the set of belief states is the powerset (set of all subsets) of the
set of physical states. There are 2n physical states, hence 22n
belief states. Even if we used
the most compact possible encoding of logical formulas, with each belief state represented
12 We can think of the percept history itself as a representation of the belief state, but one that makes inference
increasingly expensive as the history gets longer.
270 Chapter 7. Logical Agents
function HYBRID-WUMPUS-AGENT(percept) returns an action
inputs: percept, a list, [stench,breeze,glitter ,bump,scream]
persistent: KB, a knowledge base, initially the atemporal “wumpus physics”
t, a counter, initially 0, indicating time
plan, an action sequence, initially empty
TELL(KB, MAKE-PERCEPT-SENTENCE(percept,t))
TELL the KB the temporal “physics” sentences for time t
safe ← {[x , y] : ASK(KB,OKt
x,y) = true}
if ASK(KB,Glitter t
) = true then
plan ← [Grab]+PLAN-ROUTE(current, {[1,1]}, safe)+[Climb]
if plan is empty then
unvisited ← {[x , y] : ASK(KB, Lt
x,y) = false for all t ≤ t}
plan ← PLAN-ROUTE(current, unvisited ∩safe, safe)
if plan is empty and ASK(KB,HaveArrowt
) = true then
possible wumpus ← {[x , y] : ASK(KB,¬ Wx,y) = false}
plan ← PLAN-SHOT(current, possible wumpus, safe)
if plan is empty then // no choice but to take a risk
not unsafe ← {[x , y] : ASK(KB,¬ OKt
x,y) = false}
plan ← PLAN-ROUTE(current, unvisited ∩not unsafe, safe)
if plan is empty then
plan ← PLAN-ROUTE(current, {[1, 1]}, safe) + [Climb]
action ← POP(plan)
TELL(KB, MAKE-ACTION-SENTENCE(action,t))
t ← t + 1
return action
function PLAN-ROUTE(current,goals,allowed) returns an action sequence
inputs: current, the agent’s current position
goals, a set of squares; try to plan a route to one of them
allowed, a set of squares that can form part of the route
problem ← ROUTE-PROBLEM(current, goals,allowed)
return A*-GRAPH-SEARCH(problem)
Figure 7.20 A hybrid agent program for the wumpus world. It uses a propositional knowledge base to infer the state of the world, and a combination of problem-solving search and
domain-specific code to decide what actions to take.
by a unique binary number, we would need numbers with log2(22n
)=2n bits to label the
current belief state. That is, exact state estimation may require logical formulas whose size is
exponential in the number of symbols.
One very common and natural scheme for approximate state estimation is to represent
belief states as conjunctions of literals, that is, 1-CNF formulas. To do this, the agent program
simply tries to prove Xt and ¬Xt for each symbol Xt (as well as each atemporal symbol
whose truth value is not yet known), given the belief state at t − 1. The conjunction of
Section 7.7. Agents Based on Propositional Logic 271
Figure 7.21 Depiction of a 1-CNF belief state (bold outline) as a simply representable,
conservative approximation to the exact (wiggly) belief state (shaded region with dashed
outline). Each possible world is shown as a circle; the shaded ones are consistent with all the
percepts.
provable literals becomes the new belief state, and the previous belief state is discarded.
It is important to understand that this scheme may lose some information as time goes
along. For example, if the sentence in Equation (7.4) were the true belief state, then neither
P3,1 nor P2,2 would be provable individually and neither would appear in the 1-CNF belief
state. (Exercise 7.27 explores one possible solution to this problem.) On the other hand,
because every literal in the 1-CNF belief state is proved from the previous belief state, and
the initial belief state is a true assertion, we know that entire 1-CNF belief state must be
true. Thus, the set of possible states represented by the 1-CNF belief state includes all states
that are in fact possible given the full percept history. As illustrated in Figure 7.21, the 1-
CNF belief state acts as a simple outer envelope, or conservative approximation, around the CONSERVATIVE
APPROXIMATION
exact belief state. We see this idea of conservative approximations to complicated sets as a
recurring theme in many areas of AI.
7.7.4 Making plans by propositional inference
The agent in Figure 7.20 uses logical inference to determine which squares are safe, but uses
A∗ search to make plans. In this section, we show how to make plans by logical inference.
The basic idea is very simple:
1. Construct a sentence that includes
(a) Init0, a collection of assertions about the initial state;
(b) Transition1,..., Transitiont
, the successor-state axioms for all possible actions
at each time up to some maximum time t;
(c) the assertion that the goal is achieved at time t: HaveGoldt ∧ ClimbedOutt
.
272 Chapter 7. Logical Agents
2. Present the whole sentence to a SAT solver. If the solver finds a satisfying model, then
the goal is achievable; if the sentence is unsatisfiable, then the planning problem is
impossible.
3. Assuming a model is found, extract from the model those variables that represent actions and are assigned true. Together they represent a plan to achieve the goals.
A propositional planning procedure, SATPLAN, is shown in Figure 7.22. It implements the
basic idea just given, with one twist. Because the agent does not know how many steps it
will take to reach the goal, the algorithm tries each possible number of steps t, up to some
maximum conceivable plan length Tmax. In this way, it is guaranteed to find the shortest plan
if one exists. Because of the way SATPLAN searches for a solution, this approach cannot
be used in a partially observable environment; SATPLAN would just set the unobservable
variables to the values it needs to create a solution.
function SATPLAN(init, transition, goal, T max) returns solution or failure
inputs: init, transition, goal, constitute a description of the problem
T max, an upper limit for plan length
for t = 0 to T max do
cnf ← TRANSLATE-TO-SAT(init, transition, goal,t)
model ← SAT-SOLVER(cnf )
if model is not null then
return EXTRACT-SOLUTION(model)
return failure
Figure 7.22 The SATPLAN algorithm. The planning problem is translated into a CNF
sentence in which the goal is asserted to hold at a fixed time step t and axioms are included
for each time step up to t. If the satisfiability algorithm finds a model, then a plan is extracted
by looking at those proposition symbols that refer to actions and are assigned true in the
model. If no model exists, then the process is repeated with the goal moved one step later.
The key step in using SATPLAN is the construction of the knowledge base. It might
seem, on casual inspection, that the wumpus world axioms in Section 7.7.1 suffice for steps
1(a) and 1(b) above. There is, however, a significant difference between the requirements for
entailment (as tested by ASK) and those for satisfiability. Consider, for example, the agent’s
location, initially [1, 1], and suppose the agent’s unambitious goal is to be in [2, 1] at time 1.
The initial knowledge base contains L0
1,1 and the goal is L1
2,1. Using ASK, we can prove L1
2,1
if Forward0 is asserted, and, reassuringly, we cannot prove L1
2,1 if, say, Shoot0 is asserted
instead. Now, SATPLAN will find the plan [Forward0]; so far, so good. Unfortunately,
SATPLAN also finds the plan [Shoot0]. How could this be? To find out, we inspect the model
that SATPLAN constructs: it includes the assignment L0
2,1, that is, the agent can be in [2, 1]
at time 1 by being there at time 0 and shooting. One might ask, “Didn’t we say the agent is in
[1, 1] at time 0?” Yes, we did, but we didn’t tell the agent that it can’t be in two places at once!
For entailment, L0
2,1 is unknown and cannot, therefore, be used in a proof; for satisfiability,
Section 7.7. Agents Based on Propositional Logic 273
on the other hand, L0
2,1 is unknown and can, therefore, be set to whatever value helps to
make the goal true. For this reason, SATPLAN is a good debugging tool for knowledge bases
because it reveals places where knowledge is missing. In this particular case, we can fix the
knowledge base by asserting that, at each time step, the agent is in exactly one location, using
a collection of sentences similar to those used to assert the existence of exactly one wumpus.
Alternatively, we can assert ¬L0
x,y for all locations other than [1, 1]; the successor-state axiom
for location takes care of subsequent time steps. The same fixes also work to make sure the
agent has only one orientation.
SATPLAN has more surprises in store, however. The first is that it finds models with
impossible actions, such as shooting with no arrow. To understand why, we need to look more
carefully at what the successor-state axioms (such as Equation (7.3)) say about actions whose
preconditions are not satisfied. The axioms do predict correctly that nothing will happen when
such an action is executed (see Exercise 10.14), but they do not say that the action cannot be
executed! To avoid generating plans with illegal actions, we must add precondition axioms PRECONDITION
AXIOMS
stating that an action occurrence requires the preconditions to be satisfied.13 For example, we
need to say, for each time t, that
Shoott ⇒ HaveArrowt .
This ensures that if a plan selects the Shoot action at any time, it must be the case that the
agent has an arrow at that time.
SATPLAN’s second surprise is the creation of plans with multiple simultaneous actions.
For example, it may come up with a model in which both Forward 0 and Shoot 0 are true,
which is not allowed. To eliminate this problem, we introduce action exclusion axioms: for ACTION EXCLUSION
AXIOM
every pair of actions At
i and At
j we add the axiom
¬At
i ∨ ¬At
j .
It might be pointed out that walking forward and shooting at the same time is not so hard to
do, whereas, say, shooting and grabbing at the same time is rather impractical. By imposing
action exclusion axioms only on pairs of actions that really do interfere with each other, we
can allow for plans that include multiple simultaneous actions—and because SATPLAN finds
the shortest legal plan, we can be sure that it will take advantage of this capability.
To summarize, SATPLAN finds models for a sentence containing the initial state, the
goal, the successor-state axioms, the precondition axioms, and the action exclusion axioms.
It can be shown that this collection of axioms is sufficient, in the sense that there are no
longer any spurious “solutions.” Any model satisfying the propositional sentence will be a
valid plan for the original problem. Modern SAT-solving technology makes the approach
quite practical. For example, a DPLL-style solver has no difficulty in generating the 11-step
solution for the wumpus world instance shown in Figure 7.2.
This section has described a declarative approach to agent construction: the agent works
by a combination of asserting sentences in the knowledge base and performing logical inference. This approach has some weaknesses hidden in phrases such as “for each time t” and
13 Notice that the addition of precondition axioms means that we need not include preconditions for actions in
the successor-state axioms.
274 Chapter 7. Logical Agents
“for each square [x, y].” For any practical agent, these phrases have to be implemented by
code that generates instances of the general sentence schema automatically for insertion into
the knowledge base. For a wumpus world of reasonable size—one comparable to a smallish
computer game—we might need a 100 × 100 board and 1000 time steps, leading to knowledge bases with tens or hundreds of millions of sentences. Not only does this become rather
impractical, but it also illustrates a deeper problem: we know something about the wumpus world—namely, that the “physics” works the same way across all squares and all time
steps—that we cannot express directly in the language of propositional logic. To solve this
problem, we need a more expressive language, one in which phrases like “for each time t”
and “for each square [x, y]” can be written in a natural way. First-order logic, described in
Chapter 8, is such a language; in first-order logic a wumpus world of any size and duration
can be described in about ten sentences rather than ten million or ten trillion.
7.8 SUMMARY
We have introduced knowledge-based agents and have shown how to define a logic with
which such agents can reason about the world. The main points are as follows:
• Intelligent agents need knowledge about the world in order to reach good decisions.
• Knowledge is contained in agents in the form of sentences in a knowledge representation language that are stored in a knowledge base.
• A knowledge-based agent is composed of a knowledge base and an inference mechanism. It operates by storing sentences about the world in its knowledge base, using the
inference mechanism to infer new sentences, and using these sentences to decide what
action to take.
• A representation language is defined by its syntax, which specifies the structure of
sentences, and its semantics, which defines the truth of each sentence in each possible
world or model.
• The relationship of entailment between sentences is crucial to our understanding of
reasoning. A sentence α entails another sentence β if β is true in all worlds where
α is true. Equivalent definitions include the validity of the sentence α ⇒ β and the
unsatisfiability of the sentence α ∧ ¬β.
• Inference is the process of deriving new sentences from old ones. Sound inference algorithms derive only sentences that are entailed; complete algorithms derive all sentences
that are entailed.
• Propositional logic is a simple language consisting of proposition symbols and logical
connectives. It can handle propositions that are known true, known false, or completely
unknown.
• The set of possible models, given a fixed propositional vocabulary, is finite, so entailment can be checked by enumerating models. Efficient model-checking inference
algorithms for propositional logic include backtracking and local search methods and
can often solve large problems quickly.
Bibliographical and Historical Notes 275
• Inference rules are patterns of sound inference that can be used to find proofs. The
resolution rule yields a complete inference algorithm for knowledge bases that are
expressed in conjunctive normal form. Forward chaining and backward chaining
are very natural reasoning algorithms for knowledge bases in Horn form.
• Local search methods such as WALKSAT can be used to find solutions. Such algorithms are sound but not complete.
• Logical state estimation involves maintaining a logical sentence that describes the set
of possible states consistent with the observation history. Each update step requires
inference using the transition model of the environment, which is built from successorstate axioms that specify how each fluent changes.
• Decisions within a logical agent can be made by SAT solving: finding possible models
specifying future action sequences that reach the goal. This approach works only for
fully observable or sensorless environments.
• Propositional logic does not scale to environments of unbounded size because it lacks
the expressive power to deal concisely with time, space, and universal patterns of relationships among objects.
BIBLIOGRAPHICAL AND HISTORICAL NOTES
John McCarthy’s paper “Programs with Common Sense” (McCarthy, 1958, 1968) promulgated the notion of agents that use logical reasoning to mediate between percepts and actions.
It also raised the flag of declarativism, pointing out that telling an agent what it needs to know
is an elegant way to build software. Allen Newell’s (1982) article “The Knowledge Level”
makes the case that rational agents can be described and analyzed at an abstract level defined
by the knowledge they possess rather than the programs they run. The declarative and procedural approaches to AI are analyzed in depth by Boden (1977). The debate was revived by,
among others, Brooks (1991) and Nilsson (1991), and continues to this day (Shaparau et al.,
2008). Meanwhile, the declarative approach has spread into other areas of computer science
such as networking (Loo et al., 2006).
Logic itself had its origins in ancient Greek philosophy and mathematics. Various logical principles—principles connecting the syntactic structure of sentences with their truth
and falsity, with their meaning, or with the validity of arguments in which they figure—are
scattered in the works of Plato. The first known systematic study of logic was carried out
by Aristotle, whose work was assembled by his students after his death in 322 B.C. as a
SYLLOGISM treatise called the Organon. Aristotle’s syllogisms were what we would now call inference
rules. Although the syllogisms included elements of both propositional and first-order logic,
the system as a whole lacked the compositional properties required to handle sentences of
arbitrary complexity.
The closely related Megarian and Stoic schools (originating in the fifth century B.C.
and continuing for several centuries thereafter) began the systematic study of the basic logical
connectives. The use of truth tables for defining connectives is due to Philo of Megara. The
276 Chapter 7. Logical Agents
Stoics took five basic inference rules as valid without proof, including the rule we now call
Modus Ponens. They derived a number of other rules from these five, using, among other
principles, the deduction theorem (page 249) and were much clearer about the notion of
proof than was Aristotle. A good account of the history of Megarian and Stoic logic is given
by Benson Mates (1953).
The idea of reducing logical inference to a purely mechanical process applied to a formal language is due to Wilhelm Leibniz (1646–1716), although he had limited success in implementing the ideas. George Boole (1847) introduced the first comprehensive and workable
system of formal logic in his book The Mathematical Analysis of Logic. Boole’s logic was
closely modeled on the ordinary algebra of real numbers and used substitution of logically
equivalent expressions as its primary inference method. Although Boole’s system still fell
short of full propositional logic, it was close enough that other mathematicians could quickly
fill in the gaps. Schr¨oder (1877) described conjunctive normal form, while Horn form was
introduced much later by Alfred Horn (1951). The first comprehensive exposition of modern
propositional logic (and first-order logic) is found in Gottlob Frege’s (1879) Begriffschrift
(“Concept Writing” or “Conceptual Notation”).
The first mechanical device to carry out logical inferences was constructed by the third
Earl of Stanhope (1753–1816). The Stanhope Demonstrator could handle syllogisms and
certain inferences in the theory of probability. William Stanley Jevons, one of those who
improved upon and extended Boole’s work, constructed his “logical piano” in 1869 to perform inferences in Boolean logic. An entertaining and instructive history of these and other
early mechanical devices for reasoning is given by Martin Gardner (1968). The first published computer program for logical inference was the Logic Theorist of Newell, Shaw,
and Simon (1957). This program was intended to model human thought processes. Martin Davis (1957) had actually designed a program that came up with a proof in 1954, but the
Logic Theorist’s results were published slightly earlier.
Truth tables as a method of testing validity or unsatisfiability in propositional logic were
introduced independently by Emil Post (1921) and Ludwig Wittgenstein (1922). In the 1930s,
a great deal of progress was made on inference methods for first-order logic. In particular,
G¨odel (1930) showed that a complete procedure for inference in first-order logic could be
obtained via a reduction to propositional logic, using Herbrand’s theorem (Herbrand, 1930).
We take up this history again in Chapter 9; the important point here is that the development
of efficient propositional algorithms in the 1960s was motivated largely by the interest of
mathematicians in an effective theorem prover for first-order logic. The Davis–Putnam algorithm (Davis and Putnam, 1960) was the first effective algorithm for propositional resolution
but was in most cases much less efficient than the DPLL backtracking algorithm introduced
two years later (1962). The full resolution rule and a proof of its completeness appeared in a
seminal paper by J. A. Robinson (1965), which also showed how to do first-order reasoning
without resort to propositional techniques.
Stephen Cook (1971) showed that deciding satisfiability of a sentence in propositional
logic (the SAT problem) is NP-complete. Since deciding entailment is equivalent to deciding unsatisfiability, it is co-NP-complete. Many subsets of propositional logic are known for
which the satisfiability problem is polynomially solvable; Horn clauses are one such subset.
Bibliographical and Historical Notes 277
The linear-time forward-chaining algorithm for Horn clauses is due to Dowling and Gallier
(1984), who describe their algorithm as a dataflow process similar to the propagation of signals in a circuit.
Early theoretical investigations showed that DPLL has polynomial average-case complexity for certain natural distributions of problems. This potentially exciting fact became
less exciting when Franco and Paull (1983) showed that the same problems could be solved
in constant time simply by guessing random assignments. The random-generation method
described in the chapter produces much harder problems. Motivated by the empirical success
of local search on these problems, Koutsoupias and Papadimitriou (1992) showed that a simple hill-climbing algorithm can solve almost all satisfiability problem instances very quickly,
suggesting that hard problems are rare. Moreover, Sch¨oning (1999) exhibited a randomized
hill-climbing algorithm whose worst-case expected run time on 3-SAT problems (that is, satisfiability of 3-CNF sentences) is O(1.333n)—still exponential, but substantially faster than
previous worst-case bounds. The current record is O(1.324n) (Iwama and Tamaki, 2004).
Achlioptas et al. (2004) and Alekhnovich et al. (2005) exhibit families of 3-SAT instances
for which all known DPLL-like algorithms require exponential running time.
On the practical side, efficiency gains in propositional solvers have been marked. Given
ten minutes of computing time, the original DPLL algorithm in 1962 could only solve problems with no more than 10 or 15 variables. By 1995 the SATZ solver (Li and Anbulagan,
1997) could handle 1,000 variables, thanks to optimized data structures for indexing variables. Two crucial contributions were the watched literal indexing technique of Zhang and
Stickel (1996), which makes unit propagation very efficient, and the introduction of clause
(i.e., constraint) learning techniques from the CSP community by Bayardo and Schrag (1997).
Using these ideas, and spurred by the prospect of solving industrial-scale circuit verification
problems, Moskewicz et al. (2001) developed the CHAFF solver, which could handle problems with millions of variables. Beginning in 2002, SAT competitions have been held regularly; most of the winning entries have either been descendants of CHAFF or have used the
same general approach. RSAT (Pipatsrisawat and Darwiche, 2007), the 2007 winner, falls in
the latter category. Also noteworthy is MINISAT (Een and S¨orensson, 2003), an open-source
implementation available at http://minisat.se that is designed to be easily modified
and improved. The current landscape of solvers is surveyed by Gomes et al. (2008).
Local search algorithms for satisfiability were tried by various authors throughout the
1980s; all of the algorithms were based on the idea of minimizing the number of unsatisfied
clauses (Hansen and Jaumard, 1990). A particularly effective algorithm was developed by
Gu (1989) and independently by Selman et al. (1992), who called it GSAT and showed that
it was capable of solving a wide range of very hard problems very quickly. The WALKSAT
algorithm described in the chapter is due to Selman et al. (1996).
The “phase transition” in satisfiability of random k-SAT problems was first observed
by Simon and Dubois (1989) and has given rise to a great deal of theoretical and empirical
research—due, in part, to the obvious connection to phase transition phenomena in statistical
physics. Cheeseman et al. (1991) observed phase transitions in several CSPs and conjecture
that all NP-hard problems have a phase transition. Crawford and Auton (1993) located the
3-SAT transition at a clause/variable ratio of around 4.26, noting that this coincides with a
278 Chapter 7. Logical Agents
sharp peak in the run time of their SAT solver. Cook and Mitchell (1997) provide an excellent
summary of the early literature on the problem.
The current state of theoretical understanding is summarized by Achlioptas (2009).
The satisfiability threshold conjecture states that, for each k, there is a sharp satisfiability SATISFIABILITY
THRESHOLD
CONJECTURE
threshold rk, such that as the number of variables n → ∞, instances below the threshold are
satisfiable with probability 1, while those above the threshold are unsatisfiable with probability 1. The conjecture was not quite proved by Friedgut (1999): a sharp threshold exists but
its location might depend on n even as n → ∞. Despite significant progress in asymptotic
analysis of the threshold location for large k (Achlioptas and Peres, 2004; Achlioptas et al.,
2007), all that can be proved for k = 3 is that it lies in the range [3.52,4.51]. Current theory
suggests that a peak in the run time of a SAT solver is not necessarily related to the satisfiability threshold, but instead to a phase transition in the solution distribution and structure of
SAT instances. Empirical results due to Coarfa et al. (2003) support this view. In fact, algorithms such as survey propagation (Parisi and Zecchina, 2002; Maneva et al., 2007) take SURVEY
PROPAGATION
advantage of special properties of random SAT instances near the satisfiability threshold and
greatly outperform general SAT solvers on such instances.
The best sources for information on satisfiability, both theoretical and practical, are the
Handbook of Satisfiability (Biere et al., 2009) and the regular International Conferences on
Theory and Applications of Satisfiability Testing, known as SAT.
The idea of building agents with propositional logic can be traced back to the seminal
paper of McCulloch and Pitts (1943), which initiated the field of neural networks. Contrary to popular supposition, the paper was concerned with the implementation of a Boolean
circuit-based agent design in the brain. Circuit-based agents, which perform computation by
propagating signals in hardware circuits rather than running algorithms in general-purpose
computers, have received little attention in AI, however. The most notable exception is the
work of Stan Rosenschein (Rosenschein, 1985; Kaelbling and Rosenschein, 1990), who developed ways to compile circuit-based agents from declarative descriptions of the task environment. (Rosenschein’s approach is described at some length in the second edition of this
book.) The work of Rod Brooks (1986, 1989) demonstrates the effectiveness of circuit-based
designs for controlling robots—a topic we take up in Chapter 25. Brooks (1991) argues
that circuit-based designs are all that is needed for AI—that representation and reasoning
are cumbersome, expensive, and unnecessary. In our view, neither approach is sufficient by
itself. Williams et al. (2003) show how a hybrid agent design not too different from our
wumpus agent has been used to control NASA spacecraft, planning sequences of actions and
diagnosing and recovering from faults.
The general problem of keeping track of a partially observable environment was introduced for state-based representations in Chapter 4. Its instantiation for propositional representations was studied by Amir and Russell (2003), who identified several classes of environments that admit efficient state-estimation algorithms and showed that for several other
classes the problem is intractable. The temporal-projection problem, which involves deter- TEMPORALPROJECTION
mining what propositions hold true after an action sequence is executed, can be seen as a
special case of state estimation with empty percepts. Many authors have studied this problem
because of its importance in planning; some important hardness results were established by
Exercises 279
Liberatore (1997). The idea of representing a belief state with propositions can be traced to
Wittgenstein (1922).
Logical state estimation, of course, requires a logical representation of the effects of
actions—a key problem in AI since the late 1950s. The dominant proposal has been the situation calculus formalism (McCarthy, 1963), which is couched within first-order logic. We
discuss situation calculus, and various extensions and alternatives, in Chapters 10 and 12. The
approach taken in this chapter—using temporal indices on propositional variables—is more
restrictive but has the benefit of simplicity. The general approach embodied in the SATPLAN
algorithm was proposed by Kautz and Selman (1992). Later generations of SATPLAN were
able to take advantage of the advances in SAT solvers, described earlier, and remain among
the most effective ways of solving difficult problems (Kautz, 2006).
The frame problem was first recognized by McCarthy and Hayes (1969). Many researchers considered the problem unsolvable within first-order logic, and it spurred a great
deal of research into nonmonotonic logics. Philosophers from Dreyfus (1972) to Crockett
(1994) have cited the frame problem as one symptom of the inevitable failure of the entire
AI enterprise. The solution of the frame problem with successor-state axioms is due to Ray
Reiter (1991). Thielscher (1999) identifies the inferential frame problem as a separate idea
and provides a solution. In retrospect, one can see that Rosenschein’s (1985) agents were
using circuits that implemented successor-state axioms, but Rosenschein did not notice that
the frame problem was thereby largely solved. Foo (2001) explains why the discrete-event
control theory models typically used by engineers do not have to explicitly deal with the
frame problem: because they are dealing with prediction and control, not with explanation
and reasoning about counterfactual situations.
Modern propositional solvers have wide applicability in industrial applications. The application of propositional inference in the synthesis of computer hardware is now a standard
technique having many large-scale deployments (Nowick et al., 1993). The SATMC satisfiability checker was used to detect a previously unknown vulnerability in a Web browser user
sign-on protocol (Armando et al., 2008).
The wumpus world was invented by Gregory Yob (1975). Ironically, Yob developed it
because he was bored with games played on a rectangular grid: the topology of his original
wumpus world was a dodecahedron, and we put it back in the boring old grid. Michael
Genesereth was the first to suggest that the wumpus world be used as an agent testbed.
EXERCISES
7.1 Suppose the agent has progressed to the point shown in Figure 7.4(a), page 239, having
perceived nothing in [1,1], a breeze in [2,1], and a stench in [1,2], and is now concerned with
the contents of [1,3], [2,2], and [3,1]. Each of these can contain a pit, and at most one can
contain a wumpus. Following the example of Figure 7.5, construct the set of possible worlds.
(You should find 32 of them.) Mark the worlds in which the KB is true and those in which
280 Chapter 7. Logical Agents
each of the following sentences is true:
α2 = “There is no pit in [2,2].”
α3 = “There is a wumpus in [1,3].”
Hence show that KB |= α2 and KB |= α3.
7.2 (Adapted from Barwise and Etchemendy (1993).) Given the following, can you prove
that the unicorn is mythical? How about magical? Horned?
If the unicorn is mythical, then it is immortal, but if it is not mythical, then it is a
mortal mammal. If the unicorn is either immortal or a mammal, then it is horned.
The unicorn is magical if it is horned.
7.3 Consider the problem of deciding whether a propositional logic sentence is true in a
given model.
a. Write a recursive algorithm PL-TRUE?(s, m) that returns true if and only if the sentence s is true in the model m (where m assigns a truth value for every symbol in s).
The algorithm should run in time linear in the size of the sentence. (Alternatively, use a
version of this function from the online code repository.)
b. Give three examples of sentences that can be determined to be true or false in a partial
model that does not specify a truth value for some of the symbols.
c. Show that the truth value (if any) of a sentence in a partial model cannot be determined
efficiently in general.
d. Modify your PL-TRUE? algorithm so that it can sometimes judge truth from partial
models, while retaining its recursive structure and linear run time. Give three examples
of sentences whose truth in a partial model is not detected by your algorithm.
e. Investigate whether the modified algorithm makes TT-ENTAILS? more efficient.
7.4 Which of the following are correct?
a. False |= True.
b. True |= False.
c. (A ∧ B) |= (A ⇔ B).
d. A ⇔ B |= A ∨ B.
e. A ⇔ B |= ¬A ∨ B.
f. (A ∧ B) ⇒ C |= (A ⇒ C) ∨ (B ⇒ C).
g. (C ∨ (¬A ∧ ¬B)) ≡ ((A ⇒ C) ∧ (B ⇒ C)).
h. (A ∨ B) ∧ (¬C ∨ ¬D ∨ E) |= (A ∨ B).
i. (A ∨ B) ∧ (¬C ∨ ¬D ∨ E) |= (A ∨ B) ∧ (¬D ∨ E).
j. (A ∨ B) ∧ ¬(A ⇒ B) is satisfiable.
k. (A ⇔ B) ∧ (¬A ∨ B) is satisfiable.
l. (A ⇔ B) ⇔ C has the same number of models as (A ⇔ B) for any fixed set of
proposition symbols that includes A, B, C.
Exercises 281
7.5 Prove each of the following assertions:
a. α is valid if and only if True |= α.
b. For any α, False |= α.
c. α |= β if and only if the sentence (α ⇒ β) is valid.
d. α ≡ β if and only if the sentence (α ⇔ β) is valid.
e. α |= β if and only if the sentence (α ∧ ¬β) is unsatisfiable.
7.6 Prove, or find a counterexample to, each of the following assertions:
a. If α |= γ or β |= γ (or both) then (α ∧ β) |= γ
b. If α |= (β ∧ γ) then α |= β and α |= γ.
c. If α |= (β ∨ γ) then α |= β or α |= γ (or both).
7.7 Consider a vocabulary with only four propositions, A, B, C, and D. How many models
are there for the following sentences?
a. B ∨ C.
b. ¬A ∨ ¬B ∨ ¬C ∨ ¬D.
c. (A ⇒ B) ∧ A ∧ ¬B ∧ C ∧ D.
7.8 We have defined four binary logical connectives.
a. Are there any others that might be useful?
b. How many binary connectives can there be?
c. Why are some of them not very useful?
7.9 Using a method of your choice, verify each of the equivalences in Figure 7.11 (page 249).
7.10 Decide whether each of the following sentences is valid, unsatisfiable, or neither. Verify your decisions using truth tables or the equivalence rules of Figure 7.11 (page 249).
a. Smoke ⇒ Smoke
b. Smoke ⇒ Fire
c. (Smoke ⇒ Fire) ⇒ (¬Smoke ⇒ ¬Fire)
d. Smoke ∨ Fire ∨ ¬Fire
e. ((Smoke ∧ Heat) ⇒ Fire) ⇔ ((Smoke ⇒ Fire) ∨ (Heat ⇒ Fire))
f. (Smoke ⇒ Fire) ⇒ ((Smoke ∧ Heat) ⇒ Fire)
g. Big ∨ Dumb ∨ (Big ⇒ Dumb)
7.11 Any propositional logic sentence is logically equivalent to the assertion that each possible world in which it would be false is not the case. From this observation, prove that any
sentence can be written in CNF.
7.12 Use resolution to prove the sentence ¬A∧¬B from the clauses in Exercise 7.20.
7.13 This exercise looks into the relationship between clauses and implication sentences.
282 Chapter 7. Logical Agents
a. Show that the clause (¬P1 ∨···∨¬Pm ∨ Q) is logically equivalent to the implication
sentence (P1 ∧···∧ Pm) ⇒ Q.
b. Show that every clause (regardless of the number of positive literals) can be written in
the form (P1 ∧···∧ Pm) ⇒ (Q1 ∨···∨ Qn), where the Ps and Qs are proposition
symbols. A knowledge base consisting of such sentences is in implicative normal
form or Kowalski form (Kowalski, 1979). IMPLICATIVE
NORMAL FORM
c. Write down the full resolution rule for sentences in implicative normal form.
7.14 According to some political pundits, a person who is radical (R) is electable (E) if
he/she is conservative (C), but otherwise is not electable.
a. Which of the following are correct representations of this assertion?
(i) (R ∧ E) ⇐⇒ C
(ii) R ⇒ (E ⇐⇒ C)
(iii) R ⇒ ((C ⇒ E) ∨ ¬E)
b. Which of the sentences in (a) can be expressed in Horn form?
7.15 This question considers representing satisfiability (SAT) problems as CSPs.
a. Draw the constraint graph corresponding to the SAT problem
(¬X1 ∨ X2) ∧ (¬X2 ∨ X3) ∧ ... ∧ (¬Xn−1 ∨ Xn)
for the particular case n = 5.
b. How many solutions are there for this general SAT problem as a function of n?
c. Suppose we apply BACKTRACKING-SEARCH (page 215) to find all solutions to a SAT
CSP of the type given in (a). (To find all solutions to a CSP, we simply modify the
basic algorithm so it continues searching after each solution is found.) Assume that
variables are ordered X1,...,Xn and false is ordered before true. How much time
will the algorithm take to terminate? (Write an O(·) expression as a function of n.)
d. We know that SAT problems in Horn form can be solved in linear time by forward
chaining (unit propagation). We also know that every tree-structured binary CSP with
discrete, finite domains can be solved in time linear in the number of variables (Section 6.5). Are these two facts connected? Discuss.
7.16 Explain why every nonempty propositional clause, by itself, is satisfiable. Prove rigorously that every set of five 3-SAT clauses is satisfiable, provided that each clause mentions
exactly three distinct variables. What is the smallest set of such clauses that is unsatisfiable?
Construct such a set.
7.17 A propositional 2-CNF expression is a conjunction of clauses, each containing exactly
2 literals, e.g.,
(A ∨ B) ∧ (¬A ∨ C) ∧ (¬B ∨ D) ∧ (¬C ∨ G) ∧ (¬D ∨ G) .
a. Prove using resolution that the above sentence entails G.
Exercises 283
b. Two clauses are semantically distinct if they are not logically equivalent. How many
semantically distinct 2-CNF clauses can be constructed from n proposition symbols?
c. Using your answer to (b), prove that propositional resolution always terminates in time
polynomial in n given a 2-CNF sentence containing no more than n distinct symbols.
d. Explain why your argument in (c) does not apply to 3-CNF.
7.18 Consider the following sentence:
[(Food ⇒ Party) ∨ (Drinks ⇒ Party)] ⇒ [(Food ∧ Drinks) ⇒ Party] .
a. Determine, using enumeration, whether this sentence is valid, satisfiable (but not valid),
or unsatisfiable.
b. Convert the left-hand and right-hand sides of the main implication into CNF, showing
each step, and explain how the results confirm your answer to (a).
c. Prove your answer to (a) using resolution.
7.19 A sentence is in disjunctive normal form (DNF) if it is the disjunction of conjunctions DISJUNCTIVE
NORMAL FORM
of literals. For example, the sentence (A ∧ B ∧ ¬C) ∨ (¬A ∧ C) ∨ (B ∧ ¬C) is in DNF.
a. Any propositional logic sentence is logically equivalent to the assertion that some possible world in which it would be true is in fact the case. From this observation, prove
that any sentence can be written in DNF.
b. Construct an algorithm that converts any sentence in propositional logic into DNF.
(Hint: The algorithm is similar to the algorithm for conversion to CNF given in Section 7.5.2.)
c. Construct a simple algorithm that takes as input a sentence in DNF and returns a satisfying assignment if one exists, or reports that no satisfying assignment exists.
d. Apply the algorithms in (b) and (c) to the following set of sentences:
A ⇒ B
B ⇒ C
C ⇒ ¬A .
e. Since the algorithm in (b) is very similar to the algorithm for conversion to CNF, and
since the algorithm in (c) is much simpler than any algorithm for solving a set of sentences in CNF, why is this technique not used in automated reasoning?
7.20 Convert the following set of sentences to clausal form.
S1: A ⇔ (B ∨ E).
S2: E ⇒ D.
S3: C ∧ F ⇒ ¬B.
S4: E ⇒ B.
S5: B ⇒ F.
S6: B ⇒ C
Give a trace of the execution of DPLL on the conjunction of these clauses.
284 Chapter 7. Logical Agents
7.21 Is a randomly generated 4-CNF sentence with n symbols and m clauses more or less
likely to be solvable than a randomly generated 3-CNF sentence with n symbols and m
clauses? Explain.
7.22 Minesweeper, the well-known computer game, is closely related to the wumpus world.
A minesweeper world is a rectangular grid of N squares with M invisible mines scattered
among them. Any square may be probed by the agent; instant death follows if a mine is
probed. Minesweeper indicates the presence of mines by revealing, in each probed square,
the number of mines that are directly or diagonally adjacent. The goal is to probe every
unmined square.
a. Let Xi,j be true iff square [i, j] contains a mine. Write down the assertion that exactly
two mines are adjacent to [1,1] as a sentence involving some logical combination of
Xi,j propositions.
b. Generalize your assertion from (a) by explaining how to construct a CNF sentence
asserting that k of n neighbors contain mines.
c. Explain precisely how an agent can use DPLL to prove that a given square does (or
does not) contain a mine, ignoring the global constraint that there are exactly M mines
in all.
d. Suppose that the global constraint is constructed from your method from part (b). How
does the number of clauses depend on M and N? Suggest a way to modify DPLL so
that the global constraint does not need to be represented explicitly.
e. Are any conclusions derived by the method in part (c) invalidated when the global
constraint is taken into account?
f. Give examples of configurations of probe values that induce long-range dependencies
such that the contents of a given unprobed square would give information about the
contents of a far-distant square. (Hint: consider an N × 1 board.)
7.23 How long does it take to prove KB |= α using DPLL when α is a literal already
contained in KB? Explain.
7.24 Trace the behavior of DPLL on the knowledge base in Figure 7.16 when trying to
prove Q, and compare this behavior with that of the forward-chaining algorithm.
7.25 Write a successor-state axiom for the Locked predicate, which applies to doors, assuming the only actions available are Lock and Unlock.
7.26 Section 7.7.1 provides some of the successor-state axioms required for the wumpus
world. Write down axioms for all remaining fluent symbols.
7.27 Modify the HYBRID-WUMPUS-AGENT to use the 1-CNF logical state estimation
method described on page 271. We noted on that page that such an agent will not be able
to acquire, maintain, and use more complex beliefs such as the disjunction P3,1 ∨ P2,2. Suggest a method for overcoming this problem by defining additional proposition symbols, and
try it out in the wumpus world. Does it improve the performance of the agent?
8 FIRST-ORDER LOGIC
In which we notice that the world is blessed with many objects, some of which are
related to other objects, and in which we endeavor to reason about them.
In Chapter 7, we showed how a knowledge-based agent could represent the world in which it
operates and deduce what actions to take. We used propositional logic as our representation
language because it sufficed to illustrate the basic concepts of logic and knowledge-based
agents. Unfortunately, propositional logic is too puny a language to represent knowledge
of complex environments in a concise way. In this chapter, we examine first-order logic,
1 FIRST-ORDER LOGIC
which is sufficiently expressive to represent a good deal of our commonsense knowledge.
It also either subsumes or forms the foundation of many other representation languages and
has been studied intensively for many decades. We begin in Section 8.1 with a discussion of
representation languages in general; Section 8.2 covers the syntax and semantics of first-order
logic; Sections 8.3 and 8.4 illustrate the use of first-order logic for simple representations.
8.1 REPRESENTATION REVISITED
In this section, we discuss the nature of representation languages. Our discussion motivates
the development of first-order logic, a much more expressive language than the propositional
logic introduced in Chapter 7. We look at propositional logic and at other kinds of languages
to understand what works and what fails. Our discussion will be cursory, compressing centuries of thought, trial, and error into a few paragraphs.
Programming languages (such as C++ or Java or Lisp) are by far the largest class of
formal languages in common use. Programs themselves represent, in a direct sense, only
computational processes. Data structures within programs can represent facts; for example,
a program could use a 4 × 4 array to represent the contents of the wumpus world. Thus, the
programming language statement World[2,2]← Pit is a fairly natural way to assert that there
is a pit in square [2,2]. (Such representations might be considered ad hoc; database systems
were developed precisely to provide a more general, domain-independent way to store and
1 Also called first-order predicate calculus, sometimes abbreviated as FOL or FOPC.
285
286 Chapter 8. First-Order Logic
retrieve facts.) What programming languages lack is any general mechanism for deriving
facts from other facts; each update to a data structure is done by a domain-specific procedure
whose details are derived by the programmer from his or her own knowledge of the domain.
This procedural approach can be contrasted with the declarative nature of propositional logic,
in which knowledge and inference are separate, and inference is entirely domain independent.
A second drawback of data structures in programs (and of databases, for that matter)
is the lack of any easy way to say, for example, “There is a pit in [2,2] or [3,1]” or “If the
wumpus is in [1,1] then he is not in [2,2].” Programs can store a single value for each variable,
and some systems allow the value to be “unknown,” but they lack the expressiveness required
to handle partial information.
Propositional logic is a declarative language because its semantics is based on a truth
relation between sentences and possible worlds. It also has sufficient expressive power to
deal with partial information, using disjunction and negation. Propositional logic has a third
COMPOSITIONALITY property that is desirable in representation languages, namely, compositionality. In a compositional language, the meaning of a sentence is a function of the meaning of its parts. For
example, the meaning of “S1,4 ∧ S1,2” is related to the meanings of “S1,4” and “S1,2.” It
would be very strange if “S1,4” meant that there is a stench in square [1,4] and “S1,2” meant
that there is a stench in square [1,2], but “S1,4 ∧S1,2” meant that France and Poland drew 1–1
in last week’s ice hockey qualifying match. Clearly, noncompositionality makes life much
more difficult for the reasoning system.
As we saw in Chapter 7, however, propositional logic lacks the expressive power to
concisely describe an environment with many objects. For example, we were forced to write
a separate rule about breezes and pits for each square, such as
B1,1 ⇔ (P1,2 ∨ P2,1) .
In English, on the other hand, it seems easy enough to say, once and for all, “Squares adjacent
to pits are breezy.” The syntax and semantics of English somehow make it possible to describe
the environment concisely.
8.1.1 The language of thought
Natural languages (such as English or Spanish) are very expressive indeed. We managed to
write almost this whole book in natural language, with only occasional lapses into other languages (including logic, mathematics, and the language of diagrams). There is a long tradition in linguistics and the philosophy of language that views natural language as a declarative
knowledge representation language. If we could uncover the rules for natural language, we
could use it in representation and reasoning systems and gain the benefit of the billions of
pages that have been written in natural language.
The modern view of natural language is that it serves a as a medium for communication
rather than pure representation. When a speaker points and says, “Look!” the listener comes
to know that, say, Superman has finally appeared over the rooftops. Yet we would not want
to say that the sentence “Look!” represents that fact. Rather, the meaning of the sentence
depends both on the sentence itself and on the context in which the sentence was spoken.
Clearly, one could not store a sentence such as “Look!” in a knowledge base and expect to
Section 8.1. Representation Revisited 287
recover its meaning without also storing a representation of the context—which raises the
question of how the context itself can be represented. Natural languages also suffer from
AMBIGUITY ambiguity, a problem for a representation language. As Pinker (1995) puts it: “When people
think about spring, surely they are not confused as to whether they are thinking about a season
or something that goes boing—and if one word can correspond to two thoughts, thoughts
can’t be words.”
The famous Sapir–Whorf hypothesis claims that our understanding of the world is
strongly influenced by the language we speak. Whorf (1956) wrote “We cut nature up, organize it into concepts, and ascribe significances as we do, largely because we are parties to an
agreement to organize it this way—an agreement that holds throughout our speech community and is codified in the patterns of our language.” It is certainly true that different speech
communities divide up the world differently. The French have two words “chaise” and “fauteuil,” for a concept that English speakers cover with one: “chair.” But English speakers
can easily recognize the category fauteuil and give it a name—roughly “open-arm chair”—so
does language really make a difference? Whorf relied mainly on intuition and speculation,
but in the intervening years we actually have real data from anthropological, psychological
and neurological studies.
For example, can you remember which of the following two phrases formed the opening
of Section 8.1?
“In this section, we discuss the nature of representation languages ...”
“This section covers the topic of knowledge representation languages ...”
Wanner (1974) did a similar experiment and found that subjects made the right choice at
chance level—about 50% of the time—but remembered the content of what they read with
better than 90% accuracy. This suggests that people process the words to form some kind of
nonverbal representation.
More interesting is the case in which a concept is completely absent in a language.
Speakers of the Australian aboriginal language Guugu Yimithirr have no words for relative
directions, such as front, back, right, or left. Instead they use absolute directions, saying,
for example, the equivalent of “I have a pain in my north arm.” This difference in language
makes a difference in behavior: Guugu Yimithirr speakers are better at navigating in open
terrain, while English speakers are better at placing the fork to the right of the plate.
Language also seems to influence thought through seemingly arbitrary grammatical
features such as the gender of nouns. For example, “bridge” is masculine in Spanish and
feminine in German. Boroditsky (2003) asked subjects to choose English adjectives to describe a photograph of a particular bridge. Spanish speakers chose big, dangerous, strong,
and towering, whereas German speakers chose beautiful, elegant, fragile, and slender. Words
can serve as anchor points that affect how we perceive the world. Loftus and Palmer (1974)
showed experimental subjects a movie of an auto accident. Subjects who were asked “How
fast were the cars going when they contacted each other?” reported an average of 32 mph,
while subjects who were asked the question with the word “smashed” instead of “contacted”
reported 41mph for the same cars in the same movie.
288 Chapter 8. First-Order Logic
In a first-order logic reasoning system that uses CNF, we can see that the linguistic form
“¬(A ∨ B)” and “¬A ∧ ¬B” are the same because we can look inside the system and see
that the two sentences are stored as the same canonical CNF form. Can we do that with the
human brain? Until recently the answer was “no,” but now it is “maybe.” Mitchell et al.
(2008) put subjects in an fMRI (functional magnetic resonance imaging) machine, showed
them words such as “celery,” and imaged their brains. The researchers were then able to train
a computer program to predict, from a brain image, what word the subject had been presented
with. Given two choices (e.g., “celery” or “airplane”), the system predicts correctly 77% of
the time. The system can even predict at above-chance levels for words it has never seen
an fMRI image of before (by considering the images of related words) and for people it has
never seen before (proving that fMRI reveals some level of common representation across
people). This type of work is still in its infancy, but fMRI (and other imaging technology
such as intracranial electrophysiology (Sahin et al., 2009)) promises to give us much more
concrete ideas of what human knowledge representations are like.
From the viewpoint of formal logic, representing the same knowledge in two different
ways makes absolutely no difference; the same facts will be derivable from either representation. In practice, however, one representation might require fewer steps to derive a conclusion, meaning that a reasoner with limited resources could get to the conclusion using one
representation but not the other. For nondeductive tasks such as learning from experience,
outcomes are necessarily dependent on the form of the representations used. We show in
Chapter 18 that when a learning program considers two possible theories of the world, both
of which are consistent with all the data, the most common way of breaking the tie is to choose
the most succinct theory—and that depends on the language used to represent theories. Thus,
the influence of language on thought is unavoidable for any agent that does learning.
8.1.2 Combining the best of formal and natural languages
We can adopt the foundation of propositional logic—a declarative, compositional semantics
that is context-independent and unambiguous—and build a more expressive logic on that
foundation, borrowing representational ideas from natural language while avoiding its drawbacks. When we look at the syntax of natural language, the most obvious elements are nouns
OBJECT and noun phrases that refer to objects (squares, pits, wumpuses) and verbs and verb phrases
RELATION that refer to relations among objects (is breezy, is adjacent to, shoots). Some of these relaFUNCTION tions are functions—relations in which there is only one “value” for a given “input.” It is
easy to start listing examples of objects, relations, and functions:
• Objects: people, houses, numbers, theories, Ronald McDonald, colors, baseball games,
wars, centuries ...
PROPERTY • Relations: these can be unary relations or properties such as red, round, bogus, prime,
multistoried ..., or more general n-ary relations such as brother of, bigger than, inside,
part of, has color, occurred after, owns, comes between, ...
• Functions: father of, best friend, third inning of, one more than, beginning of ...
Indeed, almost any assertion can be thought of as referring to objects and properties or relations. Some examples follow:
Section 8.1. Representation Revisited 289
• “One plus two equals three.”
Objects: one, two, three, one plus two; Relation: equals; Function: plus. (“One plus
two” is a name for the object that is obtained by applying the function “plus” to the
objects “one” and “two.” “Three” is another name for this object.)
• “Squares neighboring the wumpus are smelly.”
Objects: wumpus, squares; Property: smelly; Relation: neighboring.
• “Evil King John ruled England in 1200.”
Objects: John, England, 1200; Relation: ruled; Properties: evil, king.
The language of first-order logic, whose syntax and semantics we define in the next section,
is built around objects and relations. It has been so important to mathematics, philosophy, and
artificial intelligence precisely because those fields—and indeed, much of everyday human
existence—can be usefully thought of as dealing with objects and the relations among them.
First-order logic can also express facts about some or all of the objects in the universe. This
enables one to represent general laws or rules, such as the statement “Squares neighboring
the wumpus are smelly.”
The primary difference between propositional and first-order logic lies in the ontological commitment made by each language—that is, what it assumes about the nature of reality. ONTOLOGICAL
COMMITMENT
Mathematically, this commitment is expressed through the nature of the formal models with
respect to which the truth of sentences is defined. For example, propositional logic assumes
that there are facts that either hold or do not hold in the world. Each fact can be in one
of two states: true or false, and each model assigns true or false to each proposition symbol (see Section 7.4.2).2 First-order logic assumes more; namely, that the world consists of
objects with certain relations among them that do or do not hold. The formal models are
correspondingly more complicated than those for propositional logic. Special-purpose logics
TEMPORAL LOGIC make still further ontological commitments; for example, temporal logic assumes that facts
hold at particular times and that those times (which may be points or intervals) are ordered.
Thus, special-purpose logics give certain kinds of objects (and the axioms about them) “first
class” status within the logic, rather than simply defining them within the knowledge base.
Higher-order logic views the relations and functions referred to by first-order logic as ob- HIGHER-ORDER
LOGIC
jects in themselves. This allows one to make assertions about all relations—for example, one
could wish to define what it means for a relation to be transitive. Unlike most special-purpose
logics, higher-order logic is strictly more expressive than first-order logic, in the sense that
some sentences of higher-order logic cannot be expressed by any finite number of first-order
logic sentences.
A logic can also be characterized by its epistemological commitments—the possible EPISTEMOLOGICAL
COMMITMENT
states of knowledge that it allows with respect to each fact. In both propositional and firstorder logic, a sentence represents a fact and the agent either believes the sentence to be true,
believes it to be false, or has no opinion. These logics therefore have three possible states
of knowledge regarding any sentence. Systems using probability theory, on the other hand,
2 In contrast, facts in fuzzy logic have a degree of truth between 0 and 1. For example, the sentence “Vienna is
a large city” might be true in our world only to degree 0.6 in fuzzy logic.
290 Chapter 8. First-Order Logic
can have any degree of belief, ranging from 0 (total disbelief) to 1 (total belief).3 For example, a probabilistic wumpus-world agent might believe that the wumpus is in [1,3] with
probability 0.75. The ontological and epistemological commitments of five different logics
are summarized in Figure 8.1.
Language Ontological Commitment Epistemological Commitment
(What exists in the world) (What an agent believes about facts)
Propositional logic facts true/false/unknown
First-order logic facts, objects, relations true/false/unknown
Temporal logic facts, objects, relations, times true/false/unknown
Probability theory facts degree of belief ∈ [0, 1]
Fuzzy logic facts with degree of truth ∈ [0, 1] known interval value
Figure 8.1 Formal languages and their ontological and epistemological commitments.
In the next section, we will launch into the details of first-order logic. Just as a student of
physics requires some familiarity with mathematics, a student of AI must develop a talent for
working with logical notation. On the other hand, it is also important not to get too concerned
with the specifics of logical notation—after all, there are dozens of different versions. The
main things to keep hold of are how the language facilitates concise representations and how
its semantics leads to sound reasoning procedures.
8.2 SYNTAX AND SEMANTICS OF FIRST-ORDER LOGIC
We begin this section by specifying more precisely the way in which the possible worlds
of first-order logic reflect the ontological commitment to objects and relations. Then we
introduce the various elements of the language, explaining their semantics as we go along.
8.2.1 Models for first-order logic
Recall from Chapter 7 that the models of a logical language are the formal structures that
constitute the possible worlds under consideration. Each model links the vocabulary of the
logical sentences to elements of the possible world, so that the truth of any sentence can
be determined. Thus, models for propositional logic link proposition symbols to predefined
truth values. Models for first-order logic are much more interesting. First, they have objects
DOMAIN in them! The domain of a model is the set of objects or domain elements it contains. The doDOMAIN ELEMENTS main is required to be nonempty—every possible world must contain at least one object. (See
Exercise 8.7 for a discussion of empty worlds.) Mathematically speaking, it doesn’t matter
what these objects are—all that matters is how many there are in each particular model—but
for pedagogical purposes we’ll use a concrete example. Figure 8.2 shows a model with five
3 It is important not to confuse the degree of belief in probability theory with the degree of truth in fuzzy logic.
Indeed, some fuzzy systems allow uncertainty (degree of belief) about degrees of truth.
Section 8.2. Syntax and Semantics of First-Order Logic 291
objects: Richard the Lionheart, King of England from 1189 to 1199; his younger brother, the
evil King John, who ruled from 1199 to 1215; the left legs of Richard and John; and a crown.
The objects in the model may be related in various ways. In the figure, Richard and
TUPLE John are brothers. Formally speaking, a relation is just the set of tuples of objects that are
related. (A tuple is a collection of objects arranged in a fixed order and is written with angle
brackets surrounding the objects.) Thus, the brotherhood relation in this model is the set
{ Richard the Lionheart, King John, King John, Richard the Lionheart } . (8.1)
(Here we have named the objects in English, but you may, if you wish, mentally substitute the
pictures for the names.) The crown is on King John’s head, so the “on head” relation contains
just one tuple, the crown, King John. The “brother” and “on head” relations are binary
relations—that is, they relate pairs of objects. The model also contains unary relations, or
properties: the “person” property is true of both Richard and John; the “king” property is true
only of John (presumably because Richard is dead at this point); and the “crown” property is
true only of the crown.
Certain kinds of relationships are best considered as functions, in that a given object
must be related to exactly one object in this way. For example, each person has one left leg,
so the model has a unary “left leg” function that includes the following mappings:
Richard the Lionheart → Richard’s left leg
King John → John’s left leg . (8.2)
TOTAL FUNCTIONS Strictly speaking, models in first-order logic require total functions, that is, there must be a
value for every input tuple. Thus, the crown must have a left leg and so must each of the left
legs. There is a technical solution to this awkward problem involving an additional “invisible”
R J
$
left leg
on head brother
brother
person person
king
crown
left leg
Figure 8.2 A model containing five objects, two binary relations, three unary relations
(indicated by labels on the objects), and one unary function, left-leg.
292 Chapter 8. First-Order Logic
object that is the left leg of everything that has no left leg, including itself. Fortunately, as
long as one makes no assertions about the left legs of things that have no left legs, these
technicalities are of no import.
So far, we have described the elements that populate models for first-order logic. The
other essential part of a model is the link between those elements and the vocabulary of the
logical sentences, which we explain next.
8.2.2 Symbols and interpretations
We turn now to the syntax of first-order logic. The impatient reader can obtain a complete
description from the formal grammar in Figure 8.3.
The basic syntactic elements of first-order logic are the symbols that stand for objects,
CONSTANT SYMBOL relations, and functions. The symbols, therefore, come in three kinds: constant symbols,
PREDICATE SYMBOL which stand for objects; predicate symbols, which stand for relations; and function symFUNCTION SYMBOL bols, which stand for functions. We adopt the convention that these symbols will begin with
uppercase letters. For example, we might use the constant symbols Richard and John; the
predicate symbols Brother , OnHead, Person, King, and Crown; and the function symbol
LeftLeg. As with proposition symbols, the choice of names is entirely up to the user. Each
ARITY predicate and function symbol comes with an arity that fixes the number of arguments.
As in propositional logic, every model must provide the information required to determine if any given sentence is true or false. Thus, in addition to its objects, relations, and
INTERPRETATION functions, each model includes an interpretation that specifies exactly which objects, relations and functions are referred to by the constant, predicate, and function symbols. One
possible interpretation for our example—which a logician would call the intended interpretation—is as follows: INTENDED
INTERPRETATION
• Richard refers to Richard the Lionheart and John refers to the evil King John.
• Brother refers to the brotherhood relation, that is, the set of tuples of objects given in
Equation (8.1); OnHead refers to the “on head” relation that holds between the crown
and King John; Person, King, and Crown refer to the sets of objects that are persons,
kings, and crowns.
• LeftLeg refers to the “left leg” function, that is, the mapping given in Equation (8.2).
There are many other possible interpretations, of course. For example, one interpretation
maps Richard to the crown and John to King John’s left leg. There are five objects in
the model, so there are 25 possible interpretations just for the constant symbols Richard
and John. Notice that not all the objects need have a name—for example, the intended
interpretation does not name the crown or the legs. It is also possible for an object to have
several names; there is an interpretation under which both Richard and John refer to the
crown.4 If you find this possibility confusing, remember that, in propositional logic, it is
perfectly possible to have a model in which Cloudy and Sunny are both true; it is the job of
the knowledge base to rule out models that are inconsistent with our knowledge.
4 Later, in Section 8.2.8, we examine a semantics in which every object has exactly one name.
Section 8.2. Syntax and Semantics of First-Order Logic 293
Sentence → AtomicSentence | ComplexSentence
AtomicSentence → Predicate | Predicate(Term,...) | Term = Term
ComplexSentence → ( Sentence ) | [ Sentence ]
| ¬ Sentence
| Sentence ∧ Sentence
| Sentence ∨ Sentence
| Sentence ⇒ Sentence
| Sentence ⇔ Sentence
| Quantifier Variable,... Sentence
Term → Function(Term,...)
| Constant
| Variable
Quantifier → ∀| ∃
Constant → A | X1 | John | ···
Variable → a | x | s | ···
Predicate → True | False | After | Loves | Raining | ···
Function → Mother | LeftLeg | ···
OPERATOR PRECEDENCE : ¬, =, ∧, ∨, ⇒, ⇔
Figure 8.3 The syntax of first-order logic with equality, specified in Backus–Naur form
(see page 1060 if you are not familiar with this notation). Operator precedences are specified,
from highest to lowest. The precedence of quantifiers is such that a quantifier holds over
everything to the right of it.
R J R J R J R J R J R J
. . . . . . . . .
Figure 8.4 Some members of the set of all models for a language with two constant symbols, R and J, and one binary relation symbol. The interpretation of each constant symbol is
shown by a gray arrow. Within each model, the related objects are connected by arrows.
294 Chapter 8. First-Order Logic
In summary, a model in first-order logic consists of a set of objects and an interpretation
that maps constant symbols to objects, predicate symbols to relations on those objects, and
function symbols to functions on those objects. Just as with propositional logic, entailment,
validity, and so on are defined in terms of all possible models. To get an idea of what the
set of all possible models looks like, see Figure 8.4. It shows that models vary in how many
objects they contain—from one up to infinity—and in the way the constant symbols map
to objects. If there are two constant symbols and one object, then both symbols must refer
to the same object; but this can still happen even with more objects. When there are more
objects than constant symbols, some of the objects will have no names. Because the number
of possible models is unbounded, checking entailment by the enumeration of all possible
models is not feasible for first-order logic (unlike propositional logic). Even if the number of
objects is restricted, the number of combinations can be very large. (See Exercise 8.5.) For
the example in Figure 8.4, there are 137,506,194,466 models with six or fewer objects.
8.2.3 Terms
TERM A term is a logical expression that refers to an object. Constant symbols are therefore terms,
but it is not always convenient to have a distinct symbol to name every object. For example,
in English we might use the expression “King John’s left leg” rather than giving a name
to his leg. This is what function symbols are for: instead of using a constant symbol, we
use LeftLeg(John). In the general case, a complex term is formed by a function symbol
followed by a parenthesized list of terms as arguments to the function symbol. It is important
to remember that a complex term is just a complicated kind of name. It is not a “subroutine
call” that “returns a value.” There is no LeftLeg subroutine that takes a person as input and
returns a leg. We can reason about left legs (e.g., stating the general rule that everyone has one
and then deducing that John must have one) without ever providing a definition of LeftLeg.
This is something that cannot be done with subroutines in programming languages.5
The formal semantics of terms is straightforward. Consider a term f(t1,...,tn). The
function symbol f refers to some function in the model (call it F); the argument terms refer
to objects in the domain (call them d1,...,dn); and the term as a whole refers to the object
that is the value of the function F applied to d1,...,dn. For example, suppose the LeftLeg
function symbol refers to the function shown in Equation (8.2) and John refers to King John,
then LeftLeg(John) refers to King John’s left leg. In this way, the interpretation fixes the
referent of every term.
8.2.4 Atomic sentences
Now that we have both terms for referring to objects and predicate symbols for referring to
relations, we can put them together to make atomic sentences that state facts. An atomic
5 λ-expressions provide a useful notation in which new function symbols are constructed “on the fly.” For
example, the function that squares its argument can be written as (λx x × x) and can be applied to arguments
just like any other function symbol. A λ-expression can also be defined and used as a predicate symbol. (See
Chapter 22.) The lambda operator in Lisp plays exactly the same role. Notice that the use of λ in this way does
not increase the formal expressive power of first-order logic, because any sentence that includes a λ-expression
can be rewritten by “plugging in” its arguments to yield an equivalent sentence.
Section 8.2. Syntax and Semantics of First-Order Logic 295
ATOMIC SENTENCE sentence (or atom for short) is formed from a predicate symbol optionally followed by a
ATOM parenthesized list of terms, such as
Brother (Richard, John).
This states, under the intended interpretation given earlier, that Richard the Lionheart is the
brother of King John.6 Atomic sentences can have complex terms as arguments. Thus,
Married(Father (Richard), Mother (John))
states that Richard the Lionheart’s father is married to King John’s mother (again, under a
suitable interpretation).
An atomic sentence is true in a given model if the relation referred to by the predicate
symbol holds among the objects referred to by the arguments.
8.2.5 Complex sentences
We can use logical connectives to construct more complex sentences, with the same syntax
and semantics as in propositional calculus. Here are four sentences that are true in the model
of Figure 8.2 under our intended interpretation:
¬Brother (LeftLeg(Richard), John)
Brother (Richard, John) ∧ Brother (John, Richard)
King(Richard) ∨ King(John)
¬King(Richard) ⇒ King(John) .
8.2.6 Quantifiers
Once we have a logic that allows objects, it is only natural to want to express properties of
QUANTIFIER entire collections of objects, instead of enumerating the objects by name. Quantifiers let us
do this. First-order logic contains two standard quantifiers, called universal and existential.
Universal quantification (∀)
Recall the difficulty we had in Chapter 7 with the expression of general rules in propositional logic. Rules such as “Squares neighboring the wumpus are smelly” and “All kings
are persons” are the bread and butter of first-order logic. We deal with the first of these in
Section 8.3. The second rule, “All kings are persons,” is written in first-order logic as
∀ x King(x) ⇒ Person(x) .
∀ is usually pronounced “For all ...”. (Remember that the upside-down A stands for “all.”)
Thus, the sentence says, “For all x, if x is a king, then x is a person.” The symbol x is called
VARIABLE a variable. By convention, variables are lowercase letters. A variable is a term all by itself,
and as such can also serve as the argument of a function—for example, LeftLeg(x). A term
GROUND TERM with no variables is called a ground term.
Intuitively, the sentence ∀ x P, where P is any logical expression, says that P is true
for every object x. More precisely, ∀ x P is true in a given model if P is true in all possible
extended interpretations constructed from the interpretation given in the model, where each EXTENDED
INTERPRETATION
6 We usually follow the argument-ordering convention that P(x, y) is read as “x is a P of y.”
296 Chapter 8. First-Order Logic
extended interpretation specifies a domain element to which x refers.
This sounds complicated, but it is really just a careful way of stating the intuitive meaning of universal quantification. Consider the model shown in Figure 8.2 and the intended
interpretation that goes with it. We can extend the interpretation in five ways:
x → Richard the Lionheart,
x → King John,
x → Richard’s left leg,
x → John’s left leg,
x → the crown.
The universally quantified sentence ∀ x King(x) ⇒ Person(x) is true in the original model
if the sentence King(x) ⇒ Person(x) is true under each of the five extended interpretations. That is, the universally quantified sentence is equivalent to asserting the following five
sentences:
Richard the Lionheart is a king ⇒ Richard the Lionheart is a person.
King John is a king ⇒ King John is a person.
Richard’s left leg is a king ⇒ Richard’s left leg is a person.
John’s left leg is a king ⇒ John’s left leg is a person.
The crown is a king ⇒ the crown is a person.
Let us look carefully at this set of assertions. Since, in our model, King John is the only
king, the second sentence asserts that he is a person, as we would hope. But what about
the other four sentences, which appear to make claims about legs and crowns? Is that part
of the meaning of “All kings are persons”? In fact, the other four assertions are true in the
model, but make no claim whatsoever about the personhood qualifications of legs, crowns,
or indeed Richard. This is because none of these objects is a king. Looking at the truth table
for ⇒ (Figure 7.8 on page 246), we see that the implication is true whenever its premise is
false—regardless of the truth of the conclusion. Thus, by asserting the universally quantified
sentence, which is equivalent to asserting a whole list of individual implications, we end
up asserting the conclusion of the rule just for those objects for whom the premise is true
and saying nothing at all about those individuals for whom the premise is false. Thus, the
truth-table definition of ⇒ turns out to be perfect for writing general rules with universal
quantifiers.
A common mistake, made frequently even by diligent readers who have read this paragraph several times, is to use conjunction instead of implication. The sentence
∀ x King(x) ∧ Person(x)
would be equivalent to asserting
Richard the Lionheart is a king ∧ Richard the Lionheart is a person,
King John is a king ∧ King John is a person,
Richard’s left leg is a king ∧ Richard’s left leg is a person,
and so on. Obviously, this does not capture what we want.
Section 8.2. Syntax and Semantics of First-Order Logic 297
Existential quantification (∃)
Universal quantification makes statements about every object. Similarly, we can make a statement about some object in the universe without naming it, by using an existential quantifier.
To say, for example, that King John has a crown on his head, we write
∃ x Crown(x) ∧ OnHead(x, John) .
∃x is pronounced “There exists an x such that ...” or “For some x...”.
Intuitively, the sentence ∃ x P says that P is true for at least one object x. More
precisely, ∃ x P is true in a given model if P is true in at least one extended interpretation
that assigns x to a domain element. That is, at least one of the following is true:
Richard the Lionheart is a crown ∧ Richard the Lionheart is on John’s head;
King John is a crown ∧ King John is on John’s head;
Richard’s left leg is a crown ∧ Richard’s left leg is on John’s head;
John’s left leg is a crown ∧ John’s left leg is on John’s head;
The crown is a crown ∧ the crown is on John’s head.
The fifth assertion is true in the model, so the original existentially quantified sentence is
true in the model. Notice that, by our definition, the sentence would also be true in a model
in which King John was wearing two crowns. This is entirely consistent with the original
sentence “King John has a crown on his head.” 7
Just as ⇒ appears to be the natural connective to use with ∀, ∧ is the natural connective
to use with ∃. Using ∧ as the main connective with ∀ led to an overly strong statement in
the example in the previous section; using ⇒ with ∃ usually leads to a very weak statement,
indeed. Consider the following sentence:
∃ x Crown(x) ⇒ OnHead(x, John) .
On the surface, this might look like a reasonable rendition of our sentence. Applying the
semantics, we see that the sentence says that at least one of the following assertions is true:
Richard the Lionheart is a crown ⇒ Richard the Lionheart is on John’s head;
King John is a crown ⇒ King John is on John’s head;
Richard’s left leg is a crown ⇒ Richard’s left leg is on John’s head;
and so on. Now an implication is true if both premise and conclusion are true, or if its premise
is false. So if Richard the Lionheart is not a crown, then the first assertion is true and the
existential is satisfied. So, an existentially quantified implication sentence is true whenever
any object fails to satisfy the premise; hence such sentences really do not say much at all.
Nested quantifiers
We will often want to express more complex sentences using multiple quantifiers. The simplest case is where the quantifiers are of the same type. For example, “Brothers are siblings”
can be written as
∀ x ∀ y Brother (x, y) ⇒ Sibling(x, y) .
7 There is a variant of the existential quantifier, usually written ∃1 or ∃!, that means “There exists exactly one.”
The same meaning can be expressed using equality statements.
298 Chapter 8. First-Order Logic
Consecutive quantifiers of the same type can be written as one quantifier with several variables. For example, to say that siblinghood is a symmetric relationship, we can write
∀ x, y Sibling(x, y) ⇔ Sibling(y, x) .
In other cases we will have mixtures. “Everybody loves somebody” means that for every
person, there is someone that person loves:
∀ x ∃ y Loves(x, y) .
On the other hand, to say “There is someone who is loved by everyone,” we write
∃ y ∀ x Loves(x, y) .
The order of quantification is therefore very important. It becomes clearer if we insert parentheses. ∀ x (∃ y Loves(x, y)) says that everyone has a particular property, namely, the property that they love someone. On the other hand, ∃ y (∀ x Loves(x, y)) says that someone in
the world has a particular property, namely the property of being loved by everybody.
Some confusion can arise when two quantifiers are used with the same variable name.
Consider the sentence
∀ x (Crown(x) ∨ (∃ x Brother (Richard, x))) .
Here the x in Brother (Richard, x) is existentially quantified. The rule is that the variable
belongs to the innermost quantifier that mentions it; then it will not be subject to any other
quantification. Another way to think of it is this: ∃ x Brother (Richard, x) is a sentence
about Richard (that he has a brother), not about x; so putting a ∀ x outside it has no effect. It
could equally well have been written ∃ z Brother (Richard, z). Because this can be a source
of confusion, we will always use different variable names with nested quantifiers.
Connections between ∀ and ∃
The two quantifiers are actually intimately connected with each other, through negation. Asserting that everyone dislikes parsnips is the same as asserting there does not exist someone
who likes them, and vice versa:
∀ x ¬Likes(x,Parsnips ) is equivalent to ¬∃ x Likes(x,Parsnips) .
We can go one step further: “Everyone likes ice cream” means that there is no one who does
not like ice cream:
∀ x Likes(x,IceCream) is equivalent to ¬∃ x ¬Likes(x,IceCream) .
Because ∀ is really a conjunction over the universe of objects and ∃ is a disjunction, it should
not be surprising that they obey De Morgan’s rules. The De Morgan rules for quantified and
unquantified sentences are as follows:
∀ x ¬P ≡ ¬∃ x P ¬(P ∨ Q) ≡ ¬P ∧ ¬Q
¬∀ x P ≡ ∃ x ¬P ¬(P ∧ Q) ≡ ¬P ∨ ¬Q
∀ x P ≡ ¬∃ x ¬P P ∧ Q ≡ ¬(¬P ∨ ¬Q)
∃ x P ≡ ¬∀ x ¬P P ∨ Q ≡ ¬(¬P ∧ ¬Q) .
Thus, we do not really need both ∀ and ∃, just as we do not really need both ∧ and ∨. Still,
readability is more important than parsimony, so we will keep both of the quantifiers.
Section 8.2. Syntax and Semantics of First-Order Logic 299
8.2.7 Equality
First-order logic includes one more way to make atomic sentences, other than using a prediEQUALITY SYMBOL cate and terms as described earlier. We can use the equality symbol to signify that two terms
refer to the same object. For example,
Father (John) = Henry
says that the object referred to by Father (John) and the object referred to by Henry are the
same. Because an interpretation fixes the referent of any term, determining the truth of an
equality sentence is simply a matter of seeing that the referents of the two terms are the same
object.
The equality symbol can be used to state facts about a given function, as we just did for
the Father symbol. It can also be used with negation to insist that two terms are not the same
object. To say that Richard has at least two brothers, we would write
∃ x, y Brother (x, Richard) ∧ Brother (y, Richard) ∧ ¬(x = y) .
The sentence
∃ x, y Brother (x, Richard) ∧ Brother (y, Richard)
does not have the intended meaning. In particular, it is true in the model of Figure 8.2, where
Richard has only one brother. To see this, consider the extended interpretation in which both
x and y are assigned to King John. The addition of ¬(x = y) rules out such models. The
notation x = y is sometimes used as an abbreviation for ¬(x = y).
8.2.8 An alternative semantics?
Continuing the example from the previous section, suppose that we believe that Richard has
two brothers, John and Geoffrey.8 Can we capture this state of affairs by asserting
Brother (John, Richard) ∧ Brother (Geoffrey, Richard) ? (8.3)
Not quite. First, this assertion is true in a model where Richard has only one brother—
we need to add John = Geoffrey. Second, the sentence doesn’t rule out models in which
Richard has many more brothers besides John and Geoffrey. Thus, the correct translation of
“Richard’s brothers are John and Geoffrey” is as follows:
Brother (John, Richard) ∧ Brother (Geoffrey, Richard) ∧ John = Geoffrey
∧ ∀ x Brother (x, Richard) ⇒ (x = John ∨ x = Geoffrey) .
For many purposes, this seems much more cumbersome than the corresponding naturallanguage expression. As a consequence, humans may make mistakes in translating their
knowledge into first-order logic, resulting in unintuitive behaviors from logical reasoning
systems that use the knowledge. Can we devise a semantics that allows a more straightforward logical expression?
One proposal that is very popular in database systems works as follows. First, we insist
that every constant symbol refer to a distinct object—the so-called unique-names assumption. Second, we assume that atomic sentences not known to be true are in fact false—the UNIQUE-NAMES
ASSUMPTION
closed-world assumption. Finally, we invoke domain closure, meaning that each model CLOSED-WORLD
ASSUMPTION
DOMAIN CLOSURE 8 Actually he had four, the others being William and Henry.
300 Chapter 8. First-Order Logic
. . .
R J
R
J
R J
R
J
R J
R
J
R J
R
J
R J
R
J
Figure 8.5 Some members of the set of all models for a language with two constant symbols, R and J, and one binary relation symbol, under database semantics. The interpretation
of the constant symbols is fixed, and there is a distinct object for each constant symbol.
contains no more domain elements than those named by the constant symbols. Under the
resulting semantics, which we call database semantics to distinguish it from the standard DATABASE
SEMANTICS
semantics of first-order logic, the sentence Equation (8.3) does indeed state that Richard’s
two brothers are John and Geoffrey. Database semantics is also used in logic programming
systems, as explained in Section 9.4.5.
It is instructive to consider the set of all possible models under database semantics for
the same case as shown in Figure 8.4. Figure 8.5 shows some of the models, ranging from
the model with no tuples satisfying the relation to the model with all tuples satisfying the
relation. With two objects, there are four possible two-element tuples, so there are 24 = 16
different subsets of tuples that can satisfy the relation. Thus, there are 16 possible models in
all—a lot fewer than the infinitely many models for the standard first-order semantics. On the
other hand, the database semantics requires definite knowledge of what the world contains.
This example brings up an important point: there is no one “correct” semantics for
logic. The usefulness of any proposed semantics depends on how concise and intuitive it
makes the expression of the kinds of knowledge we want to write down, and on how easy
and natural it is to develop the corresponding rules of inference. Database semantics is most
useful when we are certain about the identity of all the objects described in the knowledge
base and when we have all the facts at hand; in other cases, it is quite awkward. For the rest
of this chapter, we assume the standard semantics while noting instances in which this choice
leads to cumbersome expressions.
8.3 USING FIRST-ORDER LOGIC
Now that we have defined an expressive logical language, it is time to learn how to use it. The
best way to do this is through examples. We have seen some simple sentences illustrating the
various aspects of logical syntax; in this section, we provide more systematic representations
DOMAIN of some simple domains. In knowledge representation, a domain is just some part of the
world about which we wish to express some knowledge.
We begin with a brief description of the TELL/ASK interface for first-order knowledge
bases. Then we look at the domains of family relationships, numbers, sets, and lists, and at
Section 8.3. Using First-Order Logic 301
the wumpus world. The next section contains a more substantial example (electronic circuits)
and Chapter 12 covers everything in the universe.
8.3.1 Assertions and queries in first-order logic
Sentences are added to a knowledge base using TELL, exactly as in propositional logic. Such
ASSERTION sentences are called assertions. For example, we can assert that John is a king, Richard is a
person, and all kings are persons:
TELL(KB, King(John)) .
TELL(KB, Person(Richard)) .
TELL(KB, ∀ x King(x) ⇒ Person(x)) .
We can ask questions of the knowledge base using ASK. For example,
ASK(KB, King(John))
QUERY returns true. Questions asked with ASK are called queries or goals. Generally speaking, any
GOAL query that is logically entailed by the knowledge base should be answered affirmatively. For
example, given the two preceding assertions, the query
ASK(KB, Person(John))
should also return true. We can ask quantified queries, such as
ASK(KB, ∃ x Person(x)) .
The answer is true, but this is perhaps not as helpful as we would like. It is rather like
answering “Can you tell me the time?” with “Yes.” If we want to know what value of x
makes the sentence true, we will need a different function, ASKVARS, which we call with
ASKVARS(KB,Person(x))
and which yields a stream of answers. In this case there will be two answers: {x/John} and
SUBSTITUTION {x/Richard}. Such an answer is called a substitution or binding list. ASKVARS is usually
BINDING LIST reserved for knowledge bases consisting solely of Horn clauses, because in such knowledge
bases every way of making the query true will bind the variables to specific values. That is
not the case with first-order logic; if KB has been told King(John) ∨ King(Richard), then
there is no binding to x for the query ∃ x King(x), even though the query is true.
8.3.2 The kinship domain
The first example we consider is the domain of family relationships, or kinship. This domain
includes facts such as “Elizabeth is the mother of Charles” and “Charles is the father of
William” and rules such as “One’s grandmother is the mother of one’s parent.”
Clearly, the objects in our domain are people. We have two unary predicates, Male and
Female. Kinship relations—parenthood, brotherhood, marriage, and so on—are represented
by binary predicates: Parent, Sibling, Brother , Sister , Child, Daughter, Son, Spouse,
Wife, Husband, Grandparent, Grandchild , Cousin, Aunt, and Uncle. We use functions
for Mother and Father , because every person has exactly one of each of these (at least
according to nature’s design).
302 Chapter 8. First-Order Logic
We can go through each function and predicate, writing down what we know in terms
of the other symbols. For example, one’s mother is one’s female parent:
∀ m, c Mother (c) = m ⇔ Female(m) ∧ Parent(m, c) .
One’s husband is one’s male spouse:
∀ w, h Husband(h, w) ⇔ Male(h) ∧ Spouse(h, w) .
Male and female are disjoint categories:
∀ x Male(x) ⇔ ¬Female(x) .
Parent and child are inverse relations:
∀ p, c Parent(p, c) ⇔ Child(c, p) .
A grandparent is a parent of one’s parent:
∀ g, c Grandparent(g, c) ⇔ ∃ p Parent(g, p) ∧ Parent(p, c) .
A sibling is another child of one’s parents:
∀ x, y Sibling(x, y) ⇔ x = y ∧ ∃ p Parent(p, x) ∧ Parent(p, y) .
We could go on for several more pages like this, and Exercise 8.14 asks you to do just that.
Each of these sentences can be viewed as an axiom of the kinship domain, as explained
in Section 7.1. Axioms are commonly associated with purely mathematical domains—we
will see some axioms for numbers shortly—but they are needed in all domains. They provide
the basic factual information from which useful conclusions can be derived. Our kinship
DEFINITION axioms are also definitions; they have the form ∀ x, y P(x, y) ⇔ .... The axioms define
the Mother function and the Husband, Male, Parent, Grandparent, and Sibling predicates
in terms of other predicates. Our definitions “bottom out” at a basic set of predicates (Child,
Spouse, and Female) in terms of which the others are ultimately defined. This is a natural
way in which to build up the representation of a domain, and it is analogous to the way in
which software packages are built up by successive definitions of subroutines from primitive
library functions. Notice that there is not necessarily a unique set of primitive predicates;
we could equally well have used Parent, Spouse, and Male. In some domains, as we show,
there is no clearly identifiable basic set.
THEOREM Not all logical sentences about a domain are axioms. Some are theorems—that is, they
are entailed by the axioms. For example, consider the assertion that siblinghood is symmetric:
∀ x, y Sibling(x, y) ⇔ Sibling(y, x) .
Is this an axiom or a theorem? In fact, it is a theorem that follows logically from the axiom
that defines siblinghood. If we ASK the knowledge base this sentence, it should return true.
From a purely logical point of view, a knowledge base need contain only axioms and
no theorems, because the theorems do not increase the set of conclusions that follow from
the knowledge base. From a practical point of view, theorems are essential to reduce the
computational cost of deriving new sentences. Without them, a reasoning system has to start
from first principles every time, rather like a physicist having to rederive the rules of calculus
for every new problem.
Section 8.3. Using First-Order Logic 303
Not all axioms are definitions. Some provide more general information about certain
predicates without constituting a definition. Indeed, some predicates have no complete definition because we do not know enough to characterize them fully. For example, there is no
obvious definitive way to complete the sentence
∀ x Person(x) ⇔ ...
Fortunately, first-order logic allows us to make use of the Person predicate without completely defining it. Instead, we can write partial specifications of properties that every person
has and properties that make something a person:
∀ x Person(x) ⇒ ...
∀ x ... ⇒ Person(x) .
Axioms can also be “just plain facts,” such as Male(Jim) and Spouse(Jim, Laura).
Such facts form the descriptions of specific problem instances, enabling specific questions
to be answered. The answers to these questions will then be theorems that follow from
the axioms. Often, one finds that the expected answers are not forthcoming—for example,
from Spouse(Jim, Laura) one expects (under the laws of many countries) to be able to infer
¬Spouse(George, Laura); but this does not follow from the axioms given earlier—even after
we add Jim = George as suggested in Section 8.2.8. This is a sign that an axiom is missing.
Exercise 8.8 asks the reader to supply it.
8.3.3 Numbers, sets, and lists
Numbers are perhaps the most vivid example of how a large theory can be built up from
NATURAL NUMBERS a tiny kernel of axioms. We describe here the theory of natural numbers or non-negative
integers. We need a predicate NatNum that will be true of natural numbers; we need one
PEANO AXIOMS constant symbol, 0; and we need one function symbol, S (successor). The Peano axioms
define natural numbers and addition.9 Natural numbers are defined recursively:
NatNum(0) .
∀ n NatNum(n) ⇒ NatNum(S(n)) .
That is, 0 is a natural number, and for every object n, if n is a natural number, then S(n) is
a natural number. So the natural numbers are 0, S(0), S(S(0)), and so on. (After reading
Section 8.2.8, you will notice that these axioms allow for other natural numbers besides the
usual ones; see Exercise 8.12.) We also need axioms to constrain the successor function:
∀ n 0 = S(n) .
∀ m, n m = n ⇒ S(m) = S(n) .
Now we can define addition in terms of the successor function:
∀ m NatNum(m) ⇒ + (0, m) = m .
∀ m, n NatNum(m) ∧ NatNum(n) ⇒ + (S(m), n) = S(+(m, n)) .
The first of these axioms says that adding 0 to any natural number m gives m itself. Notice
the use of the binary function symbol “+” in the term +(m, 0); in ordinary mathematics, the
INFIX term would be written m + 0 using infix notation. (The notation we have used for first-order
9 The Peano axioms also include the principle of induction, which is a sentence of second-order logic rather
than of first-order logic. The importance of this distinction is explained in Chapter 9.
304 Chapter 8. First-Order Logic
PREFIX logic is called prefix.) To make our sentences about numbers easier to read, we allow the use
of infix notation. We can also write S(n) as n + 1, so the second axiom becomes
∀ m, n NatNum(m) ∧ NatNum(n) ⇒ (m + 1) + n = (m + n)+1 .
This axiom reduces addition to repeated application of the successor function.
SYNTACTIC SUGAR The use of infix notation is an example of syntactic sugar, that is, an extension to or
abbreviation of the standard syntax that does not change the semantics. Any sentence that
uses sugar can be “desugared” to produce an equivalent sentence in ordinary first-order logic.
Once we have addition, it is straightforward to define multiplication as repeated addition, exponentiation as repeated multiplication, integer division and remainders, prime numbers, and so on. Thus, the whole of number theory (including cryptography) can be built up
from one constant, one function, one predicate and four axioms.
SET The domain of sets is also fundamental to mathematics as well as to commonsense
reasoning. (In fact, it is possible to define number theory in terms of set theory.) We want to
be able to represent individual sets, including the empty set. We need a way to build up sets
by adding an element to a set or taking the union or intersection of two sets. We will want
to know whether an element is a member of a set and we will want to distinguish sets from
objects that are not sets.
We will use the normal vocabulary of set theory as syntactic sugar. The empty set is a
constant written as { }. There is one unary predicate, Set, which is true of sets. The binary
predicates are x∈ s (x is a member of set s) and s1 ⊆ s2 (set s1 is a subset, not necessarily
proper, of set s2). The binary functions are s1 ∩ s2 (the intersection of two sets), s1 ∪ s2
(the union of two sets), and {x|s} (the set resulting from adjoining element x to set s). One
possible set of axioms is as follows:
1. The only sets are the empty set and those made by adjoining something to a set:
∀ s Set(s) ⇔ (s = { }) ∨ (∃ x, s2 Set(s2) ∧ s = {x|s2}) .
2. The empty set has no elements adjoined into it. In other words, there is no way to
decompose { } into a smaller set and an element:
¬∃ x, s {x|s} = { } .
3. Adjoining an element already in the set has no effect:
∀ x, s x∈ s ⇔ s = {x|s} .
4. The only members of a set are the elements that were adjoined into it. We express
this recursively, saying that x is a member of s if and only if s is equal to some set s2
adjoined with some element y, where either y is the same as x or x is a member of s2:
∀ x, s x∈ s ⇔ ∃ y, s2 (s = {y|s2} ∧ (x = y ∨ x∈ s2)) .
5. A set is a subset of another set if and only if all of the first set’s members are members
of the second set:
∀ s1, s2 s1 ⊆ s2 ⇔ (∀ x x∈ s1 ⇒ x∈ s2) .
6. Two sets are equal if and only if each is a subset of the other:
∀ s1, s2 (s1 = s2) ⇔ (s1 ⊆ s2 ∧ s2 ⊆ s1) .
Section 8.3. Using First-Order Logic 305
7. An object is in the intersection of two sets if and only if it is a member of both sets:
∀ x, s1, s2 x∈ (s1 ∩ s2) ⇔ (x∈ s1 ∧ x∈s2) .
8. An object is in the union of two sets if and only if it is a member of either set:
∀ x, s1, s2 x∈ (s1 ∪ s2) ⇔ (x∈ s1 ∨ x∈s2) .
LIST Lists are similar to sets. The differences are that lists are ordered and the same element can
appear more than once in a list. We can use the vocabulary of Lisp for lists: Nil is the constant
list with no elements; Cons, Append, First, and Rest are functions; and Find is the predicate that does for lists what Member does for sets. List? is a predicate that is true only of
lists. As with sets, it is common to use syntactic sugar in logical sentences involving lists. The
empty list is [ ]. The term Cons(x, y), where y is a nonempty list, is written [x|y]. The term
Cons(x, Nil) (i.e., the list containing the element x) is written as [x]. A list of several elements, such as [A, B, C], corresponds to the nested term Cons(A, Cons(B, Cons(C, Nil))).
Exercise 8.16 asks you to write out the axioms for lists.
8.3.4 The wumpus world
Some propositional logic axioms for the wumpus world were given in Chapter 7. The firstorder axioms in this section are much more concise, capturing in a natural way exactly what
we want to say.
Recall that the wumpus agent receives a percept vector with five elements. The corresponding first-order sentence stored in the knowledge base must include both the percept and
the time at which it occurred; otherwise, the agent will get confused about when it saw what.
We use integers for time steps. A typical percept sentence would be
Percept([Stench, Breeze, Glitter , None, None], 5) .
Here, Percept is a binary predicate, and Stench and so on are constants placed in a list. The
actions in the wumpus world can be represented by logical terms:
Turn(Right), Turn(Left), Forward, Shoot, Grab, Climb .
To determine which is best, the agent program executes the query
ASKVARS(∃ a BestAction(a, 5)) ,
which returns a binding list such as {a/Grab}. The agent program can then return Grab as
the action to take. The raw percept data implies certain facts about the current state. For
example:
∀ t, s, g, m, c Percept([s, Breeze, g, m, c], t) ⇒ Breeze(t) ,
∀ t, s, b, m, c Percept([s, b, Glitter , m, c], t) ⇒ Glitter(t) ,
and so on. These rules exhibit a trivial form of the reasoning process called perception, which
we study in depth in Chapter 24. Notice the quantification over time t. In propositional logic,
we would need copies of each sentence for each time step.
Simple “reflex” behavior can also be implemented by quantified implication sentences.
For example, we have
∀ t Glitter (t) ⇒ BestAction(Grab, t) .
306 Chapter 8. First-Order Logic
Given the percept and rules from the preceding paragraphs, this would yield the desired conclusion BestAction(Grab, 5)—that is, Grab is the right thing to do.
We have represented the agent’s inputs and outputs; now it is time to represent the
environment itself. Let us begin with objects. Obvious candidates are squares, pits, and the
wumpus. We could name each square—Square 1,2 and so on—but then the fact that Square1,2
and Square1,3 are adjacent would have to be an “extra” fact, and we would need one such
fact for each pair of squares. It is better to use a complex term in which the row and column
appear as integers; for example, we can simply use the list term [1, 2]. Adjacency of any two
squares can be defined as
∀ x, y, a, b Adjacent([x, y], [a, b]) ⇔
(x = a ∧ (y = b − 1 ∨ y = b + 1)) ∨ (y = b ∧ (x = a − 1 ∨ x = a + 1)) .
We could name each pit, but this would be inappropriate for a different reason: there is no
reason to distinguish among pits.10 It is simpler to use a unary predicate Pit that is true of
squares containing pits. Finally, since there is exactly one wumpus, a constant Wumpus is
just as good as a unary predicate (and perhaps more dignified from the wumpus’s viewpoint).
The agent’s location changes over time, so we write At(Agent, s, t) to mean that the
agent is at square s at time t. We can fix the wumpus’s location with ∀t At(Wumpus, [2, 2], t).
We can then say that objects can only be at one location at a time:
∀ x, s1, s2, t At(x, s1, t) ∧ At(x, s2, t) ⇒ s1 = s2 .
Given its current location, the agent can infer properties of the square from properties of its
current percept. For example, if the agent is at a square and perceives a breeze, then that
square is breezy:
∀ s, t At(Agent, s, t) ∧ Breeze(t) ⇒ Breezy(s) .
It is useful to know that a square is breezy because we know that the pits cannot move about.
Notice that Breezy has no time argument.
Having discovered which places are breezy (or smelly) and, very important, not breezy
(or not smelly), the agent can deduce where the pits are (and where the wumpus is). Whereas
propositional logic necessitates a separate axiom for each square (see R2 and R3 on page 247)
and would need a different set of axioms for each geographical layout of the world, first-order
logic just needs one axiom:
∀ s Breezy(s) ⇔ ∃ r Adjacent(r, s) ∧ Pit(r) . (8.4)
Similarly, in first-order logic we can quantify over time, so we need just one successor-state
axiom for each predicate, rather than a different copy for each time step. For example, the
axiom for the arrow (Equation (7.2) on page 267) becomes
∀ t HaveArrow(t + 1) ⇔ (HaveArrow(t) ∧ ¬Action(Shoot, t)) .
From these two example sentences, we can see that the first-order logic formulation is no
less concise than the original English-language description given in Chapter 7. The reader
10 Similarly, most of us do not name each bird that flies overhead as it migrates to warmer regions in winter. An
ornithologist wishing to study migration patterns, survival rates, and so on does name each bird, by means of a
ring on its leg, because individual birds must be tracked.
Section 8.4. Knowledge Engineering in First-Order Logic 307
is invited to construct analogous axioms for the agent’s location and orientation; in these
cases, the axioms quantify over both space and time. As in the case of propositional state
estimation, an agent can use logical inference with axioms of this kind to keep track of aspects
of the world that are not directly observed. Chapter 10 goes into more depth on the subject of
first-order successor-state axioms and their uses for constructing plans.
8.4 KNOWLEDGE ENGINEERING IN FIRST-ORDER LOGIC
The preceding section illustrated the use of first-order logic to represent knowledge in three
simple domains. This section describes the general process of knowledge-base construction—
a process called knowledge engineering. A knowledge engineer is someone who investigates KNOWLEDGE
ENGINEERING
a particular domain, learns what concepts are important in that domain, and creates a formal
representation of the objects and relations in the domain. We illustrate the knowledge engineering process in an electronic circuit domain that should already be fairly familiar, so that
we can concentrate on the representational issues involved. The approach we take is suitable
for developing special-purpose knowledge bases whose domain is carefully circumscribed
and whose range of queries is known in advance. General-purpose knowledge bases, which
cover a broad range of human knowledge and are intended to support tasks such as natural
language understanding, are discussed in Chapter 12.
8.4.1 The knowledge-engineering process
Knowledge engineering projects vary widely in content, scope, and difficulty, but all such
projects include the following steps:
1. Identify the task. The knowledge engineer must delineate the range of questions that
the knowledge base will support and the kinds of facts that will be available for each
specific problem instance. For example, does the wumpus knowledge base need to be
able to choose actions or is it required to answer questions only about the contents
of the environment? Will the sensor facts include the current location? The task will
determine what knowledge must be represented in order to connect problem instances to
answers. This step is analogous to the PEAS process for designing agents in Chapter 2.
2. Assemble the relevant knowledge. The knowledge engineer might already be an expert
in the domain, or might need to work with real experts to extract what they know—a
process called knowledge acquisition. At this stage, the knowledge is not represented KNOWLEDGE
ACQUISITION
formally. The idea is to understand the scope of the knowledge base, as determined by
the task, and to understand how the domain actually works.
For the wumpus world, which is defined by an artificial set of rules, the relevant
knowledge is easy to identify. (Notice, however, that the definition of adjacency was
not supplied explicitly in the wumpus-world rules.) For real domains, the issue of
relevance can be quite difficult—for example, a system for simulating VLSI designs
might or might not need to take into account stray capacitances and skin effects.
308 Chapter 8. First-Order Logic
3. Decide on a vocabulary of predicates, functions, and constants. That is, translate the
important domain-level concepts into logic-level names. This involves many questions
of knowledge-engineering style. Like programming style, this can have a significant
impact on the eventual success of the project. For example, should pits be represented
by objects or by a unary predicate on squares? Should the agent’s orientation be a
function or a predicate? Should the wumpus’s location depend on time? Once the
ONTOLOGY choices have been made, the result is a vocabulary that is known as the ontology of
the domain. The word ontology means a particular theory of the nature of being or
existence. The ontology determines what kinds of things exist, but does not determine
their specific properties and interrelationships.
4. Encode general knowledge about the domain. The knowledge engineer writes down
the axioms for all the vocabulary terms. This pins down (to the extent possible) the
meaning of the terms, enabling the expert to check the content. Often, this step reveals
misconceptions or gaps in the vocabulary that must be fixed by returning to step 3 and
iterating through the process.
5. Encode a description of the specific problem instance. If the ontology is well thought
out, this step will be easy. It will involve writing simple atomic sentences about instances of concepts that are already part of the ontology. For a logical agent, problem
instances are supplied by the sensors, whereas a “disembodied” knowledge base is supplied with additional sentences in the same way that traditional programs are supplied
with input data.
6. Pose queries to the inference procedure and get answers. This is where the reward is:
we can let the inference procedure operate on the axioms and problem-specific facts to
derive the facts we are interested in knowing. Thus, we avoid the need for writing an
application-specific solution algorithm.
7. Debug the knowledge base. Alas, the answers to queries will seldom be correct on
the first try. More precisely, the answers will be correct for the knowledge base as
written, assuming that the inference procedure is sound, but they will not be the ones
that the user is expecting. For example, if an axiom is missing, some queries will not be
answerable from the knowledge base. A considerable debugging process could ensue.
Missing axioms or axioms that are too weak can be easily identified by noticing places
where the chain of reasoning stops unexpectedly. For example, if the knowledge base
includes a diagnostic rule (see Exercise 8.13) for finding the wumpus,
∀ s Smelly(s) ⇒ Adjacent(Home(Wumpus), s) ,
instead of the biconditional, then the agent will never be able to prove the absence of
wumpuses. Incorrect axioms can be identified because they are false statements about
the world. For example, the sentence
∀ x NumOfLegs(x, 4) ⇒ Mammal(x)
is false for reptiles, amphibians, and, more importantly, tables. The falsehood of this
sentence can be determined independently of the rest of the knowledge base. In contrast,
Section 8.4. Knowledge Engineering in First-Order Logic 309
a typical error in a program looks like this:
offset = position + 1 .
It is impossible to tell whether this statement is correct without looking at the rest of the
program to see whether, for example, offset is used to refer to the current position,
or to one beyond the current position, or whether the value of position is changed
by another statement and so offset should also be changed again.
To understand this seven-step process better, we now apply it to an extended example—the
domain of electronic circuits.
8.4.2 The electronic circuits domain
We will develop an ontology and knowledge base that allow us to reason about digital circuits
of the kind shown in Figure 8.6. We follow the seven-step process for knowledge engineering.
Identify the task
There are many reasoning tasks associated with digital circuits. At the highest level, one
analyzes the circuit’s functionality. For example, does the circuit in Figure 8.6 actually add
properly? If all the inputs are high, what is the output of gate A2? Questions about the
circuit’s structure are also interesting. For example, what are all the gates connected to the
first input terminal? Does the circuit contain feedback loops? These will be our tasks in this
section. There are more detailed levels of analysis, including those related to timing delays,
circuit area, power consumption, production cost, and so on. Each of these levels would
require additional knowledge.
Assemble the relevant knowledge
What do we know about digital circuits? For our purposes, they are composed of wires and
gates. Signals flow along wires to the input terminals of gates, and each gate produces a
1
2
3
1
2
X1 X2
A1
A2
O1
C1
Figure 8.6 A digital circuit C1, purporting to be a one-bit full adder. The first two inputs
are the two bits to be added, and the third input is a carry bit. The first output is the sum, and
the second output is a carry bit for the next adder. The circuit contains two XOR gates, two
AND gates, and one OR gate.
310 Chapter 8. First-Order Logic
signal on the output terminal that flows along another wire. To determine what these signals
will be, we need to know how the gates transform their input signals. There are four types
of gates: AND, OR, and XOR gates have two input terminals, and NOT gates have one. All
gates have one output terminal. Circuits, like gates, have input and output terminals.
To reason about functionality and connectivity, we do not need to talk about the wires
themselves, the paths they take, or the junctions where they come together. All that matters
is the connections between terminals—we can say that one output terminal is connected to
another input terminal without having to say what actually connects them. Other factors such
as the size, shape, color, or cost of the various components are irrelevant to our analysis.
If our purpose were something other than verifying designs at the gate level, the ontology would be different. For example, if we were interested in debugging faulty circuits, then
it would probably be a good idea to include the wires in the ontology, because a faulty wire
can corrupt the signal flowing along it. For resolving timing faults, we would need to include
gate delays. If we were interested in designing a product that would be profitable, then the
cost of the circuit and its speed relative to other products on the market would be important.
Decide on a vocabulary
We now know that we want to talk about circuits, terminals, signals, and gates. The next step
is to choose functions, predicates, and constants to represent them. First, we need to be able
to distinguish gates from each other and from other objects. Each gate is represented as an
object named by a constant, about which we assert that it is a gate with, say, Gate(X1). The
behavior of each gate is determined by its type: one of the constants AND, OR, XOR, or
NOT. Because a gate has exactly one type, a function is appropriate: Type(X1) = XOR.
Circuits, like gates, are identified by a predicate: Circuit(C1).
Next we consider terminals, which are identified by the predicate Terminal(x). A gate
or circuit can have one or more input terminals and one or more output terminals. We use the
function In(1, X1) to denote the first input terminal for gate X1. A similar function Out is
used for output terminals. The function Arity(c, i, j) says that circuit c has i input and j output terminals. The connectivity between gates can be represented by a predicate, Connected,
which takes two terminals as arguments, as in Connected(Out(1, X1),In(1, X2)).
Finally, we need to know whether a signal is on or off. One possibility is to use a unary
predicate, On(t), which is true when the signal at a terminal is on. This makes it a little
difficult, however, to pose questions such as “What are all the possible values of the signals
at the output terminals of circuit C1 ?” We therefore introduce as objects two signal values, 1
and 0, and a function Signal(t) that denotes the signal value for the terminal t.
Encode general knowledge of the domain
One sign that we have a good ontology is that we require only a few general rules, which can
be stated clearly and concisely. These are all the axioms we will need:
1. If two terminals are connected, then they have the same signal:
∀ t1, t2 Terminal(t1) ∧ Terminal(t2) ∧ Connected(t1, t2) ⇒
Signal(t1) = Signal(t2) .
Section 8.4. Knowledge Engineering in First-Order Logic 311
2. The signal at every terminal is either 1 or 0:
∀ t Terminal(t) ⇒ Signal(t)=1 ∨ Signal(t)=0 .
3. Connected is commutative:
∀ t1, t2 Connected(t1, t2) ⇔ Connected(t2, t1) .
4. There are four types of gates:
∀ g Gate(g) ∧ k = Type(g) ⇒ k = AND ∨ k = OR ∨ k = XOR ∨ k = NOT .
5. An AND gate’s output is 0 if and only if any of its inputs is 0:
∀ g Gate(g) ∧ Type(g) = AND ⇒
Signal(Out(1, g)) = 0 ⇔ ∃ n Signal(In(n, g)) = 0 .
6. An OR gate’s output is 1 if and only if any of its inputs is 1:
∀ g Gate(g) ∧ Type(g) = OR ⇒
Signal(Out(1, g)) = 1 ⇔ ∃ n Signal(In(n, g)) = 1 .
7. An XOR gate’s output is 1 if and only if its inputs are different:
∀ g Gate(g) ∧ Type(g) = XOR ⇒
Signal(Out(1, g)) = 1 ⇔ Signal(In(1, g)) = Signal(In(2, g)) .
8. A NOT gate’s output is different from its input:
∀ g Gate(g) ∧ (Type(g) = NOT) ⇒
Signal(Out(1, g)) = Signal(In(1, g)) .
9. The gates (except for NOT) have two inputs and one output.
∀ g Gate(g) ∧ Type(g) = NOT ⇒ Arity(g, 1, 1) .
∀ g Gate(g) ∧ k = Type(g) ∧ (k = AND ∨ k = OR ∨ k = XOR) ⇒
Arity(g, 2, 1)
10. A circuit has terminals, up to its input and output arity, and nothing beyond its arity:
∀ c, i, j Circuit(c) ∧ Arity(c, i, j) ⇒
∀ n (n ≤ i ⇒ Terminal(In(c, n))) ∧ (n>i ⇒ In(c, n) = Nothing) ∧
∀ n (n ≤ j ⇒ Terminal(Out(c, n))) ∧ (n>j ⇒ Out(c, n) = Nothing)
11. Gates, terminals, signals, gate types, and Nothing are all distinct.
∀ g, t Gate(g) ∧ Terminal(t) ⇒
g = t = 1 = 0 = OR = AND = XOR = NOT = Nothing .
12. Gates are circuits.
∀ g Gate(g) ⇒ Circuit(g)
Encode the specific problem instance
The circuit shown in Figure 8.6 is encoded as circuit C1 with the following description. First,
we categorize the circuit and its component gates:
Circuit(C1) ∧ Arity(C1, 3, 2)
Gate(X1) ∧ Type(X1) = XOR
Gate(X2) ∧ Type(X2) = XOR
Gate(A1) ∧ Type(A1) = AND
Gate(A2) ∧ Type(A2) = AND
Gate(O1) ∧ Type(O1) = OR .
312 Chapter 8. First-Order Logic
Then, we show the connections between them:
Connected(Out(1, X1),In(1, X2)) Connected(In(1, C1),In(1, X1))
Connected(Out(1, X1),In(2, A2)) Connected(In(1, C1),In(1, A1))
Connected(Out(1, A2),In(1, O1)) Connected(In(2, C1),In(2, X1))
Connected(Out(1, A1),In(2, O1)) Connected(In(2, C1),In(2, A1))
Connected(Out(1, X2), Out(1, C1)) Connected(In(3, C1),In(2, X2))
Connected(Out(1, O1), Out(2, C1)) Connected(In(3, C1),In(1, A2)) .
Pose queries to the inference procedure
What combinations of inputs would cause the first output of C1 (the sum bit) to be 0 and the
second output of C1 (the carry bit) to be 1?
∃ i1, i2, i3 Signal(In(1, C1)) = i1 ∧ Signal(In(2, C1)) = i2 ∧ Signal(In(3, C1)) = i3
∧ Signal(Out(1, C1)) = 0 ∧ Signal(Out(2, C1)) = 1 .
The answers are substitutions for the variables i1, i2, and i3 such that the resulting sentence
is entailed by the knowledge base. ASKVARS will give us three such substitutions:
{i1/1, i2/1, i3/0} {i1/1, i2/0, i3/1} {i1/0, i2/1, i3/1} .
What are the possible sets of values of all the terminals for the adder circuit?
∃ i1, i2, i3, o1, o2 Signal(In(1, C1)) = i1 ∧ Signal(In(2, C1)) = i2
∧ Signal(In(3, C1)) = i3 ∧ Signal(Out(1, C1)) = o1 ∧ Signal(Out(2, C1)) = o2 .
This final query will return a complete input–output table for the device, which can be used
to check that it does in fact add its inputs correctly. This is a simple example of circuit
verification. We can also use the definition of the circuit to build larger digital systems, for CIRCUIT
VERIFICATION
which the same kind of verification procedure can be carried out. (See Exercise 8.26.) Many
domains are amenable to the same kind of structured knowledge-base development, in which
more complex concepts are defined on top of simpler concepts.
Debug the knowledge base
We can perturb the knowledge base in various ways to see what kinds of erroneous behaviors
emerge. For example, suppose we fail to read Section 8.2.8 and hence forget to assert that
1 = 0. Suddenly, the system will be unable to prove any outputs for the circuit, except for
the input cases 000 and 110. We can pinpoint the problem by asking for the outputs of each
gate. For example, we can ask
∃ i1, i2, o Signal(In(1, C1)) = i1 ∧ Signal(In(2, C1)) = i2 ∧ Signal(Out(1, X1)) ,
which reveals that no outputs are known at X1 for the input cases 10 and 01. Then, we look
at the axiom for XOR gates, as applied to X1:
Signal(Out(1, X1)) = 1 ⇔ Signal(In(1, X1)) = Signal(In(2, X1)) .
If the inputs are known to be, say, 1 and 0, then this reduces to
Signal(Out(1, X1)) = 1 ⇔ 1 = 0 .
Now the problem is apparent: the system is unable to infer that Signal(Out(1, X1)) = 1, so
we need to tell it that 1 = 0.
Section 8.5. Summary 313
8.5 SUMMARY
This chapter has introduced first-order logic, a representation language that is far more powerful than propositional logic. The important points are as follows:
• Knowledge representation languages should be declarative, compositional, expressive,
context independent, and unambiguous.
• Logics differ in their ontological commitments and epistemological commitments.
While propositional logic commits only to the existence of facts, first-order logic commits to the existence of objects and relations and thereby gains expressive power.
• The syntax of first-order logic builds on that of propositional logic. It adds terms to
represent objects, and has universal and existential quantifiers to construct assertions
about all or some of the possible values of the quantified variables.
• A possible world, or model, for first-order logic includes a set of objects and an interpretation that maps constant symbols to objects, predicate symbols to relations among
objects, and function symbols to functions on objects.
• An atomic sentence is true just when the relation named by the predicate holds between
the objects named by the terms. Extended interpretations, which map quantifier variables to objects in the model, define the truth of quantified sentences.
• Developing a knowledge base in first-order logic requires a careful process of analyzing
the domain, choosing a vocabulary, and encoding the axioms required to support the
desired inferences.
BIBLIOGRAPHICAL AND HISTORICAL NOTES
Although Aristotle’s logic deals with generalizations over objects, it fell far short of the expressive power of first-order logic. A major barrier to its further development was its concentration on one-place predicates to the exclusion of many-place relational predicates. The first
systematic treatment of relations was given by Augustus De Morgan (1864), who cited the
following example to show the sorts of inferences that Aristotle’s logic could not handle: “All
horses are animals; therefore, the head of a horse is the head of an animal.” This inference
is inaccessible to Aristotle because any valid rule that can support this inference must first
analyze the sentence using the two-place predicate “x is the head of y.” The logic of relations
was studied in depth by Charles Sanders Peirce (1870, 2004).
True first-order logic dates from the introduction of quantifiers in Gottlob Frege’s (1879)
Begriffschrift (“Concept Writing” or “Conceptual Notation”). Peirce (1883) also developed
first-order logic independently of Frege, although slightly later. Frege’s ability to nest quantifiers was a big step forward, but he used an awkward notation. The present notation for
first-order logic is due substantially to Giuseppe Peano (1889), but the semantics is virtually
identical to Frege’s. Oddly enough, Peano’s axioms were due in large measure to Grassmann
(1861) and Dedekind (1888).
314 Chapter 8. First-Order Logic
Leopold L¨owenheim (1915) gave a systematic treatment of model theory for first-order
logic, including the first proper treatment of the equality symbol. L¨owenheim’s results were
further extended by Thoralf Skolem (1920). Alfred Tarski (1935, 1956) gave an explicit
definition of truth and model-theoretic satisfaction in first-order logic, using set theory.
McCarthy (1958) was primarily responsible for the introduction of first-order logic as a
tool for building AI systems. The prospects for logic-based AI were advanced significantly by
Robinson’s (1965) development of resolution, a complete procedure for first-order inference
described in Chapter 9. The logicist approach took root at Stanford University. Cordell Green
(1969a, 1969b) developed a first-order reasoning system, QA3, leading to the first attempts to
build a logical robot at SRI (Fikes and Nilsson, 1971). First-order logic was applied by Zohar
Manna and Richard Waldinger (1971) for reasoning about programs and later by Michael
Genesereth (1984) for reasoning about circuits. In Europe, logic programming (a restricted
form of first-order reasoning) was developed for linguistic analysis (Colmerauer et al., 1973)
and for general declarative systems (Kowalski, 1974). Computational logic was also well
entrenched at Edinburgh through the LCF (Logic for Computable Functions) project (Gordon
et al., 1979). These developments are chronicled further in Chapters 9 and 12.
Practical applications built with first-order logic include a system for evaluating the
manufacturing requirements for electronic products (Mannion, 2002), a system for reasoning
about policies for file access and digital rights management (Halpern and Weissman, 2008),
and a system for the automated composition of Web services (McIlraith and Zeng, 2001).
Reactions to the Whorf hypothesis (Whorf, 1956) and the problem of language and
thought in general, appear in several recent books (Gumperz and Levinson, 1996; Bowerman
and Levinson, 2001; Pinker, 2003; Gentner and Goldin-Meadow, 2003). The “theory” theory
(Gopnik and Glymour, 2002; Tenenbaum et al., 2007) views children’s learning about the
world as analogous to the construction of scientific theories. Just as the predictions of a
machine learning algorithm depend strongly on the vocabulary supplied to it, so will the
child’s formulation of theories depend on the linguistic environment in which learning occurs.
There are a number of good introductory texts on first-order logic, including some by
leading figures in the history of logic: Alfred Tarski (1941), Alonzo Church (1956), and
W.V. Quine (1982) (which is one of the most readable). Enderton (1972) gives a more mathematically oriented perspective. A highly formal treatment of first-order logic, along with
many more advanced topics in logic, is provided by Bell and Machover (1977). Manna and
Waldinger (1985) give a readable introduction to logic from a computer science perspective, as do Huth and Ryan (2004), who concentrate on program verification. Barwise and
Etchemendy (2002) take an approach similar to the one used here. Smullyan (1995) presents
results concisely, using the tableau format. Gallier (1986) provides an extremely rigorous
mathematical exposition of first-order logic, along with a great deal of material on its use in
automated reasoning. Logical Foundations of Artificial Intelligence (Genesereth and Nilsson,
1987) is both a solid introduction to logic and the first systematic treatment of logical agents
with percepts and actions, and there are two good handbooks: van Bentham and ter Meulen
(1997) and Robinson and Voronkov (2001). The journal of record for the field of pure mathematical logic is the Journal of Symbolic Logic, whereas the Journal of Applied Logic deals
with concerns closer to those of artificial intelligence.
Exercises 315
EXERCISES
8.1 A logical knowledge base represents the world using a set of sentences with no explicit
structure. An analogical representation, on the other hand, has physical structure that corresponds directly to the structure of the thing represented. Consider a road map of your country
as an analogical representation of facts about the country—it represents facts with a map language. The two-dimensional structure of the map corresponds to the two-dimensional surface
of the area.
a. Give five examples of symbols in the map language.
b. An explicit sentence is a sentence that the creator of the representation actually writes
down. An implicit sentence is a sentence that results from explicit sentences because
of properties of the analogical representation. Give three examples each of implicit and
explicit sentences in the map language.
c. Give three examples of facts about the physical structure of your country that cannot be
represented in the map language.
d. Give two examples of facts that are much easier to express in the map language than in
first-order logic.
e. Give two other examples of useful analogical representations. What are the advantages
and disadvantages of each of these languages?
8.2 Consider a knowledge base containing just two sentences: P(a) and P(b). Does this
knowledge base entail ∀ x P(x)? Explain your answer in terms of models.
8.3 Is the sentence ∃ x, y x = y valid? Explain.
8.4 Write down a logical sentence such that every world in which it is true contains exactly
one object.
8.5 Consider a symbol vocabulary that contains c constant symbols, pk predicate symbols
of each arity k, and fk function symbols of each arity k, where 1 ≤ k ≤ A. Let the domain
size be fixed at D. For any given model, each predicate or function symbol is mapped onto a
relation or function, respectively, of the same arity. You may assume that the functions in the
model allow some input tuples to have no value for the function (i.e., the value is the invisible
object). Derive a formula for the number of possible models for a domain with D elements.
Don’t worry about eliminating redundant combinations.
8.6 Which of the following are valid (necessarily true) sentences?
a. (∃x x = x) ⇒ (∀ y ∃z y = z).
b. ∀ x P(x) ∨ ¬P(x).
c. ∀ x Smart(x) ∨ (x = x).
8.7 Consider a version of the semantics for first-order logic in which models with empty
domains are allowed. Give at least two examples of sentences that are valid according to the
316 Chapter 8. First-Order Logic
standard semantics but not according to the new semantics. Discuss which outcome makes
more intuitive sense for your examples.
8.8 Does the fact ¬Spouse(George, Laura) follow from the facts Jim = George and
Spouse(Jim, Laura)? If so, give a proof; if not, supply additional axioms as needed. What
happens if we use Spouse as a unary function symbol instead of a binary predicate?
8.9 This exercise uses the function MapColor and predicates In(x, y), Borders (x, y), and
Country(x), whose arguments are geographical regions, along with constant symbols for
various regions. In each of the following we give an English sentence and a number of candidate logical expressions. For each of the logical expressions, state whether it (1) correctly
expresses the English sentence; (2) is syntactically invalid and therefore meaningless; or (3)
is syntactically valid but does not express the meaning of the English sentence.
a. Paris and Marseilles are both in France.
(i) In(Paris ∧ Marseilles,France).
(ii) In(Paris,France) ∧ In(Marseilles,France).
(iii) In(Paris,France) ∨ In(Marseilles,France).
b. There is a country that borders both Iraq and Pakistan.
(i) ∃ c Country(c) ∧ Border (c,Iraq) ∧ Border (c,Pakistan).
(ii) ∃ c Country(c) ⇒ [Border (c,Iraq) ∧ Border (c,Pakistan)].
(iii) [∃ c Country(c)] ⇒ [Border (c,Iraq) ∧ Border (c,Pakistan)].
(iv) ∃ c Border (Country(c),Iraq ∧ Pakistan).
c. All countries that border Ecuador are in South America.
(i) ∀ c Country(c) ∧ Border (c,Ecuador ) ⇒ In(c, SouthAmerica).
(ii) ∀ c Country(c) ⇒ [Border (c,Ecuador ) ⇒ In(c, SouthAmerica)].
(iii) ∀ c [Country(c) ⇒ Border (c,Ecuador )] ⇒ In(c, SouthAmerica).
(iv) ∀ c Country(c) ∧ Border (c,Ecuador ) ∧ In(c, SouthAmerica).
d. No region in South America borders any region in Europe.
(i) ¬[∃ c, d In(c, SouthAmerica) ∧ In(d,Europe) ∧ Borders(c, d)].
(ii) ∀ c, d [In(c, SouthAmerica) ∧ In(d,Europe)] ⇒ ¬Borders(c, d)].
(iii) ¬∀ c In(c, SouthAmerica) ⇒ ∃ d In(d,Europe) ∧ ¬Borders(c, d).
(iv) ∀ c In(c, SouthAmerica) ⇒ ∀ d In(d,Europe) ⇒ ¬Borders(c, d).
e. No two adjacent countries have the same map color.
(i) ∀ x, y ¬Country(x) ∨ ¬Country(y) ∨ ¬Borders(x, y) ∨
¬(MapColor (x) = MapColor (y)).
(ii) ∀ x, y (Country(x) ∧ Country(y) ∧ Borders (x, y) ∧ ¬(x = y)) ⇒
¬(MapColor (x) = MapColor (y)).
(iii) ∀ x, y Country(x) ∧ Country(y) ∧ Borders(x, y) ∧
¬(MapColor (x) = MapColor (y)).
(iv) ∀ x, y (Country(x) ∧ Country(y) ∧ Borders (x, y)) ⇒ MapColor (x = y).
Exercises 317
8.10 Consider a vocabulary with the following symbols:
Occupation(p, o): Predicate. Person p has occupation o.
Customer (p1, p2): Predicate. Person p1 is a customer of person p2.
Boss(p1, p2): Predicate. Person p1 is a boss of person p2.
Doctor , Surgeon, Lawyer , Actor : Constants denoting occupations.
Emily, Joe: Constants denoting people.
Use these symbols to write the following assertions in first-order logic:
a. Emily is either a surgeon or a lawyer.
b. Joe is an actor, but he also holds another job.
c. All surgeons are doctors.
d. Joe does not have a lawyer (i.e., is not a customer of any lawyer).
e. Emily has a boss who is a lawyer.
f. There exists a lawyer all of whose customers are doctors.
g. Every surgeon has a lawyer.
8.11 Complete the following exercises about logical senntences:
a. Translate into good, natural English (no xs or ys!):
∀ x, y, l SpeaksLanguage(x, l) ∧ SpeaksLanguage(y,l)
⇒ Understands (x, y) ∧ Understands(y, x).
b. Explain why this sentence is entailed by the sentence
∀ x, y, l SpeaksLanguage(x, l) ∧ SpeaksLanguage(y,l)
⇒ Understands (x, y).
c. Translate into first-order logic the following sentences:
(i) Understanding leads to friendship.
(ii) Friendship is transitive.
Remember to define all predicates, functions, and constants you use.
8.12 Rewrite the first two Peano axioms in Section 8.3.3 as a single axiom that defines
NatNum(x) so as to exclude the possibility of natural numbers except for those generated by
the successor function.
8.13 Equation (8.4) on page 306 defines the conditions under which a square is breezy. Here
we consider two other ways to describe this aspect of the wumpus world.
DIAGNOSTIC RULE a. We can write diagnostic rules leading from observed effects to hidden causes. For finding pits, the obvious diagnostic rules say that if a square is breezy, some adjacent square
must contain a pit; and if a square is not breezy, then no adjacent square contains a pit.
Write these two rules in first-order logic and show that their conjunction is logically
equivalent to Equation (8.4).
CAUSAL RULE b. We can write causal rules leading from cause to effect. One obvious causal rule is that
a pit causes all adjacent squares to be breezy. Write this rule in first-order logic, explain
why it is incomplete compared to Equation (8.4), and supply the missing axiom.
318 Chapter 8. First-Order Logic
Beatrice
Andrew
William Harry Eugenie
Diana Charles
George Mum
Spencer Kydd Elizabeth Philip Margaret
Peter
Mark
Zara
Anne Sarah Edward Sophie
Louise James
Figure 8.7 A typical family tree. The symbol “
” connects spouses and arrows point to
children.
8.14 Write axioms describing the predicates Grandchild, Greatgrandparent, Ancestor ,
Brother , Sister, Daughter , Son, FirstCousin, BrotherInLaw, SisterInLaw, Aunt, and
Uncle. Find out the proper definition of mth cousin n times removed, and write the definition in first-order logic. Now write down the basic facts depicted in the family tree in
Figure 8.7. Using a suitable logical reasoning system, TELL it all the sentences you have
written down, and ASK it who are Elizabeth’s grandchildren, Diana’s brothers-in-law, Zara’s
great-grandparents, and Eugenie’s ancestors.
8.15 Explain what is wrong with the following proposed definition of the set membership
predicate ∈ :
∀ x, s x∈ {x|s}
∀ x, s x∈ s ⇒ ∀ y x∈ {y|s} .
8.16 Using the set axioms as examples, write axioms for the list domain, including all the
constants, functions, and predicates mentioned in the chapter.
8.17 Explain what is wrong with the following proposed definition of adjacent squares in
the wumpus world:
∀ x, y Adjacent([x, y], [x + 1, y]) ∧ Adjacent([x, y], [x, y + 1]) .
8.18 Write out the axioms required for reasoning about the wumpus’s location, using a
constant symbol Wumpus and a binary predicate At(Wumpus, Location). Remember that
there is only one wumpus.
8.19 Assuming predicates Parent(p, q) and Female(p) and constants Joan and Kevin,
with the obvious meanings, express each of the following sentences in first-order logic. (You
may use the abbreviation ∃1 to mean “there exists exactly one.”)
a. Joan has a daughter (possibly more than one, and possibly sons as well).
b. Joan has exactly one daughter (but may have sons as well).
c. Joan has exactly one child, a daughter.
d. Joan and Kevin have exactly one child together.
e. Joan has at least one child with Kevin, and no children with anyone else.
Exercises 319
8.20 Arithmetic assertions can be written in first-order logic with the predicate symbol <,
the function symbols + and ×, and the constant symbols 0 and 1. Additional predicates can
also be defined with biconditionals.
a. Represent the property “x is an even number.”
b. Represent the property “x is prime.”
c. Goldbach’s conjecture is the conjecture (unproven as yet) that every even number is
equal to the sum of two primes. Represent this conjecture as a logical sentence.
8.21 In Chapter 6, we used equality to indicate the relation between a variable and its value.
For instance, we wrote WA = red to mean that Western Australia is colored red. Representing this in first-order logic, we must write more verbosely ColorOf (WA) = red. What
incorrect inference could be drawn if we wrote sentences such as WA = red directly as logical
assertions?
8.22 Write in first-order logic the assertion that every key and at least one of every pair of
socks will eventually be lost forever, using only the following vocabulary: Key(x), x is a key;
Sock(x), x is a sock; Pair (x, y), x and y are a pair; Now, the current time; Before(t1, t2),
time t1 comes before time t2; Lost(x, t), object x is lost at time t.
8.23 For each of the following sentences in English, decide if the accompanying first-order
logic sentence is a good translation. If not, explain why not and correct it. (Some sentences
may have more than one error!)
a. No two people have the same social security number.
¬∃ x, y, n Person(x) ∧ Person(y) ⇒ [HasSS#(x, n) ∧ HasSS#(y, n)].
b. John’s social security number is the same as Mary’s.
∃ n HasSS#(John, n) ∧ HasSS#(Mary, n).
c. Everyone’s social security number has nine digits.
∀ x, n Person(x) ⇒ [HasSS#(x, n) ∧ Digits(n, 9)].
d. Rewrite each of the above (uncorrected) sentences using a function symbol SS# instead
of the predicate HasSS#.
8.24 Represent the following sentences in first-order logic, using a consistent vocabulary
(which you must define):
a. Some students took French in spring 2001.
b. Every student who takes French passes it.
c. Only one student took Greek in spring 2001.
d. The best score in Greek is always higher than the best score in French.
e. Every person who buys a policy is smart.
f. No person buys an expensive policy.
g. There is an agent who sells policies only to people who are not insured.
320 Chapter 8. First-Order Logic
Z0
Z1
Z2
Z3
Z4
X0
Y0
X1
Y1
X2
Y2
X3
Y3
Ad0
Ad1
Ad2
Ad3
X3 X2 X1 X0
Z4 Z3 Z2 Z1 Z0
+ Y3 Y2 Y1 Y0
Figure 8.8 A four-bit adder. Each Adi is a one-bit adder, as in Figure 8.6 on page 309.
h. There is a barber who shaves all men in town who do not shave themselves.
i. A person born in the UK, each of whose parents is a UK citizen or a UK resident, is a
UK citizen by birth.
j. A person born outside the UK, one of whose parents is a UK citizen by birth, is a UK
citizen by descent.
k. Politicians can fool some of the people all of the time, and they can fool all of the people
some of the time, but they can’t fool all of the people all of the time.
l. All Greeks speak the same language. (Use Speaks(x, l) to mean that person x speaks
language l.)
8.25 Write a general set of facts and axioms to represent the assertion “Wellington heard
about Napoleon’s death” and to correctly answer the question “Did Napoleon hear about
Wellington’s death?”
8.26 Extend the vocabulary from Section 8.4 to define addition for n-bit binary numbers.
Then encode the description of the four-bit adder in Figure 8.8, and pose the queries needed
to verify that it is in fact correct.
8.27 Obtain a passport application for your country, identify the rules determining eligibility for a passport, and translate them into first-order logic, following the steps outlined in
Section 8.4.
8.28 Consider a first-order logical knowledge base that describes worlds containing people,
songs, albums (e.g., “Meet the Beatles”) and disks (i.e., particular physical instances of CDs).
The vocabulary contains the following symbols:
CopyOf (d, a): Predicate. Disk d is a copy of album a.
Owns(p, d): Predicate. Person p owns disk d.
Sings(p, s, a): Album a includes a recording of song s sung by person p.
Wrote(p, s): Person p wrote song s.
McCartney, Gershwin, BHoliday, Joe, EleanorRigby, TheManILove, Revolver :
Constants with the obvious meanings.
Exercises 321
Express the following statements in first-order logic:
a. Gershwin wrote “The Man I Love.”
b. Gershwin did not write “Eleanor Rigby.”
c. Either Gershwin or McCartney wrote “The Man I Love.”
d. Joe has written at least one song.
e. Joe owns a copy of Revolver.
f. Every song that McCartney sings on Revolver was written by McCartney.
g. Gershwin did not write any of the songs on Revolver.
h. Every song that Gershwin wrote has been recorded on some album. (Possibly different
songs are recorded on different albums.)
i. There is a single album that contains every song that Joe has written.
j. Joe owns a copy of an album that has Billie Holiday singing “The Man I Love.”
k. Joe owns a copy of every album that has a song sung by McCartney. (Of course, each
different album is instantiated in a different physical CD.)
l. Joe owns a copy of every album on which all the songs are sung by Billie Holiday.
9 INFERENCE IN
FIRST-ORDER LOGIC
In which we define effective procedures for answering questions posed in firstorder logic.
Chapter 7 showed how sound and complete inference can be achieved for propositional logic.
In this chapter, we extend those results to obtain algorithms that can answer any answerable question stated in first-order logic. Section 9.1 introduces inference rules for quantifiers
and shows how to reduce first-order inference to propositional inference, albeit at potentially
great expense. Section 9.2 describes the idea of unification, showing how it can be used
to construct inference rules that work directly with first-order sentences. We then discuss
three major families of first-order inference algorithms. Forward chaining and its applications to deductive databases and production systems are covered in Section 9.3; backward
chaining and logic programming systems are developed in Section 9.4. Forward and backward chaining can be very efficient, but are applicable only to knowledge bases that can
be expressed as sets of Horn clauses. General first-order sentences require resolution-based
theorem proving, which is described in Section 9.5.
9.1 PROPOSITIONAL VS. FIRST-ORDER INFERENCE
This section and the next introduce the ideas underlying modern logical inference systems.
We begin with some simple inference rules that can be applied to sentences with quantifiers
to obtain sentences without quantifiers. These rules lead naturally to the idea that first-order
inference can be done by converting the knowledge base to propositional logic and using
propositional inference, which we already know how to do. The next section points out an
obvious shortcut, leading to inference methods that manipulate first-order sentences directly.
9.1.1 Inference rules for quantifiers
Let us begin with universal quantifiers. Suppose our knowledge base contains the standard
folkloric axiom stating that all greedy kings are evil:
∀ x King(x) ∧ Greedy(x) ⇒ Evil(x) .
322
Section 9.1. Propositional vs. First-Order Inference 323
Then it seems quite permissible to infer any of the following sentences:
King(John) ∧ Greedy(John) ⇒ Evil(John)
King(Richard) ∧ Greedy(Richard) ⇒ Evil(Richard)
King(Father (John)) ∧ Greedy(Father (John)) ⇒ Evil(Father (John)) .
.
.
.
The rule of Universal Instantiation (UI for short) says that we can infer any sentence ob- UNIVERSAL
INSTANTIATION
tained by substituting a ground term (a term without variables) for the variable.1 GROUND TERM To write
out the inference rule formally, we use the notion of substitutions introduced in Section 8.3.
Let SUBST(θ,α) denote the result of applying the substitution θ to the sentence α. Then the
rule is written
∀ v α
SUBST({v/g}, α)
for any variable v and ground term g. For example, the three sentences given earlier are
obtained with the substitutions {x/John}, {x/Richard}, and {x/Father (John)}.
In the rule for Existential Instantiation, the variable is replaced by a single new con- EXISTENTIAL
INSTANTIATION
stant symbol. The formal statement is as follows: for any sentence α, variable v, and constant
symbol k that does not appear elsewhere in the knowledge base,
∃ v α
SUBST({v/k}, α) .
For example, from the sentence
∃ x Crown(x) ∧ OnHead(x, John)
we can infer the sentence
Crown(C1) ∧ OnHead(C1, John)
as long as C1 does not appear elsewhere in the knowledge base. Basically, the existential
sentence says there is some object satisfying a condition, and applying the existential instantiation rule just gives a name to that object. Of course, that name must not already belong
to another object. Mathematics provides a nice example: suppose we discover that there is a
number that is a little bigger than 2.71828 and that satisfies the equation d(xy)/dy = xy for x.
We can give this number a name, such as e, but it would be a mistake to give it the name of
SKOLEM CONSTANT an existing object, such as π. In logic, the new name is called a Skolem constant. Existential Instantiation is a special case of a more general process called skolemization, which we
cover in Section 9.5.
Whereas Universal Instantiation can be applied many times to produce many different
consequences, Existential Instantiation can be applied once, and then the existentially quantified sentence can be discarded. For example, we no longer need ∃ x Kill(x, Victim) once
we have added the sentence Kill(Murderer , Victim). Strictly speaking, the new knowledge
base is not logically equivalent to the old, but it can be shown to be inferentially equivalent INFERENTIAL
EQUIVALENCE
in the sense that it is satisfiable exactly when the original knowledge base is satisfiable.
1 Do not confuse these substitutions with the extended interpretations used to define the semantics of quantifiers.
The substitution replaces a variable with a term (a piece of syntax) to produce a new sentence, whereas an
interpretation maps a variable to an object in the domain.
324 Chapter 9. Inference in First-Order Logic
9.1.2 Reduction to propositional inference
Once we have rules for inferring nonquantified sentences from quantified sentences, it becomes possible to reduce first-order inference to propositional inference. In this section we
give the main ideas; the details are given in Section 9.5.
The first idea is that, just as an existentially quantified sentence can be replaced by
one instantiation, a universally quantified sentence can be replaced by the set of all possible
instantiations. For example, suppose our knowledge base contains just the sentences
∀ x King(x) ∧ Greedy(x) ⇒ Evil(x)
King(John)
Greedy(John)
Brother (Richard, John) .
(9.1)
Then we apply UI to the first sentence using all possible ground-term substitutions from the
vocabulary of the knowledge base—in this case, {x/John} and {x/Richard}. We obtain
King(John) ∧ Greedy(John) ⇒ Evil(John)
King(Richard) ∧ Greedy(Richard) ⇒ Evil(Richard) ,
and we discard the universally quantified sentence. Now, the knowledge base is essentially
propositional if we view the ground atomic sentences—King (John), Greedy(John), and
so on—as proposition symbols. Therefore, we can apply any of the complete propositional
algorithms in Chapter 7 to obtain conclusions such as Evil(John).
This technique of propositionalization can be made completely general, as we show
in Section 9.5; that is, every first-order knowledge base and query can be propositionalized
in such a way that entailment is preserved. Thus, we have a complete decision procedure
for entailment ... or perhaps not. There is a problem: when the knowledge base includes
a function symbol, the set of possible ground-term substitutions is infinite! For example, if
the knowledge base mentions the Father symbol, then infinitely many nested terms such as
Father (Father (Father (John))) can be constructed. Our propositional algorithms will have
difficulty with an infinitely large set of sentences.
Fortunately, there is a famous theorem due to Jacques Herbrand (1930) to the effect
that if a sentence is entailed by the original, first-order knowledge base, then there is a proof
involving just a finite subset of the propositionalized knowledge base. Since any such subset
has a maximum depth of nesting among its ground terms, we can find the subset by first
generating all the instantiations with constant symbols (Richard and John), then all terms of
depth 1 (Father (Richard) and Father (John)), then all terms of depth 2, and so on, until we
are able to construct a propositional proof of the entailed sentence.
We have sketched an approach to first-order inference via propositionalization that is
complete—that is, any entailed sentence can be proved. This is a major achievement, given
that the space of possible models is infinite. On the other hand, we do not know until the
proof is done that the sentence is entailed! What happens when the sentence is not entailed?
Can we tell? Well, for first-order logic, it turns out that we cannot. Our proof procedure can
go on and on, generating more and more deeply nested terms, but we will not know whether
it is stuck in a hopeless loop or whether the proof is just about to pop out. This is very much
Section 9.2. Unification and Lifting 325
like the halting problem for Turing machines. Alan Turing (1936) and Alonzo Church (1936)
both proved, in rather different ways, the inevitability of this state of affairs. The question of
entailment for first-order logic is semidecidable—that is, algorithms exist that say yes to every
entailed sentence, but no algorithm exists that also says no to every nonentailed sentence.
9.2 UNIFICATION AND LIFTING
The preceding section described the understanding of first-order inference that existed up
to the early 1960s. The sharp-eyed reader (and certainly the computational logicians of the
early 1960s) will have noticed that the propositionalization approach is rather inefficient. For
example, given the query Evil(x) and the knowledge base in Equation (9.1), it seems perverse to generate sentences such as King(Richard) ∧ Greedy(Richard) ⇒ Evil(Richard).
Indeed, the inference of Evil(John) from the sentences
∀ x King(x) ∧ Greedy(x) ⇒ Evil(x)
King(John)
Greedy(John)
seems completely obvious to a human being. We now show how to make it completely
obvious to a computer.
9.2.1 A first-order inference rule
The inference that John is evil—that is, that {x/John} solves the query Evil(x)—works like
this: to use the rule that greedy kings are evil, find some x such that x is a king and x is
greedy, and then infer that this x is evil. More generally, if there is some substitution θ that
makes each of the conjuncts of the premise of the implication identical to sentences already
in the knowledge base, then we can assert the conclusion of the implication, after applying θ.
In this case, the substitution θ = {x/John} achieves that aim.
We can actually make the inference step do even more work. Suppose that instead of
knowing Greedy(John), we know that everyone is greedy:
∀ y Greedy(y) . (9.2)
Then we would still like to be able to conclude that Evil(John), because we know that
John is a king (given) and John is greedy (because everyone is greedy). What we need for
this to work is to find a substitution both for the variables in the implication sentence and
for the variables in the sentences that are in the knowledge base. In this case, applying the
substitution {x/John, y/John} to the implication premises King(x) and Greedy(x) and the
knowledge-base sentences King(John) and Greedy(y) will make them identical. Thus, we
can infer the conclusion of the implication.
This inference process can be captured as a single inference rule that we call Generalized Modus Ponens:
2 For atomic sentences pi, pi

, and q, where there is a substitution θ GENERALIZED
MODUS PONENS
326 Chapter 9. Inference in First-Order Logic
such that SUBST(θ, pi

) = SUBST(θ, pi), for all i,
p1

, p2

, ..., pn

, (p1 ∧ p2 ∧ ... ∧ pn ⇒ q)
SUBST(θ, q) .
There are n+ 1 premises to this rule: the n atomic sentences pi
 and the one implication. The
conclusion is the result of applying the substitution θ to the consequent q. For our example:
p1
 is King(John) p1 is King(x)
p2
 is Greedy(y) p2 is Greedy(x)
θ is {x/John, y/John} q is Evil(x)
SUBST(θ, q) is Evil(John) .
It is easy to show that Generalized Modus Ponens is a sound inference rule. First, we observe
that, for any sentence p (whose variables are assumed to be universally quantified) and for
any substitution θ,
p |= SUBST(θ, p)
holds by Universal Instantiation. It holds in particular for a θ that satisfies the conditions of
the Generalized Modus Ponens rule. Thus, from p1

,...,pn we can infer
SUBST(θ, p1

) ∧ ... ∧ SUBST(θ, pn

)
and from the implication p1 ∧ ... ∧ pn ⇒ q we can infer
SUBST(θ, p1) ∧ ... ∧ SUBST(θ, pn) ⇒ SUBST(θ, q) .
Now, θ in Generalized Modus Ponens is defined so that SUBST(θ, pi

) = SUBST(θ, pi), for
all i; therefore the first of these two sentences matches the premise of the second exactly.
Hence, SUBST(θ, q) follows by Modus Ponens.
LIFTING Generalized Modus Ponens is a lifted version of Modus Ponens—it raises Modus Ponens from ground (variable-free) propositional logic to first-order logic. We will see in the
rest of this chapter that we can develop lifted versions of the forward chaining, backward
chaining, and resolution algorithms introduced in Chapter 7. The key advantage of lifted
inference rules over propositionalization is that they make only those substitutions that are
required to allow particular inferences to proceed.
9.2.2 Unification
Lifted inference rules require finding substitutions that make different logical expressions
UNIFICATION look identical. This process is called unification and is a key component of all first-order
UNIFIER inference algorithms. The UNIFY algorithm takes two sentences and returns a unifier for
them if one exists:
UNIFY(p, q) = θ where SUBST(θ, p) = SUBST(θ, q) .
Let us look at some examples of how UNIFY should behave. Suppose we have a query
AskVars(Knows(John, x)): whom does John know? Answers to this query can be found
2 Generalized Modus Ponens is more general than Modus Ponens (page 249) in the sense that the known facts
and the premise of the implication need match only up to a substitution, rather than exactly. On the other hand,
Modus Ponens allows any sentence α as the premise, rather than just a conjunction of atomic sentences.
Section 9.2. Unification and Lifting 327
by finding all sentences in the knowledge base that unify with Knows(John, x). Here are the
results of unification with four different sentences that might be in the knowledge base:
UNIFY(Knows(John, x), Knows(John, Jane)) = {x/Jane}
UNIFY(Knows(John, x), Knows(y, Bill)) = {x/Bill, y/John}
UNIFY(Knows(John, x), Knows(y, Mother (y))) = {y/John, x/Mother (John)}
UNIFY(Knows(John, x), Knows(x,Elizabeth)) = fail .
The last unification fails because x cannot take on the values John and Elizabeth at the
same time. Now, remember that Knows(x,Elizabeth) means “Everyone knows Elizabeth,”
so we should be able to infer that John knows Elizabeth. The problem arises only because
the two sentences happen to use the same variable name, x. The problem can be avoided
by standardizing apart one of the two sentences being unified, which means renaming its STANDARDIZING
APART
variables to avoid name clashes. For example, we can rename x in Knows(x,Elizabeth) to
x17 (a new variable name) without changing its meaning. Now the unification will work:
UNIFY(Knows(John, x), Knows(x17,Elizabeth)) = {x/Elizabeth, x17/John} .
Exercise 9.12 delves further into the need for standardizing apart.
There is one more complication: we said that UNIFY should return a substitution
that makes the two arguments look the same. But there could be more than one such unifier. For example, UNIFY(Knows(John, x), Knows(y, z)) could return {y/John, x/z} or
{y/John, x/John, z/John}. The first unifier gives Knows(John, z) as the result of unification, whereas the second gives Knows(John, John). The second result could be obtained
from the first by an additional substitution {z/John}; we say that the first unifier is more
general than the second, because it places fewer restrictions on the values of the variables. It
turns out that, for every unifiable pair of expressions, there is a single most general unifier (or MOST GENERAL
UNIFIER
MGU) that is unique up to renaming and substitution of variables. (For example, {x/John}
and {y/John} are considered equivalent, as are {x/John, y/John} and {x/John, y/x}.) In
this case it is {y/John, x/z}.
An algorithm for computing most general unifiers is shown in Figure 9.1. The process
is simple: recursively explore the two expressions simultaneously “side by side,” building up
a unifier along the way, but failing if two corresponding points in the structures do not match.
There is one expensive step: when matching a variable against a complex term, one must
check whether the variable itself occurs inside the term; if it does, the match fails because no
consistent unifier can be constructed. For example, S(x) can’t unify with S(S(x)). This soOCCUR CHECK called occur check makes the complexity of the entire algorithm quadratic in the size of the
expressions being unified. Some systems, including all logic programming systems, simply
omit the occur check and sometimes make unsound inferences as a result; other systems use
more complex algorithms with linear-time complexity.
9.2.3 Storage and retrieval
Underlying the TELL and ASK functions used to inform and interrogate a knowledge base
are the more primitive STORE and FETCH functions. STORE(s) stores a sentence s into the
knowledge base and FETCH(q) returns all unifiers such that the query q unifies with some
328 Chapter 9. Inference in First-Order Logic
function UNIFY(x , y, θ) returns a substitution to make x and y identical
inputs: x , a variable, constant, list, or compound expression
y, a variable, constant, list, or compound expression
θ, the substitution built up so far (optional, defaults to empty)
if θ = failure then return failure
else if x = y then return θ
else if VARIABLE?(x ) then return UNIFY-VAR(x , y, θ)
else if VARIABLE?(y) then return UNIFY-VAR(y, x , θ)
else if COMPOUND?(x ) and COMPOUND?(y) then
return UNIFY(x .ARGS, y.ARGS, UNIFY(x .OP, y.OP, θ))
else if LIST?(x ) and LIST?(y) then
return UNIFY(x .REST, y.REST, UNIFY(x .FIRST, y.FIRST, θ))
else return failure
function UNIFY-VAR(var , x , θ) returns a substitution
if {var/val} ∈ θ then return UNIFY(val, x , θ)
else if {x/val} ∈ θ then return UNIFY(var , val, θ)
else if OCCUR-CHECK?(var , x ) then return failure
else return add {var /x } to θ
Figure 9.1 The unification algorithm. The algorithm works by comparing the structures
of the inputs, element by element. The substitution θ that is the argument to UNIFY is built
up along the way and is used to make sure that later comparisons are consistent with bindings
that were established earlier. In a compound expression such as F(A, B), the OP field picks
out the function symbol F and the ARGS field picks out the argument list (A, B).
sentence in the knowledge base. The problem we used to illustrate unification—finding all
facts that unify with Knows(John, x)—is an instance of FETCHing.
The simplest way to implement STORE and FETCH is to keep all the facts in one long
list and unify each query against every element of the list. Such a process is inefficient, but
it works, and it’s all you need to understand the rest of the chapter. The remainder of this
section outlines ways to make retrieval more efficient; it can be skipped on first reading.
We can make FETCH more efficient by ensuring that unifications are attempted only
with sentences that have some chance of unifying. For example, there is no point in trying
to unify Knows(John, x) with Brother (Richard, John). We can avoid such unifications by
INDEXING indexing the facts in the knowledge base. A simple scheme called predicate indexing puts
PREDICATE
INDEXING all the Knows facts in one bucket and all the Brother facts in another. The buckets can be
stored in a hash table for efficient access.
Predicate indexing is useful when there are many predicate symbols but only a few
clauses for each symbol. Sometimes, however, a predicate has many clauses. For example,
suppose that the tax authorities want to keep track of who employs whom, using a predicate Employs(x, y). This would be a very large bucket with perhaps millions of employers
Section 9.2. Unification and Lifting 329
Employs(x,y)
Employs(x,Richard) Employs(IBM,y)
Employs(IBM,Richard)
Employs(x,y)
Employs(John,John)
Employs(x,John) Employs(x,x) Employs(John,y)
(a) (b)
Figure 9.2 (a) The subsumption lattice whose lowest node is Employs(IBM , Richard).
(b) The subsumption lattice for the sentence Employs (John, John).
and tens of millions of employees. Answering a query such as Employs(x, Richard) with
predicate indexing would require scanning the entire bucket.
For this particular query, it would help if facts were indexed both by predicate and by
second argument, perhaps using a combined hash table key. Then we could simply construct
the key from the query and retrieve exactly those facts that unify with the query. For other
queries, such as Employs(IBM , y), we would need to have indexed the facts by combining
the predicate with the first argument. Therefore, facts can be stored under multiple index
keys, rendering them instantly accessible to various queries that they might unify with.
Given a sentence to be stored, it is possible to construct indices for all possible queries
that unify with it. For the fact Employs(IBM , Richard), the queries are
Employs(IBM , Richard) Does IBM employ Richard?
Employs(x, Richard) Who employs Richard?
Employs(IBM , y) Whom does IBM employ?
Employs(x, y) Who employs whom?
These queries form a subsumption lattice, as shown in Figure 9.2(a). The lattice has some SUBSUMPTION
LATTICE
interesting properties. For example, the child of any node in the lattice is obtained from its
parent by a single substitution; and the “highest” common descendant of any two nodes is
the result of applying their most general unifier. The portion of the lattice above any ground
fact can be constructed systematically (Exercise 9.5). A sentence with repeated constants has
a slightly different lattice, as shown in Figure 9.2(b). Function symbols and variables in the
sentences to be stored introduce still more interesting lattice structures.
The scheme we have described works very well whenever the lattice contains a small
number of nodes. For a predicate with n arguments, however, the lattice contains O(2n)
nodes. If function symbols are allowed, the number of nodes is also exponential in the size
of the terms in the sentence to be stored. This can lead to a huge number of indices. At some
point, the benefits of indexing are outweighed by the costs of storing and maintaining all
the indices. We can respond by adopting a fixed policy, such as maintaining indices only on
keys composed of a predicate plus each argument, or by using an adaptive policy that creates
indices to meet the demands of the kinds of queries being asked. For most AI systems, the
number of facts to be stored is small enough that efficient indexing is considered a solved
problem. For commercial databases, where facts number in the billions, the problem has
been the subject of intensive study and technology development..
330 Chapter 9. Inference in First-Order Logic
9.3 FORWARD CHAINING
A forward-chaining algorithm for propositional definite clauses was given in Section 7.5.
The idea is simple: start with the atomic sentences in the knowledge base and apply Modus
Ponens in the forward direction, adding new atomic sentences, until no further inferences
can be made. Here, we explain how the algorithm is applied to first-order definite clauses.
Definite clauses such as Situation ⇒ Response are especially useful for systems that make
inferences in response to newly arrived information. Many systems can be defined this way,
and forward chaining can be implemented very efficiently.
9.3.1 First-order definite clauses
First-order definite clauses closely resemble propositional definite clauses (page 256): they
are disjunctions of literals of which exactly one is positive. A definite clause either is atomic
or is an implication whose antecedent is a conjunction of positive literals and whose consequent is a single positive literal. The following are first-order definite clauses:
King(x) ∧ Greedy(x) ⇒ Evil(x) .
King(John) .
Greedy(y) .
Unlike propositional literals, first-order literals can include variables, in which case those
variables are assumed to be universally quantified. (Typically, we omit universal quantifiers
when writing definite clauses.) Not every knowledge base can be converted into a set of
definite clauses because of the single-positive-literal restriction, but many can. Consider the
following problem:
The law says that it is a crime for an American to sell weapons to hostile nations. The
country Nono, an enemy of America, has some missiles, and all of its missiles were sold
to it by Colonel West, who is American.
We will prove that West is a criminal. First, we will represent these facts as first-order definite
clauses. The next section shows how the forward-chaining algorithm solves the problem.
“... it is a crime for an American to sell weapons to hostile nations”:
American(x) ∧ Weapon(y) ∧ Sells(x, y, z) ∧ Hostile(z) ⇒ Criminal(x) . (9.3)
“Nono ... has some missiles.” The sentence ∃ x Owns(Nono, x)∧Missile(x) is transformed
into two definite clauses by Existential Instantiation, introducing a new constant M1:
Owns(Nono, M1) (9.4)
Missile . (M1) (9.5)
“All of its missiles were sold to it by Colonel West”:
Missile(x) ∧ Owns(Nono, x) ⇒ Sells(West, x, Nono) . (9.6)
We will also need to know that missiles are weapons:
Missile(x) ⇒ Weapon(x) (9.7)
Section 9.3. Forward Chaining 331
and we must know that an enemy of America counts as “hostile”:
Enemy(x, America) ⇒ Hostile(x) . (9.8)
“West, who is American ...”:
American(West) . (9.9)
“The country Nono, an enemy of America ...”:
Enemy(Nono, America) . (9.10)
This knowledge base contains no function symbols and is therefore an instance of the class
DATALOG of Datalog knowledge bases. Datalog is a language that is restricted to first-order definite
clauses with no function symbols. Datalog gets its name because it can represent the type of
statements typically made in relational databases. We will see that the absence of function
symbols makes inference much easier.
9.3.2 A simple forward-chaining algorithm
The first forward-chaining algorithm we consider is a simple one, shown in Figure 9.3. Starting from the known facts, it triggers all the rules whose premises are satisfied, adding their
conclusions to the known facts. The process repeats until the query is answered (assuming
that just one answer is required) or no new facts are added. Notice that a fact is not “new”
RENAMING if it is just a renaming of a known fact. One sentence is a renaming of another if they
are identical except for the names of the variables. For example, Likes(x,IceCream) and
Likes(y,IceCream) are renamings of each other because they differ only in the choice of x
or y; their meanings are identical: everyone likes ice cream.
We use our crime problem to illustrate how FOL-FC-ASK works. The implication
sentences are (9.3), (9.6), (9.7), and (9.8). Two iterations are required:
• On the first iteration, rule (9.3) has unsatisfied premises.
Rule (9.6) is satisfied with {x/M1}, and Sells(West, M1, Nono) is added.
Rule (9.7) is satisfied with {x/M1}, and Weapon(M1) is added.
Rule (9.8) is satisfied with {x/Nono}, and Hostile(Nono) is added.
• On the second iteration, rule (9.3) is satisfied with {x/West, y/M1, z/Nono}, and
Criminal(West) is added.
Figure 9.4 shows the proof tree that is generated. Notice that no new inferences are possible
at this point because every sentence that could be concluded by forward chaining is already
contained explicitly in the KB. Such a knowledge base is called a fixed point of the inference
process. Fixed points reached by forward chaining with first-order definite clauses are similar
to those for propositional forward chaining (page 258); the principal difference is that a firstorder fixed point can include universally quantified atomic sentences.
FOL-FC-ASK is easy to analyze. First, it is sound, because every inference is just an
application of Generalized Modus Ponens, which is sound. Second, it is complete for definite
clause knowledge bases; that is, it answers every query whose answers are entailed by any
knowledge base of definite clauses. For Datalog knowledge bases, which contain no function
symbols, the proof of completeness is fairly easy. We begin by counting the number of
332 Chapter 9. Inference in First-Order Logic
function FOL-FC-ASK(KB,α) returns a substitution or false
inputs: KB, the knowledge base, a set of first-order definite clauses
α, the query, an atomic sentence
local variables: new, the new sentences inferred on each iteration
repeat until new is empty
new ←{}
for each rule in KB do
(p1 ∧ ... ∧ pn ⇒ q)← STANDARDIZE-VARIABLES(rule)
for each θ such that SUBST(θ, p1 ∧ ... ∧ pn)=SUBST(θ, p
1 ∧ ... ∧ p
n)
for some p
1,..., p
n in KB
q ← SUBST(θ, q)
if q does not unify with some sentence already in KB or new then
add q to new
φ← UNIFY(q
,α)
if φ is not fail then return φ
add new to KB
return false
Figure 9.3 A conceptually straightforward, but very inefficient, forward-chaining algorithm. On each iteration, it adds to KB all the atomic sentences that can be inferred in one
step from the implication sentences and the atomic sentences already in KB. The function
STANDARDIZE-VARIABLES replaces all variables in its arguments with new ones that have
not been used before.
Hostile(Nono)
Owns(Nono,M Enemy(Nono,America) 1 Missile(M ) 1 American(West) )
Weapon(M1)
Criminal(West)
Sells(West,M1,Nono)
Figure 9.4 The proof tree generated by forward chaining on the crime example. The initial
facts appear at the bottom level, facts inferred on the first iteration in the middle level, and
facts inferred on the second iteration at the top level.
possible facts that can be added, which determines the maximum number of iterations. Let k
be the maximum arity (number of arguments) of any predicate, p be the number of predicates,
and n be the number of constant symbols. Clearly, there can be no more than pnk distinct
ground facts, so after this many iterations the algorithm must have reached a fixed point. Then
we can make an argument very similar to the proof of completeness for propositional forward
Section 9.3. Forward Chaining 333
chaining. (See page 258.) The details of how to make the transition from propositional to
first-order completeness are given for the resolution algorithm in Section 9.5.
For general definite clauses with function symbols, FOL-FC-ASK can generate infinitely many new facts, so we need to be more careful. For the case in which an answer to
the query sentence q is entailed, we must appeal to Herbrand’s theorem to establish that the
algorithm will find a proof. (See Section 9.5 for the resolution case.) If the query has no
answer, the algorithm could fail to terminate in some cases. For example, if the knowledge
base includes the Peano axioms
NatNum(0)
∀ n NatNum(n) ⇒ NatNum(S(n)) ,
then forward chaining adds NatNum(S(0)), NatNum(S(S(0))), NatNum(S(S(S(0)))),
and so on. This problem is unavoidable in general. As with general first-order logic, entailment with definite clauses is semidecidable.
9.3.3 Efficient forward chaining
The forward-chaining algorithm in Figure 9.3 is designed for ease of understanding rather
than for efficiency of operation. There are three possible sources of inefficiency. First, the
“inner loop” of the algorithm involves finding all possible unifiers such that the premise of
a rule unifies with a suitable set of facts in the knowledge base. This is often called pattern
PATTERN MATCHING matching and can be very expensive. Second, the algorithm rechecks every rule on every
iteration to see whether its premises are satisfied, even if very few additions are made to the
knowledge base on each iteration. Finally, the algorithm might generate many facts that are
irrelevant to the goal. We address each of these issues in turn.
Matching rules against known facts
The problem of matching the premise of a rule against the facts in the knowledge base might
seem simple enough. For example, suppose we want to apply the rule
Missile(x) ⇒ Weapon(x) .
Then we need to find all the facts that unify with Missile(x); in a suitably indexed knowledge
base, this can be done in constant time per fact. Now consider a rule such as
Missile(x) ∧ Owns(Nono, x) ⇒ Sells(West, x, Nono) .
Again, we can find all the objects owned by Nono in constant time per object; then, for each
object, we could check whether it is a missile. If the knowledge base contains many objects
owned by Nono and very few missiles, however, it would be better to find all the missiles first
and then check whether they are owned by Nono. This is the conjunct ordering problem: CONJUNCT
ORDERING
find an ordering to solve the conjuncts of the rule premise so that the total cost is minimized.
It turns out that finding the optimal ordering is NP-hard, but good heuristics are available.
For example, the minimum-remaining-values (MRV) heuristic used for CSPs in Chapter 6
would suggest ordering the conjuncts to look for missiles first if fewer missiles than objects
are owned by Nono.
334 Chapter 9. Inference in First-Order Logic
WA
NT
SA
Q
NSW
V
T
Diff (wa, nt) ∧ Diff (wa, sa) ∧
Diff (nt, q) ∧ Diff (nt, sa) ∧
Diff (q, nsw) ∧ Diff (q, sa) ∧
Diff (nsw, v) ∧ Diff (nsw, sa) ∧
Diff (v, sa) ⇒ Colorable()
Diff (Red, Blue) Diff (Red, Green)
Diff (Green, Red ) Diff (Green, Blue)
Diff (Blue, Red) Diff (Blue, Green)
(a) (b)
Figure 9.5 (a) Constraint graph for coloring the map of Australia. (b) The map-coloring
CSP expressed as a single definite clause. Each map region is represented as a variable whose
value can be one of the constants Red, Green or Blue.
The connection between pattern matching and constraint satisfaction is actually very
close. We can view each conjunct as a constraint on the variables that it contains—for example, Missile(x) is a unary constraint on x. Extending this idea, we can express every
finite-domain CSP as a single definite clause together with some associated ground facts.
Consider the map-coloring problem from Figure 6.1, shown again in Figure 9.5(a). An equivalent formulation as a single definite clause is given in Figure 9.5(b). Clearly, the conclusion
Colorable() can be inferred only if the CSP has a solution. Because CSPs in general include
3-SAT problems as special cases, we can conclude that matching a definite clause against a
set of facts is NP-hard.
It might seem rather depressing that forward chaining has an NP-hard matching problem
in its inner loop. There are three ways to cheer ourselves up:
• We can remind ourselves that most rules in real-world knowledge bases are small and
simple (like the rules in our crime example) rather than large and complex (like the
CSP formulation in Figure 9.5). It is common in the database world to assume that
both the sizes of rules and the arities of predicates are bounded by a constant and to
DATA COMPLEXITY worry only about data complexity—that is, the complexity of inference as a function
of the number of ground facts in the knowledge base. It is easy to show that the data
complexity of forward chaining is polynomial.
• We can consider subclasses of rules for which matching is efficient. Essentially every
Datalog clause can be viewed as defining a CSP, so matching will be tractable just
when the corresponding CSP is tractable. Chapter 6 describes several tractable families
of CSPs. For example, if the constraint graph (the graph whose nodes are variables
and whose links are constraints) forms a tree, then the CSP can be solved in linear
time. Exactly the same result holds for rule matching. For instance, if we remove South
Section 9.3. Forward Chaining 335
Australia from the map in Figure 9.5, the resulting clause is
Diff (wa, nt) ∧ Diff (nt, q) ∧ Diff (q, nsw) ∧ Diff (nsw, v) ⇒ Colorable()
which corresponds to the reduced CSP shown in Figure 6.12 on page 224. Algorithms
for solving tree-structured CSPs can be applied directly to the problem of rule matching.
• We can try to to eliminate redundant rule-matching attempts in the forward-chaining
algorithm, as described next.
Incremental forward chaining
When we showed how forward chaining works on the crime example, we cheated; in particular, we omitted some of the rule matching done by the algorithm shown in Figure 9.3. For
example, on the second iteration, the rule
Missile(x) ⇒ Weapon(x)
matches against Missile(M1) (again), and of course the conclusion Weapon(M1) is already
known so nothing happens. Such redundant rule matching can be avoided if we make the
following observation: Every new fact inferred on iteration t must be derived from at least
one new fact inferred on iteration t − 1. This is true because any inference that does not
require a new fact from iteration t − 1 could have been done at iteration t − 1 already.
This observation leads naturally to an incremental forward-chaining algorithm where,
at iteration t, we check a rule only if its premise includes a conjunct pi that unifies with a fact
p
i newly inferred at iteration t − 1. The rule-matching step then fixes pi to match with p
i, but
allows the other conjuncts of the rule to match with facts from any previous iteration. This
algorithm generates exactly the same facts at each iteration as the algorithm in Figure 9.3, but
is much more efficient.
With suitable indexing, it is easy to identify all the rules that can be triggered by any
given fact, and indeed many real systems operate in an “update” mode wherein forward chaining occurs in response to each new fact that is TELLed to the system. Inferences cascade
through the set of rules until the fixed point is reached, and then the process begins again for
the next new fact.
Typically, only a small fraction of the rules in the knowledge base are actually triggered
by the addition of a given fact. This means that a great deal of redundant work is done in
repeatedly constructing partial matches that have some unsatisfied premises. Our crime example is rather too small to show this effectively, but notice that a partial match is constructed
on the first iteration between the rule
American(x) ∧ Weapon(y) ∧ Sells(x, y, z) ∧ Hostile(z) ⇒ Criminal(x)
and the fact American(West). This partial match is then discarded and rebuilt on the second
iteration (when the rule succeeds). It would be better to retain and gradually complete the
partial matches as new facts arrive, rather than discarding them.
The rete algorithm3 RETE was the first to address this problem. The algorithm preprocesses
the set of rules in the knowledge base to construct a sort of dataflow network in which each
3 Rete is Latin for net. The English pronunciation rhymes with treaty.
336 Chapter 9. Inference in First-Order Logic
node is a literal from a rule premise. Variable bindings flow through the network and are
filtered out when they fail to match a literal. If two literals in a rule share a variable—for
example, Sells(x, y, z) ∧ Hostile(z) in the crime example—then the bindings from each
literal are filtered through an equality node. A variable binding reaching a node for an nary literal such as Sells(x, y, z) might have to wait for bindings for the other variables to be
established before the process can continue. At any given point, the state of a rete network
captures all the partial matches of the rules, avoiding a great deal of recomputation.
Rete networks, and various improvements thereon, have been a key component of socalled production systems, which were among the earliest forward-chaining systems in PRODUCTION
SYSTEM
widespread use.4 The XCON system (originally called R1; McDermott, 1982) was built
with a production-system architecture. XCON contained several thousand rules for designing
configurations of computer components for customers of the Digital Equipment Corporation.
It was one of the first clear commercial successes in the emerging field of expert systems.
Many other similar systems have been built with the same underlying technology, which has
been implemented in the general-purpose language OPS-5.
Production systems are also popular in cognitive architectures—that is, models of hu- COGNITIVE
ARCHITECTURES
man reasoning—such as ACT (Anderson, 1983) and SOAR (Laird et al., 1987). In such systems, the “working memory” of the system models human short-term memory, and the productions are part of long-term memory. On each cycle of operation, productions are matched
against the working memory of facts. A production whose conditions are satisfied can add or
delete facts in working memory. In contrast to the typical situation in databases, production
systems often have many rules and relatively few facts. With suitably optimized matching
technology, some modern systems can operate in real time with tens of millions of rules.
Irrelevant facts
The final source of inefficiency in forward chaining appears to be intrinsic to the approach
and also arises in the propositional context. Forward chaining makes all allowable inferences
based on the known facts, even if they are irrelevant to the goal at hand. In our crime example,
there were no rules capable of drawing irrelevant conclusions, so the lack of directedness was
not a problem. In other cases (e.g., if many rules describe the eating habits of Americans and
the prices of missiles), FOL-FC-ASK will generate many irrelevant conclusions.
One way to avoid drawing irrelevant conclusions is to use backward chaining, as described in Section 9.4. Another solution is to restrict forward chaining to a selected subset of
rules, as in PL-FC-ENTAILS? (page 258). A third approach has emerged in the field of deductive databases, which are large-scale databases, like relational databases, but which use DEDUCTIVE
DATABASES
forward chaining as the standard inference tool rather than SQL queries. The idea is to rewrite
the rule set, using information from the goal, so that only relevant variable bindings—those
MAGIC SET belonging to a so-called magic set—are considered during forward inference. For example, if
the goal is Criminal(West), the rule that concludes Criminal(x) will be rewritten to include
an extra conjunct that constrains the value of x:
Magic(x) ∧ American(x) ∧ Weapon(y) ∧ Sells(x, y, z) ∧ Hostile(z) ⇒ Criminal(x) .
4 The word production in production systems denotes a condition–action rule.
Section 9.4. Backward Chaining 337
The fact Magic(West) is also added to the KB. In this way, even if the knowledge base
contains facts about millions of Americans, only Colonel West will be considered during the
forward inference process. The complete process for defining magic sets and rewriting the
knowledge base is too complex to go into here, but the basic idea is to perform a sort of
“generic” backward inference from the goal in order to work out which variable bindings
need to be constrained. The magic sets approach can therefore be thought of as a kind of
hybrid between forward inference and backward preprocessing.
9.4 BACKWARD CHAINING
The second major family of logical inference algorithms uses the backward chaining approach introduced in Section 7.5 for definite clauses. These algorithms work backward from
the goal, chaining through rules to find known facts that support the proof. We describe
the basic algorithm, and then we describe how it is used in logic programming, which is the
most widely used form of automated reasoning. We also see that backward chaining has some
disadvantages compared with forward chaining, and we look at ways to overcome them. Finally, we look at the close connection between logic programming and constraint satisfaction
problems.
9.4.1 A backward-chaining algorithm
Figure 9.6 shows a backward-chaining algorithm for definite clauses. FOL-BC-ASK(KB,
goal) will be proved if the knowledge base contains a clause of the form lhs ⇒ goal, where
lhs (left-hand side) is a list of conjuncts. An atomic fact like American(West) is considered
as a clause whose lhs is the empty list. Now a query that contains variables might be proved
in multiple ways. For example, the query Person(x) could be proved with the substitution
GENERATOR {x/John} as well as with {x/Richard}. So we implement FOL-BC-ASK as a generator—
a function that returns multiple times, each time giving one possible result.
Backward chaining is a kind of AND/OR search—the OR part because the goal query
can be proved by any rule in the knowledge base, and the AND part because all the conjuncts
in the lhs of a clause must be proved. FOL-BC-OR works by fetching all clauses that might
unify with the goal, standardizing the variables in the clause to be brand-new variables, and
then, if the rhs of the clause does indeed unify with the goal, proving every conjunct in the
lhs, using FOL-BC-AND. That function in turn works by proving each of the conjuncts in
turn, keeping track of the accumulated substitution as we go. Figure 9.7 is the proof tree for
deriving Criminal(West) from sentences (9.3) through (9.10).
Backward chaining, as we have written it, is clearly a depth-first search algorithm.
This means that its space requirements are linear in the size of the proof (neglecting, for
now, the space required to accumulate the solutions). It also means that backward chaining
(unlike forward chaining) suffers from problems with repeated states and incompleteness. We
will discuss these problems and some potential solutions, but first we show how backward
chaining is used in logic programming systems.
338 Chapter 9. Inference in First-Order Logic
function FOL-BC-ASK(KB, query) returns a generator of substitutions
return FOL-BC-OR(KB, query, { })
generator FOL-BC-OR(KB, goal, θ) yields a substitution
for each rule (lhs ⇒ rhs) in FETCH-RULES-FOR-GOAL(KB, goal) do
(lhs, rhs) ← STANDARDIZE-VARIABLES((lhs, rhs))
for each θ in FOL-BC-AND(KB, lhs, UNIFY(rhs, goal, θ)) do
yield θ
generator FOL-BC-AND(KB, goals, θ) yields a substitution
if θ = failure then return
else if LENGTH(goals)=0 then yield θ
else do
first,rest ← FIRST(goals), REST(goals)
for each θ in FOL-BC-OR(KB, SUBST(θ, first), θ) do
for each θ in FOL-BC-AND(KB, rest, θ
) do
yield θ
Figure 9.6 A simple backward-chaining algorithm for first-order knowledge bases.
Hostile(Nono)
Owns(Nono,M Enemy(Nono,America) 1 Missile(M ) 1)
Criminal(West)
Missile(y)
Weapon(y) Sells(West,M1 American(West) ,z)
{y/M1} { } { } { }
{ } {z/Nono}
Figure 9.7 Proof tree constructed by backward chaining to prove that West is a criminal.
The tree should be read depth first, left to right. To prove Criminal(West), we have to prove
the four conjuncts below it. Some of these are in the knowledge base, and others require
further backward chaining. Bindings for each successful unification are shown next to the
corresponding subgoal. Note that once one subgoal in a conjunction succeeds, its substitution
is applied to subsequent subgoals. Thus, by the time FOL-BC-ASK gets to the last conjunct,
originally Hostile(z), z is already bound to Nono.
Section 9.4. Backward Chaining 339
9.4.2 Logic programming
Logic programming is a technology that comes fairly close to embodying the declarative
ideal described in Chapter 7: that systems should be constructed by expressing knowledge in
a formal language and that problems should be solved by running inference processes on that
knowledge. The ideal is summed up in Robert Kowalski’s equation,
Algorithm = Logic + Control .
PROLOG Prolog is the most widely used logic programming language. It is used primarily as a rapidprototyping language and for symbol-manipulation tasks such as writing compilers (Van Roy,
1990) and parsing natural language (Pereira and Warren, 1980). Many expert systems have
been written in Prolog for legal, medical, financial, and other domains.
Prolog programs are sets of definite clauses written in a notation somewhat different
from standard first-order logic. Prolog uses uppercase letters for variables and lowercase for
constants—the opposite of our convention for logic. Commas separate conjuncts in a clause,
and the clause is written “backwards” from what we are used to; instead of A ∧ B ⇒ C in
Prolog we have C :- A, B. Here is a typical example:
criminal(X) :- american(X), weapon(Y), sells(X,Y,Z), hostile(Z).
The notation [E|L] denotes a list whose first element is E and whose rest is L. Here is a
Prolog program for append(X,Y,Z), which succeeds if list Z is the result of appending
lists X and Y:
append([],Y,Y).
append([A|X],Y,[A|Z]) :- append(X,Y,Z).
In English, we can read these clauses as (1) appending an empty list with a list Y produces
the same list Y and (2) [A|Z] is the result of appending [A|X] onto Y, provided that Z is
the result of appending X onto Y. In most high-level languages we can write a similar recursive function that describes how to append two lists. The Prolog definition is actually much
more powerful, however, because it describes a relation that holds among three arguments,
rather than a function computed from two arguments. For example, we can ask the query
append(X,Y,[1,2]): what two lists can be appended to give [1,2]? We get back the
solutions
X=[] Y=[1,2];
X=[1] Y=[2];
X=[1,2] Y=[]
The execution of Prolog programs is done through depth-first backward chaining, where
clauses are tried in the order in which they are written in the knowledge base. Some aspects
of Prolog fall outside standard logical inference:
• Prolog uses the database semantics of Section 8.2.8 rather than first-order semantics,
and this is apparent in its treatment of equality and negation (see Section 9.4.5).
• There is a set of built-in functions for arithmetic. Literals using these function symbols
are “proved” by executing code rather than doing further inference. For example, the
340 Chapter 9. Inference in First-Order Logic
goal “X is 4+3” succeeds with X bound to 7. On the other hand, the goal “5 is X+Y”
fails, because the built-in functions do not do arbitrary equation solving.5
• There are built-in predicates that have side effects when executed. These include input–
output predicates and the assert/retract predicates for modifying the knowledge
base. Such predicates have no counterpart in logic and can produce confusing results—
for example, if facts are asserted in a branch of the proof tree that eventually fails.
• The occur check is omitted from Prolog’s unification algorithm. This means that some
unsound inferences can be made; these are almost never a problem in practice.
• Prolog uses depth-first backward-chaining search with no checks for infinite recursion.
This makes it very fast when given the right set of axioms, but incomplete when given
the wrong ones.
Prolog’s design represents a compromise between declarativeness and execution efficiency—
inasmuch as efficiency was understood at the time Prolog was designed.
9.4.3 Efficient implementation of logic programs
The execution of a Prolog program can happen in two modes: interpreted and compiled.
Interpretation essentially amounts to running the FOL-BC-ASK algorithm from Figure 9.6,
with the program as the knowledge base. We say “essentially” because Prolog interpreters
contain a variety of improvements designed to maximize speed. Here we consider only two.
First, our implementation had to explicitly manage the iteration over possible results
generated by each of the subfunctions. Prolog interpreters have a global data structure,
CHOICE POINT a stack of choice points, to keep track of the multiple possibilities that we considered in
FOL-BC-OR. This global stack is more efficient, and it makes debugging easier, because
the debugger can move up and down the stack.
Second, our simple implementation of FOL-BC-ASK spends a good deal of time generating substitutions. Instead of explicitly constructing substitutions, Prolog has logic variables
that remember their current binding. At any point in time, every variable in the program either is unbound or is bound to some value. Together, these variables and values implicitly
define the substitution for the current branch of the proof. Extending the path can only add
new variable bindings, because an attempt to add a different binding for an already bound
variable results in a failure of unification. When a path in the search fails, Prolog will back
up to a previous choice point, and then it might have to unbind some variables. This is done
TRAIL by keeping track of all the variables that have been bound in a stack called the trail. As each
new variable is bound by UNIFY-VAR, the variable is pushed onto the trail. When a goal fails
and it is time to back up to a previous choice point, each of the variables is unbound as it is
removed from the trail.
Even the most efficient Prolog interpreters require several thousand machine instructions per inference step because of the cost of index lookup, unification, and building the
recursive call stack. In effect, the interpreter always behaves as if it has never seen the program before; for example, it has to find clauses that match the goal. A compiled Prolog
5 Note that if the Peano axioms are provided, such goals can be solved by inference within a Prolog program.
Section 9.4. Backward Chaining 341
procedure APPEND(ax , y, az , continuation)
trail ← GLOBAL-TRAIL-POINTER()
if ax = [ ] and UNIFY(y, az ) then CALL(continuation)
RESET-TRAIL(trail)
a, x , z ← NEW-VARIABLE(), NEW-VARIABLE(), NEW-VARIABLE()
if UNIFY(ax , [a | x ]) and UNIFY(az , [a | z ]) then APPEND(x , y, z , continuation)
Figure 9.8 Pseudocode representing the result of compiling the Append predicate. The
function NEW-VARIABLE returns a new variable, distinct from all other variables used so far.
The procedure CALL(continuation) continues execution with the specified continuation.
program, on the other hand, is an inference procedure for a specific set of clauses, so it knows
what clauses match the goal. Prolog basically generates a miniature theorem prover for each
different predicate, thereby eliminating much of the overhead of interpretation. It is also posOPEN-CODE sible to open-code the unification routine for each different call, thereby avoiding explicit
analysis of term structure. (For details of open-coded unification, see Warren et al. (1977).)
The instruction sets of today’s computers give a poor match with Prolog’s semantics,
so most Prolog compilers compile into an intermediate language rather than directly into machine language. The most popular intermediate language is the Warren Abstract Machine,
or WAM, named after David H. D. Warren, one of the implementers of the first Prolog compiler. The WAM is an abstract instruction set that is suitable for Prolog and can be either
interpreted or translated into machine language. Other compilers translate Prolog into a highlevel language such as Lisp or C and then use that language’s compiler to translate to machine
language. For example, the definition of the Append predicate can be compiled into the code
shown in Figure 9.8. Several points are worth mentioning:
• Rather than having to search the knowledge base for Append clauses, the clauses become a procedure and the inferences are carried out simply by calling the procedure.
• As described earlier, the current variable bindings are kept on a trail. The first step of the
procedure saves the current state of the trail, so that it can be restored by RESET-TRAIL
if the first clause fails. This will undo any bindings generated by the first call to UNIFY.
CONTINUATION • The trickiest part is the use of continuations to implement choice points. You can think
of a continuation as packaging up a procedure and a list of arguments that together
define what should be done next whenever the current goal succeeds. It would not
do just to return from a procedure like APPEND when the goal succeeds, because it
could succeed in several ways, and each of them has to be explored. The continuation
argument solves this problem because it can be called each time the goal succeeds. In
the APPEND code, if the first argument is empty and the second argument unifies with
the third, then the APPEND predicate has succeeded. We then CALL the continuation,
with the appropriate bindings on the trail, to do whatever should be done next. For
example, if the call to APPEND were at the top level, the continuation would print the
bindings of the variables.
342 Chapter 9. Inference in First-Order Logic
Before Warren’s work on the compilation of inference in Prolog, logic programming was
too slow for general use. Compilers by Warren and others allowed Prolog code to achieve
speeds that are competitive with C on a variety of standard benchmarks (Van Roy, 1990).
Of course, the fact that one can write a planner or natural language parser in a few dozen
lines of Prolog makes it somewhat more desirable than C for prototyping most small-scale AI
research projects.
Parallelization can also provide substantial speedup. There are two principal sources of
OR-PARALLELISM parallelism. The first, called OR-parallelism, comes from the possibility of a goal unifying
with many different clauses in the knowledge base. Each gives rise to an independent branch
in the search space that can lead to a potential solution, and all such branches can be solved
AND-PARALLELISM in parallel. The second, called AND-parallelism, comes from the possibility of solving
each conjunct in the body of an implication in parallel. AND-parallelism is more difficult to
achieve, because solutions for the whole conjunction require consistent bindings for all the
variables. Each conjunctive branch must communicate with the other branches to ensure a
global solution.
9.4.4 Redundant inference and infinite loops
We now turn to the Achilles heel of Prolog: the mismatch between depth-first search and
search trees that include repeated states and infinite paths. Consider the following logic program that decides if a path exists between two points on a directed graph:
path(X,Z) :- link(X,Z).
path(X,Z) :- path(X,Y), link(Y,Z).
A simple three-node graph, described by the facts link(a,b) and link(b,c), is shown
in Figure 9.9(a). With this program, the query path(a,c) generates the proof tree shown
in Figure 9.10(a). On the other hand, if we put the two clauses in the order
path(X,Z) :- path(X,Y), link(Y,Z).
path(X,Z) :- link(X,Z).
then Prolog follows the infinite path shown in Figure 9.10(b). Prolog is therefore incomplete
as a theorem prover for definite clauses—even for Datalog programs, as this example shows—
because, for some knowledge bases, it fails to prove sentences that are entailed. Notice that
forward chaining does not suffer from this problem: once path(a,b), path(b,c), and
path(a,c) are inferred, forward chaining halts.
Depth-first backward chaining also has problems with redundant computations. For
example, when finding a path from A1 to J4 in Figure 9.9(b), Prolog performs 877 inferences,
most of which involve finding all possible paths to nodes from which the goal is unreachable.
This is similar to the repeated-state problem discussed in Chapter 3. The total amount of
inference can be exponential in the number of ground facts that are generated. If we apply
forward chaining instead, at most n2 path(X,Y) facts can be generated linking n nodes.
For the problem in Figure 9.9(b), only 62 inferences are needed.
Forward chaining on graph search problems is an example of dynamic programming, DYNAMIC
PROGRAMMING
in which the solutions to subproblems are constructed incrementally from those of smaller
Section 9.4. Backward Chaining 343
(a) (b)
ABC
A1
J4
Figure 9.9 (a) Finding a path from A to C can lead Prolog into an infinite loop. (b) A
graph in which each node is connected to two random successors in the next layer. Finding a
path from A1 to J4 requires 877 inferences.
path(a,c)
fail
{ } Y b/
{ }
link(a,c) path(a,Y)
link(a,Y)
link(b,c)
path(a,c)
path(a,Y) link(Y,c)
path(a,Y’) link(Y’,Y)
(a) (b)
Figure 9.10 (a) Proof that a path exists from A to C. (b) Infinite proof tree generated
when the clauses are in the “wrong” order.
subproblems and are cached to avoid recomputation. We can obtain a similar effect in a
backward chaining system using memoization—that is, caching solutions to subgoals as
they are found and then reusing those solutions when the subgoal recurs, rather than repeating the previous computation. This is the approach taken by tabled logic programming sys- TABLED LOGIC
PROGRAMMING
tems, which use efficient storage and retrieval mechanisms to perform memoization. Tabled
logic programming combines the goal-directedness of backward chaining with the dynamicprogramming efficiency of forward chaining. It is also complete for Datalog knowledge
bases, which means that the programmer need worry less about infinite loops. (It is still possible to get an infinite loop with predicates like father(X,Y) that refer to a potentially
unbounded number of objects.)
9.4.5 Database semantics of Prolog
Prolog uses database semantics, as discussed in Section 8.2.8. The unique names assumption
says that every Prolog constant and every ground term refers to a distinct object, and the
closed world assumption says that the only sentences that are true are those that are entailed
344 Chapter 9. Inference in First-Order Logic
by the knowledge base. There is no way to assert that a sentence is false in Prolog. This makes
Prolog less expressive than first-order logic, but it is part of what makes Prolog more efficient
and more concise. Consider the following Prolog assertions about some course offerings:
Course(CS, 101), Course(CS, 102), Course(CS, 106), Course(EE, 101). (9.11)
Under the unique names assumption, CS and EE are different (as are 101, 102, and 106),
so this means that there are four distinct courses. Under the closed-world assumption there
are no other courses, so there are exactly four courses. But if these were assertions in FOL
rather than in Prolog, then all we could say is that there are somewhere between one and
infinity courses. That’s because the assertions (in FOL) do not deny the possibility that other
unmentioned courses are also offered, nor do they say that the courses mentioned are different
from each other. If we wanted to translate Equation (9.11) into FOL, we would get this:
Course(d, n) ⇔ (d = CS ∧ n = 101) ∨ (d = CS ∧ n = 102)
∨ (d = CS ∧ n = 106) ∨ (d = EE ∧ n = 101) . (9.12)
COMPLETION This is called the completion of Equation (9.11). It expresses in FOL the idea that there are
at most four courses. To express in FOL the idea that there are at least four courses, we need
to write the completion of the equality predicate:
x = y ⇔ (x = CS ∧ y = CS) ∨ (x = EE ∧ y = EE) ∨ (x = 101 ∧ y = 101)
∨ (x = 102 ∧ y = 102) ∨ (x = 106 ∧ y = 106) .
The completion is useful for understanding database semantics, but for practical purposes, if
your problem can be described with database semantics, it is more efficient to reason with
Prolog or some other database semantics system, rather than translating into FOL and reasoning with a full FOL theorem prover.
9.4.6 Constraint logic programming
In our discussion of forward chaining (Section 9.3), we showed how constraint satisfaction
problems (CSPs) can be encoded as definite clauses. Standard Prolog solves such problems
in exactly the same way as the backtracking algorithm given in Figure 6.5.
Because backtracking enumerates the domains of the variables, it works only for finitedomain CSPs. In Prolog terms, there must be a finite number of solutions for any goal
with unbound variables. (For example, the goal diff(Q,SA), which says that Queensland
and South Australia must be different colors, has six solutions if three colors are allowed.)
Infinite-domain CSPs—for example, with integer or real-valued variables—require quite different algorithms, such as bounds propagation or linear programming.
Consider the following example. We define triangle(X,Y,Z) as a predicate that
holds if the three arguments are numbers that satisfy the triangle inequality:
triangle(X,Y,Z) :-
X>0, Y>0, Z>0, X+Y>=Z, Y+Z>=X, X+Z>=Y.
If we ask Prolog the query triangle(3,4,5), it succeeds. On the other hand, if we
ask triangle(3,4,Z), no solution will be found, because the subgoal Z>=0 cannot be
handled by Prolog; we can’t compare an unbound value to 0.
Section 9.5. Resolution 345
Constraint logic programming (CLP) allows variables to be constrained rather than CONSTRAINT LOGIC
PROGRAMMING
bound. A CLP solution is the most specific set of constraints on the query variables that can
be derived from the knowledge base. For example, the solution to the triangle(3,4,Z)
query is the constraint 7 >= Z >= 1. Standard logic programs are just a special case of
CLP in which the solution constraints must be equality constraints—that is, bindings.
CLP systems incorporate various constraint-solving algorithms for the constraints allowed in the language. For example, a system that allows linear inequalities on real-valued
variables might include a linear programming algorithm for solving those constraints. CLP
systems also adopt a much more flexible approach to solving standard logic programming
queries. For example, instead of depth-first, left-to-right backtracking, they might use any of
the more efficient algorithms discussed in Chapter 6, including heuristic conjunct ordering,
backjumping, cutset conditioning, and so on. CLP systems therefore combine elements of
constraint satisfaction algorithms, logic programming, and deductive databases.
Several systems that allow the programmer more control over the search order for inference have been defined. The MRS language (Genesereth and Smith, 1981; Russell, 1985)
METARULE allows the programmer to write metarules to determine which conjuncts are tried first. The
user could write a rule saying that the goal with the fewest variables should be tried first or
could write domain-specific rules for particular predicates.
9.5 RESOLUTION
The last of our three families of logical systems is based on resolution. We saw on page 250
that propositional resolution using refutation is a complete inference procedure for propositional logic. In this section, we describe how to extend resolution to first-order logic.
9.5.1 Conjunctive normal form for first-order logic
As in the propositional case, first-order resolution requires that sentences be in conjunctive
normal form (CNF)—that is, a conjunction of clauses, where each clause is a disjunction of
literals.6 Literals can contain variables, which are assumed to be universally quantified. For
example, the sentence
∀ x American(x) ∧ Weapon(y) ∧ Sells(x, y, z) ∧ Hostile(z) ⇒ Criminal(x)
becomes, in CNF,
¬American(x) ∨ ¬Weapon(y) ∨ ¬Sells(x, y, z) ∨ ¬Hostile(z) ∨ Criminal(x) .
Every sentence of first-order logic can be converted into an inferentially equivalent CNF
sentence. In particular, the CNF sentence will be unsatisfiable just when the original sentence
is unsatisfiable, so we have a basis for doing proofs by contradiction on the CNF sentences.
6 A clause can also be represented as an implication with a conjunction of atoms in the premise and a disjunction
of atoms in the conclusion (Exercise 7.13). This is called implicative normal form or Kowalski form (especially
when written with a right-to-left implication symbol (Kowalski, 1979)) and is often much easier to read.
346 Chapter 9. Inference in First-Order Logic
The procedure for conversion to CNF is similar to the propositional case, which we saw
on page 253. The principal difference arises from the need to eliminate existential quantifiers.
We illustrate the procedure by translating the sentence “Everyone who loves all animals is
loved by someone,” or
∀ x [∀ y Animal(y) ⇒ Loves(x, y)] ⇒ [∃ y Loves(y, x)] .
The steps are as follows:
• Eliminate implications:
∀ x [¬∀ y ¬Animal(y) ∨ Loves(x, y)] ∨ [∃ y Loves(y, x)] .
• Move ¬ inwards: In addition to the usual rules for negated connectives, we need rules
for negated quantifiers. Thus, we have
¬∀ x p becomes ∃ x ¬p
¬∃ x p becomes ∀ x ¬p .
Our sentence goes through the following transformations:
∀ x [∃ y ¬(¬Animal(y) ∨ Loves(x, y))] ∨ [∃ y Loves(y, x)] .
∀ x [∃ y ¬¬Animal(y) ∧ ¬Loves(x, y)] ∨ [∃ y Loves(y, x)] .
∀ x [∃ y Animal(y) ∧ ¬Loves(x, y)] ∨ [∃ y Loves(y, x)] .
Notice how a universal quantifier (∀ y) in the premise of the implication has become
an existential quantifier. The sentence now reads “Either there is some animal that x
doesn’t love, or (if this is not the case) someone loves x.” Clearly, the meaning of the
original sentence has been preserved.
• Standardize variables: For sentences like (∃ x P(x))∨(∃ x Q(x)) which use the same
variable name twice, change the name of one of the variables. This avoids confusion
later when we drop the quantifiers. Thus, we have
∀ x [∃ y Animal(y) ∧ ¬Loves(x, y)] ∨ [∃ z Loves(z, x)] .
SKOLEMIZATION • Skolemize: Skolemization is the process of removing existential quantifiers by elimination. In the simple case, it is just like the Existential Instantiation rule of Section 9.1:
translate ∃ x P(x) into P(A), where A is a new constant. However, we can’t apply Existential Instantiation to our sentence above because it doesn’t match the pattern ∃ v α;
only parts of the sentence match the pattern. If we blindly apply the rule to the two
matching parts we get
∀ x [Animal(A) ∧ ¬Loves(x, A)] ∨ Loves(B,x) ,
which has the wrong meaning entirely: it says that everyone either fails to love a particular animal A or is loved by some particular entity B. In fact, our original sentence
allows each person to fail to love a different animal or to be loved by a different person.
Thus, we want the Skolem entities to depend on x and z:
∀ x [Animal(F(x)) ∧ ¬Loves(x, F(x))] ∨ Loves(G(z), x) .
SKOLEM FUNCTION Here F and G are Skolem functions. The general rule is that the arguments of the
Skolem function are all the universally quantified variables in whose scope the existential quantifier appears. As with Existential Instantiation, the Skolemized sentence is
satisfiable exactly when the original sentence is satisfiable.
Section 9.5. Resolution 347
• Drop universal quantifiers: At this point, all remaining variables must be universally
quantified. Moreover, the sentence is equivalent to one in which all the universal quantifiers have been moved to the left. We can therefore drop the universal quantifiers:
[Animal(F(x)) ∧ ¬Loves(x, F(x))] ∨ Loves(G(z), x) .
• Distribute ∨ over ∧:
[Animal(F(x)) ∨ Loves(G(z), x)] ∧ [¬Loves(x, F(x)) ∨ Loves(G(z), x)] .
This step may also require flattening out nested conjunctions and disjunctions.
The sentence is now in CNF and consists of two clauses. It is quite unreadable. (It may
help to explain that the Skolem function F(x) refers to the animal potentially unloved by x,
whereas G(z) refers to someone who might love x.) Fortunately, humans seldom need look
at CNF sentences—the translation process is easily automated.
9.5.2 The resolution inference rule
The resolution rule for first-order clauses is simply a lifted version of the propositional resolution rule given on page 253. Two clauses, which are assumed to be standardized apart so
that they share no variables, can be resolved if they contain complementary literals. Propositional literals are complementary if one is the negation of the other; first-order literals are
complementary if one unifies with the negation of the other. Thus, we have
1 ∨···∨ k, m1 ∨···∨ mn
SUBST(θ, 1 ∨···∨ i−1 ∨ i+1 ∨···∨ k ∨ m1 ∨···∨ mj−1 ∨ mj+1 ∨···∨ mn)
where UNIFY(i,¬mj ) = θ. For example, we can resolve the two clauses
[Animal(F(x)) ∨ Loves(G(x), x)] and [¬Loves(u, v) ∨ ¬Kills(u, v)]
by eliminating the complementary literals Loves(G(x), x) and ¬Loves(u, v), with unifier
θ = {u/G(x), v/x}, to produce the resolvent clause
[Animal(F(x)) ∨ ¬Kills(G(x), x)] .
BINARY RESOLUTION This rule is called the binary resolution rule because it resolves exactly two literals. The
binary resolution rule by itself does not yield a complete inference procedure. The full resolution rule resolves subsets of literals in each clause that are unifiable. An alternative approach
is to extend factoring—the removal of redundant literals—to the first-order case. Propositional factoring reduces two literals to one if they are identical; first-order factoring reduces
two literals to one if they are unifiable. The unifier must be applied to the entire clause. The
combination of binary resolution and factoring is complete.
9.5.3 Example proofs
Resolution proves that KB |= α by proving KB ∧ ¬α unsatisfiable, that is, by deriving the
empty clause. The algorithmic approach is identical to the propositional case, described in
348 Chapter 9. Inference in First-Order Logic
¬American(x) ¬Weapon(y) ¬Sells(x,y,z) ¬Hostile(z) Criminal(x) ¬Criminal(West)
Enemy(Nono,America) ¬Enemy(Nono, America)
¬Missile(x) Weapon(x) ¬Weapon(y) ¬Sells(West,y,z) ¬Hostile(z)
Missile(M1) ¬Missile(y) ¬Sells(West,y,z) ¬Hostile(z)
¬Missile(x) ¬Owns(Nono,x) Sells(West,x,Nono) ¬Sells(West,M1,z) ¬Hostile(z)
American(West) ¬American(West) ¬Weapon(y) ¬Sells(West,y,z) ¬Hostile(z)
¬Missile(M1) ¬Owns(Nono,M1 Missile(M ) ¬Hostile(Nono) 1)
¬Owns(Nono,M1 Owns(Nono,M ) ¬Hostile(Nono) 1)
¬Enemy(x,America) Hostile(x) ¬Hostile(Nono)
^ ^ ^ ^
^ ^ ^
^ ^ ^
^ ^
^ ^ ^
^ ^
^
^
Figure 9.11 A resolution proof that West is a criminal. At each step, the literals that unify
are in bold.
Figure 7.12, so we need not repeat it here. Instead, we give two example proofs. The first is
the crime example from Section 9.3. The sentences in CNF are
¬American(x) ∨ ¬Weapon(y) ∨ ¬Sells(x, y, z) ∨ ¬Hostile(z) ∨ Criminal(x)
¬Missile(x) ∨ ¬Owns(Nono, x) ∨ Sells(West, x, Nono)
¬Enemy(x, America) ∨ Hostile(x)
¬Missile(x) ∨ Weapon(x)
Owns(Nono, M1) Missile(M1)
American(West) Enemy(Nono, America) .
We also include the negated goal ¬Criminal(West). The resolution proof is shown in Figure 9.11. Notice the structure: single “spine” beginning with the goal clause, resolving against
clauses from the knowledge base until the empty clause is generated. This is characteristic
of resolution on Horn clause knowledge bases. In fact, the clauses along the main spine
correspond exactly to the consecutive values of the goals variable in the backward-chaining
algorithm of Figure 9.6. This is because we always choose to resolve with a clause whose
positive literal unified with the leftmost literal of the “current” clause on the spine; this is
exactly what happens in backward chaining. Thus, backward chaining is just a special case
of resolution with a particular control strategy to decide which resolution to perform next.
Our second example makes use of Skolemization and involves clauses that are not definite clauses. This results in a somewhat more complex proof structure. In English, the
problem is as follows:
Everyone who loves all animals is loved by someone.
Anyone who kills an animal is loved by no one.
Jack loves all animals.
Either Jack or Curiosity killed the cat, who is named Tuna.
Did Curiosity kill the cat?
Section 9.5. Resolution 349
First, we express the original sentences, some background knowledge, and the negated goal
G in first-order logic:
A. ∀ x [∀ y Animal(y) ⇒ Loves(x, y)] ⇒ [∃ y Loves(y, x)]
B. ∀ x [∃ z Animal(z) ∧ Kills(x, z)] ⇒ [∀ y ¬Loves(y, x)]
C. ∀ x Animal(x) ⇒ Loves(Jack, x)
D. Kills(Jack, Tuna) ∨ Kills(Curiosity, Tuna)
E. Cat(Tuna)
F. ∀ x Cat(x) ⇒ Animal(x)
¬G. ¬Kills(Curiosity, Tuna)
Now we apply the conversion procedure to convert each sentence to CNF:
A1. Animal(F(x)) ∨ Loves(G(x), x)
A2. ¬Loves(x, F(x)) ∨ Loves(G(x), x)
B. ¬Loves(y, x) ∨ ¬Animal(z) ∨ ¬Kills(x, z)
C. ¬Animal(x) ∨ Loves(Jack, x)
D. Kills(Jack, Tuna) ∨ Kills(Curiosity, Tuna)
E. Cat(Tuna)
F. ¬Cat(x) ∨ Animal(x)
¬G. ¬Kills(Curiosity, Tuna)
The resolution proof that Curiosity killed the cat is given in Figure 9.12. In English, the proof
could be paraphrased as follows:
Suppose Curiosity did not kill Tuna. We know that either Jack or Curiosity did; thus
Jack must have. Now, Tuna is a cat and cats are animals, so Tuna is an animal. Because
anyone who kills an animal is loved by no one, we know that no one loves Jack. On the
other hand, Jack loves all animals, so someone loves him; so we have a contradiction.
Therefore, Curiosity killed the cat.
¬Loves(y, Jack) Loves(G(Jack), Jack)
Cat(Tuna) ¬Cat(x) Animal(x) Kills(Jack, Tuna) Kills(Curiosity, Tuna) ¬Kills(Curiosity, Tuna)
¬Loves(y, x) ¬Kills(x, Tuna) ¬Animal(F(Jack)) Loves(G(Jack), Jack) Animal(F(x)) Loves(G(x), x)
Animal(Tuna) ¬Loves(y, x) ¬Animal(z) ¬Kills(x, z) Kills(Jack, Tuna) ¬Loves(x,F(x)) Loves(G(x), x) ¬Animal(x) Loves(Jack, x)
^ ^
^ ^ ^ ^
^^ ^
Figure 9.12 A resolution proof that Curiosity killed the cat. Notice the use of factoring
in the derivation of the clause Loves(G(Jack ), Jack). Notice also in the upper right, the
unification of Loves(x, F(x)) and Loves(Jack, x) can only succeed after the variables have
been standardized apart.
350 Chapter 9. Inference in First-Order Logic
The proof answers the question “Did Curiosity kill the cat?” but often we want to pose more
general questions, such as “Who killed the cat?” Resolution can do this, but it takes a little
more work to obtain the answer. The goal is ∃ w Kills(w, Tuna), which, when negated,
becomes ¬Kills(w, Tuna) in CNF. Repeating the proof in Figure 9.12 with the new negated
goal, we obtain a similar proof tree, but with the substitution {w/Curiosity} in one of the
steps. So, in this case, finding out who killed the cat is just a matter of keeping track of the
bindings for the query variables in the proof.
Unfortunately, resolution can produce nonconstructive proofs for existential goals. NONCONSTRUCTIVE
PROOF
For example, ¬Kills(w, Tuna) resolves with Kills(Jack, Tuna) ∨ Kills(Curiosity, Tuna)
to give Kills(Jack, Tuna), which resolves again with ¬Kills(w, Tuna) to yield the empty
clause. Notice that w has two different bindings in this proof; resolution is telling us that,
yes, someone killed Tuna—either Jack or Curiosity. This is no great surprise! One solution is to restrict the allowed resolution steps so that the query variables can be bound
only once in a given proof; then we need to be able to backtrack over the possible bindANSWER LITERAL ings. Another solution is to add a special answer literal to the negated goal, which becomes ¬Kills(w, Tuna) ∨ Answer (w). Now, the resolution process generates an answer
whenever a clause is generated containing just a single answer literal. For the proof in Figure 9.12, this is Answer(Curiosity). The nonconstructive proof would generate the clause
Answer (Curiosity) ∨ Answer(Jack), which does not constitute an answer.
9.5.4 Completeness of resolution
This section gives a completeness proof of resolution. It can be safely skipped by those who
are willing to take it on faith.
We show that resolution is refutation-complete, which means that if a set of sentences REFUTATION
COMPLETENESS
is unsatisfiable, then resolution will always be able to derive a contradiction. Resolution
cannot be used to generate all logical consequences of a set of sentences, but it can be used
to establish that a given sentence is entailed by the set of sentences. Hence, it can be used to
find all answers to a given question, Q(x), by proving that KB ∧ ¬Q(x) is unsatisfiable.
We take it as given that any sentence in first-order logic (without equality) can be rewritten as a set of clauses in CNF. This can be proved by induction on the form of the sentence,
using atomic sentences as the base case (Davis and Putnam, 1960). Our goal therefore is to
prove the following: if S is an unsatisfiable set of clauses, then the application of a finite
number of resolution steps to S will yield a contradiction.
Our proof sketch follows Robinson’s original proof with some simplifications from
Genesereth and Nilsson (1987). The basic structure of the proof (Figure 9.13) is as follows:
1. First, we observe that if S is unsatisfiable, then there exists a particular set of ground
instances of the clauses of S such that this set is also unsatisfiable (Herbrand’s theorem).
2. We then appeal to the ground resolution theorem given in Chapter 7, which states that
propositional resolution is complete for ground sentences.
3. We then use a lifting lemma to show that, for any propositional resolution proof using
the set of ground sentences, there is a corresponding first-order resolution proof using
the first-order sentences from which the ground sentences were obtained.
Section 9.5. Resolution 351
Resolution can find a contradiction in S'
There is a resolution proof for the contradiction in S'
Herbrand’s theorem
Some set S' of ground instances is unsatisfiable
Any set of sentences S is representable in clausal form
Assume S is unsatisfiable, and in clausal form
Lifting lemma
Ground resolution
theorem
Figure 9.13 Structure of a completeness proof for resolution.
To carry out the first step, we need three new concepts:
• Herbrand universe: If S is a set of clauses, then HS, the Herbrand universe of S, is HERBRAND
UNIVERSE
the set of all ground terms constructable from the following:
a. The function symbols in S, if any.
b. The constant symbols in S, if any; if none, then the constant symbol A.
For example, if S contains just the clause ¬P(x, F(x, A))∨ ¬Q(x, A)∨ R(x, B), then
HS is the following infinite set of ground terms:
{A, B, F(A, A), F(A, B), F(B,A), F(B,B), F(A, F(A, A)),...} .
SATURATION • Saturation: If S is a set of clauses and P is a set of ground terms, then P(S), the
saturation of S with respect to P, is the set of all ground clauses obtained by applying
all possible consistent substitutions of ground terms in P with variables in S.
HERBRAND BASE • Herbrand base: The saturation of a set S of clauses with respect to its Herbrand universe is called the Herbrand base of S, written as HS(S). For example, if S contains
solely the clause just given, then HS(S) is the infinite set of clauses
{¬P(A, F(A, A)) ∨ ¬Q(A, A) ∨ R(A, B),
¬P(B,F(B,A)) ∨ ¬Q(B,A) ∨ R(B,B),
¬P(F(A, A), F(F(A, A), A)) ∨ ¬Q(F(A, A), A) ∨ R(F(A, A), B),
¬P(F(A, B), F(F(A, B), A)) ∨ ¬Q(F(A, B), A) ∨ R(F(A, B), B),... }
These definitions allow us to state a form of Herbrand’s theorem (Herbrand, 1930): HERBRAND’S
THEOREM
If a set S of clauses is unsatisfiable, then there exists a finite subset of HS(S) that
is also unsatisfiable.
Let S be this finite subset of ground sentences. Now, we can appeal to the ground resolution
theorem (page 255) to show that the resolution closure RC(S
) contains the empty clause.
That is, running propositional resolution to completion on S will derive a contradiction.
Now that we have established that there is always a resolution proof involving some
finite subset of the Herbrand base of S, the next step is to show that there is a resolution
352 Chapter 9. Inference in First-Order Logic
GODEL ¨ ’S INCOMPLETENESS THEOREM
By slightly extending the language of first-order logic to allow for the mathematical induction schema in arithmetic, Kurt G¨odel was able to show, in his incompleteness theorem, that there are true arithmetic sentences that cannot be proved.
The proof of the incompleteness theorem is somewhat beyond the scope of
this book, occupying, as it does, at least 30 pages, but we can give a hint here. We
begin with the logical theory of numbers. In this theory, there is a single constant,
0, and a single function, S (the successor function). In the intended model, S(0)
denotes 1, S(S(0)) denotes 2, and so on; the language therefore has names for all
the natural numbers. The vocabulary also includes the function symbols +, ×, and
Expt (exponentiation) and the usual set of logical connectives and quantifiers. The
first step is to notice that the set of sentences that we can write in this language can
be enumerated. (Imagine defining an alphabetical order on the symbols and then
arranging, in alphabetical order, each of the sets of sentences of length 1, 2, and
so on.) We can then number each sentence α with a unique natural number #α
(the Godel number ¨ ). This is crucial: number theory contains a name for each of
its own sentences. Similarly, we can number each possible proof P with a G¨odel
number G(P), because a proof is simply a finite sequence of sentences.
Now suppose we have a recursively enumerable set A of sentences that are
true statements about the natural numbers. Recalling that A can be named by a
given set of integers, we can imagine writing in our language a sentence α(j, A) of
the following sort:
∀ i i is not the G¨odel number of a proof of the sentence whose G¨odel
number is j, where the proof uses only premises in A.
Then let σ be the sentence α(#σ, A), that is, a sentence that states its own unprovability from A. (That this sentence always exists is true but not entirely obvious.)
Now we make the following ingenious argument: Suppose that σ is provable
from A; then σ is false (because σ says it cannot be proved). But then we have a
false sentence that is provable from A, so A cannot consist of only true sentences—
a violation of our premise. Therefore, σ is not provable from A. But this is exactly
what σ itself claims; hence σ is a true sentence.
So, we have shown (barring 29 1
2 pages) that for any set of true sentences of
number theory, and in particular any set of basic axioms, there are other true sentences that cannot be proved from those axioms. This establishes, among other
things, that we can never prove all the theorems of mathematics within any given
system of axioms. Clearly, this was an important discovery for mathematics. Its
significance for AI has been widely debated, beginning with speculations by G¨odel
himself. We take up the debate in Chapter 26.
Section 9.5. Resolution 353
proof using the clauses of S itself, which are not necessarily ground clauses. We start by
considering a single application of the resolution rule. Robinson stated this lemma:
Let C1 and C2 be two clauses with no shared variables, and let C
1 and C
2 be
ground instances of C1 and C2. If C is a resolvent of C
1 and C
2, then there exists
a clause C such that (1) C is a resolvent of C1 and C2 and (2) C is a ground
instance of C.
LIFTING LEMMA This is called a lifting lemma, because it lifts a proof step from ground clauses up to general
first-order clauses. In order to prove his basic lifting lemma, Robinson had to invent unification and derive all of the properties of most general unifiers. Rather than repeat the proof
here, we simply illustrate the lemma:
C1 = ¬P(x, F(x, A)) ∨ ¬Q(x, A) ∨ R(x, B)
C2 = ¬N(G(y), z) ∨ P(H(y), z)
C
1 = ¬P(H(B), F(H(B), A)) ∨ ¬Q(H(B), A) ∨ R(H(B), B)
C
2 = ¬N(G(B), F(H(B), A)) ∨ P(H(B), F(H(B), A))
C = ¬N(G(B), F(H(B), A)) ∨ ¬Q(H(B), A) ∨ R(H(B), B)
C = ¬N(G(y), F(H(y), A)) ∨ ¬Q(H(y), A) ∨ R(H(y), B) .
We see that indeed C is a ground instance of C. In general, for C
1 and C
2 to have any
resolvents, they must be constructed by first applying to C1 and C2 the most general unifier
of a pair of complementary literals in C1 and C2. From the lifting lemma, it is easy to derive
a similar statement about any sequence of applications of the resolution rule:
For any clause C in the resolution closure of S there is a clause C in the resolution closure of S such that C is a ground instance of C and the derivation of C is
the same length as the derivation of C
.
From this fact, it follows that if the empty clause appears in the resolution closure of S
, it
must also appear in the resolution closure of S. This is because the empty clause cannot be a
ground instance of any other clause. To recap: we have shown that if S is unsatisfiable, then
there is a finite derivation of the empty clause using the resolution rule.
The lifting of theorem proving from ground clauses to first-order clauses provides a vast
increase in power. This increase comes from the fact that the first-order proof need instantiate
variables only as far as necessary for the proof, whereas the ground-clause methods were
required to examine a huge number of arbitrary instantiations.
9.5.5 Equality
None of the inference methods described so far in this chapter handle an assertion of the form
x = y. Three distinct approaches can be taken. The first approach is to axiomatize equality—
to write down sentences about the equality relation in the knowledge base. We need to say that
equality is reflexive, symmetric, and transitive, and we also have to say that we can substitute
equals for equals in any predicate or function. So we need three basic axioms, and then one
354 Chapter 9. Inference in First-Order Logic
for each predicate and function:
∀ x x = x
∀ x, y x = y ⇒ y = x
∀ x, y, z x = y ∧ y = z ⇒ x = z
∀ x, y x = y ⇒ (P1(x) ⇔ P1(y))
∀ x, y x = y ⇒ (P2(x) ⇔ P2(y))
.
.
.
∀ w, x, y, z w = y ∧ x = z ⇒ (F1(w, x) = F1(y, z))
∀ w, x, y, z w = y ∧ x = z ⇒ (F2(w, x) = F2(y, z))
.
.
.
Given these sentences, a standard inference procedure such as resolution can perform tasks
requiring equality reasoning, such as solving mathematical equations. However, these axioms
will generate a lot of conclusions, most of them not helpful to a proof. So there has been a
search for more efficient ways of handling equality. One alternative is to add inference rules
rather than axioms. The simplest rule, demodulation, takes a unit clause x = y and some
clause α that contains the term x, and yields a new clause formed by substituting y for x
within α. It works if the term within α unifies with x; it need not be exactly equal to x.
Note that demodulation is directional; given x = y, the x always gets replaced with y, never
vice versa. That means that demodulation can be used for simplifying expressions using
demodulators such as x +0= x or x1 = x. As another example, given
Father (Father (x)) = PaternalGrandfather (x)
Birthdate(Father (Father (Bella)), 1926)
we can conclude by demodulation
Birthdate(PaternalGrandfather (Bella), 1926) .
More formally, we have
• Demodulation: For any terms x, y, and z, where z appears somewhere in literal mi DEMODULATION
and where UNIFY(x, z) = θ,
x = y, m1 ∨···∨ mn
SUB(SUBST(θ, x), SUBST(θ, y), m1 ∨···∨ mn) .
where SUBST is the usual substitution of a binding list, and SUB(x, y, m) means to
replace x with y everywhere that x occurs within m.
The rule can also be extended to handle non-unit clauses in which an equality literal appears:
• Paramodulation: For any terms x, y, and z, where z appears somewhere in literal mi PARAMODULATION ,
and where UNIFY(x, z) = θ,
1 ∨···∨ k ∨ x = y, m1 ∨···∨ mn
SUB(SUBST(θ, x), SUBST(θ, y), SUBST(θ, 1 ∨···∨ k ∨ m1 ∨···∨ mn) .
For example, from
P(F(x, B), x) ∨ Q(x) and F(A, y) = y ∨ R(y)
Section 9.5. Resolution 355
we have θ = UNIFY(F(A, y), F(x, B)) = {x/A, y/B}, and we can conclude by paramodulation the sentence
P(B,A) ∨ Q(A) ∨ R(B) .
Paramodulation yields a complete inference procedure for first-order logic with equality.
A third approach handles equality reasoning entirely within an extended unification
algorithm. That is, terms are unifiable if they are provably equal under some substitution,
where “provably” allows for equality reasoning. For example, the terms 1+2 and 2+1
normally are not unifiable, but a unification algorithm that knows that x + y = y + x could
unify them with the empty substitution. Equational unification of this kind can be done with EQUATIONAL
UNIFICATION
efficient algorithms designed for the particular axioms used (commutativity, associativity, and
so on) rather than through explicit inference with those axioms. Theorem provers using this
technique are closely related to the CLP systems described in Section 9.4.
9.5.6 Resolution strategies
We know that repeated applications of the resolution inference rule will eventually find a
proof if one exists. In this subsection, we examine strategies that help find proofs efficiently.
UNIT PREFERENCE Unit preference: This strategy prefers to do resolutions where one of the sentences is a single
literal (also known as a unit clause). The idea behind the strategy is that we are trying to
produce an empty clause, so it might be a good idea to prefer inferences that produce shorter
clauses. Resolving a unit sentence (such as P) with any other sentence (such as ¬P ∨¬Q∨R)
always yields a clause (in this case, ¬Q ∨ R) that is shorter than the other clause. When
the unit preference strategy was first tried for propositional inference in 1964, it led to a
dramatic speedup, making it feasible to prove theorems that could not be handled without the
preference. Unit resolution is a restricted form of resolution in which every resolution step
must involve a unit clause. Unit resolution is incomplete in general, but complete for Horn
clauses. Unit resolution proofs on Horn clauses resemble forward chaining.
The OTTER theorem prover (Organized Techniques for Theorem-proving and Effective
Research, McCune, 1992), uses a form of best-first search. Its heuristic function measures
the “weight” of each clause, where lighter clauses are preferred. The exact choice of heuristic
is up to the user, but generally, the weight of a clause should be correlated with its size or
difficulty. Unit clauses are treated as light; the search can thus be seen as a generalization of
the unit preference strategy.
SET OF SUPPORT Set of support: Preferences that try certain resolutions first are helpful, but in general it is
more effective to try to eliminate some potential resolutions altogether. For example, we can
insist that every resolution step involve at least one element of a special set of clauses—the
set of support. The resolvent is then added into the set of support. If the set of support is
small relative to the whole knowledge base, the search space will be reduced dramatically.
We have to be careful with this approach because a bad choice for the set of support
will make the algorithm incomplete. However, if we choose the set of support S so that the
remainder of the sentences are jointly satisfiable, then set-of-support resolution is complete.
For example, one can use the negated query as the set of support, on the assumption that the
356 Chapter 9. Inference in First-Order Logic
original knowledge base is consistent. (After all, if it is not consistent, then the fact that the
query follows from it is vacuous.) The set-of-support strategy has the additional advantage of
generating goal-directed proof trees that are often easy for humans to understand.
INPUT RESOLUTION Input resolution: In this strategy, every resolution combines one of the input sentences (from
the KB or the query) with some other sentence. The proof in Figure 9.11 on page 348 uses
only input resolutions and has the characteristic shape of a single “spine” with single sentences combining onto the spine. Clearly, the space of proof trees of this shape is smaller
than the space of all proof graphs. In Horn knowledge bases, Modus Ponens is a kind of
input resolution strategy, because it combines an implication from the original KB with some
other sentences. Thus, it is no surprise that input resolution is complete for knowledge bases
LINEAR RESOLUTION that are in Horn form, but incomplete in the general case. The linear resolution strategy is a
slight generalization that allows P and Q to be resolved together either if P is in the original
KB or if P is an ancestor of Q in the proof tree. Linear resolution is complete.
SUBSUMPTION Subsumption: The subsumption method eliminates all sentences that are subsumed by (that
is, more specific than) an existing sentence in the KB. For example, if P(x) is in the KB, then
there is no sense in adding P(A) and even less sense in adding P(A) ∨ Q(B). Subsumption
helps keep the KB small and thus helps keep the search space small.
Practical uses of resolution theorem provers
SYNTHESIS Theorem provers can be applied to the problems involved in the synthesis and verification
VERIFICATION of both hardware and software. Thus, theorem-proving research is carried out in the fields of
hardware design, programming languages, and software engineering—not just in AI.
In the case of hardware, the axioms describe the interactions between signals and circuit elements. (See Section 8.4.2 on page 309 for an example.) Logical reasoners designed
specially for verification have been able to verify entire CPUs, including their timing properties (Srivas and Bickford, 1990). The AURA theorem prover has been applied to design
circuits that are more compact than any previous design (Wojciechowski and Wojcik, 1983).
In the case of software, reasoning about programs is quite similar to reasoning about
actions, as in Chapter 7: axioms describe the preconditions and effects of each statement.
The formal synthesis of algorithms was one of the first uses of theorem provers, as outlined
by Cordell Green (1969a), who built on earlier ideas by Herbert Simon (1963). The idea
is to constructively prove a theorem to the effect that “there exists a program p satisfying a
certain specification.” Although fully automated deductive synthesis, as it is called, has not DEDUCTIVE
SYNTHESIS
yet become feasible for general-purpose programming, hand-guided deductive synthesis has
been successful in designing several novel and sophisticated algorithms. Synthesis of specialpurpose programs, such as scientific computing code, is also an active area of research.
Similar techniques are now being applied to software verification by systems such as the
SPIN model checker (Holzmann, 1997). For example, the Remote Agent spacecraft control
program was verified before and after flight (Havelund et al., 2000). The RSA public key
encryption algorithm and the Boyer–Moore string-matching algorithm have been verified this
way (Boyer and Moore, 1984).
Section 9.6. Summary 357
9.6 SUMMARY
We have presented an analysis of logical inference in first-order logic and a number of algorithms for doing it.
• A first approach uses inference rules (universal instantiation and existential instantiation) to propositionalize the inference problem. Typically, this approach is slow,
unless the domain is small.
• The use of unification to identify appropriate substitutions for variables eliminates the
instantiation step in first-order proofs, making the process more efficient in many cases.
• A lifted version of Modus Ponens uses unification to provide a natural and powerful
inference rule, generalized Modus Ponens. The forward-chaining and backwardchaining algorithms apply this rule to sets of definite clauses.
• Generalized Modus Ponens is complete for definite clauses, although the entailment
problem is semidecidable. For Datalog knowledge bases consisting of function-free
definite clauses, entailment is decidable.
• Forward chaining is used in deductive databases, where it can be combined with relational database operations. It is also used in production systems, which perform
efficient updates with very large rule sets. Forward chaining is complete for Datalog
and runs in polynomial time.
• Backward chaining is used in logic programming systems, which employ sophisticated compiler technology to provide very fast inference. Backward chaining suffers
from redundant inferences and infinite loops; these can be alleviated by memoization.
• Prolog, unlike first-order logic, uses a closed world with the unique names assumption
and negation as failure. These make Prolog a more practical programming language,
but bring it further from pure logic.
• The generalized resolution inference rule provides a complete proof system for firstorder logic, using knowledge bases in conjunctive normal form.
• Several strategies exist for reducing the search space of a resolution system without
compromising completeness. One of the most important issues is dealing with equality;
we showed how demodulation and paramodulation can be used.
• Efficient resolution-based theorem provers have been used to prove interesting mathematical theorems and to verify and synthesize software and hardware.
BIBLIOGRAPHICAL AND HISTORICAL NOTES
Gottlob Frege, who developed full first-order logic in 1879, based his system of inference
on a collection of valid schemas plus a single inference rule, Modus Ponens. Whitehead
and Russell (1910) expounded the so-called rules of passage (the actual term is from Herbrand (1930)) that are used to move quantifiers to the front of formulas. Skolem constants
358 Chapter 9. Inference in First-Order Logic
and Skolem functions were introduced, appropriately enough, by Thoralf Skolem (1920).
Oddly enough, it was Skolem who introduced the Herbrand universe (Skolem, 1928).
Herbrand’s theorem (Herbrand, 1930) has played a vital role in the development of
automated reasoning. Herbrand is also the inventor of unification. G¨odel (1930) built on
the ideas of Skolem and Herbrand to show that first-order logic has a complete proof procedure. Alan Turing (1936) and Alonzo Church (1936) simultaneously showed, using very
different proofs, that validity in first-order logic was not decidable. The excellent text by
Enderton (1972) explains all of these results in a rigorous yet understandable fashion.
Abraham Robinson proposed that an automated reasoner could be built using propositionalization and Herbrand’s theorem, and Paul Gilmore (1960) wrote the first program. Davis
and Putnam (1960) introduced the propositionalization method of Section 9.1. Prawitz (1960)
developed the key idea of letting the quest for propositional inconsistency drive the search,
and generating terms from the Herbrand universe only when they were necessary to establish propositional inconsistency. After further development by other researchers, this idea led
J. A. Robinson (no relation) to develop resolution (Robinson, 1965).
In AI, resolution was adopted for question-answering systems by Cordell Green and
Bertram Raphael (1968). Early AI implementations put a good deal of effort into data structures that would allow efficient retrieval of facts; this work is covered in AI programming
texts (Charniak et al., 1987; Norvig, 1992; Forbus and de Kleer, 1993). By the early 1970s,
forward chaining was well established in AI as an easily understandable alternative to resolution. AI applications typically involved large numbers of rules, so it was important to
develop efficient rule-matching technology, particularly for incremental updates. The technology for production systems was developed to support such applications. The production
system language OPS-5 (Forgy, 1981; Brownston et al., 1985), incorporating the efficient
RETE rete match process (Forgy, 1982), was used for applications such as the R1 expert system for
minicomputer configuration (McDermott, 1982).
The SOAR cognitive architecture (Laird et al., 1987; Laird, 2008) was designed to handle very large rule sets—up to a million rules (Doorenbos, 1994). Example applications of
SOAR include controlling simulated fighter aircraft (Jones et al., 1998), airspace management (Taylor et al., 2007), AI characters for computer games (Wintermute et al., 2007), and
training tools for soldiers (Wray and Jones, 2005).
The field of deductive databases began with a workshop in Toulouse in 1977 that
brought together experts in logical inference and database systems (Gallaire and Minker,
1978). Influential work by Chandra and Harel (1980) and Ullman (1985) led to the adoption
of Datalog as a standard language for deductive databases. The development of the magic sets
technique for rule rewriting by Bancilhon et al. (1986) allowed forward chaining to borrow
the advantage of goal-directedness from backward chaining. Current work includes the idea
of integrating multiple databases into a consistent dataspace (Halevy, 2007).
Backward chaining for logical inference appeared first in Hewitt’s PLANNER language (1969). Meanwhile, in 1972, Alain Colmerauer had developed and implemented Prolog for the purpose of parsing natural language—Prolog’s clauses were intended initially
as context-free grammar rules (Roussel, 1975; Colmerauer et al., 1973). Much of the theoretical background for logic programming was developed by Robert Kowalski, working
Bibliographical and Historical Notes 359
with Colmerauer; see Kowalski (1988) and Colmerauer and Roussel (1993) for a historical
overview. Efficient Prolog compilers are generally based on the Warren Abstract Machine
(WAM) model of computation developed by David H. D. Warren (1983). Van Roy (1990)
showed that Prolog programs can be competitive with C programs in terms of speed.
Methods for avoiding unnecessary looping in recursive logic programs were developed
independently by Smith et al. (1986) and Tamaki and Sato (1986). The latter paper also
included memoization for logic programs, a method developed extensively as tabled logic
programming by David S. Warren. Swift and Warren (1994) show how to extend the WAM
to handle tabling, enabling Datalog programs to execute an order of magnitude faster than
forward-chaining deductive database systems.
Early work on constraint logic programming was done by Jaffar and Lassez (1987).
Jaffar et al. (1992) developed the CLP(R) system for handling real-valued constraints. There
are now commercial products for solving large-scale configuration and optimization problems
with constraint programming; one of the best known is ILOG (Junker, 2003). Answer set
programming (Gelfond, 2008) extends Prolog, allowing disjunction and negation.
Texts on logic programming and Prolog, including Shoham (1994), Bratko (2001),
Clocksin (2003), and Clocksin and Mellish (2003). Prior to 2000, the Journal of Logic Programming was the journal of record; it has now been replaced by Theory and Practice of
Logic Programming. Logic programming conferences include the International Conference
on Logic Programming (ICLP) and the International Logic Programming Symposium (ILPS).
Research into mathematical theorem proving began even before the first complete
first-order systems were developed. Herbert Gelernter’s Geometry Theorem Prover (Gelernter, 1959) used heuristic search methods combined with diagrams for pruning false subgoals
and was able to prove some quite intricate results in Euclidean geometry. The demodulation and paramodulation rules for equality reasoning were introduced by Wos et al. (1967)
and Wos and Robinson (1968), respectively. These rules were also developed independently
in the context of term-rewriting systems (Knuth and Bendix, 1970). The incorporation of
equality reasoning into the unification algorithm is due to Gordon Plotkin (1972). Jouannaud
and Kirchner (1991) survey equational unification from a term-rewriting perspective. An
overview of unification is given by Baader and Snyder (2001).
A number of control strategies have been proposed for resolution, beginning with the
unit preference strategy (Wos et al., 1964). The set-of-support strategy was proposed by Wos
et al. (1965) to provide a degree of goal-directedness in resolution. Linear resolution first
appeared in Loveland (1970). Genesereth and Nilsson (1987, Chapter 5) provide a short but
thorough analysis of a wide variety of control strategies.
A Computational Logic (Boyer and Moore, 1979) is the basic reference on the BoyerMoore theorem prover. Stickel (1992) covers the Prolog Technology Theorem Prover (PTTP),
which combines the advantages of Prolog compilation with the completeness of model elimination. SETHEO (Letz et al., 1992) is another widely used theorem prover based on this approach. LEANTAP (Beckert and Posegga, 1995) is an efficient theorem prover implemented
in only 25 lines of Prolog. Weidenbach (2001) describes SPASS, one of the strongest current
theorem provers. The most successful theorem prover in recent annual competitions has been
VAMPIRE (Riazanov and Voronkov, 2002). The COQ system (Bertot et al., 2004) and the E
360 Chapter 9. Inference in First-Order Logic
equational solver (Schulz, 2004) have also proven to be valuable tools for proving correctness. Theorem provers have been used to automatically synthesize and verify software for
controlling spacecraft (Denney et al., 2006), including NASA’s new Orion capsule (Lowry,
2008). The design of the FM9001 32-bit microprocessor was proved correct by the NQTHM
system (Hunt and Brock, 1992). The Conference on Automated Deduction (CADE) runs an
annual contest for automated theorem provers. From 2002 through 2008, the most successful
system has been VAMPIRE (Riazanov and Voronkov, 2002). Wiedijk (2003) compares the
strength of 15 mathematical provers. TPTP (Thousands of Problems for Theorem Provers)
is a library of theorem-proving problems, useful for comparing the performance of systems
(Sutcliffe and Suttner, 1998; Sutcliffe et al., 2006).
Theorem provers have come up with novel mathematical results that eluded human
mathematicians for decades, as detailed in the book Automated Reasoning and the Discovery of Missing Elegant Proofs (Wos and Pieper, 2003). The SAM (Semi-Automated Mathematics) program was the first, proving a lemma in lattice theory (Guard et al., 1969). The
AURA program has also answered open questions in several areas of mathematics (Wos and
Winker, 1983). The Boyer–Moore theorem prover (Boyer and Moore, 1979) was used by
Natarajan Shankar to give the first fully rigorous formal proof of G¨odel’s Incompleteness
Theorem (Shankar, 1986). The NUPRL system proved Girard’s paradox (Howe, 1987) and
Higman’s Lemma (Murthy and Russell, 1990). In 1933, Herbert Robbins proposed a simple
ROBBINS ALGEBRA set of axioms—the Robbins algebra—that appeared to define Boolean algebra, but no proof
could be found (despite serious work by Alfred Tarski and others). On October 10, 1996,
after eight days of computation, EQP (a version of OTTER) found a proof (McCune, 1997).
Many early papers in mathematical logic are to be found in From Frege to Godel: ¨
A Source Book in Mathematical Logic (van Heijenoort, 1967). Textbooks geared toward
automated deduction include the classic Symbolic Logic and Mechanical Theorem Proving (Chang and Lee, 1973), as well as more recent works by Duffy (1991), Wos et al. (1992),
Bibel (1993), and Kaufmann et al. (2000). The principal journal for theorem proving is the
Journal of Automated Reasoning; the main conferences are the annual Conference on Automated Deduction (CADE) and the International Joint Conference on Automated Reasoning
(IJCAR). The Handbook of Automated Reasoning (Robinson and Voronkov, 2001) collects
papers in the field. MacKenzie’s Mechanizing Proof (2004) covers the history and technology
of theorem proving for the popular audience.
EXERCISES
9.1 Prove that Universal Instantiation is sound and that Existential Instantiation produces
an inferentially equivalent knowledge base.
9.2 From Likes(Jerry,IceCream) it seems reasonable to infer ∃ x Likes(x,IceCream).
Write down a general inference rule, Existential Introduction, that sanctions this inference. EXISTENTIAL
INTRODUCTION
State carefully the conditions that must be satisfied by the variables and terms involved.
Exercises 361
9.3 Suppose a knowledge base contains just one sentence, ∃ x AsHighAs(x,Everest).
Which of the following are legitimate results of applying Existential Instantiation?
a. AsHighAs(Everest,Everest).
b. AsHighAs(Kilimanjaro,Everest).
c. AsHighAs(Kilimanjaro,Everest) ∧ AsHighAs(BenNevis,Everest)
(after two applications).
9.4 For each pair of atomic sentences, give the most general unifier if it exists:
a. P(A, B, B), P(x, y, z).
b. Q(y,G(A, B)), Q(G(x, x), y).
c. Older(Father (y), y), Older (Father (x), John).
d. Knows(Father (y), y), Knows(x, x).
9.5 Consider the subsumption lattices shown in Figure 9.2 (page 329).
a. Construct the lattice for the sentence Employs(Mother (John),Father (Richard)).
b. Construct the lattice for the sentence Employs(IBM , y) (“Everyone works for IBM”).
Remember to include every kind of query that unifies with the sentence.
c. Assume that STORE indexes each sentence under every node in its subsumption lattice.
Explain how FETCH should work when some of these sentences contain variables; use
as examples the sentences in (a) and (b) and the query Employs(x,Father (x)).
9.6 Write down logical representations for the following sentences, suitable for use with
Generalized Modus Ponens:
a. Horses, cows, and pigs are mammals.
b. An offspring of a horse is a horse.
c. Bluebeard is a horse.
d. Bluebeard is Charlie’s parent.
e. Offspring and parent are inverse relations.
f. Every mammal has a parent.
9.7 These questions concern concern issues with substitution and Skolemization.
a. Given the premise ∀ x ∃ y P(x, y), it is not valid to conclude that ∃ q P(q, q). Give
an example of a predicate P where the first is true but the second is false.
b. Suppose that an inference engine is incorrectly written with the occurs check omitted,
so that it allows a literal like P(x, F(x)) to be unified with P(q, q). (As mentioned,
most standard implementations of Prolog actually do allow this.) Show that such an
inference engine will allow the conclusion ∃ y P(q, q) to be inferred from the premise
∀ x ∃ y P(x, y).
362 Chapter 9. Inference in First-Order Logic
c. Suppose that a procedure that converts first-order logic to clausal form incorrectly
Skolemizes ∀ x ∃ y P(x, y) to P(x, Sk0)—that is, it replaces y by a Skolem constant rather than by a Skolem function of x. Show that an inference engine that uses
such a procedure will likewise allow ∃ q P(q, q) to be inferred from the premise
∀ x ∃ y P(x, y).
d. A common error among students is to suppose that, in unification, one is allowed to
substitute a term for a Skolem constant instead of for a variable. For instance, they will
say that the formulas P(Sk1) and P(A) can be unified under the substitution {Sk1/A}.
Give an example where this leads to an invalid inference.
9.8 Explain how to write any given 3-SAT problem of arbitrary size using a single first-order
definite clause and no more than 30 ground facts.
9.9 Suppose you are given the following axioms:
1. 0 ≤ 3.
2. 7 ≤ 9.
3. ∀ x x ≤ x.
4. ∀ x x ≤ x + 0.
5. ∀ x x + 0 ≤ x.
6. ∀ x, y x + y ≤ y + x.
7. ∀ w, x, y, z w ≤ y ∧ x ≤ z ⇒ w + x ≤ y + z.
8. ∀ x, y, z x ≤ y ∧ y ≤ z ⇒ x ≤ z
a. Give a backward-chaining proof of the sentence 7 ≤ 3+9. (Be sure, of course, to use
only the axioms given here, not anything else you may know about arithmetic.) Show
only the steps that leads to success, not the irrelevant steps.
b. Give a forward-chaining proof of the sentence 7 ≤ 3+9. Again, show only the steps
that lead to success.
9.10 A popular children’s riddle is “Brothers and sisters have I none, but that man’s father
is my father’s son.” Use the rules of the family domain (Section 8.3.2 on page 301) to show
who that man is. You may apply any of the inference methods described in this chapter. Why
do you think that this riddle is difficult?
9.11 Suppose we put into a logical knowledge base a segment of the U.S. census data listing the age, city of residence, date of birth, and mother of every person, using social security numbers as identifying constants for each person. Thus, George’s age is given by
Age(443-65-1282, 56). Which of the following indexing schemes S1–S5 enable an efficient
solution for which of the queries Q1–Q4 (assuming normal backward chaining)?
• S1: an index for each atom in each position.
• S2: an index for each first argument.
• S3: an index for each predicate atom.
• S4: an index for each combination of predicate and first argument.
Exercises 363
• S5: an index for each combination of predicate and second argument and an index for
each first argument.
• Q1: Age(443-44-4321, x)
• Q2: ResidesIn(x, Houston)
• Q3: Mother (x, y)
• Q4: Age(x, 34) ∧ ResidesIn(x, TinyTownUSA)
9.12 One might suppose that we can avoid the problem of variable conflict in unification
during backward chaining by standardizing apart all of the sentences in the knowledge base
once and for all. Show that, for some sentences, this approach cannot work. (Hint: Consider
a sentence in which one part unifies with another.)
9.13 In this exercise, use the sentences you wrote in Exercise 9.6 to answer a question by
using a backward-chaining algorithm.
a. Draw the proof tree generated by an exhaustive backward-chaining algorithm for the
query ∃ h Horse(h), where clauses are matched in the order given.
b. What do you notice about this domain?
c. How many solutions for h actually follow from your sentences?
d. Can you think of a way to find all of them? (Hint: See Smith et al. (1986).)
9.14 Trace the execution of the backward-chaining algorithm in Figure 9.6 (page 338) when
it is applied to solve the crime problem (page 330). Show the sequence of values taken on by
the goals variable, and arrange them into a tree.
9.15 The following Prolog code defines a predicate P. (Remember that uppercase terms are
variables, not constants, in Prolog.)
P(X,[X|Y]).
P(X,[Y|Z]) :- P(X,Z).
a. Show proof trees and solutions for the queries P(A,[2,1,3])and P(2,[1,A,3]).
b. What standard list operation does P represent?
9.16 This exercise looks at sorting in Prolog.
a. Write Prolog clauses that define the predicate sorted(L), which is true if and only if
list L is sorted in ascending order.
b. Write a Prolog definition for the predicate perm(L,M), which is true if and only if L
is a permutation of M.
c. Define sort(L,M) (M is a sorted version of L) using perm and sorted.
d. Run sort on longer and longer lists until you lose patience. What is the time complexity of your program?
e. Write a faster sorting algorithm, such as insertion sort or quicksort, in Prolog.
364 Chapter 9. Inference in First-Order Logic
9.17 This exercise looks at the recursive application of rewrite rules, using logic programming. A rewrite rule (or demodulator in OTTER terminology) is an equation with a specified
direction. For example, the rewrite rule x + 0 → x suggests replacing any expression that
matches x+0 with the expression x. Rewrite rules are a key component of equational reasoning systems. Use the predicate rewrite(X,Y) to represent rewrite rules. For example, the
earlier rewrite rule is written as rewrite(X+0,X). Some terms are primitive and cannot
be further simplified; thus, we write primitive(0) to say that 0 is a primitive term.
a. Write a definition of a predicate simplify(X,Y), that is true when Y is a simplified
version of X—that is, when no further rewrite rules apply to any subexpression of Y.
b. Write a collection of rules for the simplification of expressions involving arithmetic
operators, and apply your simplification algorithm to some sample expressions.
c. Write a collection of rewrite rules for symbolic differentiation, and use them along with
your simplification rules to differentiate and simplify expressions involving arithmetic
expressions, including exponentiation.
9.18 This exercise considers the implementation of search algorithms in Prolog. Suppose
that successor(X,Y) is true when state Y is a successor of state X; and that goal(X)
is true when X is a goal state. Write a definition for solve(X,P), which means that P is a
path (list of states) beginning with X, ending in a goal state, and consisting of a sequence of
legal steps as defined by successor. You will find that depth-first search is the easiest way
to do this. How easy would it be to add heuristic search control?
9.19 Suppose a knowledge base contains just the following first-order Horn clauses:
Ancestor(Mother(x), x)
Ancestor(x, y) ∧ Ancestor(y, z) ⇒ Ancestor(x, z)
Consider a forward chaining algorithm that, on the jth iteration, terminates if the KB contains
a sentence that unifies with the query, else adds to the KB every atomic sentence that can be
inferred from the sentences already in the KB after iteration j − 1.
a. For each of the following queries, say whether the algorithm will (1) give an answer (if
so, write down that answer); or (2) terminate with no answer; or (3) never terminate.
(i) Ancestor(Mother(y), John)
(ii) Ancestor(Mother(Mother(y)), John)
(iii) Ancestor(Mother(Mother(Mother(y))), Mother(y))
(iv) Ancestor(Mother(John), Mother(Mother(John)))
b. Can a resolution algorithm prove the sentence ¬Ancestor(John, John) from the original knowledge base? Explain how, or why not.
c. Suppose we add the assertion that ¬(Mother(x) = x) and augment the resolution algorithm with inference rules for equality. Now what is the answer to (b)?
9.20 Let L be the first-order language with a single predicate S(p, q), meaning “p shaves q.”
Assume a domain of people.
Exercises 365
a. Consider the sentence “There exists a person P who shaves every one who does not
shave themselves, and only people that do not shave themselves.” Express this in L.
b. Convert the sentence in (a) to clausal form.
c. Construct a resolution proof to show that the clauses in (b) are inherently inconsistent.
(Note: you do not need any additional axioms.)
9.21 How can resolution be used to show that a sentence is valid? Unsatisfiable?
9.22 Construct an example of two clauses that can be resolved together in two different
ways giving two different outcomes.
9.23 From “Horses are animals,” it follows that “The head of a horse is the head of an
animal.” Demonstrate that this inference is valid by carrying out the following steps:
a. Translate the premise and the conclusion into the language of first-order logic. Use three
predicates: HeadOf (h, x) (meaning “h is the head of x”), Horse(x), and Animal(x).
b. Negate the conclusion, and convert the premise and the negated conclusion into conjunctive normal form.
c. Use resolution to show that the conclusion follows from the premise.
9.24 Here are two sentences in the language of first-order logic:
(A) ∀ x ∃ y (x ≥ y)
(B) ∃ y ∀ x (x ≥ y)
a. Assume that the variables range over all the natural numbers 0, 1, 2,...,∞ and that the
“≥” predicate means “is greater than or equal to.” Under this interpretation, translate
(A) and (B) into English.
b. Is (A) true under this interpretation?
c. Is (B) true under this interpretation?
d. Does (A) logically entail (B)?
e. Does (B) logically entail (A)?
f. Using resolution, try to prove that (A) follows from (B). Do this even if you think that
(B) does not logically entail (A); continue until the proof breaks down and you cannot
proceed (if it does break down). Show the unifying substitution for each resolution step.
If the proof fails, explain exactly where, how, and why it breaks down.
g. Now try to prove that (B) follows from (A).
9.25 Resolution can produce nonconstructive proofs for queries with variables, so we had
to introduce special mechanisms to extract definite answers. Explain why this issue does not
arise with knowledge bases containing only definite clauses.
9.26 We said in this chapter that resolution cannot be used to generate all logical consequences of a set of sentences. Can any algorithm do this?
10 CLASSICAL PLANNING
In which we see how an agent can take advantage of the structure of a problem to
construct complex plans of action.
We have defined AI as the study of rational action, which means that planning—devising a
plan of action to achieve one’s goals—is a critical part of AI. We have seen two examples
of planning agents so far: the search-based problem-solving agent of Chapter 3 and the hybrid logical agent of Chapter 7. In this chapter we introduce a representation for planning
problems that scales up to problems that could not be handled by those earlier approaches.
Section 10.1 develops an expressive yet carefully constrained language for representing
planning problems. Section 10.2 shows how forward and backward search algorithms can
take advantage of this representation, primarily through accurate heuristics that can be derived
automatically from the structure of the representation. (This is analogous to the way in which
effective domain-independent heuristics were constructed for constraint satisfaction problems
in Chapter 6.) Section 10.3 shows how a data structure called the planning graph can make the
search for a plan more efficient. We then describe a few of the other approaches to planning,
and conclude by comparing the various approaches.
This chapter covers fully observable, deterministic, static environments with single
agents. Chapters 11 and 17 cover partially observable, stochastic, dynamic environments
with multiple agents.
10.1 DEFINITION OF CLASSICAL PLANNING
The problem-solving agent of Chapter 3 can find sequences of actions that result in a goal
state. But it deals with atomic representations of states and thus needs good domain-specific
heuristics to perform well. The hybrid propositional logical agent of Chapter 7 can find plans
without domain-specific heuristics because it uses domain-independent heuristics based on
the logical structure of the problem. But it relies on ground (variable-free) propositional
inference, which means that it may be swamped when there are many actions and states. For
example, in the wumpus world, the simple action of moving a step forward had to be repeated
for all four agent orientations, T time steps, and n2 current locations.
366
Section 10.1. Definition of Classical Planning 367
In response to this, planning researchers have settled on a factored representation—
one in which a state of the world is represented by a collection of variables. We use a language
called PDDL, the Planning Domain Definition Language, that allows us to express all 4T n2 PDDL
actions with one action schema. There have been several versions of PDDL; we select a
simple version and alter its syntax to be consistent with the rest of the book.1 We now show
how PDDL describes the four things we need to define a search problem: the initial state, the
actions that are available in a state, the result of applying an action, and the goal test.
Each state is represented as a conjunction of fluents that are ground, functionless atoms.
For example, Poor ∧ Unknown might represent the state of a hapless agent, and a state
in a package delivery problem might be At(Truck 1, Melbourne) ∧ At(Truck 2, Sydney).
Database semantics is used: the closed-world assumption means that any fluents that are not
mentioned are false, and the unique names assumption means that Truck 1 and Truck 2 are
distinct. The following fluents are not allowed in a state: At(x, y) (because it is non-ground),
¬Poor (because it is a negation), and At(Father (Fred), Sydney) (because it uses a function
symbol). The representation of states is carefully designed so that a state can be treated
either as a conjunction of fluents, which can be manipulated by logical inference, or as a set
SET SEMANTICS of fluents, which can be manipulated with set operations. The set semantics is sometimes
easier to deal with.
Actions are described by a set of action schemas that implicitly define the ACTIONS(s)
and RESULT(s, a) functions needed to do a problem-solving search. We saw in Chapter 7 that
any system for action description needs to solve the frame problem—to say what changes and
what stays the same as the result of the action. Classical planning concentrates on problems
where most actions leave most things unchanged. Think of a world consisting of a bunch of
objects on a flat surface. The action of nudging an object causes that object to change its location by a vector Δ. A concise description of the action should mention only Δ; it shouldn’t
have to mention all the objects that stay in place. PDDL does that by specifying the result of
an action in terms of what changes; everything that stays the same is left unmentioned.
ACTION SCHEMA A set of ground (variable-free) actions can be represented by a single action schema.
The schema is a lifted representation—it lifts the level of reasoning from propositional logic
to a restricted subset of first-order logic. For example, here is an action schema for flying a
plane from one location to another:
Action(Fly(p, from,to),
PRECOND:At(p, from) ∧ Plane(p) ∧ Airport(from) ∧ Airport(to)
EFFECT:¬At(p, from) ∧ At(p,to))
The schema consists of the action name, a list of all the variables used in the schema, a
PRECONDITION precondition and an effect. Although we haven’t said yet how the action schema converts
EFFECT into logical sentences, think of the variables as being universally quantified. We are free to
choose whatever values we want to instantiate the variables. For example, here is one ground
1 PDDL was derived from the original STRIPS planning language(Fikes and Nilsson, 1971). which is slightly
more restricted than PDDL: STRIPS preconditions and goals cannot contain negative literals.
368 Chapter 10. Classical Planning
action that results from substituting values for all the variables:
Action(Fly(P1, SFO, JFK),
PRECOND:At(P1, SFO) ∧ Plane(P1) ∧ Airport(SFO) ∧ Airport(JFK)
EFFECT:¬At(P1, SFO) ∧ At(P1, JFK))
The precondition and effect of an action are each conjunctions of literals (positive or negated
atomic sentences). The precondition defines the states in which the action can be executed,
and the effect defines the result of executing the action. An action a can be executed in state
s if s entails the precondition of a. Entailment can also be expressed with the set semantics:
s |= q iff every positive literal in q is in s and every negated literal in q is not. In formal
notation we say
(a ∈ ACTIONS(s)) ⇔ s |= PRECOND(a),
where any variables in a are universally quantified. For example,
∀ p, from,to (Fly(p, from,to) ∈ ACTIONS(s)) ⇔
s |= (At(p, from) ∧ Plane(p) ∧ Airport(from) ∧ Airport(to))
APPLICABLE We say that action a is applicable in state s if the preconditions are satisfied by s. When
an action schema a contains variables, it may have multiple applicable instantiations. For
example, with the initial state defined in Figure 10.1, the Fly action can be instantiated as
Fly(P1, SFO, JFK) or as Fly(P2, JFK , SFO), both of which are applicable in the initial
state. If an action a has v variables, then, in a domain with k unique names of objects, it takes
O(vk) time in the worst case to find the applicable ground actions.
PROPOSITIONALIZE Sometimes we want to propositionalize a PDDL problem—replace each action schema
with a set of ground actions and then use a propositional solver such as SATPLAN to find a
solution. However, this is impractical when v and k are large.
The result of executing action a in state s is defined as a state s which is represented
by the set of fluents formed by starting with s, removing the fluents that appear as negative
DELETE LIST literals in the action’s effects (what we call the delete list or DEL(a)), and adding the fluents
ADD LIST that are positive literals in the action’s effects (what we call the add list or ADD(a)):
RESULT(s, a)=(s − DEL(a))∪ ADD(a) . (10.1)
For example, with the action Fly(P1, SFO, JFK), we would remove At(P1, SFO) and add
At(P1, JFK). It is a requirement of action schemas that any variable in the effect must also
appear in the precondition. That way, when the precondition is matched against the state s,
all the variables will be bound, and RESULT(s, a) will therefore have only ground atoms. In
other words, ground states are closed under the RESULT operation.
Also note that the fluents do not explicitly refer to time, as they did in Chapter 7. There
we needed superscripts for time, and successor-state axioms of the form
Ft+1 ⇔ ActionCausesFt ∨ (Ft ∧ ¬ActionCausesNotFt
) .
In PDDL the times and states are implicit in the action schemas: the precondition always
refers to time t and the effect to time t + 1.
A set of action schemas serves as a definition of a planning domain. A specific problem
within the domain is defined with the addition of an initial state and a goal. The initial
Section 10.1. Definition of Classical Planning 369
Init(At(C1, SFO) ∧ At(C2, JFK) ∧ At(P1, SFO) ∧ At(P2, JFK)
∧ Cargo(C1) ∧ Cargo(C2) ∧ Plane(P1) ∧ Plane(P2)
∧ Airport(JFK) ∧ Airport(SFO))
Goal(At(C1, JFK) ∧ At(C2, SFO))
Action(Load(c, p, a),
PRECOND: At(c, a) ∧ At(p, a) ∧ Cargo(c) ∧ Plane(p) ∧ Airport(a)
EFFECT: ¬ At(c, a) ∧ In(c, p))
Action(Unload(c, p, a),
PRECOND: In(c, p) ∧ At(p, a) ∧ Cargo(c) ∧ Plane(p) ∧ Airport(a)
EFFECT: At(c, a) ∧ ¬ In(c, p))
Action(Fly(p, from, to),
PRECOND: At(p, from) ∧ Plane(p) ∧ Airport(from) ∧ Airport(to)
EFFECT: ¬ At(p, from) ∧ At(p, to))
Figure 10.1 A PDDL description of an air cargo transportation planning problem.
INITIAL STATE state is a conjunction of ground atoms. (As with all states, the closed-world assumption is
GOAL used, which means that any atoms that are not mentioned are false.) The goal is just like a
precondition: a conjunction of literals (positive or negative) that may contain variables, such
as At(p, SFO) ∧ Plane(p). Any variables are treated as existentially quantified, so this goal
is to have any plane at SFO. The problem is solved when we can find a sequence of actions
that end in a state s that entails the goal. For example, the state Rich ∧ Famous ∧ Miserable
entails the goal Rich ∧ Famous, and the state Plane(Plane1) ∧ At(Plane1, SFO) entails
the goal At(p, SFO) ∧ Plane(p).
Now we have defined planning as a search problem: we have an initial state, an ACTIONS
function, a RESULT function, and a goal test. We’ll look at some example problems before
investigating efficient search algorithms.
10.1.1 Example: Air cargo transport
Figure 10.1 shows an air cargo transport problem involving loading and unloading cargo and
flying it from place to place. The problem can be defined with three actions: Load, Unload,
and Fly. The actions affect two predicates: In(c, p) means that cargo c is inside plane p, and
At(x, a) means that object x (either plane or cargo) is at airport a. Note that some care must
be taken to make sure the At predicates are maintained properly. When a plane flies from
one airport to another, all the cargo inside the plane goes with it. In first-order logic it would
be easy to quantify over all objects that are inside the plane. But basic PDDL does not have
a universal quantifier, so we need a different solution. The approach we use is to say that a
piece of cargo ceases to be At anywhere when it is In a plane; the cargo only becomes At the
new airport when it is unloaded. So At really means “available for use at a given location.”
The following plan is a solution to the problem:
[Load (C1, P1, SFO),Fly(P1, SFO, JFK ), Unload(C1, P1, JFK),
Load(C2, P2, JFK ),Fly(P2, JFK , SFO), Unload(C2, P2, SFO)] .
370 Chapter 10. Classical Planning
Finally, there is the problem of spurious actions such as Fly(P1, JFK, JFK ), which should
be a no-op, but which has contradictory effects (according to the definition, the effect would
include At(P1, JFK) ∧ ¬At(P1, JFK)). It is common to ignore such problems, because
they seldom cause incorrect plans to be produced. The correct approach is to add inequality
preconditions saying that the from and to airports must be different; see another example of
this in Figure 10.3.
10.1.2 Example: The spare tire problem
Consider the problem of changing a flat tire (Figure 10.2). The goal is to have a good spare
tire properly mounted onto the car’s axle, where the initial state has a flat tire on the axle and
a good spare tire in the trunk. To keep it simple, our version of the problem is an abstract
one, with no sticky lug nuts or other complications. There are just four actions: removing the
spare from the trunk, removing the flat tire from the axle, putting the spare on the axle, and
leaving the car unattended overnight. We assume that the car is parked in a particularly bad
neighborhood, so that the effect of leaving it overnight is that the tires disappear. A solution
to the problem is [Remove(Flat, Axle), Remove(Spare, Trunk ),PutOn(Spare, Axle)].
Init(Tire(Flat) ∧ Tire(Spare) ∧ At(Flat, Axle) ∧ At(Spare, Trunk))
Goal(At(Spare, Axle))
Action(Remove(obj , loc),
PRECOND: At(obj , loc)
EFFECT: ¬ At(obj , loc) ∧ At(obj, Ground))
Action(PutOn(t, Axle),
PRECOND: Tire(t) ∧ At(t, Ground) ∧ ¬ At(Flat, Axle)
EFFECT: ¬ At(t, Ground) ∧ At(t, Axle))
Action(LeaveOvernight,
PRECOND:
EFFECT: ¬ At(Spare, Ground) ∧ ¬ At(Spare, Axle) ∧ ¬ At(Spare, Trunk)
∧ ¬ At(Flat, Ground) ∧ ¬ At(Flat, Axle) ∧ ¬ At(Flat, Trunk))
Figure 10.2 The simple spare tire problem.
10.1.3 Example: The blocks world
BLOCKS WORLD One of the most famous planning domains is known as the blocks world. This domain
consists of a set of cube-shaped blocks sitting on a table.2 The blocks can be stacked, but
only one block can fit directly on top of another. A robot arm can pick up a block and move
it to another position, either on the table or on top of another block. The arm can pick up
only one block at a time, so it cannot pick up a block that has another one on it. The goal will
always be to build one or more stacks of blocks, specified in terms of what blocks are on top
2 The blocks world used in planning research is much simpler than SHRDLU’s version, shown on page 20.
Section 10.1. Definition of Classical Planning 371
Init(On(A, Table) ∧ On(B, Table) ∧ On(C, A)
∧ Block (A) ∧ Block (B) ∧ Block (C) ∧ Clear (B) ∧ Clear (C))
Goal(On(A, B) ∧ On(B,C))
Action(Move(b, x, y),
PRECOND: On(b, x) ∧ Clear (b) ∧ Clear (y) ∧ Block (b) ∧ Block (y) ∧
(b=x) ∧ (b=y) ∧ (x=y),
EFFECT: On(b, y) ∧ Clear (x) ∧ ¬On(b, x) ∧ ¬Clear (y))
Action(MoveToTable(b, x),
PRECOND: On(b, x) ∧ Clear (b) ∧ Block (b) ∧ (b=x),
EFFECT: On(b, Table) ∧ Clear (x) ∧ ¬On(b, x))
Figure 10.3 A planning problem in the blocks world: building a three-block tower. One
solution is the sequence [MoveToTable(C, A), Move(B, Table, C), Move(A, Table, B)].
Start State Goal State
B A
C
A
B
C
Figure 10.4 Diagram of the blocks-world problem in Figure 10.3.
of what other blocks. For example, a goal might be to get block A on B and block B on C
(see Figure 10.4).
We use On(b, x) to indicate that block b is on x, where x is either another block or the
table. The action for moving block b from the top of x to the top of y will be Move(b, x, y).
Now, one of the preconditions on moving b is that no other block be on it. In first-order logic,
this would be ¬∃ x On(x, b) or, alternatively, ∀ x ¬On(x, b). Basic PDDL does not allow
quantifiers, so instead we introduce a predicate Clear (x) that is true when nothing is on x.
(The complete problem description is in Figure 10.3.)
The action Move moves a block b from x to y if both b and y are clear. After the move
is made, b is still clear but y is not. A first attempt at the Move schema is
Action(Move(b, x, y),
PRECOND:On(b, x) ∧ Clear (b) ∧ Clear (y),
EFFECT:On(b, y) ∧ Clear (x) ∧ ¬On(b, x) ∧ ¬Clear (y)) .
Unfortunately, this does not maintain Clear properly when x or y is the table. When x is the
Table, this action has the effect Clear (Table), but the table should not become clear; and
when y = Table, it has the precondition Clear (Table), but the table does not have to be clear
372 Chapter 10. Classical Planning
for us to move a block onto it. To fix this, we do two things. First, we introduce another
action to move a block b from x to the table:
Action(MoveToTable(b, x),
PRECOND:On(b, x) ∧ Clear (b),
EFFECT:On(b, Table) ∧ Clear (x) ∧ ¬On(b, x)) .
Second, we take the interpretation of Clear (x) to be “there is a clear space on x to hold a
block.” Under this interpretation, Clear (Table) will always be true. The only problem is that
nothing prevents the planner from using Move(b, x, Table) instead of MoveToTable(b, x).
We could live with this problem—it will lead to a larger-than-necessary search space, but will
not lead to incorrect answers—or we could introduce the predicate Block and add Block(b)∧
Block(y) to the precondition of Move.
10.1.4 The complexity of classical planning
In this subsection we consider the theoretical complexity of planning and distinguish two
PLANSAT decision problems. PlanSAT is the question of whether there exists any plan that solves a
BOUNDED PLANSAT planning problem. Bounded PlanSAT asks whether there is a solution of length k or less;
this can be used to find an optimal plan.
The first result is that both decision problems are decidable for classical planning. The
proof follows from the fact that the number of states is finite. But if we add function symbols
to the language, then the number of states becomes infinite, and PlanSAT becomes only
semidecidable: an algorithm exists that will terminate with the correct answer for any solvable
problem, but may not terminate on unsolvable problems. The Bounded PlanSAT problem
remains decidable even in the presence of function symbols. For proofs of the assertions in
this section, see Ghallab et al. (2004).
Both PlanSAT and Bounded PlanSAT are in the complexity class PSPACE, a class that
is larger (and hence more difficult) than NP and refers to problems that can be solved by a
deterministic Turing machine with a polynomial amount of space. Even if we make some
rather severe restrictions, the problems remain quite difficult. For example, if we disallow
negative effects, both problems are still NP-hard. However, if we also disallow negative
preconditions, PlanSAT reduces to the class P.
These worst-case results may seem discouraging. We can take solace in the fact that
agents are usually not asked to find plans for arbitrary worst-case problem instances, but
rather are asked for plans in specific domains (such as blocks-world problems with n blocks),
which can be much easier than the theoretical worst case. For many domains (including the
blocks world and the air cargo world), Bounded PlanSAT is NP-complete while PlanSAT is
in P; in other words, optimal planning is usually hard, but sub-optimal planning is sometimes
easy. To do well on easier-than-worst-case problems, we will need good search heuristics.
That’s the true advantage of the classical planning formalism: it has facilitated the development of very accurate domain-independent heuristics, whereas systems based on successorstate axioms in first-order logic have had less success in coming up with good heuristics.
Section 10.2. Algorithms for Planning as State-Space Search 373
10.2 ALGORITHMS FOR PLANNING AS STATE-SPACE SEARCH
Now we turn our attention to planning algorithms. We saw how the description of a planning
problem defines a search problem: we can search from the initial state through the space
of states, looking for a goal. One of the nice advantages of the declarative representation of
action schemas is that we can also search backward from the goal, looking for the initial state.
Figure 10.5 compares forward and backward searches.
10.2.1 Forward (progression) state-space search
Now that we have shown how a planning problem maps into a search problem, we can solve
planning problems with any of the heuristic search algorithms from Chapter 3 or a local
search algorithm from Chapter 4 (provided we keep track of the actions used to reach the
goal). From the earliest days of planning research (around 1961) until around 1998 it was
assumed that forward state-space search was too inefficient to be practical. It is not hard to
come up with reasons why.
First, forward search is prone to exploring irrelevant actions. Consider the noble task
of buying a copy of AI: A Modern Approach from an online bookseller. Suppose there is an
(a)
(b)
At(P1, A)
Fly(P1, A, B)
Fly(P2, A, B)
Fly(P1, A, B)
Fly(P2, A, B)
At(P2, A)
At(P1, B)
At(P2, A)
At(P1, A)
At(P2, B)
At(P1, B)
At(P2, B)
At(P1, B)
At(P2, A)
At(P1, A)
At(P2, B)
Figure 10.5 Two approaches to searching for a plan. (a) Forward (progression) search
through the space of states, starting in the initial state and using the problem’s actions to
search forward for a member of the set of goal states. (b) Backward (regression) search
through sets of relevant states, starting at the set of states representing the goal and using the
inverse of the actions to search backward for the initial state.
374 Chapter 10. Classical Planning
action schema Buy(isbn) with effect Own(isbn). ISBNs are 10 digits, so this action schema
represents 10 billion ground actions. An uninformed forward-search algorithm would have
to start enumerating these 10 billion actions to find one that leads to the goal.
Second, planning problems often have large state spaces. Consider an air cargo problem
with 10 airports, where each airport has 5 planes and 20 pieces of cargo. The goal is to move
all the cargo at airport A to airport B. There is a simple solution to the problem: load the 20
pieces of cargo into one of the planes at A, fly the plane to B, and unload the cargo. Finding
the solution can be difficult because the average branching factor is huge: each of the 50
planes can fly to 9 other airports, and each of the 200 packages can be either unloaded (if
it is loaded) or loaded into any plane at its airport (if it is unloaded). So in any state there
is a minimum of 450 actions (when all the packages are at airports with no planes) and a
maximum of 10,450 (when all packages and planes are at the same airport). On average, let’s
say there are about 2000 possible actions per state, so the search graph up to the depth of the
obvious solution has about 200041 nodes.
Clearly, even this relatively small problem instance is hopeless without an accurate
heuristic. Although many real-world applications of planning have relied on domain-specific
heuristics, it turns out (as we see in Section 10.2.3) that strong domain-independent heuristics
can be derived automatically; that is what makes forward search feasible.
10.2.2 Backward (regression) relevant-states search
In regression search we start at the goal and apply the actions backward until we find a
RELEVANT-STATES sequence of steps that reaches the initial state. It is called relevant-states search because we
only consider actions that are relevant to the goal (or current state). As in belief-state search
(Section 4.4), there is a set of relevant states to consider at each step, not just a single state.
We start with the goal, which is a conjunction of literals forming a description of a set of
states—for example, the goal ¬Poor ∧Famous describes those states in which Poor is false,
Famous is true, and any other fluent can have any value. If there are n ground fluents in a
domain, then there are 2n ground states (each fluent can be true or false), but 3n descriptions
of sets of goal states (each fluent can be positive, negative, or not mentioned).
In general, backward search works only when we know how to regress from a state
description to the predecessor state description. For example, it is hard to search backwards
for a solution to the n-queens problem because there is no easy way to describe the states that
are one move away from the goal. Happily, the PDDL representation was designed to make
it easy to regress actions—if a domain can be expressed in PDDL, then we can do regression
search on it. Given a ground goal description g and a ground action a, the regression from g
over a gives us a state description g defined by
g = (g − ADD(a))∪ Precond(a) .
That is, the effects that were added by the action need not have been true before, and also
the preconditions must have held before, or else the action could not have been executed.
Note that DEL(a) does not appear in the formula; that’s because while we know the fluents
in DEL(a) are no longer true after the action, we don’t know whether or not they were true
before, so there’s nothing to be said about them.
Section 10.2. Algorithms for Planning as State-Space Search 375
To get the full advantage of backward search, we need to deal with partially uninstantiated actions and states, not just ground ones. For example, suppose the goal is to deliver a specific piece of cargo to SFO: At(C2, SFO). That suggests the action Unload(C2, p
, SFO):
Action(Unload(C2, p
, SFO),
PRECOND:In(C2, p
) ∧ At(p
, SFO) ∧ Cargo(C2) ∧ Plane(p
) ∧ Airport(SFO)
EFFECT:At(C2, SFO) ∧ ¬In(C2, p
).
(Note that we have standardized variable names (changing p to p in this case) so that there
will be no confusion between variable names if we happen to use the same action schema
twice in a plan. The same approach was used in Chapter 9 for first-order logical inference.)
This represents unloading the package from an unspecified plane at SFO; any plane will do,
but we need not say which one now. We can take advantage of the power of first-order
representations: a single description summarizes the possibility of using any of the planes by
implicitly quantifying over p
. The regressed state description is
g = In(C2, p
) ∧ At(p
, SFO) ∧ Cargo(C2) ∧ Plane(p
) ∧ Airport(SFO).
The final issue is deciding which actions are candidates to regress over. In the forward direction we chose actions that were applicable—those actions that could be the next step in the
RELEVANCE plan. In backward search we want actions that are relevant—those actions that could be the
last step in a plan leading up to the current goal state.
For an action to be relevant to a goal it obviously must contribute to the goal: at least
one of the action’s effects (either positive or negative) must unify with an element of the goal.
What is less obvious is that the action must not have any effect (positive or negative) that
negates an element of the goal. Now, if the goal is A ∧ B ∧ C and an action has the effect
A∧B∧¬C then there is a colloquial sense in which that action is very relevant to the goal—it
gets us two-thirds of the way there. But it is not relevant in the technical sense defined here,
because this action could not be the final step of a solution—we would always need at least
one more step to achieve C.
Given the goal At(C2, SFO), several instantiations of Unload are relevant: we could
chose any specific plane to unload from, or we could leave the plane unspecified by using
the action Unload(C2, p
, SFO). We can reduce the branching factor without ruling out any
solutions by always using the action formed by substituting the most general unifier into the
(standardized) action schema.
As another example, consider the goal Own(0136042597), given an initial state with
10 billion ISBNs, and the single action schema
A = Action(Buy(i), PRECOND:ISBN (i), EFFECT:Own(i)).
As we mentioned before, forward search without a heuristic would have to start enumerating the 10 billion ground Buy actions. But with backward search, we would unify the
goal Own(0136042597) with the (standardized) effect Own(i

), yielding the substitution
θ = {i

/0136042597}. Then we would regress over the action Subst(θ, A
) to yield the
predecessor state description ISBN (0136042597). This is part of, and thus entailed by, the
initial state, so we are done.
376 Chapter 10. Classical Planning
We can make this more formal. Assume a goal description g which contains a goal
literal gi and an action schema A that is standardized to produce A
. If A has an effect literal
e
j where Unify(gi, e
j ) = θ and where we define a = SUBST(θ, A
) and if there is no effect
in a that is the negation of a literal in g, then a is a relevant action towards g.
Backward search keeps the branching factor lower than forward search, for most problem domains. However, the fact that backward search uses state sets rather than individual
states makes it harder to come up with good heuristics. That is the main reason why the
majority of current systems favor forward search.
10.2.3 Heuristics for planning
Neither forward nor backward search is efficient without a good heuristic function. Recall
from Chapter 3 that a heuristic function h(s) estimates the distance from a state s to the
goal and that if we can derive an admissible heuristic for this distance—one that does not
overestimate—then we can use A∗ search to find optimal solutions. An admissible heuristic
can be derived by defining a relaxed problem that is easier to solve. The exact cost of a
solution to this easier problem then becomes the heuristic for the original problem.
By definition, there is no way to analyze an atomic state, and thus it it requires some
ingenuity by a human analyst to define good domain-specific heuristics for search problems
with atomic states. Planning uses a factored representation for states and action schemas.
That makes it possible to define good domain-independent heuristics and for programs to
automatically apply a good domain-independent heuristic for a given problem.
Think of a search problem as a graph where the nodes are states and the edges are
actions. The problem is to find a path connecting the initial state to a goal state. There are
two ways we can relax this problem to make it easier: by adding more edges to the graph,
making it strictly easier to find a path, or by grouping multiple nodes together, forming an
abstraction of the state space that has fewer states, and thus is easier to search.
We look first at heuristics that add edges to the graph. For example, the ignore preconditions heuristic drops all preconditions from actions. Every action becomes applicable IGNORE
PRECONDITIONS
HEURISTIC
in every state, and any single goal fluent can be achieved in one step (if there is an applicable action—if not, the problem is impossible). This almost implies that the number of steps
required to solve the relaxed problem is the number of unsatisfied goals—almost but not
quite, because (1) some action may achieve multiple goals and (2) some actions may undo
the effects of others. For many problems an accurate heuristic is obtained by considering (1)
and ignoring (2). First, we relax the actions by removing all preconditions and all effects
except those that are literals in the goal. Then, we count the minimum number of actions
required such that the union of those actions’ effects satisfies the goal. This is an instance
of the set-cover problem. There is one minor irritation: the set-cover problem is NP-hard. SET-COVER
PROBLEM
Fortunately a simple greedy algorithm is guaranteed to return a set covering whose size is
within a factor of log n of the true minimum covering, where n is the number of literals in
the goal. Unfortunately, the greedy algorithm loses the guarantee of admissibility.
It is also possible to ignore only selected preconditions of actions. Consider the slidingblock puzzle (8-puzzle or 15-puzzle) from Section 3.2. We could encode this as a planning
Section 10.2. Algorithms for Planning as State-Space Search 377
problem involving tiles with a single schema Slide:
Action(Slide(t, s1, s2),
PRECOND:On(t, s1) ∧ Tile(t) ∧ Blank (s2) ∧ Adjacent(s1, s2)
EFFECT:On(t, s2) ∧ Blank(s1) ∧ ¬On(t, s1) ∧ ¬Blank(s2))
As we saw in Section 3.6, if we remove the preconditions Blank (s2) ∧ Adjacent(s1, s2)
then any tile can move in one action to any space and we get the number-of-misplaced-tiles
heuristic. If we remove Blank(s2) then we get the Manhattan-distance heuristic. It is easy to
see how these heuristics could be derived automatically from the action schema description.
The ease of manipulating the schemas is the great advantage of the factored representation of
planning problems, as compared with the atomic representation of search problems.
Another possibility is the ignore delete lists heuristic. Assume for a moment that all IGNORE DELETE
LISTS
goals and preconditions contain only positive literals3 We want to create a relaxed version of
the original problem that will be easier to solve, and where the length of the solution will serve
as a good heuristic. We can do that by removing the delete lists from all actions (i.e., removing
all negative literals from effects). That makes it possible to make monotonic progress towards
the goal—no action will ever undo progress made by another action. It turns out it is still NPhard to find the optimal solution to this relaxed problem, but an approximate solution can be
found in polynomial time by hill-climbing. Figure 10.6 diagrams part of the state space for
two planning problems using the ignore-delete-lists heuristic. The dots represent states and
the edges actions, and the height of each dot above the bottom plane represents the heuristic
value. States on the bottom plane are solutions. In both these problems, there is a wide path
to the goal. There are no dead ends, so no need for backtracking; a simple hillclimbing search
will easily find a solution to these problems (although it may not be an optimal solution).
The relaxed problems leave us with a simplified—but still expensive—planning problem just to calculate the value of the heuristic function. Many planning problems have 10100
states or more, and relaxing the actions does nothing to reduce the number of states. Therefore, we now look at relaxations that decrease the number of states by forming a state abSTATE ABSTRACTION straction—a many-to-one mapping from states in the ground representation of the problem
to the abstract representation.
The easiest form of state abstraction is to ignore some fluents. For example, consider
an air cargo problem with 10 airports, 50 planes, and 200 pieces of cargo. Each plane can
be at one of 10 airports and each package can be either in one of the planes or unloaded at
one of the airports. So there are 5010 × 20050+10 ≈ 10155 states. Now consider a particular
problem in that domain in which it happens that all the packages are at just 5 of the airports,
and all packages at a given airport have the same destination. Then a useful abstraction of the
problem is to drop all the At fluents except for the ones involving one plane and one package
at each of the 5 airports. Now there are only 510 × 55+10 ≈ 1017 states. A solution in this
abstract state space will be shorter than a solution in the original space (and thus will be an
admissible heuristic), and the abstract solution is easy to extend to a solution to the original
problem (by adding additional Load and Unload actions).
3 Many problems are written with this convention. For problems that aren’t, replace every negative literal ¬P
in a goal or precondition with a new positive literal, P
.
378 Chapter 10. Classical Planning
Figure 10.6 Two state spaces from planning problems with the ignore-delete-lists heuristic. The height above the bottom plane is the heuristic score of a state; states on the bottom
plane are goals. There are no local minima, so search for the goal is straightforward. From
Hoffmann (2005).
DECOMPOSITION A key idea in defining heuristics is decomposition: dividing a problem into parts, solving each part independently, and then combining the parts. The subgoal independence as- SUBGOAL
INDEPENDENCE
sumption is that the cost of solving a conjunction of subgoals is approximated by the sum
of the costs of solving each subgoal independently. The subgoal independence assumption
can be optimistic or pessimistic. It is optimistic when there are negative interactions between
the subplans for each subgoal—for example, when an action in one subplan deletes a goal
achieved by another subplan. It is pessimistic, and therefore inadmissible, when subplans
contain redundant actions—for instance, two actions that could be replaced by a single action
in the merged plan.
Suppose the goal is a set of fluents G, which we divide into disjoint subsets G1,...,Gn.
We then find plans P1,...,Pn that solve the respective subgoals. What is an estimate of the
cost of the plan for achieving all of G? We can think of each Cost(Pi) as a heuristic estimate,
and we know that if we combine estimates by taking their maximum value, we always get an
admissible heuristic. So maxi COST(Pi) is admissible, and sometimes it is exactly correct:
it could be that P1 serendipitously achieves all the Gi. But in most cases, in practice the
estimate is too low. Could we sum the costs instead? For many problems that is a reasonable
estimate, but it is not admissible. The best case is when we can determine that Gi and Gj are
independent. If the effects of Pi leave all the preconditions and goals of Pj unchanged, then
the estimate COST(Pi) + COST(Pj ) is admissible, and more accurate than the max estimate.
We show in Section 10.3.1 that planning graphs can help provide better heuristic estimates.
It is clear that there is great potential for cutting down the search space by forming abstractions. The trick is choosing the right abstractions and using them in a way that makes
the total cost—defining an abstraction, doing an abstract search, and mapping the abstraction
back to the original problem—less than the cost of solving the original problem. The tech-
Section 10.3. Planning Graphs 379
niques of pattern databases from Section 3.6.3 can be useful, because the cost of creating
the pattern database can be amortized over multiple problem instances.
An example of a system that makes use of effective heuristics is FF, or FASTFORWARD
(Hoffmann, 2005), a forward state-space searcher that uses the ignore-delete-lists heuristic,
estimating the heuristic with the help of a planning graph (see Section 10.3). FF then uses
hill-climbing search (modified to keep track of the plan) with the heuristic to find a solution.
When it hits a plateau or local maximum—when no action leads to a state with better heuristic
score—then FF uses iterative deepening search until it finds a state that is better, or it gives
up and restarts hill-climbing.
10.3 PLANNING GRAPHS
All of the heuristics we have suggested can suffer from inaccuracies. This section shows
PLANNING GRAPH how a special data structure called a planning graph can be used to give better heuristic
estimates. These heuristics can be applied to any of the search techniques we have seen so
far. Alternatively, we can search for a solution over the space formed by the planning graph,
using an algorithm called GRAPHPLAN.
A planning problem asks if we can reach a goal state from the initial state. Suppose we
are given a tree of all possible actions from the initial state to successor states, and their successors, and so on. If we indexed this tree appropriately, we could answer the planning question “can we reach state G from state S0” immediately, just by looking it up. Of course, the
tree is of exponential size, so this approach is impractical. A planning graph is polynomialsize approximation to this tree that can be constructed quickly. The planning graph can’t
answer definitively whether G is reachable from S0, but it can estimate how many steps it
takes to reach G. The estimate is always correct when it reports the goal is not reachable, and
it never overestimates the number of steps, so it is an admissible heuristic.
LEVEL A planning graph is a directed graph organized into levels: first a level S0 for the initial
state, consisting of nodes representing each fluent that holds in S0; then a level A0 consisting
of nodes for each ground action that might be applicable in S0; then alternating levels Si
followed by Ai; until we reach a termination condition (to be discussed later).
Roughly speaking, Si contains all the literals that could hold at time i, depending on
the actions executed at preceding time steps. If it is possible that either P or ¬P could hold,
then both will be represented in Si. Also roughly speaking, Ai contains all the actions that
could have their preconditions satisfied at time i. We say “roughly speaking” because the
planning graph records only a restricted subset of the possible negative interactions among
actions; therefore, a literal might show up at level Sj when actually it could not be true until
a later level, if at all. (A literal will never show up too late.) Despite the possible error, the
level j at which a literal first appears is a good estimate of how difficult it is to achieve the
literal from the initial state.
Planning graphs work only for propositional planning problems—ones with no variables. As we mentioned on page 368, it is straightforward to propositionalize a set of ac-
380 Chapter 10. Classical Planning
Init(Have(Cake))
Goal(Have(Cake) ∧ Eaten(Cake))
Action(Eat(Cake)
PRECOND: Have(Cake)
EFFECT: ¬ Have(Cake) ∧ Eaten(Cake))
Action(Bake(Cake)
PRECOND: ¬ Have(Cake)
EFFECT: Have(Cake))
Figure 10.7 The “have cake and eat cake too” problem.
Bake(Cake)
Eat(Cake)
Have(Cake)
S0 A0 S1 A1 S2
Have(Cake) Have(Cake) Have(Cake)
Have(Cake)
Eaten(Cake)
Eaten(Cake) Eaten(Cake) Eaten(Cake)
Eaten(Cake)
Eat(Cake)
¬
¬ ¬
¬
¬
Figure 10.8 The planning graph for the “have cake and eat cake too” problem up to level
S2. Rectangles indicate actions (small squares indicate persistence actions), and straight
lines indicate preconditions and effects. Mutex links are shown as curved gray lines. Not all
mutex links are shown, because the graph would be too cluttered. In general, if two literals
are mutex at Si, then the persistence actions for those literals will be mutex at Ai and we
need not draw that mutex link.
tion schemas. Despite the resulting increase in the size of the problem description, planning
graphs have proved to be effective tools for solving hard planning problems.
Figure 10.7 shows a simple planning problem, and Figure 10.8 shows its planning
graph. Each action at level Ai is connected to its preconditions at Si and its effects at Si+1.
So a literal appears because an action caused it, but we also want to say that a literal can
persist if no action negates it. This is represented by a persistence action (sometimes called PERSISTENCE
ACTION
a no-op). For every literal C, we add to the problem a persistence action with precondition C
and effect C. Level A0 in Figure 10.8 shows one “real” action, Eat(Cake), along with two
persistence actions drawn as small square boxes.
Level A0 contains all the actions that could occur in state S0, but just as important it
records conflicts between actions that would prevent them from occurring together. The gray
MUTUAL EXCLUSION lines in Figure 10.8 indicate mutual exclusion (or mutex) links. For example, Eat(Cake) is
MUTEX mutually exclusive with the persistence of either Have(Cake) or ¬Eaten(Cake). We shall
see shortly how mutex links are computed.
Level S1 contains all the literals that could result from picking any subset of the actions
in A0, as well as mutex links (gray lines) indicating literals that could not appear together,
regardless of the choice of actions. For example, Have(Cake) and Eaten(Cake) are mutex:
Section 10.3. Planning Graphs 381
depending on the choice of actions in A0, either, but not both, could be the result. In other
words, S1 represents a belief state: a set of possible states. The members of this set are all
subsets of the literals such that there is no mutex link between any members of the subset.
We continue in this way, alternating between state level Si and action level Ai until we
reach a point where two consecutive levels are identical. At this point, we say that the graph
LEVELED OFF has leveled off. The graph in Figure 10.8 levels off at S2.
What we end up with is a structure where every Ai level contains all the actions that are
applicable in Si, along with constraints saying that two actions cannot both be executed at the
same level. Every Si level contains all the literals that could result from any possible choice
of actions in Ai−1, along with constraints saying which pairs of literals are not possible.
It is important to note that the process of constructing the planning graph does not require
choosing among actions, which would entail combinatorial search. Instead, it just records the
impossibility of certain choices using mutex links.
We now define mutex links for both actions and literals. A mutex relation holds between
two actions at a given level if any of the following three conditions holds:
• Inconsistent effects: one action negates an effect of the other. For example, Eat(Cake)
and the persistence of Have(Cake) have inconsistent effects because they disagree on
the effect Have(Cake).
• Interference: one of the effects of one action is the negation of a precondition of the
other. For example Eat(Cake) interferes with the persistence of Have(Cake) by negating its precondition.
• Competing needs: one of the preconditions of one action is mutually exclusive with a
precondition of the other. For example, Bake(Cake) and Eat(Cake) are mutex because
they compete on the value of the Have(Cake) precondition.
A mutex relation holds between two literals at the same level if one is the negation of the other
or if each possible pair of actions that could achieve the two literals is mutually exclusive.
This condition is called inconsistent support. For example, Have(Cake) and Eaten(Cake)
are mutex in S1 because the only way of achieving Have(Cake), the persistence action, is
mutex with the only way of achieving Eaten(Cake), namely Eat(Cake). In S2 the two
literals are not mutex, because there are new ways of achieving them, such as Bake(Cake)
and the persistence of Eaten(Cake), that are not mutex.
A planning graph is polynomial in the size of the planning problem. For a planning
problem with l literals and a actions, each Si has no more than l nodes and l
2 mutex links,
and each Ai has no more than a + l nodes (including the no-ops), (a + l)2 mutex links, and
2(al + l) precondition and effect links. Thus, an entire graph with n levels has a size of
O(n(a + l)2). The time to build the graph has the same complexity.
10.3.1 Planning graphs for heuristic estimation
A planning graph, once constructed, is a rich source of information about the problem. First,
if any goal literal fails to appear in the final level of the graph, then the problem is unsolvable.
Second, we can estimate the cost of achieving any goal literal gi from state s as the level at
which gi first appears in the planning graph constructed from initial state s. We call this the
382 Chapter 10. Classical Planning
level cost of gi LEVEL COST . In Figure 10.8, Have(Cake) has level cost 0 and Eaten(Cake) has level cost
1. It is easy to show (Exercise 10.10) that these estimates are admissible for the individual
goals. The estimate might not always be accurate, however, because planning graphs allow
several actions at each level, whereas the heuristic counts just the level and not the number
of actions. For this reason, it is common to use a serial planning graph for computing SERIAL PLANNING
GRAPH
heuristics. A serial graph insists that only one action can actually occur at any given time
step; this is done by adding mutex links between every pair of nonpersistence actions. Level
costs extracted from serial graphs are often quite reasonable estimates of actual costs.
To estimate the cost of a conjunction of goals, there are three simple approaches. The
MAX-LEVEL max-level heuristic simply takes the maximum level cost of any of the goals; this is admissible, but not necessarily accurate.
LEVEL SUM The level sum heuristic, following the subgoal independence assumption, returns the
sum of the level costs of the goals; this can be inadmissible but works well in practice
for problems that are largely decomposable. It is much more accurate than the numberof-unsatisfied-goals heuristic from Section 10.2. For our problem, the level-sum heuristic
estimate for the conjunctive goal Have(Cake) ∧ Eaten(Cake) will be 0+1= 1, whereas
the correct answer is 2, achieved by the plan [Eat(Cake), Bake(Cake)]. That doesn’t seem
so bad. A more serious error is that if Bake(Cake) were not in the set of actions, then the
estimate would still be 1, when in fact the conjunctive goal would be impossible.
SET-LEVEL Finally, the set-level heuristic finds the level at which all the literals in the conjunctive
goal appear in the planning graph without any pair of them being mutually exclusive. This
heuristic gives the correct values of 2 for our original problem and infinity for the problem
without Bake(Cake). It is admissible, it dominates the max-level heuristic, and it works
extremely well on tasks in which there is a good deal of interaction among subplans. It is not
perfect, of course; for example, it ignores interactions among three or more literals.
As a tool for generating accurate heuristics, we can view the planning graph as a relaxed
problem that is efficiently solvable. To understand the nature of the relaxed problem, we
need to understand exactly what it means for a literal g to appear at level Si in the planning
graph. Ideally, we would like it to be a guarantee that there exists a plan with i action levels
that achieves g, and also that if g does not appear, there is no such plan. Unfortunately,
making that guarantee is as difficult as solving the original planning problem. So the planning
graph makes the second half of the guarantee (if g does not appear, there is no plan), but
if g does appear, then all the planning graph promises is that there is a plan that possibly
achieves g and has no “obvious” flaws. An obvious flaw is defined as a flaw that can be
detected by considering two actions or two literals at a time—in other words, by looking at
the mutex relations. There could be more subtle flaws involving three, four, or more actions,
but experience has shown that it is not worth the computational effort to keep track of these
possible flaws. This is similar to a lesson learned from constraint satisfaction problems—that
it is often worthwhile to compute 2-consistency before searching for a solution, but less often
worthwhile to compute 3-consistency or higher. (See page 211.)
One example of an unsolvable problem that cannot be recognized as such by a planning
graph is the blocks-world problem where the goal is to get block A on B, B on C, and C on
A. This is an impossible goal; a tower with the bottom on top of the top. But a planning graph
Section 10.3. Planning Graphs 383
cannot detect the impossibility, because any two of the three subgoals are achievable. There
are no mutexes between any pair of literals, only between the three as a whole. To detect that
this problem is impossible, we would have to search over the planning graph.
10.3.2 The GRAPHPLAN algorithm
This subsection shows how to extract a plan directly from the planning graph, rather than just
using the graph to provide a heuristic. The GRAPHPLAN algorithm (Figure 10.9) repeatedly
adds a level to a planning graph with EXPAND-GRAPH. Once all the goals show up as nonmutex in the graph, GRAPHPLAN calls EXTRACT-SOLUTION to search for a plan that solves
the problem. If that fails, it expands another level and tries again, terminating with failure
when there is no reason to go on.
function GRAPHPLAN(problem) returns solution or failure
graph ← INITIAL-PLANNING-GRAPH(problem)
goals ← CONJUNCTS(problem.GOAL)
nogoods ←an empty hash table
for tl = 0 to ∞ do
if goals all non-mutex in St of graph then
solution ← EXTRACT-SOLUTION(graph, goals, NUMLEVELS(graph), nogoods)
if solution = failure then return solution
if graph and nogoods have both leveled off then return failure
graph ← EXPAND-GRAPH(graph, problem)
Figure 10.9 The GRAPHPLAN algorithm. GRAPHPLAN calls EXPAND-GRAPH to add a
level until either a solution is found by EXTRACT-SOLUTION, or no solution is possible.
Let us now trace the operation of GRAPHPLAN on the spare tire problem from page 370.
The graph is shown in Figure 10.10. The first line of GRAPHPLAN initializes the planning
graph to a one-level (S0) graph representing the initial state. The positive fluents from the
problem description’s initial state are shown, as are the relevant negative fluents. Not shown
are the unchanging positive literals (such as Tire(Spare)) and the irrelevant negative literals.
The goal At(Spare, Axle) is not present in S0, so we need not call EXTRACT-SOLUTION—
we are certain that there is no solution yet. Instead, EXPAND-GRAPH adds into A0 the three
actions whose preconditions exist at level S0 (i.e., all the actions except PutOn(Spare, Axle)),
along with persistence actions for all the literals in S0. The effects of the actions are added at
level S1. EXPAND-GRAPH then looks for mutex relations and adds them to the graph.
At(Spare, Axle)is still not present in S1, so again we do not call EXTRACT-SOLUTION.
We call EXPAND-GRAPH again, adding A1 and S1 and giving us the planning graph shown
in Figure 10.10. Now that we have the full complement of actions, it is worthwhile to look at
some of the examples of mutex relations and their causes:
• Inconsistent effects: Remove(Spare, Trunk ) is mutex with LeaveOvernight because
one has the effect At(Spare, Ground) and the other has its negation.
384 Chapter 10. Classical Planning
S0 A1 S2
At(Spare,Trunk)
At(Spare,Trunk)
At(Flat,Axle)
At(Flat,Axle)
At(Spare,Axle)
At(Flat,Ground)
At(Flat,Ground)
At(Spare,Ground)
At(Spare,Ground)
At(Spare,Trunk)
At(Spare,Trunk)
At(Flat,Axle)
At(Flat,Axle)
At(Spare,Axle)
At(Flat,Ground)
At(Flat,Ground)
At(Spare,Ground)
At(Spare,Ground)
At(Spare,Axle)
At(Spare,Trunk)
At(Flat,Axle)
At(Spare,Axle)
At(Flat,Ground)
At(Spare,Ground)
PutOn(Spare,Axle)
LeaveOvernight
Remove(Flat,Axle)
Remove(Spare,Trunk)
Remove(Spare,Trunk)
Remove(Flat,Axle)
LeaveOvernight
¬
¬
¬
¬
¬
¬
¬
¬
¬
¬
¬
¬
¬
A0 S1
Figure 10.10 The planning graph for the spare tire problem after expansion to level S2.
Mutex links are shown as gray lines. Not all links are shown, because the graph would be too
cluttered if we showed them all. The solution is indicated by bold lines and outlines.
• Interference: Remove(Flat, Axle) is mutex with LeaveOvernight because one has the
precondition At(Flat, Axle) and the other has its negation as an effect.
• Competing needs: PutOn(Spare, Axle) is mutex with Remove(Flat, Axle) because
one has At(Flat, Axle) as a precondition and the other has its negation.
• Inconsistent support: At(Spare, Axle) is mutex with At(Flat, Axle) in S2 because the
only way of achieving At(Spare, Axle) is by PutOn(Spare, Axle), and that is mutex
with the persistence action that is the only way of achieving At(Flat, Axle). Thus, the
mutex relations detect the immediate conflict that arises from trying to put two objects
in the same place at the same time.
This time, when we go back to the start of the loop, all the literals from the goal are present
in S2, and none of them is mutex with any other. That means that a solution might exist,
and EXTRACT-SOLUTION will try to find it. We can formulate EXTRACT-SOLUTION as a
Boolean constraint satisfaction problem (CSP) where the variables are the actions at each
level, the values for each variable are in or out of the plan, and the constraints are the mutexes
and the need to satisfy each goal and precondition.
Alternatively, we can define EXTRACT-SOLUTION as a backward search problem, where
each state in the search contains a pointer to a level in the planning graph and a set of unsatisfied goals. We define this search problem as follows:
• The initial state is the last level of the planning graph, Sn, along with the set of goals
from the planning problem.
• The actions available in a state at level Si are to select any conflict-free subset of the
actions in Ai−1 whose effects cover the goals in the state. The resulting state has level
Si−1 and has as its set of goals the preconditions for the selected set of actions. By
“conflict free,” we mean a set of actions such that no two of them are mutex and no two
of their preconditions are mutex.
Section 10.3. Planning Graphs 385
• The goal is to reach a state at level S0 such that all the goals are satisfied.
• The cost of each action is 1.
For this particular problem, we start at S2 with the goal At(Spare, Axle). The only choice we
have for achieving the goal set is PutOn(Spare, Axle). That brings us to a search state at S1
with goals At(Spare, Ground) and ¬At(Flat, Axle). The former can be achieved only by
Remove(Spare, Trunk), and the latter by either Remove(Flat, Axle) or LeaveOvernight.
But LeaveOvernight is mutex with Remove(Spare, Trunk ), so the only solution is to choose
Remove(Spare, Trunk) and Remove(Flat, Axle). That brings us to a search state at S0 with
the goals At(Spare, Trunk) and At(Flat, Axle). Both of these are present in the state, so
we have a solution: the actions Remove(Spare, Trunk) and Remove(Flat, Axle) in level
A0, followed by PutOn(Spare, Axle) in A1.
In the case where EXTRACT-SOLUTION fails to find a solution for a set of goals at
a given level, we record the (level, goals) pair as a no-good, just as we did in constraint
learning for CSPs (page 220). Whenever EXTRACT-SOLUTION is called again with the same
level and goals, we can find the recorded no-good and immediately return failure rather than
searching again. We see shortly that no-goods are also used in the termination test.
We know that planning is PSPACE-complete and that constructing the planning graph
takes polynomial time, so it must be the case that solution extraction is intractable in the worst
case. Therefore, we will need some heuristic guidance for choosing among actions during the
backward search. One approach that works well in practice is a greedy algorithm based on
the level cost of the literals. For any set of goals, we proceed in the following order:
1. Pick first the literal with the highest level cost.
2. To achieve that literal, prefer actions with easier preconditions. That is, choose an action
such that the sum (or maximum) of the level costs of its preconditions is smallest.
10.3.3 Termination of GRAPHPLAN
So far, we have skated over the question of termination. Here we show that GRAPHPLAN will
in fact terminate and return failure when there is no solution.
The first thing to understand is why we can’t stop expanding the graph as soon as it has
leveled off. Consider an air cargo domain with one plane and n pieces of cargo at airport
A, all of which have airport B as their destination. In this version of the problem, only one
piece of cargo can fit in the plane at a time. The graph will level off at level 4, reflecting the
fact that for any single piece of cargo, we can load it, fly it, and unload it at the destination in
three steps. But that does not mean that a solution can be extracted from the graph at level 4;
in fact a solution will require 4n − 1 steps: for each piece of cargo we load, fly, and unload,
and for all but the last piece we need to fly back to airport A to get the next piece.
How long do we have to keep expanding after the graph has leveled off? If the function
EXTRACT-SOLUTION fails to find a solution, then there must have been at least one set of
goals that were not achievable and were marked as a no-good. So if it is possible that there
might be fewer no-goods in the next level, then we should continue. As soon as the graph
itself and the no-goods have both leveled off, with no solution found, we can terminate with
failure because there is no possibility of a subsequent change that could add a solution.
386 Chapter 10. Classical Planning
Now all we have to do is prove that the graph and the no-goods will always level off. The
key to this proof is that certain properties of planning graphs are monotonically increasing or
decreasing. “X increases monotonically” means that the set of Xs at level i + 1 is a superset
(not necessarily proper) of the set at level i. The properties are as follows:
• Literals increase monotonically: Once a literal appears at a given level, it will appear
at all subsequent levels. This is because of the persistence actions; once a literal shows
up, persistence actions cause it to stay forever.
• Actions increase monotonically: Once an action appears at a given level, it will appear
at all subsequent levels. This is a consequence of the monotonic increase of literals; if
the preconditions of an action appear at one level, they will appear at subsequent levels,
and thus so will the action.
• Mutexes decrease monotonically: If two actions are mutex at a given level Ai, then they
will also be mutex for all previous levels at which they both appear. The same holds for
mutexes between literals. It might not always appear that way in the figures, because
the figures have a simplification: they display neither literals that cannot hold at level
Si nor actions that cannot be executed at level Ai. We can see that “mutexes decrease
monotonically” is true if you consider that these invisible literals and actions are mutex
with everything.
The proof can be handled by cases: if actions A and B are mutex at level Ai, it
must be because of one of the three types of mutex. The first two, inconsistent effects
and interference, are properties of the actions themselves, so if the actions are mutex
at Ai, they will be mutex at every level. The third case, competing needs, depends on
conditions at level Si: that level must contain a precondition of A that is mutex with
a precondition of B. Now, these two preconditions can be mutex if they are negations
of each other (in which case they would be mutex in every level) or if all actions for
achieving one are mutex with all actions for achieving the other. But we already know
that the available actions are increasing monotonically, so, by induction, the mutexes
must be decreasing.
• No-goods decrease monotonically: If a set of goals is not achievable at a given level,
then they are not achievable in any previous level. The proof is by contradiction: if they
were achievable at some previous level, then we could just add persistence actions to
make them achievable at a subsequent level.
Because the actions and literals increase monotonically and because there are only a finite
number of actions and literals, there must come a level that has the same number of actions
and literals as the previous level. Because mutexes and no-goods decrease, and because there
can never be fewer than zero mutexes or no-goods, there must come a level that has the
same number of mutexes and no-goods as the previous level. Once a graph has reached this
state, then if one of the goals is missing or is mutex with another goal, then we can stop the
GRAPHPLAN algorithm and return failure. That concludes a sketch of the proof; for more
details see Ghallab et al. (2004).
Section 10.4. Other Classical Planning Approaches 387
Year Track Winning Systems (approaches)
2008 Optimal GAMER (model checking, bidirectional search)
2008 Satisficing LAMA (fast downward search with FF heuristic)
2006 Optimal SATPLAN, MAXPLAN (Boolean satisfiability)
2006 Satisficing SGPLAN (forward search; partitions into independent subproblems)
2004 Optimal SATPLAN (Boolean satisfiability)
2004 Satisficing FAST DIAGONALLY DOWNWARD (forward search with causal graph)
2002 Automated LPG (local search, planning graphs converted to CSPs)
2002 Hand-coded TLPLAN (temporal action logic with control rules for forward search)
2000 Automated FF (forward search)
2000 Hand-coded TALPLANNER (temporal action logic with control rules for forward search)
1998 Automated IPP (planning graphs); HSP (forward search)
Figure 10.11 Some of the top-performing systems in the International Planning Competition. Each year there are various tracks: “Optimal” means the planners must produce the
shortest possible plan, while “Satisficing” means nonoptimal solutions are accepted. “Handcoded” means domain-specific heuristics are allowed; “Automated” means they are not.
10.4 OTHER CLASSICAL PLANNING APPROACHES
Currently the most popular and effective approaches to fully automated planning are:
• Translating to a Boolean satisfiability (SAT) problem
• Forward state-space search with carefully crafted heuristics (Section 10.2)
• Search using a planning graph (Section 10.3)
These three approaches are not the only ones tried in the 40-year history of automated planning. Figure 10.11 shows some of the top systems in the International Planning Competitions,
which have been held every even year since 1998. In this section we first describe the translation to a satisfiability problem and then describe three other influential approaches: planning
as first-order logical deduction; as constraint satisfaction; and as plan refinement.
10.4.1 Classical planning as Boolean satisfiability
In Section 7.7.4 we saw how SATPLAN solves planning problems that are expressed in propositional logic. Here we show how to translate a PDDL description into a form that can be
processed by SATPLAN. The translation is a series of straightforward steps:
• Propositionalize the actions: replace each action schema with a set of ground actions
formed by substituting constants for each of the variables. These ground actions are not
part of the translation, but will be used in subsequent steps.
• Define the initial state: assert F0 for every fluent F in the problem’s initial state, and
¬F for every fluent not mentioned in the initial state.
• Propositionalize the goal: for every variable in the goal, replace the literals that contain
the variable with a disjunction over constants. For example, the goal of having block A
388 Chapter 10. Classical Planning
on another block, On(A, x) ∧ Block(x) in a world with objects A, B and C, would be
replaced by the goal
(On(A, A) ∧ Block (A)) ∨ (On(A, B) ∧ Block (B)) ∨ (On(A, C) ∧ Block (C)).
• Add successor-state axioms: For each fluent F, add an axiom of the form
Ft+1 ⇔ ActionCausesFt ∨ (Ft ∧ ¬ActionCausesNotFt
) ,
where ActionCausesF is a disjunction of all the ground actions that have F in their
add list, and ActionCausesNotF is a disjunction of all the ground actions that have F
in their delete list.
• Add precondition axioms: For each ground action A, add the axiom At ⇒ PRE(A)t
,
that is, if an action is taken at time t, then the preconditions must have been true.
• Add action exclusion axioms: say that every action is distinct from every other action.
The resulting translation is in the form that we can hand to SATPLAN to find a solution.
10.4.2 Planning as first-order logical deduction: Situation calculus
PDDL is a language that carefully balances the expressiveness of the language with the complexity of the algorithms that operate on it. But some problems remain difficult to express in
PDDL. For example, we can’t express the goal “move all the cargo from A to B regardless
of how many pieces of cargo there are” in PDDL, but we can do it in first-order logic, using a
universal quantifier. Likewise, first-order logic can concisely express global constraints such
as “no more than four robots can be in the same place at the same time.” PDDL can only say
this with repetitious preconditions on every possible action that involves a move.
The propositional logic representation of planning problems also has limitations, such
as the fact that the notion of time is tied directly to fluents. For example, South2 means
“the agent is facing south at time 2.” With that representation, there is no way to say “the
agent would be facing south at time 2 if it executed a right turn at time 1; otherwise it would
be facing east.” First-order logic lets us get around this limitation by replacing the notion
of linear time with a notion of branching situations, using a representation called situation
calculus that works like this: SITUATION
CALCULUS
SITUATION • The initial state is called a situation. If s is a situation and a is an action, then
RESULT(s, a) is also a situation. There are no other situations. Thus, a situation corresponds to a sequence, or history, of actions. You can also think of a situation as the
result of applying the actions, but note that two situations are the same only if their start
and actions are the same: (RESULT(s, a) = RESULT(s
, a
)) ⇔ (s = s ∧ a = a
).
Some examples of actions and situations are shown in Figure 10.12.
• A function or relation that can vary from one situation to the next is a fluent. By convention, the situation s is always the last argument to the fluent, for example At(x, l, s) is a
relational fluent that is true when object x is at location l in situation s, and Location is a
functional fluent such that Location(x, s) = l holds in the same situations as At(x, l, s).
POSSIBILITY AXIOM • Each action’s preconditions are described with a possibility axiom that says when the
action can be taken. It has the form Φ(s) ⇒ Poss(a, s) where Φ(s) is some formula
Section 10.4. Other Classical Planning Approaches 389
PIT
PIT
PIT
Gold
PIT
PIT
PIT
Gold
PIT
PIT
PIT
Gold
S0
Forward
Result(S0, Forward)
Result(Result(S0, Forward),
Turn(Right))
Turn(Right)
Figure 10.12 Situations as the results of actions in the wumpus world.
involving s that describes the preconditions. An example from the wumpus world says
that it is possible to shoot if the agent is alive and has an arrow:
Alive(Agent, s) ∧ Have(Agent, Arrow, s) ⇒ Poss(Shoot, s)
• Each fluent is described with a successor-state axiom that says what happens to the
fluent, depending on what action is taken. This is similar to the approach we took for
propositional logic. The axiom has the form
Action is possible ⇒
(Fluent is true in result state ⇔ Action’s effect made it true
∨ It was true before and action left it alone) .
For example, the axiom for the relational fluent Holding says that the agent is holding
some gold g after executing a possible action if and only if the action was a Grab of g
or if the agent was already holding g and the action was not releasing it:
Poss(a, s) ⇒
(Holding(Agent, g, Result(a, s)) ⇔
a = Grab(g) ∨ (Holding(Agent, g, s) ∧ a = Release(g))) .
UNIQUE ACTION
AXIOMS • We need unique action axioms so that the agent can deduce that, for example, a =
Release(g). For each distinct pair of action names Ai and Aj we have an axiom that
says the actions are different:
Ai(x, . . .) = Aj (y,...)
390 Chapter 10. Classical Planning
and for each action name Ai we have an axiom that says two uses of that action name
are equal if and only if all their arguments are equal:
Ai(x1,...,xn) = Ai(y1,...,yn) ⇔ x1 = y1 ∧ ... ∧ xn = yn .
• A solution is a situation (and hence a sequence of actions) that satisfies the goal.
Work in situation calculus has done a lot to define the formal semantics of planning and to
open up new areas of investigation. But so far there have not been any practical large-scale
planning programs based on logical deduction over the situation calculus. This is in part
because of the difficulty of doing efficient inference in FOL, but is mainly because the field
has not yet developed effective heuristics for planning with situation calculus.
10.4.3 Planning as constraint satisfaction
We have seen that constraint satisfaction has a lot in common with Boolean satisfiability, and
we have seen that CSP techniques are effective for scheduling problems, so it is not surprising
that it is possible to encode a bounded planning problem (i.e., the problem of finding a plan of
length k) as a constraint satisfaction problem (CSP). The encoding is similar to the encoding
to a SAT problem (Section 10.4.1), with one important simplification: at each time step we
need only a single variable, Actiont
, whose domain is the set of possible actions. We no
longer need one variable for every action, and we don’t need the action exclusion axioms. It
is also possible to encode a planning graph into a CSP. This is the approach taken by GP-CSP
(Do and Kambhampati, 2003).
10.4.4 Planning as refinement of partially ordered plans
All the approaches we have seen so far construct totally ordered plans consisting of a strictly
linear sequences of actions. This representation ignores the fact that many subproblems are
independent. A solution to an air cargo problem consists of a totally ordered sequence of
actions, yet if 30 packages are being loaded onto one plane in one airport and 50 packages are
being loaded onto another at another airport, it seems pointless to come up with a strict linear
ordering of 80 load actions; the two subsets of actions should be thought of independently.
An alternative is to represent plans as partially ordered structures: a plan is a set of
actions and a set of constraints of the form Before(ai, aj ) saying that one action occurs
before another. In the bottom of Figure 10.13, we see a partially ordered plan that is a solution
to the spare tire problem. Actions are boxes and ordering constraints are arrows. Note that
Remove(Spare, Trunk) and Remove(Flat, Axle) can be done in either order as long as they
are both completed before the PutOn(Spare, Axle) action.
Partially ordered plans are created by a search through the space of plans rather than
through the state space. We start with the empty plan consisting of just the initial state and
the goal, with no actions in between, as in the top of Figure 10.13. The search procedure then
FLAW looks for a flaw in the plan, and makes an addition to the plan to correct the flaw (or if no
correction can be made, the search backtracks and tries something else). A flaw is anything
that keeps the partial plan from being a solution. For example, one flaw in the empty plan is
that no action achieves At(Spare, Axle). One way to correct the flaw is to insert into the plan
Section 10.4. Other Classical Planning Approaches 391
Start At(Spare,Axle) Finish At(Flat,Axle)
At(Spare,Trunk)
(a)
At(Spare,Trunk) Remove(Spare,Trunk)
PutOn(Spare,Axle) At(Spare,Ground)
At(Flat,Axle)
Start At(Spare,Axle) Finish At(Flat,Axle)
At(Spare,Trunk)
¬
(b)
Start
At(Spare,Trunk) Remove(Spare,Trunk)
At(Flat,Axle) Remove(Flat,Axle)
PutOn(Spare,Axle) At(Spare,Ground)
At(Flat,Axle)
At(Spare,Axle) Finish At(Flat,Axle)
At(Spare,Trunk)
¬
(c)
Figure 10.13 (a) the tire problem expressed as an empty plan. (b) an incomplete partially
ordered plan for the tire problem. Boxes represent actions and arrows indicate that one action
must occur before another. (c) a complete partially-ordered solution.
the action PutOn(Spare, Axle). Of course that introduces some new flaws: the preconditions
of the new action are not achieved. The search keeps adding to the plan (backtracking if
necessary) until all flaws are resolved, as in the bottom of Figure 10.13. At every step, we
LEAST COMMITMENT make the least commitment possible to fix the flaw. For example, in adding the action
Remove(Spare, Trunk) we need to commit to having it occur before PutOn(Spare, Axle),
but we make no other commitment that places it before or after other actions. If there were a
variable in the action schema that could be left unbound, we would do so.
In the 1980s and 90s, partial-order planning was seen as the best way to handle planning problems with independent subproblems—after all, it was the only approach that explicitly represents independent branches of a plan. On the other hand, it has the disadvantage
of not having an explicit representation of states in the state-transition model. That makes
some computations cumbersome. By 2000, forward-search planners had developed excellent
heuristics that allowed them to efficiently discover the independent subproblems that partialorder planning was designed for. As a result, partial-order planners are not competitive on
fully automated classical planning problems.
However, partial-order planning remains an important part of the field. For some specific tasks, such as operations scheduling, partial-order planning with domain specific heuristics is the technology of choice. Many of these systems use libraries of high-level plans, as
described in Section 11.2. Partial-order planning is also often used in domains where it is important for humans to understand the plans. Operational plans for spacecraft and Mars rovers
are generated by partial-order planners and are then checked by human operators before being
uploaded to the vehicles for execution. The plan refinement approach makes it easier for the
humans to understand what the planning algorithms are doing and verify that they are correct.
392 Chapter 10. Classical Planning
10.5 ANALYSIS OF PLANNING APPROACHES
Planning combines the two major areas of AI we have covered so far: search and logic. A
planner can be seen either as a program that searches for a solution or as one that (constructively) proves the existence of a solution. The cross-fertilization of ideas from the two areas
has led both to improvements in performance amounting to several orders of magnitude in
the last decade and to an increased use of planners in industrial applications. Unfortunately,
we do not yet have a clear understanding of which techniques work best on which kinds of
problems. Quite possibly, new techniques will emerge that dominate existing methods.
Planning is foremost an exercise in controlling combinatorial explosion. If there are n
propositions in a domain, then there are 2n states. As we have seen, planning is PSPACEhard. Against such pessimism, the identification of independent subproblems can be a powerful weapon. In the best case—full decomposability of the problem—we get an exponential
speedup. Decomposability is destroyed, however, by negative interactions between actions.
GRAPHPLAN records mutexes to point out where the difficult interactions are. SATPLAN represents a similar range of mutex relations, but does so by using the general CNF form rather
than a specific data structure. Forward search addresses the problem heuristically by trying
to find patterns (subsets of propositions) that cover the independent subproblems. Since this
approach is heuristic, it can work even when the subproblems are not completely independent.
Sometimes it is possible to solve a problem efficiently by recognizing that negative
interactions can be ruled out. We say that a problem has serializable subgoals if there exists SERIALIZABLE
SUBGOAL
an order of subgoals such that the planner can achieve them in that order without having to
undo any of the previously achieved subgoals. For example, in the blocks world, if the goal
is to build a tower (e.g., A on B, which in turn is on C, which in turn is on the Table, as in
Figure 10.4 on page 371), then the subgoals are serializable bottom to top: if we first achieve
C on Table, we will never have to undo it while we are achieving the other subgoals. A
planner that uses the bottom-to-top trick can solve any problem in the blocks world without
backtracking (although it might not always find the shortest plan).
As a more complex example, for the Remote Agent planner that commanded NASA’s
Deep Space One spacecraft, it was determined that the propositions involved in commanding a spacecraft are serializable. This is perhaps not too surprising, because a spacecraft is
designed by its engineers to be as easy as possible to control (subject to other constraints).
Taking advantage of the serialized ordering of goals, the Remote Agent planner was able to
eliminate most of the search. This meant that it was fast enough to control the spacecraft in
real time, something previously considered impossible.
Planners such as GRAPHPLAN, SATPLAN, and FF have moved the field of planning
forward, by raising the level of performance of planning systems, by clarifying the representational and combinatorial issues involved, and by the development of useful heuristics.
However, there is a question of how far these techniques will scale. It seems likely that further
progress on larger problems cannot rely only on factored and propositional representations,
and will require some kind of synthesis of first-order and hierarchical representations with
the efficient heuristics currently in use.
Section 10.6. Summary 393
10.6 SUMMARY
In this chapter, we defined the problem of planning in deterministic, fully observable, static
environments. We described the PDDL representation for planning problems and several
algorithmic approaches for solving them. The points to remember:
• Planning systems are problem-solving algorithms that operate on explicit propositional
or relational representations of states and actions. These representations make possible the derivation of effective heuristics and the development of powerful and flexible
algorithms for solving problems.
• PDDL, the Planning Domain Definition Language, describes the initial and goal states
as conjunctions of literals, and actions in terms of their preconditions and effects.
• State-space search can operate in the forward direction (progression) or the backward
direction (regression). Effective heuristics can be derived by subgoal independence
assumptions and by various relaxations of the planning problem.
• A planning graph can be constructed incrementally, starting from the initial state. Each
layer contains a superset of all the literals or actions that could occur at that time step
and encodes mutual exclusion (mutex) relations among literals or actions that cannot cooccur. Planning graphs yield useful heuristics for state-space and partial-order planners
and can be used directly in the GRAPHPLAN algorithm.
• Other approaches include first-order deduction over situation calculus axioms; encoding
a planning problem as a Boolean satisfiability problem or as a constraint satisfaction
problem; and explicitly searching through the space of partially ordered plans.
• Each of the major approaches to planning has its adherents, and there is as yet no consensus on which is best. Competition and cross-fertilization among the approaches have
resulted in significant gains in efficiency for planning systems.
BIBLIOGRAPHICAL AND HISTORICAL NOTES
AI planning arose from investigations into state-space search, theorem proving, and control
theory and from the practical needs of robotics, scheduling, and other domains. STRIPS (Fikes
and Nilsson, 1971), the first major planning system, illustrates the interaction of these influences. STRIPS was designed as the planning component of the software for the Shakey robot
project at SRI. Its overall control structure was modeled on that of GPS, the General Problem
Solver (Newell and Simon, 1961), a state-space search system that used means–ends analysis. Bylander (1992) shows simple STRIPS planning to be PSPACE-complete. Fikes and
Nilsson (1993) give a historical retrospective on the STRIPS project and its relationship to
more recent planning efforts.
The representation language used by STRIPS has been far more influential than its algorithmic approach; what we call the “classical” language is close to what STRIPS used.
394 Chapter 10. Classical Planning
The Action Description Language, or ADL (Pednault, 1986), relaxed some of the STRIPS
restrictions and made it possible to encode more realistic problems. Nebel (2000) explores
schemes for compiling ADL into STRIPS. The Problem Domain Description Language, or
PDDL (Ghallab et al., 1998), was introduced as a computer-parsable, standardized syntax for
representing planning problems and has been used as the standard language for the International Planning Competition since 1998. There have been several extensions; the most recent
version, PDDL 3.0, includes plan constraints and preferences (Gerevini and Long, 2005).
Planners in the early 1970s generally considered totally ordered action sequences. Problem decomposition was achieved by computing a subplan for each subgoal and then stringing
LINEAR PLANNING the subplans together in some order. This approach, called linear planning by Sacerdoti
(1975), was soon discovered to be incomplete. It cannot solve some very simple problems,
such as the Sussman anomaly (see Exercise 10.7), found by Allen Brown during experimentation with the HACKER system (Sussman, 1975). A complete planner must allow for interINTERLEAVING leaving of actions from different subplans within a single sequence. The notion of serializable
subgoals (Korf, 1987) corresponds exactly to the set of problems for which noninterleaved
planners are complete.
One solution to the interleaving problem was goal-regression planning, a technique in
which steps in a totally ordered plan are reordered so as to avoid conflict between subgoals.
This was introduced by Waldinger (1975) and also used by Warren’s (1974) WARPLAN.
WARPLAN is also notable in that it was the first planner to be written in a logic programming language (Prolog) and is one of the best examples of the remarkable economy that can
sometimes be gained with logic programming: WARPLAN is only 100 lines of code, a small
fraction of the size of comparable planners of the time.
The ideas underlying partial-order planning include the detection of conflicts (Tate,
1975a) and the protection of achieved conditions from interference (Sussman, 1975). The
construction of partially ordered plans (then called task networks) was pioneered by the
NOAH planner (Sacerdoti, 1975, 1977) and by Tate’s (1975b, 1977) NONLIN system.
Partial-order planning dominated the next 20 years of research, yet the first clear formal exposition was TWEAK (Chapman, 1987), a planner that was simple enough to allow
proofs of completeness and intractability (NP-hardness and undecidability) of various planning problems. Chapman’s work led to a straightforward description of a complete partialorder planner (McAllester and Rosenblitt, 1991), then to the widely distributed implementations SNLP (Soderland and Weld, 1991) and UCPOP (Penberthy and Weld, 1992). Partialorder planning fell out of favor in the late 1990s as faster methods emerged. Nguyen and
Kambhampati (2001) suggest that a reconsideration is merited: with accurate heuristics derived from a planning graph, their REPOP planner scales up much better than GRAPHPLAN
in parallelizable domains and is competitive with the fastest state-space planners.
The resurgence of interest in state-space planning was pioneered by Drew McDermott’s UNPOP program (1996), which was the first to suggest the ignore-delete-list heuristic,
The name UNPOP was a reaction to the overwhelming concentration on partial-order planning at the time; McDermott suspected that other approaches were not getting the attention
they deserved. Bonet and Geffner’s Heuristic Search Planner (HSP) and its later derivatives (Bonet and Geffner, 1999; Haslum et al., 2005; Haslum, 2006) were the first to make
Bibliographical and Historical Notes 395
state-space search practical for large planning problems. HSP searches in the forward direction while HSPR (Bonet and Geffner, 1999) searches backward. The most successful
state-space searcher to date is FF (Hoffmann, 2001; Hoffmann and Nebel, 2001; Hoffmann,
2005), winner of the AIPS 2000 planning competition. FASTDOWNWARD (Helmert, 2006)
is a forward state-space search planner that preprocesses the action schemas into an alternative representation which makes some of the constraints more explicit. FASTDOWNWARD
(Helmert and Richter, 2004; Helmert, 2006) won the 2004 planning competition, and LAMA
(Richter and Westphal, 2008), a planner based on FASTDOWNWARD with improved heuristics, won the 2008 competition.
Bylander (1994) and Ghallab et al. (2004) discuss the computational complexity of
several variants of the planning problem. Helmert (2003) proves complexity bounds for many
of the standard benchmark problems, and Hoffmann (2005) analyzes the search space of the
ignore-delete-list heuristic. Heuristics for the set-covering problem are discussed by Caprara
et al. (1995) for scheduling operations of the Italian railway. Edelkamp (2009) and Haslum
et al. (2007) describe how to construct pattern databases for planning heuristics. As we
mentioned in Chapter 3, Felner et al. (2004) show encouraging results using pattern databases
for sliding blocks puzzles, which can be thought of as a planning domain, but Hoffmann et al.
(2006) show some limitations of abstraction for classical planning problems.
Avrim Blum and Merrick Furst (1995, 1997) revitalized the field of planning with their
GRAPHPLAN system, which was orders of magnitude faster than the partial-order planners of
the time. Other graph-planning systems, such as IPP (Koehler et al., 1997), STAN (Fox and
Long, 1998), and SGP (Weld et al., 1998), soon followed. A data structure closely resembling
the planning graph had been developed slightly earlier by Ghallab and Laruelle (1994), whose
IXTET partial-order planner used it to derive accurate heuristics to guide searches. Nguyen
et al. (2001) thoroughly analyze heuristics derived from planning graphs. Our discussion of
planning graphs is based partly on this work and on lecture notes and articles by Subbarao
Kambhampati (Bryce and Kambhampati, 2007). As mentioned in the chapter, a planning
graph can be used in many different ways to guide the search for a solution. The winner
of the 2002 AIPS planning competition, LPG (Gerevini and Serina, 2002, 2003), searched
planning graphs using a local search technique inspired by WALKSAT.
The situation calculus approach to planning was introduced by John McCarthy (1963).
The version we show here was proposed by Ray Reiter (1991, 2001).
Kautz et al. (1996) investigated various ways to propositionalize action schemas, finding that the most compact forms did not necessarily lead to the fastest solution times. A
systematic analysis was carried out by Ernst et al. (1997), who also developed an automatic “compiler” for generating propositional representations from PDDL problems. The
BLACKBOX planner, which combines ideas from GRAPHPLAN and SATPLAN, was developed by Kautz and Selman (1998). CPLAN, a planner based on constraint satisfaction, was
described by van Beek and Chen (1999).
Most recently, there has been interest in the representation of plans as binary decision
diagrams, compact data structures for Boolean expressions widely studied in the hardware BINARY DECISION
DIAGRAM
verification community (Clarke and Grumberg, 1987; McMillan, 1993). There are techniques
for proving properties of binary decision diagrams, including the property of being a solution
396 Chapter 10. Classical Planning
to a planning problem. Cimatti et al. (1998) present a planner based on this approach. Other
representations have also been used; for example, Vossen et al. (2001) survey the use of
integer programming for planning.
The jury is still out, but there are now some interesting comparisons of the various
approaches to planning. Helmert (2001) analyzes several classes of planning problems, and
shows that constraint-based approaches such as GRAPHPLAN and SATPLAN are best for NPhard domains, while search-based approaches do better in domains where feasible solutions
can be found without backtracking. GRAPHPLAN and SATPLAN have trouble in domains
with many objects because that means they must create many actions. In some cases the
problem can be delayed or avoided by generating the propositionalized actions dynamically,
only as needed, rather than instantiating them all before the search begins.
Readings in Planning (Allen et al., 1990) is a comprehensive anthology of early work
in the field. Weld (1994, 1999) provides two excellent surveys of planning algorithms of
the 1990s. It is interesting to see the change in the five years between the two surveys:
the first concentrates on partial-order planning, and the second introduces GRAPHPLAN and
SATPLAN. Automated Planning (Ghallab et al., 2004) is an excellent textbook on all aspects
of planning. LaValle’s text Planning Algorithms (2006) covers both classical and stochastic
planning, with extensive coverage of robot motion planning.
Planning research has been central to AI since its inception, and papers on planning are
a staple of mainstream AI journals and conferences. There are also specialized conferences
such as the International Conference on AI Planning Systems, the International Workshop on
Planning and Scheduling for Space, and the European Conference on Planning.
EXERCISES
10.1 Describe the differences and similarities between problem solving and planning.
10.2 Given the action schemas and initial state from Figure 10.1, what are all the applicable
concrete instances of Fly(p, from,to) in the state described by
At(P1, JFK) ∧ At(P2, SFO) ∧ Plane(P1) ∧ Plane(P2)
∧ Airport(JFK ) ∧ Airport(SFO) ?
10.3 The monkey-and-bananas problem is faced by a monkey in a laboratory with some
bananas hanging out of reach from the ceiling. A box is available that will enable the monkey
to reach the bananas if he climbs on it. Initially, the monkey is at A, the bananas at B, and the
box at C. The monkey and box have height Low, but if the monkey climbs onto the box he
will have height High, the same as the bananas. The actions available to the monkey include
Go from one place to another, Push an object from one place to another, ClimbUp onto or
ClimbDown from an object, and Grasp or Ungrasp an object. The result of a Grasp is that
the monkey holds the object if the monkey and object are in the same place at the same height.
a. Write down the initial state description.
’s abilities. Shakey’s six actions are the following:
• Go(x, y, r), which requires that Shakey be At x and that x and y are locations In the
same room r. By convention a door between two rooms is in both of them.
• Push a box b from location x to location y within the same room: Push(b, x, y, r). You
will need the predicate Box and constants for the boxes.
• Climb onto a box from position x: ClimbUp(x, b); climb down from a box to position
x: ClimbDown(b, x). We will need the predicate On and the constant Floor .
• Turn a light switch on or off: TurnOn(s, b); TurnOff (s, b). To turn a light on or off,
Shakey must be on top of a box at the light switch’s location.
Write PDDL sentences for Shakey’s six actions and the initial state from Figure 10.14. Construct a plan for Shakey to get Box 2 into Room2.
10.5 A finite Turing machine has a finite one-dimensional tape of cells, each cell containing
one of a finite number of symbols. One cell has a read and write head above it. There is a
finite set of states the machine can be in, one of which is the accept state. At each time step,
depending on the symbol on the cell under the head and the machine’s current state, there are
a set of actions we can choose from. Each action involves writing a symbol to the cell under
the head, transitioning the machine to a state, and optionally moving the head left or right.
The mapping that determines which actions are allowed is the Turing machine’s program.
Your goal is to control the machine into the accept state.
Represent the Turing machine acceptance problem as a planning problem. If you can
do this, it demonstrates that determining whether a planning problem has a solution is at least
as hard as the Turing acceptance problem, which is PSPACE-hard.
10.6 Explain why dropping negative effects from every action schema in a planning problem results in a relaxed problem.
10.7 Figure 10.4 (page 371) shows a blocks-world problem that is known as the Sussman
SUSSMAN ANOMALY anomaly. The problem was considered anomalous because the noninterleaved planners of
the early 1970s could not solve it. Write a definition of the problem and solve it, either by
hand or with a planning program. A noninterleaved planner is a planner that, when given two
subgoals G1 and G2, produces either a plan for G1 concatenated with a plan for G2, or vice
versa. Explain why a noninterleaved planner cannot solve this problem.
10.8 Prove that backward search with PDDL problems is complete.
10.9 Construct levels 0, 1, and 2 of the planning graph for the problem in Figure 10.1.
10.10 Prove the following assertions about planning graphs:
a. A literal that does not appear in the final level of the graph cannot be achieved.
Exercises 399
b. The level cost of a literal in a serial graph is no greater than the actual cost of an optimal
plan for achieving it.
10.11 The set-level heuristic (see page 382) uses a planning graph to estimate the cost of
achieving a conjunctive goal from the current state. What relaxed problem is the set-level
heuristic the solution to?
10.12 Examine the definition of bidirectional search in Chapter 3.
a. Would bidirectional state-space search be a good idea for planning?
b. What about bidirectional search in the space of partial-order plans?
c. Devise a version of partial-order planning in which an action can be added to a plan if its
preconditions can be achieved by the effects of actions already in the plan. Explain how
to deal with conflicts and ordering constraints. Is the algorithm essentially identical to
forward state-space search?
10.13 We contrasted forward and backward state-space searchers with partial-order planners, saying that the latter is a plan-space searcher. Explain how forward and backward statespace search can also be considered plan-space searchers, and say what the plan refinement
operators are.
10.14 Up to now we have assumed that the plans we create always make sure that an action’s
preconditions are satisfied. Let us now investigate what propositional successor-state axioms
such as HaveArrowt+1 ⇔ (HaveArrowt ∧ ¬Shoott
) have to say about actions whose
preconditions are not satisfied.
a. Show that the axioms predict that nothing will happen when an action is executed in a
state where its preconditions are not satisfied.
b. Consider a plan p that contains the actions required to achieve a goal but also includes
illegal actions. Is it the case that
initial state ∧ successor-state axioms ∧ p |= goal ?
c. With first-order successor-state axioms in situation calculus, is it possible to prove that
a plan containing illegal actions will achieve the goal?
10.15 Consider how to translate a set of action schemas into the successor-state axioms of
situation calculus.
a. Consider the schema for Fly(p, from,to). Write a logical definition for the predicate
Poss(Fly(p, from,to), s), which is true if the preconditions for Fly(p, from,to) are
satisfied in situation s.
b. Next, assuming that Fly(p, from,to) is the only action schema available to the agent,
write down a successor-state axiom for At(p, x, s) that captures the same information
as the action schema.
400 Chapter 10. Classical Planning
c. Now suppose there is an additional method of travel: Teleport(p, from,to). It has
the additional precondition ¬Warped(p) and the additional effect Warped(p). Explain
how the situation calculus knowledge base must be modified.
d. Finally, develop a general and precisely specified procedure for carrying out the translation from a set of action schemas to a set of successor-state axioms.
10.16 In the SATPLAN algorithm in Figure 7.22 (page 272), each call to the satisfiability algorithm asserts a goal gT , where T ranges from 0 to Tmax. Suppose instead that the
satisfiability algorithm is called only once, with the goal g0 ∨ g1 ∨···∨ gTmax .
a. Will this always return a plan if one exists with length less than or equal to Tmax?
b. Does this approach introduce any new spurious “solutions”?
c. Discuss how one might modify a satisfiability algorithm such as WALKSAT so that it
finds short solutions (if they exist) when given a disjunctive goal of this form.
11 PLANNING AND ACTING
IN THE REAL WORLD
In which we see how more expressive representations and more interactive agent
architectures lead to planners that are useful in the real world.
The previous chapter introduced the most basic concepts, representations, and algorithms for
planning. Planners that are are used in the real world for planning and scheduling the operations of spacecraft, factories, and military campaigns are more complex; they extend both
the representation language and the way the planner interacts with the environment. This
chapter shows how. Section 11.1 extends the classical language for planning to talk about
actions with durations and resource constraints. Section 11.2 describes methods for constructing plans that are organized hierarchically. This allows human experts to communicate
to the planner what they know about how to solve the problem. Hierarchy also lends itself to
efficient plan construction because the planner can solve a problem at an abstract level before
delving into details. Section 11.3 presents agent architectures that can handle uncertain environments and interleave deliberation with execution, and gives some examples of real-world
systems. Section 11.4 shows how to plan when the environment contains other agents.
11.1 TIME, SCHEDULES, AND RESOURCES
The classical planning representation talks about what to do, and in what order, but the representation cannot talk about time: how long an action takes and when it occurs. For example,
the planners of Chapter 10 could produce a schedule for an airline that says which planes are
assigned to which flights, but we really need to know departure and arrival times as well. This
is the subject matter of scheduling. The real world also imposes many resource constraints;
for example, an airline has a limited number of staff—and staff who are on one flight cannot
be on another at the same time. This section covers methods for representing and solving
planning problems that include temporal and resource constraints.
The approach we take in this section is “plan first, schedule later”: that is, we divide
the overall problem into a planning phase in which actions are selected, with some ordering
constraints, to meet the goals of the problem, and a later scheduling phase, in which temporal information is added to the plan to ensure that it meets resource and deadline constraints.
401
402 Chapter 11. Planning and Acting in the Real World
Jobs({AddEngine1 ≺ AddWheels1 ≺ Inspect1 },
{AddEngine2 ≺ AddWheels2 ≺ Inspect2 })
Resources(EngineHoists(1),WheelStations (1),Inspectors (2), LugNuts(500))
Action(AddEngine1 , DURATION:30,
USE:EngineHoists(1))
Action(AddEngine2 , DURATION:60,
USE:EngineHoists(1))
Action(AddWheels1 , DURATION:30,
CONSUME:LugNuts(20), USE:WheelStations(1))
Action(AddWheels2 , DURATION:15,
CONSUME:LugNuts(20), USE:WheelStations(1))
Action(Inspecti, DURATION:10,
USE:Inspectors (1))
Figure 11.1 A job-shop scheduling problem for assembling two cars, with resource constraints. The notation A ≺ B means that action A must precede action B.
This approach is common in real-world manufacturing and logistical settings, where the planning phase is often performed by human experts. The automated methods of Chapter 10 can
also be used for the planning phase, provided that they produce plans with just the minimal
ordering constraints required for correctness. GRAPHPLAN (Section 10.3), SATPLAN (Section 10.4.1), and partial-order planners (Section 10.4.4) can do this; search-based methods
(Section 10.2) produce totally ordered plans, but these can easily be converted to plans with
minimal ordering constraints.
11.1.1 Representing temporal and resource constraints
A typical job-shop scheduling problem, as first introduced in Section 6.1.2, consists of a
JOB set of jobs, each of which consists a collection of actions with ordering constraints among
DURATION them. Each action has a duration and a set of resource constraints required by the action.
Each constraint specifies a type of resource (e.g., bolts, wrenches, or pilots), the number
CONSUMABLE of that resource required, and whether that resource is consumable (e.g., the bolts are no
REUSABLE longer available for use) or reusable (e.g., a pilot is occupied during a flight but is available
again when the flight is over). Resources can also be produced by actions with negative consumption, including manufacturing, growing, and resupply actions. A solution to a job-shop
scheduling problem must specify the start times for each action and must satisfy all the temporal ordering constraints and resource constraints. As with search and planning problems,
solutions can be evaluated according to a cost function; this can be quite complicated, with
nonlinear resource costs, time-dependent delay costs, and so on. For simplicity, we assume
MAKESPAN that the cost function is just the total duration of the plan, which is called the makespan.
Figure 11.1 shows a simple example: a problem involving the assembly of two cars. The
problem consists of two jobs, each of the form [AddEngine, AddWheels,Inspect]. Then the
Section 11.1. Time, Schedules, and Resources 403
Resources statement declares that there are four types of resources, and gives the number
of each type available at the start: 1 engine hoist, 1 wheel station, 2 inspectors, and 500 lug
nuts. The action schemas give the duration and resource needs of each action. The lug nuts
are consumed as wheels are added to the car, whereas the other resources are “borrowed” at
the start of an action and released at the action’s end.
The representation of resources as numerical quantities, such as Inspectors (2), rather
than as named entities, such as Inspector (I1) and Inspector (I2), is an example of a very
AGGREGATION general technique called aggregation. The central idea of aggregation is to group individual
objects into quantities when the objects are all indistinguishable with respect to the purpose
at hand. In our assembly problem, it does not matter which inspector inspects the car, so there
is no need to make the distinction. (The same idea works in the missionaries-and-cannibals
problem in Exercise 3.9.) Aggregation is essential for reducing complexity. Consider what
happens when a proposed schedule has 10 concurrent Inspect actions but only 9 inspectors
are available. With inspectors represented as quantities, a failure is detected immediately and
the algorithm backtracks to try another schedule. With inspectors represented as individuals,
the algorithm backtracks to try all 10! ways of assigning inspectors to actions.
11.1.2 Solving scheduling problems
We begin by considering just the temporal scheduling problem, ignoring resource constraints.
To minimize makespan (plan duration), we must find the earliest start times for all the actions
consistent with the ordering constraints supplied with the problem. It is helpful to view these
ordering constraints as a directed graph relating the actions, as shown in Figure 11.2. We can
apply the critical path method (CPM) to this graph to determine the possible start and end CRITICAL PATH
METHOD
times of each action. A path through a graph representing a partial-order plan is a linearly
ordered sequence of actions beginning with Start and ending with Finish. (For example,
there are two paths in the partial-order plan in Figure 11.2.)
CRITICAL PATH The critical path is that path whose total duration is longest; the path is “critical”
because it determines the duration of the entire plan—shortening other paths doesn’t shorten
the plan as a whole, but delaying the start of any action on the critical path slows down the
whole plan. Actions that are off the critical path have a window of time in which they can be
executed. The window is specified in terms of an earliest possible start time, ES, and a latest
SLACK possible start time, LS. The quantity LS – ES is known as the slack of an action. We can
see in Figure 11.2 that the whole plan will take 85 minutes, that each action in the top job
has 15 minutes of slack, and that each action on the critical path has no slack (by definition).
SCHEDULE Together the ES and LS times for all the actions constitute a schedule for the problem.
The following formulas serve as a definition for ES and LS and also as the outline of a
dynamic-programming algorithm to compute them. A and B are actions, and A ≺ B means
that A comes before B:
ES(Start)=0
ES(B) = maxA ≺ B ES(A) + Duration(A)
LS(Finish) = ES(Finish)
LS(A) = minB 	 A LS(B) − Duration(A) .
404 Chapter 11. Planning and Acting in the Real World
Start
 [0,0]
AddEngine1
30
 [0,15]
AddWheels1
30
 [30,45]
10
Inspect1
 [60,75]
Finish
 [85,85]
10
Inspect2
 [75,75]
15
AddWheels2
 [60,60]
60
AddEngine2
 [0,0]
AddEngine1
AddWheels1
Inspect1
AddWheels2
AddEngine2 Inspect2
0 10 20 30 40 50 60 70 80 90
Figure 11.2 Top: a representation of the temporal constraints for the job-shop scheduling
problem of Figure 11.1. The duration of each action is given at the bottom of each rectangle.
In solving the problem, we compute the earliest and latest start times as the pair [ES, LS],
displayed in the upper left. The difference between these two numbers is the slack of an
action; actions with zero slack are on the critical path, shown with bold arrows. Bottom: the
same solution shown as a timeline. Grey rectangles represent time intervals during which an
action may be executed, provided that the ordering constraints are respected. The unoccupied
portion of a gray rectangle indicates the slack.
The idea is that we start by assigning ES(Start) to be 0. Then, as soon as we get an action
B such that all the actions that come immediately before B have ES values assigned, we
set ES(B) to be the maximum of the earliest finish times of those immediately preceding
actions, where the earliest finish time of an action is defined as the earliest start time plus the
duration. This process repeats until every action has been assigned an ES value. The LS
values are computed in a similar manner, working backward from the Finish action.
The complexity of the critical path algorithm is just O(N b), where N is the number of
actions and b is the maximum branching factor into or out of an action. (To see this, note that
the LS and ES computations are done once for each action, and each computation iterates
over at most b other actions.) Therefore, finding a minimum-duration schedule, given a partial
ordering on the actions and no resource constraints, is quite easy.
Mathematically speaking, critical-path problems are easy to solve because they are defined as a conjunction of linear inequalities on the start and end times. When we introduce
resource constraints, the resulting constraints on start and end times become more complicated. For example, the AddEngine actions, which begin at the same time in Figure 11.2,
Section 11.1. Time, Schedules, and Resources 405
AddEngine1
AddWheels1
Inspect1
AddWheels2
Inspect2
AddEngine2
0 10 20 30 40 50 60 70 80 90 100 110 120
EngineHoists(1)
WheelStations(1)
Inspectors(2)
Figure 11.3 A solution to the job-shop scheduling problem from Figure 11.1, taking into
account resource constraints. The left-hand margin lists the three reusable resources, and
actions are shown aligned horizontally with the resources they use. There are two possible schedules, depending on which assembly uses the engine hoist first; we’ve shown the
shortest-duration solution, which takes 115 minutes.
require the same EngineHoist and so cannot overlap. The “cannot overlap” constraint is a
disjunction of two linear inequalities, one for each possible ordering. The introduction of
disjunctions turns out to make scheduling with resource constraints NP-hard.
Figure 11.3 shows the solution with the fastest completion time, 115 minutes. This is
30 minutes longer than the 85 minutes required for a schedule without resource constraints.
Notice that there is no time at which both inspectors are required, so we can immediately
move one of our two inspectors to a more productive position.
The complexity of scheduling with resource constraints is often seen in practice as
well as in theory. A challenge problem posed in 1963—to find the optimal schedule for a
problem involving just 10 machines and 10 jobs of 100 actions each—went unsolved for
23 years (Lawler et al., 1993). Many approaches have been tried, including branch-andbound, simulated annealing, tabu search, constraint satisfaction, and other techniques from
MINIMUM SLACK Chapters 3 and 4. One simple but popular heuristic is the minimum slack algorithm: on
each iteration, schedule for the earliest possible start whichever unscheduled action has all
its predecessors scheduled and has the least slack; then update the ES and LS times for each
affected action and repeat. The heuristic resembles the minimum-remaining-values (MRV)
heuristic in constraint satisfaction. It often works well in practice, but for our assembly
problem it yields a 130–minute solution, not the 115–minute solution of Figure 11.3.
Up to this point, we have assumed that the set of actions and ordering constraints is
fixed. Under these assumptions, every scheduling problem can be solved by a nonoverlapping
sequence that avoids all resource conflicts, provided that each action is feasible by itself. If
a scheduling problem is proving very difficult, however, it may not be a good idea to solve
it this way—it may be better to reconsider the actions and constraints, in case that leads to a
much easier scheduling problem. Thus, it makes sense to integrate planning and scheduling
by taking into account durations and overlaps during the construction of a partial-order plan.
Several of the planning algorithms in Chapter 10 can be augmented to handle this information.
For example, partial-order planners can detect resource constraint violations in much the
same way they detect conflicts with causal links. Heuristics can be devised to estimate the
total completion time of a plan. This is currently an active area of research.
406 Chapter 11. Planning and Acting in the Real World
11.2 HIERARCHICAL PLANNING
The problem-solving and planning methods of the preceding chapters all operate with a fixed
set of atomic actions. Actions can be strung together into sequences or branching networks;
state-of-the-art algorithms can generate solutions containing thousands of actions.
For plans executed by the human brain, atomic actions are muscle activations. In very
round numbers, we have about 103 muscles to activate (639, by some counts, but many of
them have multiple subunits); we can modulate their activation perhaps 10 times per second;
and we are alive and awake for about 109 seconds in all. Thus, a human life contains about
1013 actions, give or take one or two orders of magnitude. Even if we restrict ourselves to
planning over much shorter time horizons—for example, a two-week vacation in Hawaii—a
detailed motor plan would contain around 1010 actions. This is a lot more than 1000.
To bridge this gap, AI systems will probably have to do what humans appear to do: plan
at higher levels of abstraction. A reasonable plan for the Hawaii vacation might be “Go to
San Francisco airport; take Hawaiian Airlines flight 11 to Honolulu; do vacation stuff for two
weeks; take Hawaiian Airlines flight 12 back to San Francisco; go home.” Given such a plan,
the action “Go to San Francisco airport” can be viewed as a planning task in itself, with a
solution such as “Drive to the long-term parking lot; park; take the shuttle to the terminal.”
Each of these actions, in turn, can be decomposed further, until we reach the level of actions
that can be executed without deliberation to generate the required motor control sequences.
In this example, we see that planning can occur both before and during the execution
of the plan; for example, one would probably defer the problem of planning a route from a
parking spot in long-term parking to the shuttle bus stop until a particular parking spot has
been found during execution. Thus, that particular action will remain at an abstract level
prior to the execution phase. We defer discussion of this topic until Section 11.3. Here, we
concentrate on the aspect of hierarchical decomposition, an idea that pervades almost all HIERARCHICAL
DECOMPOSITION
attempts to manage complexity. For example, complex software is created from a hierarchy
of subroutines or object classes; armies operate as a hierarchy of units; governments and corporations have hierarchies of departments, subsidiaries, and branch offices. The key benefit
of hierarchical structure is that, at each level of the hierarchy, a computational task, military
mission, or administrative function is reduced to a small number of activities at the next lower
level, so the computational cost of finding the correct way to arrange those activities for the
current problem is small. Nonhierarchical methods, on the other hand, reduce a task to a
large number of individual actions; for large-scale problems, this is completely impractical.
11.2.1 High-level actions
The basic formalism we adopt to understand hierarchical decomposition comes from the area
of hierarchical task networks or HTN planning. As in classical planning (Chapter 10), we HIERARCHICAL TASK
NETWORK
assume full observability and determinism and the availability of a set of actions, now called
PRIMITIVE ACTION primitive actions, with standard precondition–effect schemas. The key additional concept is
HIGH-LEVEL ACTION the high-level action or HLA—for example, the action “Go to San Francisco airport” in the
Section 11.2. Hierarchical Planning 407
Refinement(Go(Home, SFO),
STEPS: [Drive(Home, SFOLongTermParking),
Shuttle(SFOLongTermParking, SFO)] )
Refinement(Go(Home, SFO),
STEPS: [Taxi(Home, SFO)] )
Refinement(Navigate([a, b], [x, y]),
PRECOND: a = x ∧ b = y
STEPS:[])
Refinement(Navigate([a, b], [x, y]),
PRECOND:Connected([a, b], [a − 1, b])
STEPS: [Left, Navigate([a − 1, b], [x, y])] )
Refinement(Navigate([a, b], [x, y]),
PRECOND:Connected([a, b], [a + 1, b])
STEPS: [Right, Navigate([a + 1, b], [x, y])] )
...
Figure 11.4 Definitions of possible refinements for two high-level actions: going to San
Francisco airport and navigating in the vacuum world. In the latter case, note the recursive
nature of the refinements and the use of preconditions.
example given earlier. Each HLA has one or more possible refinements, into a sequence1 REFINEMENT
of actions, each of which may be an HLA or a primitive action (which has no refinements
by definition). For example, the action “Go to San Francisco airport,” represented formally
as Go(Home, SFO), might have two possible refinements, as shown in Figure 11.4. The
same figure shows a recursive refinement for navigation in the vacuum world: to get to a
destination, take a step, and then go to the destination.
These examples show that high-level actions and their refinements embody knowledge
about how to do things. For instance, the refinements for Go(Home, SFO) say that to get to
the airport you can drive or take a taxi; buying milk, sitting down, and moving the knight to
e4 are not to be considered.
IMPLEMENTATION An HLA refinement that contains only primitive actions is called an implementation
of the HLA. For example, in the vacuum world, the sequences [Right, Right, Down] and
[Down, Right, Right] both implement the HLA Navigate([1, 3], [3, 2]). An implementation
of a high-level plan (a sequence of HLAs) is the concatenation of implementations of each
HLA in the sequence. Given the precondition–effect definitions of each primitive action, it is
straightforward to determine whether any given implementation of a high-level plan achieves
the goal. We can say, then, that a high-level plan achieves the goal from a given state if at
least one of its implementations achieves the goal from that state. The “at least one” in this
definition is crucial—not all implementations need to achieve the goal, because the agent gets
1 HTN planners often allow refinement into partially ordered plans, and they allow the refinements of two
different HLAs in a plan to share actions. We omit these important complications in the interest of understanding
the basic concepts of hierarchical planning.
408 Chapter 11. Planning and Acting in the Real World
to decide which implementation it will execute. Thus, the set of possible implementations in
HTN planning—each of which may have a different outcome—is not the same as the set of
possible outcomes in nondeterministic planning. There, we required that a plan work for all
outcomes because the agent doesn’t get to choose the outcome; nature does.
The simplest case is an HLA that has exactly one implementation. In that case, we
can compute the preconditions and effects of the HLA from those of the implementation
(see Exercise 11.3) and then treat the HLA exactly as if it were a primitive action itself. It
can be shown that the right collection of HLAs can result in the time complexity of blind
search dropping from exponential in the solution depth to linear in the solution depth, although devising such a collection of HLAs may be a nontrivial task in itself. When HLAs
have multiple possible implementations, there are two options: one is to search among the
implementations for one that works, as in Section 11.2.2; the other is to reason directly about
the HLAs—despite the multiplicity of implementations—as explained in Section 11.2.3. The
latter method enables the derivation of provably correct abstract plans, without the need to
consider their implementations.
11.2.2 Searching for primitive solutions
HTN planning is often formulated with a single “top level” action called Act, where the aim is
to find an implementation of Act that achieves the goal. This approach is entirely general. For
example, classical planning problems can be defined as follows: for each primitive action ai,
provide one refinement of Act with steps [ai, Act]. That creates a recursive definition of Act
that lets us add actions. But we need some way to stop the recursion; we do that by providing
one more refinement for Act, one with an empty list of steps and with a precondition equal
to the goal of the problem. This says that if the goal is already achieved, then the right
implementation is to do nothing.
The approach leads to a simple algorithm: repeatedly choose an HLA in the current
plan and replace it with one of its refinements, until the plan achieves the goal. One possible
implementation based on breadth-first tree search is shown in Figure 11.5. Plans are considered in order of depth of nesting of the refinements, rather than number of primitive steps. It
is straightforward to design a graph-search version of the algorithm as well as depth-first and
iterative deepening versions.
In essence, this form of hierarchical search explores the space of sequences that conform
to the knowledge contained in the HLA library about how things are to be done. A great deal
of knowledge can be encoded, not just in the action sequences specified in each refinement but
also in the preconditions for the refinements. For some domains, HTN planners have been
able to generate huge plans with very little search. For example, O-PLAN (Bell and Tate,
1985), which combines HTN planning with scheduling, has been used to develop production
plans for Hitachi. A typical problem involves a product line of 350 different products, 35
assembly machines, and over 2000 different operations. The planner generates a 30-day
schedule with three 8-hour shifts a day, involving tens of millions of steps. Another important
aspect of HTN plans is that they are, by definition, hierarchically structured; usually this
makes them easy for humans to understand.
Section 11.2. Hierarchical Planning 409
function HIERARCHICAL-SEARCH(problem, hierarchy) returns a solution, or failure
frontier ← a FIFO queue with [Act] as the only element
loop do
if EMPTY?(frontier ) then return failure
plan ← POP(frontier ) /* chooses the shallowest plan in frontier */
hla ← the first HLA in plan, or null if none
prefix,suffix ← the action subsequences before and after hla in plan
outcome ← RESULT(problem.INITIAL-STATE, prefix)
if hla is null then /* so plan is primitive and outcome is its result */
if outcome satisfies problem.GOAL then return plan
else for each sequence in REFINEMENTS(hla, outcome, hierarchy) do
frontier ← INSERT(APPEND(prefix , sequence, suffix),frontier )
Figure 11.5 A breadth-first implementation of hierarchical forward planning search. The
initial plan supplied to the algorithm is [Act]. The REFINEMENTS function returns a set of
action sequences, one for each refinement of the HLA whose preconditions are satisfied by
the specified state, outcome.
The computational benefits of hierarchical search can be seen by examining an idealized case. Suppose that a planning problem has a solution with d primitive actions. For
a nonhierarchical, forward state-space planner with b allowable actions at each state, the
cost is O(bd), as explained in Chapter 3. For an HTN planner, let us suppose a very regular refinement structure: each nonprimitive action has r possible refinements, each into
k actions at the next lower level. We want to know how many different refinement trees
there are with this structure. Now, if there are d actions at the primitive level, then the
number of levels below the root is logk d, so the number of internal refinement nodes is
1 + k + k2 + ··· + klogk d−1 = (d − 1)/(k − 1). Each internal node has r possible refinements, so r(d−1)/(k−1) possible regular decomposition trees could be constructed. Examining
this formula, we see that keeping r small and k large can result in huge savings: essentially
we are taking the kth root of the nonhierarchical cost, if b and r are comparable. Small r and
large k means a library of HLAs with a small number of refinements each yielding a long
action sequence (that nonetheless allows us to solve any problem). This is not always possible: long action sequences that are usable across a wide range of problems are extremely
precious.
The key to HTN planning, then, is the construction of a plan library containing known
methods for implementing complex, high-level actions. One method of constructing the library is to learn the methods from problem-solving experience. After the excruciating experience of constructing a plan from scratch, the agent can save the plan in the library as a
method for implementing the high-level action defined by the task. In this way, the agent can
become more and more competent over time as new methods are built on top of old methods.
One important aspect of this learning process is the ability to generalize the methods that
are constructed, eliminating detail that is specific to the problem instance (e.g., the name of
410 Chapter 11. Planning and Acting in the Real World
the builder or the address of the plot of land) and keeping just the key elements of the plan.
Methods for achieving this kind of generalization are described in Chapter 19. It seems to us
inconceivable that humans could be as competent as they are without some such mechanism.
11.2.3 Searching for abstract solutions
The hierarchical search algorithm in the preceding section refines HLAs all the way to primitive action sequences to determine if a plan is workable. This contradicts common sense: one
should be able to determine that the two-HLA high-level plan
[Drive(Home, SFOLongTermParking), Shuttle(SFOLongTermParking, SFO)]
gets one to the airport without having to determine a precise route, choice of parking spot,
and so on. The solution seems obvious: write precondition–effect descriptions of the HLAs,
just as we write down what the primitive actions do. From the descriptions, it ought to be
easy to prove that the high-level plan achieves the goal. This is the holy grail, so to speak, of
hierarchical planning because if we derive a high-level plan that provably achieves the goal,
working in a small search space of high-level actions, then we can commit to that plan and
work on the problem of refining each step of the plan. This gives us the exponential reduction
we seek. For this to work, it has to be the case that every high-level plan that “claims” to
achieve the goal (by virtue of the descriptions of its steps) does in fact achieve the goal in
the sense defined earlier: it must have at least one implementation that does achieve the goal.
This property has been called the downward refinement property for HLA descriptions. DOWNWARD
REFINEMENT
PROPERTY
Writing HLA descriptions that satisfy the downward refinement property is, in principle, easy: as long as the descriptions are true, then any high-level plan that claims to achieve
the goal must in fact do so—otherwise, the descriptions are making some false claim about
what the HLAs do. We have already seen how to write true descriptions for HLAs that have
exactly one implementation (Exercise 11.3); a problem arises when the HLA has multiple
implementations. How can we describe the effects of an action that can be implemented in
many different ways?
One safe answer (at least for problems where all preconditions and goals are positive) is
to include only the positive effects that are achieved by every implementation of the HLA and
the negative effects of any implementation. Then the downward refinement property would
be satisfied. Unfortunately, this semantics for HLAs is much too conservative. Consider again
the HLA Go(Home, SFO), which has two refinements, and suppose, for the sake of argument, a simple world in which one can always drive to the airport and park, but taking a taxi
requires Cash as a precondition. In that case, Go(Home, SFO) doesn’t always get you to
the airport. In particular, it fails if Cash is false, and so we cannot assert At(Agent, SFO) as
an effect of the HLA. This makes no sense, however; if the agent didn’t have Cash, it would
drive itself. Requiring that an effect hold for every implementation is equivalent to assuming
that someone else—an adversary—will choose the implementation. It treats the HLA’s multiple outcomes exactly as if the HLA were a nondeterministic action, as in Section 4.3. For
our case, the agent itself will choose the implementation.
The programming languages community has coined the term demonic nondeterminism for the case where an adversary makes the choices, contrasting this with angelic nonde- DEMONIC
NONDETERMINISM
Section 11.2. Hierarchical Planning 411
(a) (b)
Figure 11.6 Schematic examples of reachable sets. The set of goal states is shaded. Black
and gray arrows indicate possible implementations of h1 and h2, respectively. (a) The reachable set of an HLA h1 in a state s. (b) The reachable set for the sequence [h1, h2]. Because
this intersects the goal set, the sequence achieves the goal.
terminism, where the agent itself makes the choices. We borrow this term to define angelic ANGELIC
NONDETERMINISM
ANGELIC SEMANTICS semantics for HLA descriptions. The basic concept required for understanding angelic seREACHABLE SET mantics is the reachable set of an HLA: given a state s, the reachable set for an HLA h,
written as REACH(s, h), is the set of states reachable by any of the HLA’s implementations.
The key idea is that the agent can choose which element of the reachable set it ends up in
when it executes the HLA; thus, an HLA with multiple refinements is more “powerful” than
the same HLA with fewer refinements. We can also define the reachable set of a sequences of
HLAs. For example, the reachable set of a sequence [h1, h2] is the union of all the reachable
sets obtained by applying h2 in each state in the reachable set of h1:
REACH(s, [h1, h2]) = 
s∈REACH(s, h1)
REACH(s
, h2) .
Given these definitions, a high-level plan—a sequence of HLAs—achieves the goal if its
reachable set intersects the set of goal states. (Compare this to the much stronger condition
for demonic semantics, where every member of the reachable set has to be a goal state.)
Conversely, if the reachable set doesn’t intersect the goal, then the plan definitely doesn’t
work. Figure 11.6 illustrates these ideas.
The notion of reachable sets yields a straightforward algorithm: search among highlevel plans, looking for one whose reachable set intersects the goal; once that happens, the
algorithm can commit to that abstract plan, knowing that it works, and focus on refining
the plan further. We will come back to the algorithmic issues later; first, we consider the
question of how the effects of an HLA—the reachable set for each possible initial state—are
represented. As with the classical action schemas of Chapter 10, we represent the changes
412 Chapter 11. Planning and Acting in the Real World
made to each fluent. Think of a fluent as a state variable. A primitive action can add or delete
a variable or leave it unchanged. (With conditional effects (see Section 11.3.1) there is a
fourth possibility: flipping a variable to its opposite.)
An HLA under angelic semantics can do more: it can control the value of a variable,
setting it to true or false depending on which implementation is chosen. In fact, an HLA can
have nine different effects on a variable: if the variable starts out true, it can always keep
it true, always make it false, or have a choice; if the variable starts out false, it can always
keep it false, always make it true, or have a choice; and the three choices for each case can
be combined arbitrarily, making nine. Notationally, this is a bit challenging. We’ll use the 
symbol to mean “possibly, if the agent so chooses.” Thus, an effect +A means “possibly add
A,” that is, either leave A unchanged or make it true. Similarly, −A means “possibly delete
A” and ±A means “possibly add or delete A.” For example, the HLA Go(Home, SFO),
with the two refinements shown in Figure 11.4, possibly deletes Cash (if the agent decides to
take a taxi), so it should have the effect −Cash. Thus, we see that the descriptions of HLAs
are derivable, in principle, from the descriptions of their refinements—in fact, this is required
if we want true HLA descriptions, such that the downward refinement property holds. Now,
suppose we have the following schemas for the HLAs h1 and h2:
Action(h1, PRECOND:¬A, EFFECT:A ∧ −B) ,
Action(h2, PRECOND:¬B, EFFECT:+A ∧ ±C) .
That is, h1 adds A and possible deletes B, while h2 possibly adds A and has full control over
C. Now, if only B is true in the initial state and the goal is A ∧ C then the sequence [h1, h2]
achieves the goal: we choose an implementation of h1 that makes B false, then choose an
implementation of h2 that leaves A true and makes C true.
The preceding discussion assumes that the effects of an HLA—the reachable set for
any given initial state—can be described exactly by describing the effect on each variable. It
would be nice if this were always true, but in many cases we can only approximate the effects because an HLA may have infinitely many implementations and may produce arbitrarily
wiggly reachable sets—rather like the wiggly-belief-state problem illustrated in Figure 7.21
on page 271. For example, we said that Go(Home, SFO) possibly deletes Cash; it also
possibly adds At(Car , SFOLongTermParking); but it cannot do both—in fact, it must do
exactly one. As with belief states, we may need to write approximate descriptions. We will
use two kinds of approximation: an optimistic description REACH+(s, h) of an HLA h may OPTIMISTIC
DESCRIPTION
overstate the reachable set, while a pessimistic description REACH−(s, h) may understate PESSIMISTIC
DESCRIPTION
the reachable set. Thus, we have
REACH−(s, h) ⊆ REACH(s, h) ⊆ REACH+(s, h) .
For example, an optimistic description of Go(Home, SFO) says that it possible deletes Cash
and possibly adds At(Car , SFOLongTermParking). Another good example arises in the
8-puzzle, half of whose states are unreachable from any given state (see Exercise 3.4 on
page 113): the optimistic description of Act might well include the whole state space, since
the exact reachable set is quite wiggly.
With approximate descriptions, the test for whether a plan achieves the goal needs to
be modified slightly. If the optimistic reachable set for the plan doesn’t intersect the goal,
Section 11.2. Hierarchical Planning 413
(a) (b)
Figure 11.7 Goal achievement for high-level plans with approximate descriptions. The
set of goal states is shaded. For each plan, the pessimistic (solid lines) and optimistic (dashed
lines) reachable sets are shown. (a) The plan indicated by the black arrow definitely achieves
the goal, while the plan indicated by the gray arrow definitely doesn’t. (b) A plan that would
need to be refined further to determine if it really does achieve the goal.
then the plan doesn’t work; if the pessimistic reachable set intersects the goal, then the plan
does work (Figure 11.7(a)). With exact descriptions, a plan either works or it doesn’t, but
with approximate descriptions, there is a middle ground: if the optimistic set intersects the
goal but the pessimistic set doesn’t, then we cannot tell if the plan works (Figure 11.7(b)).
When this circumstance arises, the uncertainty can be resolved by refining the plan. This is
a very common situation in human reasoning. For example, in planning the aforementioned
two-week Hawaii vacation, one might propose to spend two days on each of seven islands.
Prudence would indicate that this ambitious plan needs to be refined by adding details of
inter-island transportation.
An algorithm for hierarchical planning with approximate angelic descriptions is shown
in Figure 11.8. For simplicity, we have kept to the same overall scheme used previously in
Figure 11.5, that is, a breadth-first search in the space of refinements. As just explained, the
algorithm can detect plans that will and won’t work by checking the intersections of the optimistic and pessimistic reachable sets with the goal. (The details of how to compute the reachable sets of a plan, given approximate descriptions of each step, are covered in Exercise 11.5.)
When a workable abstract plan is found, the algorithm decomposes the original problem into
subproblems, one for each step of the plan. The initial state and goal for each subproblem
are obtained by regressing a guaranteed-reachable goal state through the action schemas for
each step of the plan. (See Section 10.2.2 for a discussion of how regression works.) Figure 11.6(b) illustrates the basic idea: the right-hand circled state is the guaranteed-reachable
goal state, and the left-hand circled state is the intermediate goal obtained by regressing the
414 Chapter 11. Planning and Acting in the Real World
function ANGELIC-SEARCH(problem, hierarchy,initialPlan) returns solution or fail
frontier ← a FIFO queue with initialPlan as the only element
loop do
if EMPTY?(frontier ) then return fail
plan ← POP(frontier ) /* chooses the shallowest node in frontier */
if REACH+(problem.INITIAL-STATE, plan) intersects problem.GOAL then
if plan is primitive then return plan /* REACH+ is exact for primitive plans */
guaranteed ← REACH−(problem.INITIAL-STATE, plan) ∩ problem.GOAL
if guaranteed={ } and MAKING-PROGRESS(plan, initialPlan) then
finalState ← any element of guaranteed
return DECOMPOSE(hierarchy, problem.INITIAL-STATE, plan, finalState)
hla ← some HLA in plan
prefix ,suffix ← the action subsequences before and after hla in plan
for each sequence in REFINEMENTS(hla, outcome, hierarchy) do
frontier ← INSERT(APPEND(prefix , sequence, suffix),frontier )
function DECOMPOSE(hierarchy, s0 , plan, sf ) returns a solution
solution ←an empty plan
while plan is not empty do
action ← REMOVE-LAST(plan)
si ←a state in REACH−(s0 , plan) such that sf ∈REACH−(si, action)
problem ← a problem with INITIAL-STATE = si and GOAL = sf
solution ← APPEND(ANGELIC-SEARCH(problem, hierarchy, action), solution)
sf ← si
return solution
Figure 11.8 A hierarchical planning algorithm that uses angelic semantics to identify and
commit to high-level plans that work while avoiding high-level plans that don’t. The predicate MAKING-PROGRESS checks to make sure that we aren’t stuck in an infinite regression
of refinements. At top level, call ANGELIC-SEARCH with [Act] as the initialPlan.
goal through the final action.
The ability to commit to or reject high-level plans can give ANGELIC-SEARCH a significant computational advantage over HIERARCHICAL-SEARCH, which in turn may have
a large advantage over plain old BREADTH-FIRST-SEARCH. Consider, for example, cleaning up a large vacuum world consisting of rectangular rooms connected by narrow corridors. It makes sense to have an HLA for Navigate (as shown in Figure 11.4) and one for
CleanWholeRoom. (Cleaning the room could be implemented with the repeated application
of another HLA to clean each row.) Since there are five actions in this domain, the cost
for BREADTH-FIRST-SEARCH grows as 5d, where d is the length of the shortest solution
(roughly twice the total number of squares); the algorithm cannot manage even two 2 × 2
rooms. HIERARCHICAL-SEARCH is more efficient, but still suffers from exponential growth
because it tries all ways of cleaning that are consistent with the hierarchy. ANGELIC-SEARCH
scales approximately linearly in the number of squares—it commits to a good high-level se-
Section 11.3. Planning and Acting in Nondeterministic Domains 415
quence and prunes away the other options. Notice that cleaning a set of rooms by cleaning
each room in turn is hardly rocket science: it is easy for humans precisely because of the
hierarchical structure of the task. When we consider how difficult humans find it to solve
small puzzles such as the 8-puzzle, it seems likely that the human capacity for solving complex problems derives to a great extent from their skill in abstracting and decomposing the
problem to eliminate combinatorics.
The angelic approach can be extended to find least-cost solutions by generalizing the
notion of reachable set. Instead of a state being reachable or not, it has a cost for the most
efficient way to get there. (The cost is ∞ for unreachable states.) The optimistic and pessimistic descriptions bound these costs. In this way, angelic search can find provably optimal
abstract plans without considering their implementations. The same approach can be used to
obtain effective hierarchical lookahead algorithms for online search, in the style of LRTA HIERARCHICAL ∗ LOOKAHEAD
(page 152). In some ways, such algorithms mirror aspects of human deliberation in tasks such
as planning a vacation to Hawaii—consideration of alternatives is done initially at an abstract
level over long time scales; some parts of the plan are left quite abstract until execution time,
such as how to spend two lazy days on Molokai, while others parts are planned in detail, such
as the flights to be taken and lodging to be reserved—without these refinements, there is no
guarantee that the plan would be feasible.
11.3 PLANNING AND ACTING IN NONDETERMINISTIC DOMAINS
In this section we extend planning to handle partially observable, nondeterministic, and unknown environments. Chapter 4 extended search in similar ways, and the methods here are
also similar: sensorless planning (also known as conformant planning) for environments
with no observations; contingency planning for partially observable and nondeterministic
environments; and online planning and replanning for unknown environments.
While the basic concepts are the same as in Chapter 4, there are also significant differences. These arise because planners deal with factored representations rather than atomic
representations. This affects the way we represent the agent’s capability for action and observation and the way we represent belief states—the sets of possible physical states the agent
might be in—for unobservable and partially observable environments. We can also take advantage of many of the domain-independent methods given in Chapter 10 for calculating
search heuristics.
Consider this problem: given a chair and a table, the goal is to have them match—have
the same color. In the initial state we have two cans of paint, but the colors of the paint and
the furniture are unknown. Only the table is initially in the agent’s field of view:
Init(Object(Table) ∧ Object(Chair ) ∧ Can(C1) ∧ Can(C2) ∧ InView(Table))
Goal(Color (Chair , c) ∧ Color (Table, c))
There are two actions: removing the lid from a paint can and painting an object using the
paint from an open can. The action schemas are straightforward, with one exception: we now
allow preconditions and effects to contain variables that are not part of the action’s variable
416 Chapter 11. Planning and Acting in the Real World
list. That is, Paint(x, can) does not mention the variable c, representing the color of the
paint in the can. In the fully observable case, this is not allowed—we would have to name
the action Paint(x, can, c). But in the partially observable case, we might or might not
know what color is in the can. (The variable c is universally quantified, just like all the other
variables in an action schema.)
Action(RemoveLid(can),
PRECOND:Can(can)
EFFECT:Open(can))
Action(Paint(x , can),
PRECOND:Object(x) ∧ Can(can) ∧ Color (can, c) ∧ Open(can)
EFFECT:Color (x , c))
To solve a partially observable problem, the agent will have to reason about the percepts it will
obtain when it is executing the plan. The percept will be supplied by the agent’s sensors when
it is actually acting, but when it is planning it will need a model of its sensors. In Chapter 4,
this model was given by a function, PERCEPT(s). For planning, we augment PDDL with a
PERCEPT SCHEMA new type of schema, the percept schema:
Percept(Color (x, c),
PRECOND:Object(x) ∧ InView(x)
Percept(Color (can, c),
PRECOND:Can(can) ∧ InView(can) ∧ Open(can)
The first schema says that whenever an object is in view, the agent will perceive the color
of the object (that is, for the object x, the agent will learn the truth value of Color (x, c) for
all c). The second schema says that if an open can is in view, then the agent perceives the
color of the paint in the can. Because there are no exogenous events in this world, the color
of an object will remain the same, even if it is not being perceived, until the agent performs
an action to change the object’s color. Of course, the agent will need an action that causes
objects (one at a time) to come into view:
Action(LookAt(x),
PRECOND:InView(y) ∧ (x = y)
EFFECT:InView(x) ∧ ¬InView(y))
For a fully observable environment, we would have a Percept axiom with no preconditions
for each fluent. A sensorless agent, on the other hand, has no Percept axioms at all. Note
that even a sensorless agent can solve the painting problem. One solution is to open any can
of paint and apply it to both chair and table, thus coercing them to be the same color (even
though the agent doesn’t know what the color is).
A contingent planning agent with sensors can generate a better plan. First, look at the
table and chair to obtain their colors; if they are already the same then the plan is done. If
not, look at the paint cans; if the paint in a can is the same color as one piece of furniture,
then apply that paint to the other piece. Otherwise, paint both pieces with any color.
Finally, an online planning agent might generate a contingent plan with fewer branches
at first—perhaps ignoring the possibility that no cans match any of the furniture—and deal
Section 11.3. Planning and Acting in Nondeterministic Domains 417
with problems when they arise by replanning. It could also deal with incorrectness of its
action schemas. Whereas a contingent planner simply assumes that the effects of an action
always succeed—that painting the chair does the job—a replanning agent would check the
result and make an additional plan to fix any unexpected failure, such as an unpainted area or
the original color showing through.
In the real world, agents use a combination of approaches. Car manufacturers sell spare
tires and air bags, which are physical embodiments of contingent plan branches designed
to handle punctures or crashes. On the other hand, most car drivers never consider these
possibilities; when a problem arises they respond as replanning agents. In general, agents
plan only for contingencies that have important consequences and a nonnegligible chance
of happening. Thus, a car driver contemplating a trip across the Sahara desert should make
explicit contingency plans for breakdowns, whereas a trip to the supermarket requires less
advance planning. We next look at each of the three approaches in more detail.
11.3.1 Sensorless planning
Section 4.4.1 (page 138) introduced the basic idea of searching in belief-state space to find
a solution for sensorless problems. Conversion of a sensorless planning problem to a beliefstate planning problem works much the same way as it did in Section 4.4.1; the main differences are that the underlying physical transition model is represented by a collection of action
schemas and the belief state can be represented by a logical formula instead of an explicitly
enumerated set of states. For simplicity, we assume that the underlying planning problem is
deterministic.
The initial belief state for the sensorless painting problem can ignore InView fluents
because the agent has no sensors. Furthermore, we take as given the unchanging facts
Object(Table) ∧ Object(Chair ) ∧ Can(C1) ∧ Can(C2) because these hold in every belief state. The agent doesn’t know the colors of the cans or the objects, or whether the cans
are open or closed, but it does know that objects and cans have colors: ∀ x ∃ c Color (x, c).
After Skolemizing, (see Section 9.5), we obtain the initial belief state:
b0 = Color (x, C(x)) .
In classical planning, where the closed-world assumption is made, we would assume that
any fluent not mentioned in a state is false, but in sensorless (and partially observable) planning we have to switch to an open-world assumption in which states contain both positive
and negative fluents, and if a fluent does not appear, its value is unknown. Thus, the belief
state corresponds exactly to the set of possible worlds that satisfy the formula. Given this
initial belief state, the following action sequence is a solution:
[RemoveLid(Can1),Paint(Chair , Can1),Paint(Table, Can1)] .
We now show how to progress the belief state through the action sequence to show that the
final belief state satisfies the goal.
First, note that in a given belief state b, the agent can consider any action whose preconditions are satisfied by b. (The other actions cannot be used because the transition model
doesn’t define the effects of actions whose preconditions might be unsatisfied.) According
418 Chapter 11. Planning and Acting in the Real World
to Equation (4.4) (page 139), the general formula for updating the belief state b given an
applicable action a in a deterministic world is as follows:
b = RESULT(b, a) = {s : s = RESULTP (s, a) and s ∈ b}
where RESULTP defines the physical transition model. For the time being, we assume that the
initial belief state is always a conjunction of literals, that is, a 1-CNF formula. To construct
the new belief state b
, we must consider what happens to each literal  in each physical state
s in b when action a is applied. For literals whose truth value is already known in b, the truth
value in b is computed from the current value and the add list and delete list of the action.
(For example, if  is in the delete list of the action, then ¬ is added to b
.) What about a
literal whose truth value is unknown in b? There are three cases:
1. If the action adds , then  will be true in b regardless of its initial value.
2. If the action deletes , then  will be false in b regardless of its initial value.
3. If the action does not affect , then  will retain its initial value (which is unknown) and
will not appear in b
.
Hence, we see that the calculation of b is almost identical to the observable case, which was
specified by Equation (10.1) on page 368:
b = RESULT(b, a)=(b − DEL(a))∪ ADD(a) .
We cannot quite use the set semantics because (1) we must make sure that b does not contain both  and ¬, and (2) atoms may contain unbound variables. But it is still the case
that RESULT(b, a) is computed by starting with b, setting any atom that appears in DEL(a)
to false, and setting any atom that appears in ADD(a) to true. For example, if we apply
RemoveLid(Can1) to the initial belief state b0, we get
b1 = Color (x, C(x)) ∧ Open(Can1) .
When we apply the action Paint(Chair , Can1), the precondition Color (Can1, c) is satisfied
by the known literal Color (x, C(x)) with binding {x/Can1, c/C(Can1)} and the new belief
state is
b2 = Color (x, C(x)) ∧ Open(Can1) ∧ Color (Chair , C(Can1)) .
Finally, we apply the action Paint(Table, Can1) to obtain
b3 = Color (x, C(x)) ∧ Open(Can1) ∧ Color (Chair , C(Can1))
∧ Color (Table, C(Can1)) .
The final belief state satisfies the goal, Color (Table, c) ∧ Color (Chair , c), with the variable
c bound to C(Can1).
The preceding analysis of the update rule has shown a very important fact: the family
of belief states defined as conjunctions of literals is closed under updates defined by PDDL
action schemas. That is, if the belief state starts as a conjunction of literals, then any update
will yield a conjunction of literals. That means that in a world with n fluents, any belief
state can be represented by a conjunction of size O(n). This is a very comforting result,
considering that there are 2n states in the world. It says we can compactly represent all the
subsets of those 2n states that we will ever need. Moreover, the process of checking for belief
Section 11.3. Planning and Acting in Nondeterministic Domains 419
states that are subsets or supersets of previously visited belief states is also easy, at least in
the propositional case.
The fly in the ointment of this pleasant picture is that it only works for action schemas
that have the same effects for all states in which their preconditions are satisfied. It is this
property that enables the preservation of the 1-CNF belief-state representation. As soon as the
effect can depend on the state, dependencies are introduced between fluents and the 1-CNF
property is lost. Consider, for example, the simple vacuum world defined in Section 3.2.1.
Let the fluents be AtL and AtR for the location of the robot and CleanL and CleanR for
the state of the squares. According to the definition of the problem, the Suck action has no
precondition—it can always be done. The difficulty is that its effect depends on the robot’s location: when the robot is AtL, the result is CleanL, but when it is AtR, the result is CleanR.
For such actions, our action schemas will need something new: a conditional effect. These CONDITIONAL
EFFECT
have the syntax “when condition: effect,” where condition is a logical formula to be compared against the current state, and effect is a formula describing the resulting state. For the
vacuum world, we have
Action(Suck,
EFFECT:when AtL: CleanL ∧ when AtR: CleanR) .
When applied to the initial belief state True, the resulting belief state is (AtL ∧ CleanL) ∨
(AtR ∧ CleanR), which is no longer in 1-CNF. (This transition can be seen in Figure 4.14
on page 141.) In general, conditional effects can induce arbitrary dependencies among the
fluents in a belief state, leading to belief states of exponential size in the worst case.
It is important to understand the difference between preconditions and conditional effects. All conditional effects whose conditions are satisfied have their effects applied to generate the resulting state; if none are satisfied, then the resulting state is unchanged. On the other
hand, if a precondition is unsatisfied, then the action is inapplicable and the resulting state
is undefined. From the point of view of sensorless planning, it is better to have conditional
effects than an inapplicable action. For example, we could split Suck into two actions with
unconditional effects as follows:
Action(SuckL,
PRECOND:AtL; EFFECT:CleanL)
Action(SuckR,
PRECOND:AtR; EFFECT:CleanR) .
Now we have only unconditional schemas, so the belief states all remain in 1-CNF; unfortunately, we cannot determine the applicability of SuckL and SuckR in the initial belief state.
It seems inevitable, then, that nontrivial problems will involve wiggly belief states, just
like those encountered when we considered the problem of state estimation for the wumpus
world (see Figure 7.21 on page 271). The solution suggested then was to use a conservative
approximation to the exact belief state; for example, the belief state can remain in 1-CNF
if it contains all literals whose truth values can be determined and treats all other literals as
unknown. While this approach is sound, in that it never generates an incorrect plan, it is
incomplete because it may be unable to find solutions to problems that necessarily involve
interactions among literals. To give a trivial example, if the goal is for the robot to be on
420 Chapter 11. Planning and Acting in the Real World
a clean square, then [Suck] is a solution but a sensorless agent that insists on 1-CNF belief
states will not find it.
Perhaps a better solution is to look for action sequences that keep the belief state
as simple as possible. For example, in the sensorless vacuum world, the action sequence
[Right, Suck, Left, Suck] generates the following sequence of belief states:
b0 = True
b1 = AtR
b2 = AtR ∧ CleanR
b3 = AtL ∧ CleanR
b4 = AtL ∧ CleanR ∧ CleanL
That is, the agent can solve the problem while retaining a 1-CNF belief state, even though
some sequences (e.g., those beginning with Suck) go outside 1-CNF. The general lesson is
not lost on humans: we are always performing little actions (checking the time, patting our
pockets to make sure we have the car keys, reading street signs as we navigate through a city)
to eliminate uncertainty and keep our belief state manageable.
There is another, quite different approach to the problem of unmanageably wiggly belief states: don’t bother computing them at all. Suppose the initial belief state is b0 and we
would like to know the belief state resulting from the action sequence [a1,...,am]. Instead
of computing it explicitly, just represent it as “b0 then [a1,...,am].” This is a lazy but unambiguous representation of the belief state, and it’s quite concise—O(n + m) where n is
the size of the initial belief state (assumed to be in 1-CNF) and m is the maximum length
of an action sequence. As a belief-state representation, it suffers from one drawback, however: determining whether the goal is satisfied, or an action is applicable, may require a lot
of computation.
The computation can be implemented as an entailment test: if Am represents the collection of successor-state axioms required to define occurrences of the actions a1,...,am—as
explained for SATPLAN in Section 10.4.1—and Gm asserts that the goal is true after m steps,
then the plan achieves the goal if b0 ∧ Am |= Gm, that is, if b0 ∧ Am ∧ ¬Gm is unsatisfiable.
Given a modern SAT solver, it may be possible to do this much more quickly than computing
the full belief state. For example, if none of the actions in the sequence has a particular goal
fluent in its add list, the solver will detect this immediately. It also helps if partial results
about the belief state—for example, fluents known to be true or false—are cached to simplify
subsequent computations.
The final piece of the sensorless planning puzzle is a heuristic function to guide the
search. The meaning of the heuristic function is the same as for classical planning: an estimate (perhaps admissible) of the cost of achieving the goal from the given belief state. With
belief states, we have one additional fact: solving any subset of a belief state is necessarily
easier than solving the belief state:
if b1 ⊆ b2 then h∗(b1) ≤ h∗(b2) .
Hence, any admissible heuristic computed for a subset is admissible for the belief state itself.
The most obvious candidates are the singleton subsets, that is, individual physical states. We
Section 11.3. Planning and Acting in Nondeterministic Domains 421
can take any random collection of states s1,...,sN that are in the belief state b, apply any
admissible heuristic h from Chapter 10, and return
H(b) = max{h(s1),...,h(sN )}
as the heuristic estimate for solving b. We could also use a planning graph directly on b itself:
if it is a conjunction of literals (1-CNF), simply set those literals to be the initial state layer
of the graph. If b is not in 1-CNF, it may be possible to find sets of literals that together entail
b. For example, if b is in disjunctive normal form (DNF), each term of the DNF formula is
a conjunction of literals that entails b and can form the initial layer of a planning graph. As
before, we can take the maximum of the heuristics obtained from each set of literals. We can
also use inadmissible heuristics such as the ignore-delete-lists heuristic (page 377), which
seems to work quite well in practice.
11.3.2 Contingent planning
We saw in Chapter 4 that contingent planning—the generation of plans with conditional
branching based on percepts—is appropriate for environments with partial observability, nondeterminism, or both. For the partially observable painting problem with the percept axioms
given earlier, one possible contingent solution is as follows:
[LookAt(Table), LookAt(Chair ),
if Color (Table, c) ∧ Color (Chair , c) then NoOp
else [RemoveLid(Can1), LookAt(Can1), RemoveLid(Can2), LookAt(Can2),
if Color (Table, c) ∧ Color (can, c) then Paint(Chair , can)
else if Color (Chair , c) ∧ Color (can, c) then Paint(Table, can)
else [Paint(Chair , Can1),Paint(Table, Can1)]]]
Variables in this plan should be considered existentially quantified; the second line says
that if there exists some color c that is the color of the table and the chair, then the agent
need not do anything to achieve the goal. When executing this plan, a contingent-planning
agent can maintain its belief state as a logical formula and evaluate each branch condition
by determining if the belief state entails the condition formula or its negation. (It is up to
the contingent-planning algorithm to make sure that the agent will never end up in a belief state where the condition formula’s truth value is unknown.) Note that with first-order
conditions, the formula may be satisfied in more than one way; for example, the condition
Color (Table, c) ∧ Color (can, c) might be satisfied by {can/Can1} and by {can/Can2} if
both cans are the same color as the table. In that case, the agent can choose any satisfying
substitution to apply to the rest of the plan.
As shown in Section 4.4.2, calculating the new belief state after an action and subsequent percept is done in two stages. The first stage calculates the belief state after the action,
just as for the sensorless agent:
ˆb = (b − DEL(a))∪ ADD(a)
where, as before, we have assumed a belief state represented as a conjunction of literals. The
second stage is a little trickier. Suppose that percept literals p1,...,pk are received. One
might think that we simply need to add these into the belief state; in fact, we can also infer
422 Chapter 11. Planning and Acting in the Real World
that the preconditions for sensing are satisfied. Now, if a percept p has exactly one percept
axiom, Percept(p, PRECOND:c), where c is a conjunction of literals, then those literals can
be thrown into the belief state along with p. On the other hand, if p has more than one percept
axiom whose preconditions might hold according to the predicted belief state ˆb, then we have
to add in the disjunction of the preconditions. Obviously, this takes the belief state outside
1-CNF and brings up the same complications as conditional effects, with much the same
classes of solutions.
Given a mechanism for computing exact or approximate belief states, we can generate
contingent plans with an extension of the AND–OR forward search over belief states used
in Section 4.4. Actions with nondeterministic effects—which are defined simply by using a
disjunction in the EFFECT of the action schema—can be accommodated with minor changes
to the belief-state update calculation and no change to the search algorithm.2 For the heuristic
function, many of the methods suggested for sensorless planning are also applicable in the
partially observable, nondeterministic case.
11.3.3 Online replanning
Imagine watching a spot-welding robot in a car plant. The robot’s fast, accurate motions are
repeated over and over again as each car passes down the line. Although technically impressive, the robot probably does not seem at all intelligent because the motion is a fixed,
preprogrammed sequence; the robot obviously doesn’t “know what it’s doing” in any meaningful sense. Now suppose that a poorly attached door falls off the car just as the robot is
about to apply a spot-weld. The robot quickly replaces its welding actuator with a gripper,
picks up the door, checks it for scratches, reattaches it to the car, sends an email to the floor
supervisor, switches back to the welding actuator, and resumes its work. All of a sudden,
the robot’s behavior seems purposive rather than rote; we assume it results not from a vast,
precomputed contingent plan but from an online replanning process—which means that the
robot does need to know what it’s trying to do.
Replanning presupposes some form of execution monitoring to determine the need for EXECUTION
MONITORING
a new plan. One such need arises when a contingent planning agent gets tired of planning
for every little contingency, such as whether the sky might fall on its head.3 Some branches
of a partially constructed contingent plan can simply say Replan; if such a branch is reached
during execution, the agent reverts to planning mode. As we mentioned earlier, the decision
as to how much of the problem to solve in advance and how much to leave to replanning
is one that involves tradeoffs among possible events with different costs and probabilities of
occurring. Nobody wants to have their car break down in the middle of the Sahara desert and
only then think about having enough water.
2 If cyclic solutions are required for a nondeterministic problem, AND–OR search must be generalized to a loopy
version such as LAO∗ (Hansen and Zilberstein, 2001).
3 In 1954, a Mrs. Hodges of Alabama was hit by meteorite that crashed through her roof. In 1992, a piece of
the Mbale meteorite hit a small boy on the head; fortunately, its descent was slowed by banana leaves (Jenniskens
et al., 1994). And in 2009, a German boy claimed to have been hit in the hand by a pea-sized meteorite. No serious
injuries resulted from any of these incidents, suggesting that the need for preplanning against such contingencies
is sometimes overstated.
Section 11.3. Planning and Acting in Nondeterministic Domains 423
whole plan
plan
repair
S P
O
E G
continuation
Figure 11.9 Before execution, the planner comes up with a plan, here called whole plan,
to get from S to G. The agent executes steps of the plan until it expects to be in state E, but
observes it is actually in O. The agent then replans for the minimal repair plus continuation
to reach G.
Replanning may also be needed if the agent’s model of the world is incorrect. The model
for an action may have a missing precondition—for example, the agent may not know that MISSING
PRECONDITION
removing the lid of a paint can often requires a screwdriver; the model may have a missing
MISSING EFFECT effect—for example, painting an object may get paint on the floor as well; or the model may
have a missing state variable—for example, the model given earlier has no notion of the MISSING STATE
VARIABLE
amount of paint in a can, of how its actions affect this amount, or of the need for the amount
EXOGENOUS EVENT to be nonzero. The model may also lack provision for exogenous events such as someone
knocking over the paint can. Exogenous events can also include changes in the goal, such
as the addition of the requirement that the table and chair not be painted black. Without the
ability to monitor and replan, an agent’s behavior is likely to be extremely fragile if it relies
on absolute correctness of its model.
The online agent has a choice of how carefully to monitor the environment. We distinguish three levels:
ACTION MONITORING • Action monitoring: before executing an action, the agent verifies that all the preconditions still hold.
PLAN MONITORING • Plan monitoring: before executing an action, the agent verifies that the remaining plan
will still succeed.
GOAL MONITORING • Goal monitoring: before executing an action, the agent checks to see if there is a better
set of goals it could be trying to achieve.
In Figure 11.9 we see a schematic of action monitoring. The agent keeps track of both its
original plan, wholeplan, and the part of the plan that has not been executed yet, which is
denoted by plan. After executing the first few steps of the plan, the agent expects to be in
state E. But the agent observes it is actually in state O. It then needs to repair the plan by
finding some point P on the original plan that it can get back to. (It may be that P is the goal
state, G.) The agent tries to minimize the total cost of the plan: the repair part (from O to P)
plus the continuation (from P to G).
424 Chapter 11. Planning and Acting in the Real World
Now let’s return to the example problem of achieving a chair and table of matching
color. Suppose the agent comes up with this plan:
[LookAt(Table), LookAt(Chair ),
if Color (Table, c) ∧ Color (Chair , c) then NoOp
else [RemoveLid(Can1), LookAt(Can1),
if Color (Table, c) ∧ Color (Can1, c) then Paint(Chair , Can1)
else REPLAN]] .
Now the agent is ready to execute the plan. Suppose the agent observes that the table and
can of paint are white and the chair is black. It then executes Paint(Chair , Can1). At this
point a classical planner would declare victory; the plan has been executed. But an online
execution monitoring agent needs to check the preconditions of the remaining empty plan—
that the table and chair are the same color. Suppose the agent perceives that they do not
have the same color—in fact, the chair is now a mottled gray because the black paint is
showing through. The agent then needs to figure out a position in whole plan to aim for
and a repair action sequence to get there. The agent notices that the current state is identical
to the precondition before the Paint(Chair , Can1) action, so the agent chooses the empty
sequence for repair and makes its plan be the same [Paint] sequence that it just attempted.
With this new plan in place, execution monitoring resumes, and the Paint action is retried.
This behavior will loop until the chair is perceived to be completely painted. But notice that
the loop is created by a process of plan–execute–replan, rather than by an explicit loop in a
plan. Note also that the original plan need not cover every contingency. If the agent reaches
the step marked REPLAN, it can then generate a new plan (perhaps involving Can2).
Action monitoring is a simple method of execution monitoring, but it can sometimes
lead to less than intelligent behavior. For example, suppose there is no black or white paint,
and the agent constructs a plan to solve the painting problem by painting both the chair and
table red. Suppose that there is only enough red paint for the chair. With action monitoring,
the agent would go ahead and paint the chair red, then notice that it is out of paint and cannot
paint the table, at which point it would replan a repair—perhaps painting both chair and table
green. A plan-monitoring agent can detect failure whenever the current state is such that the
remaining plan no longer works. Thus, it would not waste time painting the chair red. Plan
monitoring achieves this by checking the preconditions for success of the entire remaining
plan—that is, the preconditions of each step in the plan, except those preconditions that are
achieved by another step in the remaining plan. Plan monitoring cuts off execution of a
doomed plan as soon as possible, rather than continuing until the failure actually occurs.4
Plan monitoring also allows for serendipity—accidental success. If someone comes along
and paints the table red at the same time that the agent is painting the chair red, then the final
plan preconditions are satisfied (the goal has been achieved), and the agent can go home early.
It is straightforward to modify a planning algorithm so that each action in the plan
is annotated with the action’s preconditions, thus enabling action monitoring. It is slightly
4 Plan monitoring means that finally, after 424 pages, we have an agent that is smarter than a dung beetle (see
page 39). A plan-monitoring agent would notice that the dung ball was missing from its grasp and would replan
to get another ball and plug its hole.
Section 11.4. Multiagent Planning 425
more complex to enable plan monitoring. Partial-order and planning-graph planners have
the advantage that they have already built up structures that contain the relations necessary
for plan monitoring. Augmenting state-space planners with the necessary annotations can be
done by careful bookkeeping as the goal fluents are regressed through the plan.
Now that we have described a method for monitoring and replanning, we need to ask,
“Does it work?” This is a surprisingly tricky question. If we mean, “Can we guarantee that
the agent will always achieve the goal?” then the answer is no, because the agent could
inadvertently arrive at a dead end from which there is no repair. For example, the vacuum
agent might have a faulty model of itself and not know that its batteries can run out. Once
they do, it cannot repair any plans. If we rule out dead ends—assume that there exists a plan
to reach the goal from any state in the environment—and assume that the environment is
really nondeterministic, in the sense that such a plan always has some chance of success on
any given execution attempt, then the agent will eventually reach the goal.
Trouble occurs when an action is actually not nondeterministic, but rather depends on
some precondition that the agent does not know about. For example, sometimes a paint
can may be empty, so painting from that can has no effect. No amount of retrying is going to
change this.5 One solution is to choose randomly from among the set of possible repair plans,
rather than to try the same one each time. In this case, the repair plan of opening another can
might work. A better approach is to learn a better model. Every prediction failure is an
opportunity for learning; an agent should be able to modify its model of the world to accord
with its percepts. From then on, the replanner will be able to come up with a repair that gets
at the root problem, rather than relying on luck to choose a good repair. This kind of learning
is described in Chapters 18 and 19.
11.4 MULTIAGENT PLANNING
So far, we have assumed that only one agent is doing the sensing, planning, and acting.
When there are multiple agents in the environment, each agent faces a multiagent planning
problem in which it tries to achieve its own goals with the help or hindrance of others. MULTIAGENT
PLANNING PROBLEM
Between the purely single-agent and truly multiagent cases is a wide spectrum of problems that exhibit various degrees of decomposition of the monolithic agent. An agent with
multiple effectors that can operate concurrently—for example, a human who can type and
speak at the same time—needs to do multieffector planning to manage each effector while MULTIEFFECTOR
PLANNING
handling positive and negative interactions among the effectors. When the effectors are
physically decoupled into detached units—as in a fleet of delivery robots in a factory—
multieffector planning becomes multibody planning. A multibody problem is still a “stan- MULTIBODY
PLANNING
dard” single-agent problem as long as the relevant sensor information collected by each body
can be pooled—either centrally or within each body—to form a common estimate of the
world state that then informs the execution of the overall plan; in this case, the multiple bodies act as a single body. When communication constraints make this impossible, we have
5 Futile repetition of a plan repair is exactly the behavior exhibited by the sphex wasp (page 39).
426 Chapter 11. Planning and Acting in the Real World
what is sometimes called a decentralized planning problem; this is perhaps a misnomer, be- DECENTRALIZED
PLANNING
cause the planning phase is centralized but the execution phase is at least partially decoupled.
In this case, the subplan constructed for each body may need to include explicit communicative actions with other bodies. For example, multiple reconnaissance robots covering a wide
area may often be out of radio contact with each other and should share their findings during
times when communication is feasible.
When a single entity is doing the planning, there is really only one goal, which all the
bodies necessarily share. When the bodies are distinct agents that do their own planning, they
may still share identical goals; for example, two human tennis players who form a doubles
team share the goal of winning the match. Even with shared goals, however, the multibody
and multiagent cases are quite different. In a multibody robotic doubles team, a single plan
dictates which body will go where on the court and which body will hit the ball. In a multiagent doubles team, on the other hand, each agent decides what to do; without some method
COORDINATION for coordination, both agents may decide to cover the same part of the court and each may
leave the ball for the other to hit.
The clearest case of a multiagent problem, of course, is when the agents have different
goals. In tennis, the goals of two opposing teams are in direct conflict, leading to the zerosum situation of Chapter 5. Spectators could be viewed as agents if their support or disdain
is a significant factor and can be influenced by the players’ conduct; otherwise, they can be
treated as an aspect of nature—just like the weather—that is assumed to be indifferent to the
players’ intentions.6
Finally, some systems are a mixture of centralized and multiagent planning. For example, a delivery company may do centralized, offline planning for the routes of its trucks
and planes each day, but leave some aspects open for autonomous decisions by drivers and
pilots who can respond individually to traffic and weather situations. Also, the goals of the
company and its employees are brought into alignment, to some extent, by the payment of
INCENTIVE incentives (salaries and bonuses)—a sure sign that this is a true multiagent system.
The issues involved in multiagent planning can be divided roughly into two sets. The
first, covered in Section 11.4.1, involves issues of representing and planning for multiple
simultaneous actions; these issues occur in all settings from multieffector to multiagent planning. The second, covered in Section 11.4.2, involves issues of cooperation, coordination,
and competition arising in true multiagent settings.
11.4.1 Planning with multiple simultaneous actions
For the time being, we will treat the multieffector, multibody, and multiagent settings in the
MULTIACTOR same way, labeling them generically as multiactor settings, using the generic term actor to
ACTOR cover effectors, bodies, and agents. The goal of this section is to work out how to define
transition models, correct plans, and efficient planning algorithms for the multiactor setting.
A correct plan is one that, if executed by the actors, achieves the goal. (In the true multiagent
setting, of course, the agents may not agree to execute any particular plan, but at least they
6 We apologize to residents of the United Kingdom, where the mere act of contemplating a game of tennis
guarantees rain.
Section 11.4. Multiagent Planning 427
Actors(A, B)
Init(At(A,LeftBaseline) ∧ At(B, RightNet) ∧
Approaching(Ball, RightBaseline)) ∧ Partner (A, B) ∧ Partner (B,A)
Goal(Returned(Ball) ∧ (At(a, RightNet) ∨ At(a,LeftNet))
Action(Hit(actor , Ball),
PRECOND:Approaching(Ball, loc) ∧ At(actor , loc)
EFFECT:Returned(Ball))
Action(Go(actor ,to),
PRECOND:At(actor , loc) ∧ to = loc,
EFFECT:At(actor ,to) ∧ ¬ At(actor , loc))
Figure 11.10 The doubles tennis problem. Two actors A and B are playing together and
can be in one of four locations: LeftBaseline, RightBaseline, LeftNet, and RightNet. The
ball can be returned only if a player is in the right place. Note that each action must include
the actor as an argument.
will know what plans would work if they did agree to execute them.) For simplicity, we
SYNCHRONIZATION assume perfect synchronization: each action takes the same amount of time and actions at
each point in the joint plan are simultaneous.
We begin with the transition model; for the deterministic case, this is the function
RESULT(s, a). In the single-agent setting, there might be b different choices for the action;
b can be quite large, especially for first-order representations with many objects to act on,
but action schemas provide a concise representation nonetheless. In the multiactor setting
with n actors, the single action a is replaced by a joint action a1,...,an, where ai JOINT ACTION is the
action taken by the ith actor. Immediately, we see two problems: first, we have to describe
the transition model for bn different joint actions; second, we have a joint planning problem
with a branching factor of bn.
Having put the actors together into a multiactor system with a huge branching factor,
the principal focus of research on multiactor planning has been to decouple the actors to
the extent possible, so that the complexity of the problem grows linearly with n rather than
exponentially. If the actors have no interaction with one another—for example, n actors each
playing a game of solitaire—then we can simply solve n separate problems. If the actors are
LOOSELY COUPLED loosely coupled, can we attain something close to this exponential improvement? This is, of
course, a central question in many areas of AI. We have seen it explicitly in the context of
CSPs, where “tree like” constraint graphs yielded efficient solution methods (see page 225),
as well as in the context of disjoint pattern databases (page 106) and additive heuristics for
planning (page 378).
The standard approach to loosely coupled problems is to pretend the problems are completely decoupled and then fix up the interactions. For the transition model, this means writing
action schemas as if the actors acted independently. Let’s see how this works for the doubles
tennis problem. Let’s suppose that at one point in the game, the team has the goal of returning
the ball that has been hit to them and ensuring that at least one of them is covering the net.
428 Chapter 11. Planning and Acting in the Real World
A first pass at a multiactor definition might look like Figure 11.10. With this definition, it is
JOINT PLAN easy to see that the following joint plan plan works:
PLAN 1:
A : [Go(A, RightBaseline), Hit(A, Ball)]
B : [NoOp(B), NoOp(B)] .
Problems arise, however, when a plan has both agents hitting the ball at the same time. In the
real world, this won’t work, but the action schema for Hit says that the ball will be returned
successfully. Technically, the difficulty is that preconditions constrain the state in which an
action can be executed successfully, but do not constrain other actions that might mess it up.
We solve this by augmenting action schemas with one new feature: a concurrent action list CONCURRENT
ACTION LIST
stating which actions must or must not be executed concurrently. For example, the Hit action
could be described as follows:
Action(Hit(a, Ball),
CONCURRENT:b = a ⇒ ¬Hit(b, Ball)
PRECOND:Approaching(Ball, loc) ∧ At(a, loc)
EFFECT:Returned(Ball)) .
In other words, the Hit action has its stated effect only if no other Hit action by another
agent occurs at the same time. (In the SATPLAN approach, this would be handled by a
partial action exclusion axiom.) For some actions, the desired effect is achieved only when
another action occurs concurrently. For example, two agents are needed to carry a cooler full
of beverages to the tennis court:
Action(Carry(a, cooler , here,there),
CONCURRENT:b = a ∧ Carry(b, cooler , here,there)
PRECOND:At(a, here) ∧ At(cooler , here) ∧ Cooler (cooler )
EFFECT:At(a,there) ∧ At(cooler ,there) ∧ ¬At(a, here) ∧ ¬At(cooler , here)).
With these kinds of action schemas, any of the planning algorithms described in Chapter 10
can be adapted with only minor modifications to generate multiactor plans. To the extent that
the coupling among subplans is loose—meaning that concurrency constraints come into play
only rarely during plan search—one would expect the various heuristics derived for singleagent planning to also be effective in the multiactor context. We could extend this approach
with the refinements of the last two chapters—HTNs, partial observability, conditionals, execution monitoring, and replanning—but that is beyond the scope of this book.
11.4.2 Planning with multiple agents: Cooperation and coordination
Now let us consider the true multiagent setting in which each agent makes its own plan. To
start with, let us assume that the goals and knowledge base are shared. One might think
that this reduces to the multibody case—each agent simply computes the joint solution and
executes its own part of that solution. Alas, the “the” in “the joint solution” is misleading.
For our doubles team, more than one joint solution exists:
PLAN 2:
A : [Go(A, LeftNet), NoOp(A)]
B : [Go(B, RightBaseline), Hit(B, Ball)] .
Section 11.4. Multiagent Planning 429
If both agents can agree on either plan 1 or plan 2, the goal will be achieved. But if A chooses
plan 2 and B chooses plan 1, then nobody will return the ball. Conversely, if A chooses 1 and
B chooses 2, then they will both try to hit the ball. The agents may realize this, but how can
they coordinate to make sure they agree on the plan?
CONVENTION One option is to adopt a convention before engaging in joint activity. A convention is
any constraint on the selection of joint plans. For example, the convention “stick to your side
of the court” would rule out plan 1, causing the doubles partners to select plan 2. Drivers on
a road face the problem of not colliding with each other; this is (partially) solved by adopting
the convention “stay on the right side of the road” in most countries; the alternative, “stay
on the left side,” works equally well as long as all agents in an environment agree. Similar
considerations apply to the development of human language, where the important thing is not
which language each individual should speak, but the fact that a community all speaks the
SOCIAL LAWS same language. When conventions are widespread, they are called social laws.
In the absence of a convention, agents can use communication to achieve common
knowledge of a feasible joint plan. For example, a tennis player could shout “Mine!” or
“Yours!” to indicate a preferred joint plan. We cover mechanisms for communication in more
depth in Chapter 22, where we observe that communication does not necessarily involve a
verbal exchange. For example, one player can communicate a preferred joint plan to the other
simply by executing the first part of it. If agent A heads for the net, then agent B is obliged
to go back to the baseline to hit the ball, because plan 2 is the only joint plan that begins with
PLAN RECOGNITION A’s heading for the net. This approach to coordination, sometimes called plan recognition,
works when a single action (or short sequence of actions) is enough to determine a joint plan
unambiguously. Note that communication can work as well with competitive agents as with
cooperative ones.
Conventions can also arise through evolutionary processes. For example, seed-eating
harvester ants are social creatures that evolved from the less social wasps. Colonies of ants
execute very elaborate joint plans without any centralized control—the queen’s job is to reproduce, not to do centralized planning—and with very limited computation, communication, and memory capabilities in each ant (Gordon, 2000, 2007). The colony has many roles,
including interior workers, patrollers, and foragers. Each ant chooses to perform a role according to the local conditions it observes. For example, foragers travel away from the nest,
search for a seed, and when they find one, bring it back immediately. Thus, the rate at which
foragers return to the nest is an approximation of the availability of food today. When the
rate is high, other ants abandon their current role and take on the role of scavenger. The ants
appear to have a convention on the importance of roles—foraging is the most important—and
ants will easily switch into the more important roles, but not into the less important. There is
some learning mechanism: a colony learns to make more successful and prudent actions over
the course of its decades-long life, even though individual ants live only about a year.
One final example of cooperative multiagent behavior appears in the flocking behavior
of birds. We can obtain a reasonable simulation of a flock if each bird agent (sometimes
BOID called a boid) observes the positions of its nearest neighbors and then chooses the heading
and acceleration that maximizes the weighted sum of these three components:
430 Chapter 11. Planning and Acting in the Real World
(a) (b) (c)
Figure 11.11 (a) A simulated flock of birds, using Reynold’s boids model. Image courtesy
Giuseppe Randazzo, novastructura.net. (b) An actual flock of starlings. Image by Eduardo
(pastaboy sleeps on flickr). (c) Two competitive teams of agents attempting to capture the
towers in the NERO game. Image courtesy Risto Miikkulainen.
1. Cohesion: a positive score for getting closer to the average position of the neighbors
2. Separation: a negative score for getting too close to any one neighbor
3. Alignment: a positive score for getting closer to the average heading of the neighbors
If all the boids execute this policy, the flock exhibits the emergent behavior of flying as a EMERGENT
BEHAVIOR
pseudorigid body with roughly constant density that does not disperse over time, and that
occasionally makes sudden swooping motions. You can see a still images in Figure 11.11(a)
and compare it to an actual flock in (b). As with ants, there is no need for each agent to
possess a joint plan that models the actions of other agents.
The most difficult multiagent problems involve both cooperation with members of one’s
own team and competition against members of opposing teams, all without centralized control. We see this in games such as robotic soccer or the NERO game shown in Figure 11.11(c),
in which two teams of software agents compete to capture the control towers. As yet, methods for efficient planning in these kinds of environments—for example, taking advantage of
loose coupling—are in their infancy.
11.5 SUMMARY
This chapter has addressed some of the complications of planning and acting in the real world.
The main points:
• Many actions consume resources, such as money, gas, or raw materials. It is convenient
to treat these resources as numeric measures in a pool rather than try to reason about,
say, each individual coin and bill in the world. Actions can generate and consume
resources, and it is usually cheap and effective to check partial plans for satisfaction of
resource constraints before attempting further refinements.
• Time is one of the most important resources. It can be handled by specialized scheduling algorithms, or scheduling can be integrated with planning.
Bibliographical and Historical Notes 431
• Hierarchical task network (HTN) planning allows the agent to take advice from the
domain designer in the form of high-level actions (HLAs) that can be implemented in
various ways by lower-level action sequences. The effects of HLAs can be defined with
angelic semantics, allowing provably correct high-level plans to be derived without
consideration of lower-level implementations. HTN methods can create the very large
plans required by many real-world applications.
• Standard planning algorithms assume complete and correct information and deterministic, fully observable environments. Many domains violate this assumption.
• Contingent plans allow the agent to sense the world during execution to decide what
branch of the plan to follow. In some cases, sensorless or conformant planning can be
used to construct a plan that works without the need for perception. Both conformant
and contingent plans can be constructed by search in the space of belief states. Efficient
representation or computation of belief states is a key problem.
• An online planning agent uses execution monitoring and splices in repairs as needed
to recover from unexpected situations, which can be due to nondeterministic actions,
exogenous events, or incorrect models of the environment.
• Multiagent planning is necessary when there are other agents in the environment with
which to cooperate or compete. Joint plans can be constructed, but must be augmented
with some form of coordination if two agents are to agree on which joint plan to execute.
• This chapter extends classic planning to cover nondeterministic environments (where
outcomes of actions are uncertain), but it is not the last word on planning. Chapter 17
describes techniques for stochastic environments (in which outcomes of actions have
probabilities associated with them): Markov decision processes, partially observable
Markov decision processes, and game theory. In Chapter 21 we show that reinforcement
learning allows an agent to learn how to behave from past successes and failures.
BIBLIOGRAPHICAL AND HISTORICAL NOTES
Planning with time constraints was first dealt with by DEVISER (Vere, 1983). The representation of time in plans was addressed by Allen (1984) and by Dean et al. (1990) in the
FORBIN system. NONLIN+ (Tate and Whiter, 1984) and SIPE (Wilkins, 1988, 1990) could
reason about the allocation of limited resources to various plan steps. O-PLAN (Bell and
Tate, 1985), an HTN planner, had a uniform, general representation for constraints on time
and resources. In addition to the Hitachi application mentioned in the text, O-PLAN has
been applied to software procurement planning at Price Waterhouse and back-axle assembly
planning at Jaguar Cars.
The two planners SAPA (Do and Kambhampati, 2001) and T4 (Haslum and Geffner,
2001) both used forward state-space search with sophisticated heuristics to handle actions
with durations and resources. An alternative is to use very expressive action languages, but
guide them by human-written domain-specific heuristics, as is done by ASPEN (Fukunaga
et al., 1997), HSTS (Jonsson et al., 2000), and IxTeT (Ghallab and Laruelle, 1994).
432 Chapter 11. Planning and Acting in the Real World
A number of hybrid planning-and-scheduling systems have been deployed: ISIS (Fox
et al., 1982; Fox, 1990) has been used for job shop scheduling at Westinghouse, GARI (Descotte and Latombe, 1985) planned the machining and construction of mechanical parts,
FORBIN was used for factory control, and NONLIN+ was used for naval logistics planning.
We chose to present planning and scheduling as two separate problems; (Cushing et al., 2007)
show that this can lead to incompleteness on certain problems. There is a long history of
scheduling in aerospace. T-SCHED (Drabble, 1990) was used to schedule mission-command
sequences for the UOSAT-II satellite. OPTIMUM-AIV (Aarup et al., 1994) and PLAN-ERS1
(Fuchs et al., 1990), both based on O-PLAN, were used for spacecraft assembly and observation planning, respectively, at the European Space Agency. SPIKE (Johnston and Adorf,
1992) was used for observation planning at NASA for the Hubble Space Telescope, while
the Space Shuttle Ground Processing Scheduling System (Deale et al., 1994) does job-shop
scheduling of up to 16,000 worker-shifts. Remote Agent (Muscettola et al., 1998) became
the first autonomous planner–scheduler to control a spacecraft when it flew onboard the Deep
Space One probe in 1999. Space applications have driven the development of algorithms for
resource allocations; see Laborie (2003) and Muscettola (2002). The literature on scheduling
is presented in a classic survey article (Lawler et al., 1993), a recent book (Pinedo, 2008),
and an edited handbook (Blazewicz et al., 2007).
MACROPS The facility in the STRIPS program for learning macrops—“macro-operators” consisting of a sequence of primitive steps—could be considered the first mechanism for hierarchical planning (Fikes et al., 1972). Hierarchy was also used in the LAWALY system (Siklossy
and Dreussi, 1973). The ABSTRIPS system (Sacerdoti, 1974) introduced the idea of an abstraction hierarchy, whereby planning at higher levels was permitted to ignore lower-level ABSTRACTION
HIERARCHY
preconditions of actions in order to derive the general structure of a working plan. Austin
Tate’s Ph.D. thesis (1975b) and work by Earl Sacerdoti (1977) developed the basic ideas of
HTN planning in its modern form. Many practical planners, including O-PLAN and SIPE,
are HTN planners. Yang (1990) discusses properties of actions that make HTN planning efficient. Erol, Hendler, and Nau (1994, 1996) present a complete hierarchical decomposition
planner as well as a range of complexity results for pure HTN planners. Our presentation of
HLAs and angelic semantics is due to Marthi et al. (2007, 2008). Kambhampati et al. (1998)
have proposed an approach in which decompositions are just another form of plan refinement,
similar to the refinements for non-hierarchical partial-order planning.
Beginning with the work on macro-operators in STRIPS, one of the goals of hierarchical
planning has been the reuse of previous planning experience in the form of generalized plans.
The technique of explanation-based learning, described in depth in Chapter 19, has been
applied in several systems as a means of generalizing previously computed plans, including
SOAR (Laird et al., 1986) and PRODIGY (Carbonell et al., 1989). An alternative approach is
to store previously computed plans in their original form and then reuse them to solve new,
similar problems by analogy to the original problem. This is the approach taken by the field
called case-based planning (Carbonell, 1983; Alterman, 1988; Hammond, 1989). Kamb- CASE-BASED
PLANNING
hampati (1994) argues that case-based planning should be analyzed as a form of refinement
planning and provides a formal foundation for case-based partial-order planning.
Bibliographical and Historical Notes 433
Early planners lacked conditionals and loops, but some could use coercion to form
conformant plans. Sacerdoti’s NOAH solved the “keys and boxes” problem, a planning challenge problem in which the planner knows little about the initial state, using coercion. Mason (1993) argued that sensing often can and should be dispensed with in robotic planning,
and described a sensorless plan that can move a tool into a specific position on a table by a
sequence of tilting actions, regardless of the initial position.
Goldman and Boddy (1996) introduced the term conformant planning, noting that sensorless plans are often effective even if the agent has sensors. The first moderately efficient
conformant planner was Smith and Weld’s (1998) Conformant Graphplan or CGP. Ferraris
and Giunchiglia (2000) and Rintanen (1999) independently developed SATPLAN-based conformant planners. Bonet and Geffner (2000) describe a conformant planner based on heuristic
search in the space of belief states, drawing on ideas first developed in the 1960s for partially
observable Markov decision processes, or POMDPs (see Chapter 17).
Currently, there are three main approaches to conformant planning. The first two use
heuristic search in belief-state space: HSCP (Bertoli et al., 2001a) uses binary decision
diagrams (BDDs) to represent belief states, whereas Hoffmann and Brafman (2006) adopt
the lazy approach of computing precondition and goal tests on demand using a SAT solver.
The third approach, championed primarily by Jussi Rintanen (2007), formulates the entire
sensorless planning problem as a quantified Boolean formula (QBF) and solves it using a
general-purpose QBF solver. Current conformant planners are five orders of magnitude faster
than CGP. The winner of the 2006 conformant-planning track at the International Planning
Competition was T0 (Palacios and Geffner, 2007), which uses heuristic search in belief-state
space while keeping the belief-state representation simple by defining derived literals that
cover conditional effects. Bryce and Kambhampati (2007) discuss how a planning graph can
be generalized to generate good heuristics for conformant and contingent planning.
There has been some confusion in the literature between the terms “conditional” and
“contingent” planning. Following Majercik and Littman (2003), we use “conditional” to
mean a plan (or action) that has different effects depending on the actual state of the world,
and “contingent” to mean a plan in which the agent can choose different actions depending
on the results of sensing. The problem of contingent planning received more attention after
the publication of Drew McDermott’s (1978a) influential article, Planning and Acting.
The contingent-planning approach described in the chapter is based on Hoffmann and
Brafman (2005), and was influenced by the efficient search algorithms for cyclic AND–OR
graphs developed by Jimenez and Torras (2000) and Hansen and Zilberstein (2001). Bertoli
et al. (2001b) describe MBP (Model-Based Planner), which uses binary decision diagrams
to do conformant and contingent planning.
In retrospect, it is now possible to see how the major classical planning algorithms led
to extended versions for uncertain domains. Fast-forward heuristic search through state space
led to forward search in belief space (Bonet and Geffner, 2000; Hoffmann and Brafman,
2005); SATPLAN led to stochastic SATPLAN (Majercik and Littman, 2003) and to planning
with quantified Boolean logic (Rintanen, 2007); partial order planning led to UWL (Etzioni
et al., 1992) and CNLP (Peot and Smith, 1992); GRAPHPLAN led to Sensory Graphplan or
SGP (Weld et al., 1998).
434 Chapter 11. Planning and Acting in the Real World
The first online planner with execution monitoring was PLANEX (Fikes et al., 1972),
which worked with the STRIPS planner to control the robot Shakey. The NASL planner
(McDermott, 1978a) treated a planning problem simply as a specification for carrying out a
complex action, so that execution and planning were completely unified. SIPE (System for
Interactive Planning and Execution monitoring) (Wilkins, 1988, 1990) was the first planner
to deal systematically with the problem of replanning. It has been used in demonstration
projects in several domains, including planning operations on the flight deck of an aircraft
carrier, job-shop scheduling for an Australian beer factory, and planning the construction of
multistory buildings (Kartam and Levitt, 1990).
In the mid-1980s, pessimism about the slow run times of planning systems led to the
REACTIVE PLANNING proposal of reflex agents called reactive planning systems (Brooks, 1986; Agre and Chapman, 1987). PENGI (Agre and Chapman, 1987) could play a (fully observable) video game
by using Boolean circuits combined with a “visual” representation of current goals and the
agent’s internal state. “Universal plans” (Schoppers, 1987, 1989) were developed as a lookupPOLICY table method for reactive planning, but turned out to be a rediscovery of the idea of policies
that had long been used in Markov decision processes (see Chapter 17). A universal plan (or
a policy) contains a mapping from any state to the action that should be taken in that state.
Koenig (2001) surveys online planning techniques, under the name Agent-Centered Search.
Multiagent planning has leaped in popularity in recent years, although it does have
a long history. Konolige (1982) formalizes multiagent planning in first-order logic, while
Pednault (1986) gives a STRIPS-style description. The notion of joint intention, which is essential if agents are to execute a joint plan, comes from work on communicative acts (Cohen
and Levesque, 1990; Cohen et al., 1990). Boutilier and Brafman (2001) show how to adapt
partial-order planning to a multiactor setting. Brafman and Domshlak (2008) devise a multiactor planning algorithm whose complexity grows only linearly with the number of actors,
provided that the degree of coupling (measured partly by the tree width of the graph of interactions among agents) is bounded. Petrik and Zilberstein (2009) show that an approach based
on bilinear programming outperforms the cover-set approach we outlined in the chapter.
We have barely skimmed the surface of work on negotiation in multiagent planning.
Durfee and Lesser (1989) discuss how tasks can be shared out among agents by negotiation.
Kraus et al. (1991) describe a system for playing Diplomacy, a board game requiring negotiation, coalition formation, and dishonesty. Stone (2000) shows how agents can cooperate as
teammates in the competitive, dynamic, partially observable environment of robotic soccer. In
a later article, Stone (2003) analyzes two competitive multiagent environments—RoboCup,
a robotic soccer competition, and TAC, the auction-based Trading Agents Competition—
and finds that the computational intractability of our current theoretically well-founded approaches has led to many multiagent systems being designed by ad hoc methods.
In his highly influential Society of Mind theory, Marvin Minsky (1986, 2007) proposes
that human minds are constructed from an ensemble of agents. Livnat and Pippenger (2006)
prove that, for the problem of optimal path-finding, and given a limitation on the total amount
of computing resources, the best architecture for an agent is an ensemble of subagents, each
of which tries to optimize its own objective, and all of which are in conflict with one another.
Exercises 435
The boid model on page 429 is due to Reynolds (1987), who won an Academy Award
for its application to swarms of penguins in Batman Returns. The NERO game and the methods for learning strategies are described by Bryant and Miikkulainen (2007).
Recent book on multiagent systems include those by Weiss (2000a), Young (2004),
Vlassis (2008), and Shoham and Leyton-Brown (2009). There is an annual conference on
autonomous agents and multiagent systems (AAMAS).
EXERCISES
11.1 The goals we have considered so far all ask the planner to make the world satisfy the
goal at just one time step. Not all goals can be expressed this way: you do not achieve the
goal of suspending a chandelier above the ground by throwing it in the air. More seriously,
you wouldn’t want your spacecraft life-support system to supply oxygen one day but not
the next. A maintenance goal is achieved when the agent’s plan causes a condition to hold
continuously from a given state onward. Describe how to extend the formalism of this chapter
to support maintenance goals.
11.2 You have a number of trucks with which to deliver a set of packages. Each package
starts at some location on a grid map, and has a destination somewhere else. Each truck is directly controlled by moving forward and turning. Construct a hierarchy of high-level actions
for this problem. What knowledge about the solution does your hierarchy encode?
11.3 Suppose that a high-level action has exactly one implementation as a sequence of
primitive actions. Give an algorithm for computing its preconditions and effects, given the
complete refinement hierarchy and schemas for the primitive actions.
11.4 Suppose that the optimistic reachable set of a high-level plan is a superset of the goal
set; can anything be concluded about whether the plan achieves the goal? What if the pessimistic reachable set doesn’t intersect the goal set? Explain.
11.5 Write an algorithm that takes an initial state (specified by a set of propositional literals)
and a sequence of HLAs (each defined by preconditions and angelic specifications of optimistic and pessimistic reachable sets) and computes optimistic and pessimistic descriptions
of the reachable set of the sequence.
11.6 In Figure 11.2 we showed how to describe actions in a scheduling problem by using
separate fields for DURATION, USE, and CONSUME. Now suppose we wanted to combine
scheduling with nondeterministic planning, which requires nondeterministic and conditional
effects. Consider each of the three fields and explain if they should remain separate fields, or
if they should become effects of the action. Give an example for each of the three.
11.7 Some of the operations in standard programming languages can be modeled as actions
that change the state of the world. For example, the assignment operation changes the contents of a memory location, and the print operation changes the state of the output stream. A
program consisting of these operations can also be considered as a plan, whose goal is given
436 Chapter 11. Planning and Acting in the Real World
by the specification of the program. Therefore, planning algorithms can be used to construct
programs that achieve a given specification.
a. Write an action schema for the assignment operator (assigning the value of one variable
to another). Remember that the original value will be overwritten!
b. Show how object creation can be used by a planner to produce a plan for exchanging
the values of two variables by using a temporary variable.
11.8 Suppose the Flip action always changes the truth value of variable L. Show how
to define its effects by using an action schema with conditional effects. Show that, despite
the use of conditional effects, a 1-CNF belief state representation remains in 1-CNF after a
Flip.
11.9 In the blocks world we were forced to introduce two action schemas, Move and
MoveToTable, in order to maintain the Clear predicate properly. Show how conditional
effects can be used to represent both of these cases with a single action.
11.10 Conditional effects were illustrated for the Suck action in the vacuum world—which
square becomes clean depends on which square the robot is in. Can you think of a new set of
propositional variables to define states of the vacuum world, such that Suck has an unconditional description? Write out the descriptions of Suck, Left, and Right, using your propositions, and demonstrate that they suffice to describe all possible states of the world.
11.11 Find a suitably dirty carpet, free of obstacles, and vacuum it. Draw the path taken
by the vacuum cleaner as accurately as you can. Explain it, with reference to the forms of
planning discussed in this chapter.
11.12 To the medication problem in the previous exercise, add a Test action that has the
conditional effect CultureGrowth when Disease is true and in any case has the perceptual
effect Known(CultureGrowth). Diagram a conditional plan that solves the problem and
minimizes the use of the Medicate action.
12 KNOWLEDGE
REPRESENTATION
In which we show how to use first-order logic to represent the most important
aspects of the real world, such as action, space, time, thoughts, and shopping.
The previous chapters described the technology for knowledge-based agents: the syntax,
semantics, and proof theory of propositional and first-order logic, and the implementation of
agents that use these logics. In this chapter we address the question of what content to put
into such an agent’s knowledge base—how to represent facts about the world.
Section 12.1 introduces the idea of a general ontology, which organizes everything in
the world into a hierarchy of categories. Section 12.2 covers the basic categories of objects,
substances, and measures; Section 12.3 covers events, and Section 12.4 discusses knowledge
about beliefs. We then return to consider the technology for reasoning with this content:
Section 12.5 discusses reasoning systems designed for efficient inference with categories,
and Section 12.6 discusses reasoning with default information. Section 12.7 brings all the
knowledge together in the context of an Internet shopping environment.
12.1 ONTOLOGICAL ENGINEERING
In “toy” domains, the choice of representation is not that important; many choices will work.
Complex domains such as shopping on the Internet or driving a car in traffic require more
general and flexible representations. This chapter shows how to create these representations,
concentrating on general concepts—such as Events, Time, Physical Objects, and Beliefs—
that occur in many different domains. Representing these abstract concepts is sometimes
called ontological engineering. ONTOLOGICAL
ENGINEERING
The prospect of representing everything in the world is daunting. Of course, we won’t
actually write a complete description of everything—that would be far too much for even a
1000-page textbook—but we will leave placeholders where new knowledge for any domain
can fit in. For example, we will define what it means to be a physical object, and the details of
different types of objects—robots, televisions, books, or whatever—can be filled in later. This
is analogous to the way that designers of an object-oriented programming framework (such as
the Java Swing graphical framework) define general concepts like Window, expecting users to
437
438 Chapter 12. Knowledge Representation
Anything
AbstractObjects
Sets Numbers RepresentationalObjects Interval Places Processes PhysicalObjects
Humans
Categories Sentences Measurements Moments Things Stuff
Times Weights Animals Agents Solid Liquid Gas
GeneralizedEvents
Figure 12.1 The upper ontology of the world, showing the topics to be covered later in
the chapter. Each link indicates that the lower concept is a specialization of the upper one.
Specializations are not necessarily disjoint; a human is both an animal and an agent, for
example. We will see in Section 12.3.3 why physical objects come under generalized events.
use these to define more specific concepts like SpreadsheetWindow. The general framework
UPPER ONTOLOGY of concepts is called an upper ontology because of the convention of drawing graphs with
the general concepts at the top and the more specific concepts below them, as in Figure 12.1.
Before considering the ontology further, we should state one important caveat. We
have elected to use first-order logic to discuss the content and organization of knowledge,
although certain aspects of the real world are hard to capture in FOL. The principal difficulty
is that most generalizations have exceptions or hold only to a degree. For example, although
“tomatoes are red” is a useful rule, some tomatoes are green, yellow, or orange. Similar
exceptions can be found to almost all the rules in this chapter. The ability to handle exceptions
and uncertainty is extremely important, but is orthogonal to the task of understanding the
general ontology. For this reason, we delay the discussion of exceptions until Section 12.5 of
this chapter, and the more general topic of reasoning with uncertainty until Chapter 13.
Of what use is an upper ontology? Consider the ontology for circuits in Section 8.4.2.
It makes many simplifying assumptions: time is omitted completely; signals are fixed and do
not propagate; the structure of the circuit remains constant. A more general ontology would
consider signals at particular times, and would include the wire lengths and propagation delays. This would allow us to simulate the timing properties of the circuit, and indeed such
simulations are often carried out by circuit designers. We could also introduce more interesting classes of gates, for example, by describing the technology (TTL, CMOS, and so on)
as well as the input–output specification. If we wanted to discuss reliability or diagnosis, we
would include the possibility that the structure of the circuit or the properties of the gates
might change spontaneously. To account for stray capacitances, we would need to represent
where the wires are on the board.
Section 12.1. Ontological Engineering 439
If we look at the wumpus world, similar considerations apply. Although we do represent
time, it has a simple structure: Nothing happens except when the agent acts, and all changes
are instantaneous. A more general ontology, better suited for the real world, would allow for
simultaneous changes extended over time. We also used a Pit predicate to say which squares
have pits. We could have allowed for different kinds of pits by having several individuals
belonging to the class of pits, each having different properties. Similarly, we might want to
allow for other animals besides wumpuses. It might not be possible to pin down the exact
species from the available percepts, so we would need to build up a biological taxonomy to
help the agent predict the behavior of cave-dwellers from scanty clues.
For any special-purpose ontology, it is possible to make changes like these to move
toward greater generality. An obvious question then arises: do all these ontologies converge
on a general-purpose ontology? After centuries of philosophical and computational investigation, the answer is “Maybe.” In this section, we present one general-purpose ontology
that synthesizes ideas from those centuries. Two major characteristics of general-purpose
ontologies distinguish them from collections of special-purpose ontologies:
• A general-purpose ontology should be applicable in more or less any special-purpose
domain (with the addition of domain-specific axioms). This means that no representational issue can be finessed or brushed under the carpet.
• In any sufficiently demanding domain, different areas of knowledge must be unified,
because reasoning and problem solving could involve several areas simultaneously. A
robot circuit-repair system, for instance, needs to reason about circuits in terms of electrical connectivity and physical layout, and about time, both for circuit timing analysis
and estimating labor costs. The sentences describing time therefore must be capable
of being combined with those describing spatial layout and must work equally well for
nanoseconds and minutes and for angstroms and meters.
We should say up front that the enterprise of general ontological engineering has so far had
only limited success. None of the top AI applications (as listed in Chapter 1) make use
of a shared ontology—they all use special-purpose knowledge engineering. Social/political
considerations can make it difficult for competing parties to agree on an ontology. As Tom
Gruber (2004) says, “Every ontology is a treaty—a social agreement—among people with
some common motive in sharing.” When competing concerns outweigh the motivation for
sharing, there can be no common ontology. Those ontologies that do exist have been created
along four routes:
1. By a team of trained ontologist/logicians, who architect the ontology and write axioms.
The CYC system was mostly built this way (Lenat and Guha, 1990).
2. By importing categories, attributes, and values from an existing database or databases.
DBPEDIA was built by importing structured facts from Wikipedia (Bizer et al., 2007).
3. By parsing text documents and extracting information from them. TEXTRUNNER was
built by reading a large corpus of Web pages (Banko and Etzioni, 2008).
4. By enticing unskilled amateurs to enter commonsense knowledge. The OPENMIND
system was built by volunteers who proposed facts in English (Singh et al., 2002;
Chklovski and Gil, 2005).
440 Chapter 12. Knowledge Representation
12.2 CATEGORIES AND OBJECTS
CATEGORY The organization of objects into categories is a vital part of knowledge representation. Although interaction with the world takes place at the level of individual objects, much reasoning takes place at the level of categories. For example, a shopper would normally have the
goal of buying a basketball, rather than a particular basketball such as BB9. Categories also
serve to make predictions about objects once they are classified. One infers the presence of
certain objects from perceptual input, infers category membership from the perceived properties of the objects, and then uses category information to make predictions about the objects.
For example, from its green and yellow mottled skin, one-foot diameter, ovoid shape, red
flesh, black seeds, and presence in the fruit aisle, one can infer that an object is a watermelon;
from this, one infers that it would be useful for fruit salad.
There are two choices for representing categories in first-order logic: predicates and
objects. That is, we can use the predicate Basketball(b), or we can reify1 REIFICATION the category as
an object, Basketballs. We could then say Member (b, Basketballs ), which we will abbreviate as b∈ Basketballs, to say that b is a member of the category of basketballs. We say
Subset(Basketballs, Balls), abbreviated as Basketballs ⊂ Balls, to say that Basketballs is
SUBCATEGORY a subcategory of Balls. We will use subcategory, subclass, and subset interchangeably.
INHERITANCE Categories serve to organize and simplify the knowledge base through inheritance. If
we say that all instances of the category Food are edible, and if we assert that Fruit is a
subclass of Food and Apples is a subclass of Fruit, then we can infer that every apple is
edible. We say that the individual apples inherit the property of edibility, in this case from
their membership in the Food category.
TAXONOMY Subclass relations organize categories into a taxonomy, or taxonomic hierarchy. Taxonomies have been used explicitly for centuries in technical fields. The largest such taxonomy
organizes about 10 million living and extinct species, many of them beetles,2 into a single hierarchy; library science has developed a taxonomy of all fields of knowledge, encoded as the
Dewey Decimal system; and tax authorities and other government departments have developed extensive taxonomies of occupations and commercial products. Taxonomies are also an
important aspect of general commonsense knowledge.
First-order logic makes it easy to state facts about categories, either by relating objects to categories or by quantifying over their members. Here are some types of facts, with
examples of each:
• An object is a member of a category.
BB9 ∈ Basketballs
• A category is a subclass of another category.
Basketballs ⊂ Balls
• All members of a category have some properties.
(x∈ Basketballs) ⇒ Spherical(x)
1 Turning a proposition into an object is called reification, from the Latin word res, or thing. John McCarthy
proposed the term “thingification,” but it never caught on.
2 The famous biologist J. B. S. Haldane deduced “An inordinate fondness for beetles” on the part of the Creator.
Section 12.2. Categories and Objects 441
• Members of a category can be recognized by some properties.
Orange(x) ∧ Round(x) ∧ Diameter(x)=9.5 ∧ x∈ Balls ⇒ x∈ Basketballs
• A category as a whole has some properties.
Dogs ∈ DomesticatedSpecies
Notice that because Dogs is a category and is a member of DomesticatedSpecies , the latter
must be a category of categories. Of course there are exceptions to many of the above rules
(punctured basketballs are not spherical); we deal with these exceptions later.
Although subclass and member relations are the most important ones for categories,
we also want to be able to state relations between categories that are not subclasses of each
other. For example, if we just say that Males and Females are subclasses of Animals, then
we have not said that a male cannot be a female. We say that two or more categories are
DISJOINT disjoint if they have no members in common. And even if we know that males and females
are disjoint, we will not know that an animal that is not a male must be a female, unless
EXHAUSTIVE
DECOMPOSITION we say that males and females constitute an exhaustive decomposition of the animals. A
PARTITION disjoint exhaustive decomposition is known as a partition. The following examples illustrate
these three concepts:
Disjoint({Animals, Vegetables})
ExhaustiveDecomposition({Americans, Canadians , Mexicans},
NorthAmericans)
Partition({Males,Females}, Animals) .
(Note that the ExhaustiveDecomposition of NorthAmericans is not a Partition, because
some people have dual citizenship.) The three predicates are defined as follows:
Disjoint(s) ⇔ (∀ c1, c2 c1 ∈s ∧ c2 ∈ s ∧ c1 = c2 ⇒ Intersection(c1, c2) = { })
ExhaustiveDecomposition(s, c) ⇔ (∀ i i∈ c ⇔ ∃ c2 c2 ∈s ∧ i∈ c2)
Partition(s, c) ⇔ Disjoint(s) ∧ ExhaustiveDecomposition(s, c) .
Categories can also be defined by providing necessary and sufficient conditions for
membership. For example, a bachelor is an unmarried adult male:
x∈ Bachelors ⇔ Unmarried(x) ∧ x∈ Adults ∧ x∈ Males .
As we discuss in the sidebar on natural kinds on page 443, strict logical definitions for categories are neither always possible nor always necessary.
12.2.1 Physical composition
The idea that one object can be part of another is a familiar one. One’s nose is part of one’s
head, Romania is part of Europe, and this chapter is part of this book. We use the general
PartOf relation to say that one thing is part of another. Objects can be grouped into PartOf
hierarchies, reminiscent of the Subset hierarchy:
PartOf (Bucharest, Romania)
PartOf (Romania,EasternEurope)
PartOf (EasternEurope,Europe)
PartOf (Europe,Earth) .
442 Chapter 12. Knowledge Representation
The PartOf relation is transitive and reflexive; that is,
PartOf (x, y) ∧ PartOf (y, z) ⇒ PartOf (x, z) .
PartOf (x, x) .
Therefore, we can conclude PartOf (Bucharest,Earth).
COMPOSITE OBJECT Categories of composite objects are often characterized by structural relations among
parts. For example, a biped has two legs attached to a body:
Biped(a) ⇒ ∃ l1, l2, b Leg(l1) ∧ Leg(l2) ∧ Body(b) ∧
PartOf (l1, a) ∧ PartOf (l2, a) ∧ PartOf (b, a) ∧
Attached(l1, b) ∧ Attached(l2, b) ∧
l1 = l2 ∧ [∀ l3 Leg(l3) ∧ PartOf (l3, a) ⇒ (l3 = l1 ∨ l3 = l2)] .
The notation for “exactly two” is a little awkward; we are forced to say that there are two
legs, that they are not the same, and that if anyone proposes a third leg, it must be the same
as one of the other two. In Section 12.5.2, we describe a formalism called description logic
makes it easier to represent constraints like “exactly two.”
We can define a PartPartition relation analogous to the Partition relation for categories. (See Exercise 12.8.) An object is composed of the parts in its PartPartition and can
be viewed as deriving some properties from those parts. For example, the mass of a composite object is the sum of the masses of the parts. Notice that this is not the case with categories,
which have no mass, even though their elements might.
It is also useful to define composite objects with definite parts but no particular structure. For example, we might want to say “The apples in this bag weigh two pounds.” The
temptation would be to ascribe this weight to the set of apples in the bag, but this would be
a mistake because the set is an abstract mathematical concept that has elements but does not
BUNCH have weight. Instead, we need a new concept, which we will call a bunch. For example, if
the apples are Apple1, Apple2, and Apple3, then
BunchOf ({Apple1, Apple2, Apple3})
denotes the composite object with the three apples as parts (not elements). We can then use the
bunch as a normal, albeit unstructured, object. Notice that BunchOf ({x}) = x. Furthermore,
BunchOf (Apples) is the composite object consisting of all apples—not to be confused with
Apples, the category or set of all apples.
We can define BunchOf in terms of the PartOf relation. Obviously, each element of
s is part of BunchOf (s):
∀ x x∈ s ⇒ PartOf (x, BunchOf (s)) .
Furthermore, BunchOf (s) is the smallest object satisfying this condition. In other words,
BunchOf (s) must be part of any object that has all the elements of s as parts:
∀ y [∀ x x∈ s ⇒ PartOf (x, y)] ⇒ PartOf (BunchOf (s), y) .
These axioms are an example of a general technique called logical minimization, which LOGICAL
MINIMIZATION
means defining an object as the smallest one satisfying certain conditions.
Section 12.2. Categories and Objects 443
NATURAL KINDS
Some categories have strict definitions: an object is a triangle if and only if it is
a polygon with three sides. On the other hand, most categories in the real world
have no clear-cut definition; these are called natural kind categories. For example,
tomatoes tend to be a dull scarlet; roughly spherical; with an indentation at the top
where the stem was; about two to four inches in diameter; with a thin but tough
skin; and with flesh, seeds, and juice inside. There is, however, variation: some
tomatoes are yellow or orange, unripe tomatoes are green, some are smaller or
larger than average, and cherry tomatoes are uniformly small. Rather than having
a complete definition of tomatoes, we have a set of features that serves to identify
objects that are clearly typical tomatoes, but might not be able to decide for other
objects. (Could there be a tomato that is fuzzy like a peach?)
This poses a problem for a logical agent. The agent cannot be sure that an
object it has perceived is a tomato, and even if it were sure, it could not be certain which of the properties of typical tomatoes this one has. This problem is an
inevitable consequence of operating in partially observable environments.
One useful approach is to separate what is true of all instances of a category from what is true only of typical instances. So in addition to the category
Tomatoes , we will also have the category Typical(Tomatoes ). Here, the Typical
function maps a category to the subclass that contains only typical instances:
Typical(c) ⊆ c .
Most knowledge about natural kinds will actually be about their typical instances:
x∈ Typical(Tomatoes ) ⇒ Red(x) ∧ Round(x) .
Thus, we can write down useful facts about categories without exact definitions. The difficulty of providing exact definitions for most natural categories was
explained in depth by Wittgenstein (1953). He used the example of games to show
that members of a category shared “family resemblances” rather than necessary
and sufficient characteristics: what strict definition encompasses chess, tag, solitaire, and dodgeball?
The utility of the notion of strict definition was also challenged by
Quine (1953). He pointed out that even the definition of “bachelor” as an unmarried adult male is suspect; one might, for example, question a statement such
as “the Pope is a bachelor.” While not strictly false, this usage is certainly infelicitous because it induces unintended inferences on the part of the listener. The
tension could perhaps be resolved by distinguishing between logical definitions
suitable for internal knowledge representation and the more nuanced criteria for
felicitous linguistic usage. The latter may be achieved by “filtering” the assertions
derived from the former. It is also possible that failures of linguistic usage serve as
feedback for modifying internal definitions, so that filtering becomes unnecessary.
444 Chapter 12. Knowledge Representation
12.2.2 Measurements
In both scientific and commonsense theories of the world, objects have height, mass, cost,
MEASURE and so on. The values that we assign for these properties are called measures. Ordinary quantitative measures are quite easy to represent. We imagine that the universe includes abstract “measure objects,” such as the length that is the length of this line segment: . We can call this length 1.5 inches or 3.81 centimeters. Thus,
the same length has different names in our language.We represent the length with a units
UNITS FUNCTION function that takes a number as argument. (An alternative scheme is explored in Exercise 12.9.) If the line segment is called L1, we can write
Length(L1) = Inches(1.5) = Centimeters(3.81) .
Conversion between units is done by equating multiples of one unit to another:
Centimeters(2.54 × d) = Inches(d) .
Similar axioms can be written for pounds and kilograms, seconds and days, and dollars and
cents. Measures can be used to describe objects as follows:
Diameter (Basketball 12) = Inches(9.5) .
ListPrice(Basketball 12) = $(19) .
d∈ Days ⇒ Duration(d) = Hours(24) .
Note that $(1) is not a dollar bill! One can have two dollar bills, but there is only one object
named $(1). Note also that, while Inches(0) and Centimeters(0) refer to the same zero
length, they are not identical to other zero measures, such as Seconds(0).
Simple, quantitative measures are easy to represent. Other measures present more of a
problem, because they have no agreed scale of values. Exercises have difficulty, desserts have
deliciousness, and poems have beauty, yet numbers cannot be assigned to these qualities. One
might, in a moment of pure accountancy, dismiss such properties as useless for the purpose of
logical reasoning; or, still worse, attempt to impose a numerical scale on beauty. This would
be a grave mistake, because it is unnecessary. The most important aspect of measures is not
the particular numerical values, but the fact that measures can be ordered.
Although measures are not numbers, we can still compare them, using an ordering
symbol such as >. For example, we might well believe that Norvig’s exercises are tougher
than Russell’s, and that one scores less on tougher exercises:
e1 ∈Exercises ∧ e2 ∈Exercises ∧ Wrote(Norvig, e1) ∧ Wrote(Russell, e2) ⇒
Difficulty(e1) > Difficulty(e2) .
e1 ∈Exercises ∧ e2 ∈Exercises ∧ Difficulty(e1) > Difficulty(e2) ⇒
ExpectedScore(e1) < ExpectedScore(e2) .
This is enough to allow one to decide which exercises to do, even though no numerical values
for difficulty were ever used. (One does, however, have to discover who wrote which exercises.) These sorts of monotonic relationships among measures form the basis for the field of
qualitative physics, a subfield of AI that investigates how to reason about physical systems
without plunging into detailed equations and numerical simulations. Qualitative physics is
discussed in the historical notes section.
Section 12.2. Categories and Objects 445
12.2.3 Objects: Things and stuff
The real world can be seen as consisting of primitive objects (e.g., atomic particles) and
composite objects built from them. By reasoning at the level of large objects such as apples
and cars, we can overcome the complexity involved in dealing with vast numbers of primitive
objects individually. There is, however, a significant portion of reality that seems to defy any
INDIVIDUATION obvious individuation—division into distinct objects. We give this portion the generic name
STUFF stuff. For example, suppose I have some butter and an aardvark in front of me. I can say
there is one aardvark, but there is no obvious number of “butter-objects,” because any part of
a butter-object is also a butter-object, at least until we get to very small parts indeed. This is
the major distinction between stuff and things. If we cut an aardvark in half, we do not get
two aardvarks (unfortunately).
The English language distinguishes clearly between stuff and things. We say “an aardvark,” but, except in pretentious California restaurants, one cannot say “a butter.” Linguists
COUNT NOUNS distinguish between count nouns, such as aardvarks, holes, and theorems, and mass nouns,
MASS NOUN such as butter, water, and energy. Several competing ontologies claim to handle this distinction. Here we describe just one; the others are covered in the historical notes section.
To represent stuff properly, we begin with the obvious. We need to have as objects in
our ontology at least the gross “lumps” of stuff we interact with. For example, we might
recognize a lump of butter as the one left on the table the night before; we might pick it up,
weigh it, sell it, or whatever. In these senses, it is an object just like the aardvark. Let us
call it Butter 3. We also define the category Butter. Informally, its elements will be all those
things of which one might say “It’s butter,” including Butter 3. With some caveats about very
small parts that we w omit for now, any part of a butter-object is also a butter-object:
b∈ Butter ∧ PartOf (p, b) ⇒ p ∈ Butter .
We can now say that butter melts at around 30 degrees centigrade:
b∈ Butter ⇒ MeltingPoint(b, Centigrade(30)) .
We could go on to say that butter is yellow, is less dense than water, is soft at room temperature, has a high fat content, and so on. On the other hand, butter has no particular size, shape,
or weight. We can define more specialized categories of butter such as UnsaltedButter ,
which is also a kind of stuff. Note that the category PoundOfButter , which includes as
members all butter-objects weighing one pound, is not a kind of stuff. If we cut a pound of
butter in half, we do not, alas, get two pounds of butter.
INTRINSIC What is actually going on is this: some properties are intrinsic: they belong to the very
substance of the object, rather than to the object as a whole. When you cut an instance of
stuff in half, the two pieces retain the intrinsic properties—things like density, boiling point,
EXTRINSIC flavor, color, ownership, and so on. On the other hand, their extrinsic properties—weight,
length, shape, and so on—are not retained under subdivision. A category of objects that
includes in its definition only intrinsic properties is then a substance, or mass noun; a class
that includes any extrinsic properties in its definition is a count noun. The category Stuff is
the most general substance category, specifying no intrinsic properties. The category Thing
is the most general discrete object category, specifying no extrinsic properties.
446 Chapter 12. Knowledge Representation
12.3 EVENTS
In Section 10.4.2, we showed how situation calculus represents actions and their effects.
Situation calculus is limited in its applicability: it was designed to describe a world in which
actions are discrete, instantaneous, and happen one at a time. Consider a continuous action,
such as filling a bathtub. Situation calculus can say that the tub is empty before the action and
full when the action is done, but it can’t talk about what happens during the action. It also
can’t describe two actions happening at the same time—such as brushing one’s teeth while
waiting for the tub to fill. To handle such cases we introduce an alternative formalism known
as event calculus, which is based on points of time rather than on situations.3 EVENT CALCULUS
Event calculus reifies fluents and events. The fluent At(Shankar , Berkeley) is an object that refers to the fact of Shankar being in Berkeley, but does not by itself say anything
about whether it is true. To assert that a fluent is actually true at some point in time we use
the predicate T, as in T(At(Shankar , Berkeley), t).
Events are described as instances of event categories.4 The event E1 of Shankar flying
from San Francisco to Washington, D.C. is described as
E1 ∈ Flyings ∧ Flyer (E1, Shankar ) ∧ Origin(E1, SF) ∧ Destination(E1, DC ).
If this is too verbose, we can define an alternative three-argument version of the category of
flying events and say
E1 ∈ Flyings(Shankar , SF, DC).
We then use Happens(E1, i) to say that the event E1 took place over the time interval i, and
we say the same thing in functional form with Extent(E1) = i. We represent time intervals
by a (start, end) pair of times; that is, i = (t1, t2) is the time interval that starts at t1 and ends
at t2. The complete set of predicates for one version of the event calculus is
T(f, t) Fluent f is true at time t
Happens(e, i) Event e happens over the time interval i
Initiates(e, f, t) Event e causes fluent f to start to hold at time t
Terminates(e, f, t) Event e causes fluent f to cease to hold at time t
Clipped(f, i) Fluent f ceases to be true at some point during time interval i
Restored(f, i) Fluent f becomes true sometime during time interval i
We assume a distinguished event, Start, that describes the initial state by saying which fluents
are initiated or terminated at the start time. We define T by saying that a fluent holds at a point
in time if the fluent was initiated by an event at some time in the past and was not made false
(clipped) by an intervening event. A fluent does not hold if it was terminated by an event and
3 The terms “event” and “action” may be used interchangeably. Informally, “action” connotes an agent while
“event” connotes the possibility of agentless actions.
4 Some versions of event calculus do not distinguish event categories from instances of the categories.
Section 12.3. Events 447
not made true (restored) by another event. Formally, the axioms are:
Happens(e,(t1, t2)) ∧ Initiates(e, f, t1) ∧ ¬Clipped(f,(t1, t)) ∧ t1 < t ⇒
T(f, t)
Happens(e,(t1, t2)) ∧ Terminates(e, f, t1) ∧ ¬Restored(f,(t1, t)) ∧ t1 < t ⇒
¬T(f, t)
where Clipped and Restored are defined by
Clipped(f,(t1, t2)) ⇔
∃ e, t, t3 Happens(e,(t, t3)) ∧ t1 ≤ t<t2 ∧ Terminates(e, f, t)
Restored(f,(t1, t2)) ⇔
∃ e, t, t3 Happens(e,(t, t3)) ∧ t1 ≤ t<t2 ∧ Initiates(e, f, t)
It is convenient to extend T to work over intervals as well as time points; a fluent holds over
an interval if it holds on every point within the interval:
T(f,(t1, t2)) ⇔ [∀ t (t1 ≤ t<t2) ⇒ T(f, t)]
Fluents and actions are defined with domain-specific axioms that are similar to successorstate axioms. For example, we can say that the only way a wumpus-world agent gets an
arrow is at the start, and the only way to use up an arrow is to shoot it:
Initiates(e, HaveArrow(a), t) ⇔ e = Start
Terminates(e, HaveArrow(a), t) ⇔ e ∈ Shootings(a)
By reifying events we make it possible to add any amount of arbitrary information about
them. For example, we can say that Shankar’s flight was bumpy with Bumpy(E1). In an
ontology where events are n-ary predicates, there would be no way to add extra information
like this; moving to an n + 1-ary predicate isn’t a scalable solution.
We can extend event calculus to make it possible to represent simultaneous events (such
as two people being necessary to ride a seesaw), exogenous events (such as the wind blowing
and changing the location of an object), continuous events (such as the level of water in the
bathtub continuously rising) and other complications.
12.3.1 Processes
DISCRETE EVENTS The events we have seen so far are what we call discrete events—they have a definite structure. Shankar’s trip has a beginning, middle, and end. If interrupted halfway, the event would
be something different—it would not be a trip from San Francisco to Washington, but instead
a trip from San Francisco to somewhere over Kansas. On the other hand, the category of
events denoted by Flyings has a different quality. If we take a small interval of Shankar’s
flight, say, the third 20-minute segment (while he waits anxiously for a bag of peanuts), that
event is still a member of Flyings. In fact, this is true for any subinterval.
PROCESS Categories of events with this property are called process categories or liquid event
LIQUID EVENT categories. Any process e that happens over an interval also happens over any subinterval:
(e ∈ Processes) ∧ Happens(e,(t1, t4)) ∧ (t1 < t2 < t3 < t4) ⇒ Happens(e,(t2, t3)).
The distinction between liquid and nonliquid events is exactly analogous to the difference
between substances, or stuff, and individual objects, or things. In fact, some have called
liquid events temporal substances, whereas substances like butter are spatial substances. TEMPORAL
SUBSTANCE
SPATIAL SUBSTANCE
448 Chapter 12. Knowledge Representation
12.3.2 Time intervals
Event calculus opens us up to the possibility of talking about time, and time intervals. We
will consider two kinds of time intervals: moments and extended intervals. The distinction is
that only moments have zero duration:
Partition({Moments,ExtendedIntervals},Intervals )
i∈ Moments ⇔ Duration(i) = Seconds(0) .
Next we invent a time scale and associate points on that scale with moments, giving us absolute times. The time scale is arbitrary; we measure it in seconds and say that the moment
at midnight (GMT) on January 1, 1900, has time 0. The functions Begin and End pick out
the earliest and latest moments in an interval, and the function Time delivers the point on the
time scale for a moment. The function Duration gives the difference between the end time
and the start time.
Interval(i) ⇒ Duration(i)=(Time(End(i)) − Time(Begin(i))) .
Time(Begin(AD1900)) = Seconds(0) .
Time(Begin(AD2001)) = Seconds(3187324800) .
Time(End(AD2001)) = Seconds(3218860800) .
Duration(AD2001) = Seconds(31536000) .
To make these numbers easier to read, we also introduce a function Date, which takes six
arguments (hours, minutes, seconds, day, month, and year) and returns a time point:
Time(Begin(AD2001)) = Date(0, 0, 0, 1, Jan, 2001)
Date(0, 20, 21, 24, 1, 1995) = Seconds(3000000000) .
Two intervals Meet if the end time of the first equals the start time of the second. The complete set of interval relations, as proposed by Allen (1983), is shown graphically in Figure 12.2
and logically below:
Meet(i, j) ⇔ End(i) = Begin(j)
Before(i, j) ⇔ End(i) < Begin(j)
After (j, i) ⇔ Before(i, j)
During(i, j) ⇔ Begin(j) < Begin(i) < End(i) < End(j)
Overlap(i, j) ⇔ Begin(i) < Begin(j) < End(i) < End(j)
Begins(i, j) ⇔ Begin(i) = Begin(j)
Finishes(i, j) ⇔ End(i) = End(j)
Equals(i, j) ⇔ Begin(i) = Begin(j) ∧ End(i) = End(j)
These all have their intuitive meaning, with the exception of Overlap: we tend to think of
overlap as symmetric (if i overlaps j then j overlaps i), but in this definition, Overlap(i, j)
only holds if i begins before j. To say that the reign of Elizabeth II immediately followed that
of George VI, and the reign of Elvis overlapped with the 1950s, we can write the following:
Meets(ReignOf (GeorgeVI), ReignOf (ElizabethII)) .
Overlap(Fifties, ReignOf (Elvis)) .
Begin(Fifties) = Begin(AD1950) .
End(Fifties) = End(AD1959) .
Section 12.3. Events 449
Figure 12.2 Predicates on time intervals.
time
1801 1797
1789
Washington
Adams Jefferson
Figure 12.3 A schematic view of the object President(USA) for the first 15 years of its
existence.
12.3.3 Fluents and objects
Physical objects can be viewed as generalized events, in the sense that a physical object is
a chunk of space–time. For example, USA can be thought of as an event that began in,
say, 1776 as a union of 13 states and is still in progress today as a union of 50. We can
describe the changing properties of USA using state fluents, such as Population(USA). A
property of the USA that changes every four or eight years, barring mishaps, is its president.
One might propose that President(USA) is a logical term that denotes a different object
at different times. Unfortunately, this is not possible, because a term denotes exactly one
object in a given model structure. (The term President(USA, t) can denote different objects,
depending on the value of t, but our ontology keeps time indices separate from fluents.) The
450 Chapter 12. Knowledge Representation
only possibility is that President(USA) denotes a single object that consists of different
people at different times. It is the object that is George Washington from 1789 to 1797, John
Adams from 1797 to 1801, and so on, as in Figure 12.3. To say that George Washington was
president throughout 1790, we can write
T(Equals(President(USA), GeorgeWashington), AD1790) .
We use the function symbol Equals rather than the standard logical predicate =, because
we cannot have a predicate as an argument to T, and because the interpretation is not that
GeorgeWashington and President(USA) are logically identical in 1790; logical identity is
not something that can change over time. The identity is between the subevents of each object
that are defined by the period 1790.
12.4 MENTAL EVENTS AND MENTAL OBJECTS
The agents we have constructed so far have beliefs and can deduce new beliefs. Yet none
of them has any knowledge about beliefs or about deduction. Knowledge about one’s own
knowledge and reasoning processes is useful for controlling inference. For example, suppose
Alice asks “what is the square root of 1764” and Bob replies “I don’t know.” If Alice insists
“think harder,” Bob should realize that with some more thought, this question can in fact
be answered. On the other hand, if the question were “Is your mother sitting down right
now?” then Bob should realize that thinking harder is unlikely to help. Knowledge about
the knowledge of other agents is also important; Bob should realize that his mother knows
whether she is sitting or not, and that asking her would be a way to find out.
What we need is a model of the mental objects that are in someone’s head (or something’s knowledge base) and of the mental processes that manipulate those mental objects.
The model does not have to be detailed. We do not have to be able to predict how many
milliseconds it will take for a particular agent to make a deduction. We will be happy just to
be able to conclude that mother knows whether or not she is sitting.
We begin with the propositional attitudes that an agent can have toward mental ob- PROPOSITIONAL
ATTITUDE
jects: attitudes such as Believes, Knows, Wants, Intends, and Informs. The difficulty is
that these attitudes do not behave like “normal” predicates. For example, suppose we try to
assert that Lois knows that Superman can fly:
Knows(Lois, CanFly(Superman)).
One minor issue with this is that we normally think of CanFly(Superman) as a sentence, but
here it appears as a term. That issue can be patched up just be reifying CanFly(Superman);
making it a fluent. A more serious problem is that, if it is true that Superman is Clark Kent,
then we must conclude that Lois knows that Clark can fly:
(Superman = Clark) ∧ Knows(Lois, CanFly(Superman))
|= Knows(Lois, CanFly(Clark )).
This is a consequence of the fact that equality reasoning is built into logic. Normally that is
a good thing; if our agent knows that 2+2=4 and 4 < 5, then we want our agent to know
Section 12.4. Mental Events and Mental Objects 451
that 2+2 < 5. This property is called referential transparency—it doesn’t matter what REFERENTIAL
TRANSPARENCY
term a logic uses to refer to an object, what matters is the object that the term names. But for
propositional attitudes like believes and knows, we would like to have referential opacity—the
terms used do matter, because not all agents know which terms are co-referential.
MODAL LOGIC Modal logic is designed to address this problem. Regular logic is concerned with a single modality, the modality of truth, allowing us to express “P is true.” Modal logic includes
special modal operators that take sentences (rather than terms) as arguments. For example,
“A knows P” is represented with the notation KAP, where K is the modal operator for knowledge. It takes two arguments, an agent (written as the subscript) and a sentence. The syntax
of modal logic is the same as first-order logic, except that sentences can also be formed with
modal operators.
The semantics of modal logic is more complicated. In first-order logic a model contains a set of objects and an interpretation that maps each name to the appropriate object,
relation, or function. In modal logic we want to be able to consider both the possibility that
Superman’s secret identity is Clark and that it isn’t. Therefore, we will need a more comPOSSIBLE WORLD plicated model, one that consists of a collection of possible worlds rather than just one true
world. The worlds are connected in a graph by accessibility relations, one relation for each ACCESSIBILITY
RELATIONS
modal operator. We say that world w1 is accessible from world w0 with respect to the modal
operator KA if everything in w1 is consistent with what A knows in w0, and we write this
as Acc(KA, w0, w1). In diagrams such as Figure 12.4 we show accessibility as an arrow between possible worlds. As an example, in the real world, Bucharest is the capital of Romania,
but for an agent that did not know that, other possible worlds are accessible, including ones
where the capital of Romania is Sibiu or Sofia. Presumably a world where 2+2=5 would
not be accessible to any agent.
In general, a knowledge atom KAP is true in world w if and only if P is true in every
world accessible from w. The truth of more complex sentences is derived by recursive application of this rule and the normal rules of first-order logic. That means that modal logic can
be used to reason about nested knowledge sentences: what one agent knows about another
agent’s knowledge. For example, we can say that, even though Lois doesn’t know whether
Superman’s secret identity is Clark Kent, she does know that Clark knows:
KLois [KClark Identity(Superman, Clark ) ∨ KClark¬Identity(Superman, Clark )]
Figure 12.4 shows some possible worlds for this domain, with accessibility relations for Lois
and Superman.
In the TOP-LEFT diagram, it is common knowledge that Superman knows his own identity, and neither he nor Lois has seen the weather report. So in w0 the worlds w0 and w2 are
accessible to Superman; maybe rain is predicted, maybe not. For Lois all four worlds are accessible from each other; she doesn’t know anything about the report or if Clark is Superman.
But she does know that Superman knows whether he is Clark, because in every world that is
accessible to Lois, either Superman knows I, or he knows ¬I. Lois does not know which is
the case, but either way she knows Superman knows.
In the TOP-RIGHT diagram it is common knowledge that Lois has seen the weather
report. So in w4 she knows rain is predicted and in w6 she knows rain is not predicted.
452 Chapter 12. Knowledge Representation
(a) (b)
(c)
w0
: I,R
w2
: I,¬R w3
: ¬I,¬R
w1
: ¬I,R w4
: I,R
w6
: I,¬R w7
: ¬I,¬R
w5
: ¬I,R
w0
: I,R
w2
: I,¬R w3
: ¬I,¬R
w1
: ¬I,R
w4
: I,R w5
: ¬I,R
w6
: I,¬R w7
: ¬I,¬R
Figure 12.4 Possible worlds with accessibility relations KSuperman (solid arrows) and
KLois (dotted arrows). The proposition R means “the weather report for tomorrow is rain”
and I means “Superman’s secret identity is Clark Kent.” All worlds are accessible to themselves; the arrows from a world to itself are not shown.
Superman does not know the report, but he knows that Lois knows, because in every world
that is accessible to him, either she knows R or she knows ¬R.
In the BOTTOM diagram we represent the scenario where it is common knowledge that
Superman knows his identity, and Lois might or might not have seen the weather report. We
represent this by combining the two top scenarios, and adding arrows to show that Superman
does not know which scenario actually holds. Lois does know, so we don’t need to add any
arrows for her. In w0 Superman still knows I but not R, and now he does not know whether
Lois knows R. From what Superman knows, he might be in w0 or w2, in which case Lois
does not know whether R is true, or he could be in w4, in which case she knows R, or w6, in
which case she knows ¬R.
There are an infinite number of possible worlds, so the trick is to introduce just the ones
you need to represent what you are trying to model. A new possible world is needed to talk
about different possible facts (e.g., rain is predicted or not), or to talk about different states
of knowledge (e.g., does Lois know that rain is predicted). That means two possible worlds,
such as w4 and w0 in Figure 12.4, might have the same base facts about the world, but differ
in their accessibility relations, and therefore in facts about knowledge.
Modal logic solves some tricky issues with the interplay of quantifiers and knowledge.
The English sentence “Bond knows that someone is a spy” is ambiguous. The first reading is
Section 12.5. Reasoning Systems for Categories 453
that there is a particular someone who Bond knows is a spy; we can write this as
∃ x KBondSpy(x),
which in modal logic means that there is an x that, in all accessible worlds, Bond knows to
be a spy. The second reading is that Bond just knows that there is at least one spy:
KBond∃ x Spy(x).
The modal logic interpretation is that in each accessible world there is an x that is a spy, but
it need not be the same x in each world.
Now that we have a modal operator for knowledge, we can write axioms for it. First,
we can say that agents are able to draw deductions; if an agent knows P and knows that P
implies Q, then the agent knows Q:
(KaP ∧ Ka(P ⇒ Q)) ⇒ KaQ .
From this (and a few other rules about logical identities) we can establish that KA(P ∨ ¬P)
is a tautology; every agent knows every proposition P is either true or false. On the other
hand, (KAP) ∨ (KA¬P) is not a tautology; in general, there will be lots of propositions that
an agent does not know to be true and does not know to be false.
It is said (going back to Plato) that knowledge is justified true belief. That is, if it is
true, if you believe it, and if you have an unassailably good reason, then you know it. That
means that if you know something, it must be true, and we have the axiom:
KaP ⇒ P .
Furthermore, logical agents should be able to introspect on their own knowledge. If they
know something, then they know that they know it:
KaP ⇒ Ka(KaP) .
We can define similar axioms for belief (often denoted by B) and other modalities. However,
one problem with the modal logic approach is that it assumes logical omniscience on the LOGICAL
OMNISCIENCE
part of agents. That is, if an agent knows a set of axioms, then it knows all consequences of
those axioms. This is on shaky ground even for the somewhat abstract notion of knowledge,
but it seems even worse for belief, because belief has more connotation of referring to things
that are physically represented in the agent, not just potentially derivable. There have been
attempts to define a form of limited rationality for agents; to say that agents believe those
assertions that can be derived with the application of no more than k reasoning steps, or no
more than s seconds of computation. These attempts have been generally unsatisfactory.
12.5 REASONING SYSTEMS FOR CATEGORIES
Categories are the primary building blocks of large-scale knowledge representation schemes.
This section describes systems specially designed for organizing and reasoning with categories. There are two closely related families of systems: semantic networks provide graphical aids for visualizing a knowledge base and efficient algorithms for inferring properties
454 Chapter 12. Knowledge Representation
of an object on the basis of its category membership; and description logics provide a formal language for constructing and combining category definitions and efficient algorithms
for deciding subset and superset relationships between categories.
12.5.1 Semantic networks
In 1909, Charles S. Peirce proposed a graphical notation of nodes and edges called existential
graphs that he called “the logic of the future.” Thus began a long-running debate between EXISTENTIAL
GRAPHS
advocates of “logic” and advocates of “semantic networks.” Unfortunately, the debate obscured the fact that semantics networks—at least those with well-defined semantics—are a
form of logic. The notation that semantic networks provide for certain kinds of sentences
is often more convenient, but if we strip away the “human interface” issues, the underlying
concepts—objects, relations, quantification, and so on—are the same.
There are many variants of semantic networks, but all are capable of representing individual objects, categories of objects, and relations among objects. A typical graphical notation displays object or category names in ovals or boxes, and connects them with labeled
links. For example, Figure 12.5 has a MemberOf link between Mary and FemalePersons,
corresponding to the logical assertion Mary ∈FemalePersons ; similarly, the SisterOf link
between Mary and John corresponds to the assertion SisterOf (Mary, John). We can connect categories using SubsetOf links, and so on. It is such fun drawing bubbles and arrows
that one can get carried away. For example, we know that persons have female persons as
mothers, so can we draw a HasMother link from Persons to FemalePersons? The answer
is no, because HasMother is a relation between a person and his or her mother, and categories
do not have mothers.5
For this reason, we have used a special notation—the double-boxed link—in Figure 12.5.
This link asserts that
∀ x x∈Persons ⇒ [∀ y HasMother (x, y) ⇒ y ∈ FemalePersons] .
We might also want to assert that persons have two legs—that is,
∀ x x∈Persons ⇒ Legs(x, 2) .
As before, we need to be careful not to assert that a category has legs; the single-boxed link
in Figure 12.5 is used to assert properties of every member of a category.
The semantic network notation makes it convenient to perform inheritance reasoning
of the kind introduced in Section 12.2. For example, by virtue of being a person, Mary inherits
the property of having two legs. Thus, to find out how many legs Mary has, the inheritance
algorithm follows the MemberOf link from Mary to the category she belongs to, and then
follows SubsetOf links up the hierarchy until it finds a category for which there is a boxed
Legs link—in this case, the Persons category. The simplicity and efficiency of this inference
5 Several early systems failed to distinguish between properties of members of a category and properties of the
category as a whole. This can lead directly to inconsistencies, as pointed out by Drew McDermott (1976) in his
article “Artificial Intelligence Meets Natural Stupidity.” Another common problem was the use of IsA links for
both subset and membership relations, in correspondence with English usage: “a cat is a mammal” and “Fifi is a
cat.” See Exercise 12.22 for more on these issues.
Section 12.5. Reasoning Systems for Categories 455
Mammals
Mary John
Persons
Male
Persons
Female
Persons
1
2
SubsetOf
SubsetOf SubsetOf
MemberOf MemberOf
SisterOf Legs
HasMother Legs
Figure 12.5 A semantic network with four objects (John, Mary, 1, and 2) and four categories. Relations are denoted by labeled links.
MemberOf
FlyEvents
Fly17
Shankar NewYork NewDelhi Yesterday
Agent
Origin Destination
During
Figure 12.6 A fragment of a semantic network showing the representation of the logical
assertion Fly(Shankar , NewYork, NewDelhi, Yesterday).
mechanism, compared with logical theorem proving, has been one of the main attractions of
semantic networks.
Inheritance becomes complicated when an object can belong to more than one category
or when a category can be a subset of more than one other category; this is called multiple inheritance. In such cases, the inheritance algorithm might find two or more conflicting values MULTIPLE
INHERITANCE
answering the query. For this reason, multiple inheritance is banned in some object-oriented
programming (OOP) languages, such as Java, that use inheritance in a class hierarchy. It is
usually allowed in semantic networks, but we defer discussion of that until Section 12.6.
The reader might have noticed an obvious drawback of semantic network notation, compared to first-order logic: the fact that links between bubbles represent only binary relations.
For example, the sentence Fly(Shankar , NewYork, NewDelhi, Yesterday) cannot be asserted directly in a semantic network. Nonetheless, we can obtain the effect of n-ary assertions by reifying the proposition itself as an event belonging to an appropriate event category.
Figure 12.6 shows the semantic network structure for this particular event. Notice that the
restriction to binary relations forces the creation of a rich ontology of reified concepts.
Reification of propositions makes it possible to represent every ground, function-free
atomic sentence of first-order logic in the semantic network notation. Certain kinds of univer-
456 Chapter 12. Knowledge Representation
sally quantified sentences can be asserted using inverse links and the singly boxed and doubly
boxed arrows applied to categories, but that still leaves us a long way short of full first-order
logic. Negation, disjunction, nested function symbols, and existential quantification are all
missing. Now it is possible to extend the notation to make it equivalent to first-order logic—as
in Peirce’s existential graphs—but doing so negates one of the main advantages of semantic
networks, which is the simplicity and transparency of the inference processes. Designers can
build a large network and still have a good idea about what queries will be efficient, because
(a) it is easy to visualize the steps that the inference procedure will go through and (b) in some
cases the query language is so simple that difficult queries cannot be posed. In cases where
the expressive power proves to be too limiting, many semantic network systems provide for
procedural attachment to fill in the gaps. Procedural attachment is a technique whereby
a query about (or sometimes an assertion of) a certain relation results in a call to a special
procedure designed for that relation rather than a general inference algorithm.
One of the most important aspects of semantic networks is their ability to represent
DEFAULT VALUE default values for categories. Examining Figure 12.5 carefully, one notices that John has one
leg, despite the fact that he is a person and all persons have two legs. In a strictly logical KB,
this would be a contradiction, but in a semantic network, the assertion that all persons have
two legs has only default status; that is, a person is assumed to have two legs unless this is
contradicted by more specific information. The default semantics is enforced naturally by the
inheritance algorithm, because it follows links upwards from the object itself (John in this
OVERRIDING case) and stops as soon as it finds a value. We say that the default is overridden by the more
specific value. Notice that we could also override the default number of legs by creating a
category of OneLeggedPersons, a subset of Persons of which John is a member.
We can retain a strictly logical semantics for the network if we say that the Legs assertion for Persons includes an exception for John:
∀ x x∈Persons ∧ x = John ⇒ Legs(x, 2) .
For a fixed network, this is semantically adequate but will be much less concise than the
network notation itself if there are lots of exceptions. For a network that will be updated with
more assertions, however, such an approach fails—we really want to say that any persons as
yet unknown with one leg are exceptions too. Section 12.6 goes into more depth on this issue
and on default reasoning in general.
12.5.2 Description logics
The syntax of first-order logic is designed to make it easy to say things about objects. DeDESCRIPTION LOGIC scription logics are notations that are designed to make it easier to describe definitions and
properties of categories. Description logic systems evolved from semantic networks in response to pressure to formalize what the networks mean while retaining the emphasis on
taxonomic structure as an organizing principle.
SUBSUMPTION The principal inference tasks for description logics are subsumption (checking if one
CLASSIFICATION category is a subset of another by comparing their definitions) and classification (checking
whether an object belongs to a category).. Some systems also include consistency of a category definition—whether the membership criteria are logically satisfiable.
Section 12.5. Reasoning Systems for Categories 457
Concept → Thing | ConceptName
| And(Concept,...)
| All(RoleName, Concept)
| AtLeast(Integer , RoleName)
| AtMost(Integer , RoleName)
| Fills(RoleName,IndividualName,...)
| SameAs(Path,Path)
| OneOf(IndividualName,...)
Path → [RoleName,...]
Figure 12.7 The syntax of descriptions in a subset of the CLASSIC language.
The CLASSIC language (Borgida et al., 1989) is a typical description logic. The syntax
of CLASSIC descriptions is shown in Figure 12.7.6 For example, to say that bachelors are
unmarried adult males we would write
Bachelor = And(Unmarried, Adult, Male) .
The equivalent in first-order logic would be
Bachelor (x) ⇔ Unmarried(x) ∧ Adult(x) ∧ Male(x) .
Notice that the description logic has an an algebra of operations on predicates, which of
course we can’t do in first-order logic. Any description in CLASSIC can be translated into an
equivalent first-order sentence, but some descriptions are more straightforward in CLASSIC.
For example, to describe the set of men with at least three sons who are all unemployed
and married to doctors, and at most two daughters who are all professors in physics or math
departments, we would use
And(Man, AtLeast(3, Son), AtMost(2, Daughter ),
All(Son, And(Unemployed, Married, All(Spouse, Doctor ))),
All(Daughter , And(Professor ,Fills(Department,Physics, Math)))) .
We leave it as an exercise to translate this into first-order logic.
Perhaps the most important aspect of description logics is their emphasis on tractability
of inference. A problem instance is solved by describing it and then asking if it is subsumed
by one of several possible solution categories. In standard first-order logic systems, predicting
the solution time is often impossible. It is frequently left to the user to engineer the representation to detour around sets of sentences that seem to be causing the system to take several
weeks to solve a problem. The thrust in description logics, on the other hand, is to ensure that
subsumption-testing can be solved in time polynomial in the size of the descriptions.7
6 Notice that the language does not allow one to simply state that one concept, or category, is a subset of
another. This is a deliberate policy: subsumption between categories must be derivable from some aspects of the
descriptions of the categories. If not, then something is missing from the descriptions.
7 CLASSIC provides efficient subsumption testing in practice, but the worst-case run time is exponential.
458 Chapter 12. Knowledge Representation
This sounds wonderful in principle, until one realizes that it can only have one of two
consequences: either hard problems cannot be stated at all, or they require exponentially
large descriptions! However, the tractability results do shed light on what sorts of constructs
cause problems and thus help the user to understand how different representations behave.
For example, description logics usually lack negation and disjunction. Each forces firstorder logical systems to go through a potentially exponential case analysis in order to ensure
completeness. CLASSIC allows only a limited form of disjunction in the Fills and OneOf
constructs, which permit disjunction over explicitly enumerated individuals but not over descriptions. With disjunctive descriptions, nested definitions can lead easily to an exponential
number of alternative routes by which one category can subsume another.
12.6 REASONING WITH DEFAULT INFORMATION
In the preceding section, we saw a simple example of an assertion with default status: people
have two legs. This default can be overridden by more specific information, such as that
Long John Silver has one leg. We saw that the inheritance mechanism in semantic networks
implements the overriding of defaults in a simple and natural way. In this section, we study
defaults more generally, with a view toward understanding the semantics of defaults rather
than just providing a procedural mechanism.
12.6.1 Circumscription and default logic
We have seen two examples of reasoning processes that violate the monotonicity property of
logic that was proved in Chapter 7.8 In this chapter we saw that a property inherited by all
members of a category in a semantic network could be overridden by more specific information for a subcategory. In Section 9.4.5, we saw that under the closed-world assumption, if a
proposition α is not mentioned in KB then KB |= ¬α, but KB ∧ α |= α.
Simple introspection suggests that these failures of monotonicity are widespread in
commonsense reasoning. It seems that humans often “jump to conclusions.” For example,
when one sees a car parked on the street, one is normally willing to believe that it has four
wheels even though only three are visible. Now, probability theory can certainly provide a
conclusion that the fourth wheel exists with high probability, yet, for most people, the possibility of the car’s not having four wheels does not arise unless some new evidence presents
itself. Thus, it seems that the four-wheel conclusion is reached by default, in the absence of
any reason to doubt it. If new evidence arrives—for example, if one sees the owner carrying
a wheel and notices that the car is jacked up—then the conclusion can be retracted. This kind
NONMONOTONICITY of reasoning is said to exhibit nonmonotonicity, because the set of beliefs does not grow
monotonically over time as new evidence arrives. Nonmonotonic logics have been devised NONMONOTONIC
LOGIC
with modified notions of truth and entailment in order to capture such behavior. We will look
at two such logics that have been studied extensively: circumscription and default logic.
8 Recall that monotonicity requires all entailed sentences to remain entailed after new sentences are added to the
KB. That is, if KB |= α then KB ∧ β |= α.
Section 12.6. Reasoning with Default Information 459
CIRCUMSCRIPTION Circumscription can be seen as a more powerful and precise version of the closedworld assumption. The idea is to specify particular predicates that are assumed to be “as false
as possible”—that is, false for every object except those for which they are known to be true.
For example, suppose we want to assert the default rule that birds fly. We would introduce a
predicate, say Abnormal 1(x), and write
Bird(x) ∧ ¬Abnormal 1(x) ⇒ Flies(x) .
If we say that Abnormal 1 is to be circumscribed, a circumscriptive reasoner is entitled to
assume ¬Abnormal 1(x) unless Abnormal 1(x) is known to be true. This allows the conclusion Flies(Tweety) to be drawn from the premise Bird(Tweety), but the conclusion no
longer holds if Abnormal 1(Tweety) is asserted.
Circumscription can be viewed as an example of a model preference logic. In such MODEL
PREFERENCE
logics, a sentence is entailed (with default status) if it is true in all preferred models of the KB,
as opposed to the requirement of truth in all models in classical logic. For circumscription,
one model is preferred to another if it has fewer abnormal objects.9 Let us see how this idea
works in the context of multiple inheritance in semantic networks. The standard example for
which multiple inheritance is problematic is called the “Nixon diamond.” It arises from the
observation that Richard Nixon was both a Quaker (and hence by default a pacifist) and a
Republican (and hence by default not a pacifist). We can write this as follows:
Republican(Nixon) ∧ Quaker(Nixon) .
Republican(x) ∧ ¬Abnormal 2(x) ⇒ ¬Pacifist(x) .
Quaker(x) ∧ ¬Abnormal 3(x) ⇒ Pacifist(x) .
If we circumscribe Abnormal 2 and Abnormal 3, there are two preferred models: one in
which Abnormal 2(Nixon) and Pacifist(Nixon) hold and one in which Abnormal 3(Nixon)
and ¬Pacifist(Nixon) hold. Thus, the circumscriptive reasoner remains properly agnostic as
to whether Nixon was a pacifist. If we wish, in addition, to assert that religious beliefs take
precedence over political beliefs, we can use a formalism called prioritized circumscription PRIORITIZED
CIRCUMSCRIPTION
to give preference to models where Abnormal 3 is minimized.
DEFAULT LOGIC Default logic is a formalism in which default rules can be written to generate continDEFAULT RULES gent, nonmonotonic conclusions. A default rule looks like this:
Bird(x) : Flies(x)/Flies(x) .
This rule means that if Bird(x) is true, and if Flies(x) is consistent with the knowledge base,
then Flies(x) may be concluded by default. In general, a default rule has the form
P : J1,...,Jn/C
where P is called the prerequisite, C is the conclusion, and Ji are the justifications—if any
one of them can be proven false, then the conclusion cannot be drawn. Any variable that
9 For the closed-world assumption, one model is preferred to another if it has fewer true atoms—that is, preferred
models are minimal models. There is a natural connection between the closed-world assumption and definiteclause KBs, because the fixed point reached by forward chaining on definite-clause KBs is the unique minimal
model. See page 258 for more on this point.
460 Chapter 12. Knowledge Representation
appears in Ji or C must also appear in P. The Nixon-diamond example can be represented
in default logic with one fact and two default rules:
Republican(Nixon) ∧ Quaker(Nixon) .
Republican(x) : ¬Pacifist(x)/¬Pacifist(x) .
Quaker(x) : Pacifist(x)/Pacifist(x) .
EXTENSION To interpret what the default rules mean, we define the notion of an extension of a default
theory to be a maximal set of consequences of the theory. That is, an extension S consists
of the original known facts and a set of conclusions from the default rules, such that no
additional conclusions can be drawn from S and the justifications of every default conclusion
in S are consistent with S. As in the case of the preferred models in circumscription, we have
two possible extensions for the Nixon diamond: one wherein he is a pacifist and one wherein
he is not. Prioritized schemes exist in which some default rules can be given precedence over
others, allowing some ambiguities to be resolved.
Since 1980, when nonmonotonic logics were first proposed, a great deal of progress
has been made in understanding their mathematical properties. There are still unresolved
questions, however. For example, if “Cars have four wheels” is false, what does it mean
to have it in one’s knowledge base? What is a good set of default rules to have? If we
cannot decide, for each rule separately, whether it belongs in our knowledge base, then we
have a serious problem of nonmodularity. Finally, how can beliefs that have default status be
used to make decisions? This is probably the hardest issue for default reasoning. Decisions
often involve tradeoffs, and one therefore needs to compare the strengths of belief in the
outcomes of different actions, and the costs of making a wrong decision. In cases where the
same kinds of decisions are being made repeatedly, it is possible to interpret default rules
as “threshold probability” statements. For example, the default rule “My brakes are always
OK” really means “The probability that my brakes are OK, given no other information, is
sufficiently high that the optimal decision is for me to drive without checking them.” When
the decision context changes—for example, when one is driving a heavily laden truck down a
steep mountain road—the default rule suddenly becomes inappropriate, even though there is
no new evidence of faulty brakes. These considerations have led some researchers to consider
how to embed default reasoning within probability theory or utility theory.
12.6.2 Truth maintenance systems
We have seen that many of the inferences drawn by a knowledge representation system will
have only default status, rather than being absolutely certain. Inevitably, some of these inferred facts will turn out to be wrong and will have to be retracted in the face of new information. This process is called belief revision.
10 BELIEF REVISION Suppose that a knowledge base KB contains
a sentence P—perhaps a default conclusion recorded by a forward-chaining algorithm, or
perhaps just an incorrect assertion—and we want to execute TELL(KB, ¬P). To avoid creating a contradiction, we must first execute RETRACT(KB, P). This sounds easy enough.
10 Belief revision is often contrasted with belief update, which occurs when a knowledge base is revised to reflect
a change in the world rather than new information about a fixed world. Belief update combines belief revision
with reasoning about time and change; it is also related to the process of filtering described in Chapter 15.
Section 12.6. Reasoning with Default Information 461
Problems arise, however, if any additional sentences were inferred from P and asserted in
the KB. For example, the implication P ⇒ Q might have been used to add Q. The obvious
“solution”—retracting all sentences inferred from P—fails because such sentences may have
other justifications besides P. For example, if R and R ⇒ Q are also in the KB, then Q
does not have to be removed after all. Truth maintenance systems, or TMSs, are designed TRUTH
MAINTENANCE
SYSTEM
to handle exactly these kinds of complications.
One simple approach to truth maintenance is to keep track of the order in which sentences are told to the knowledge base by numbering them from P1 to Pn. When the call
RETRACT(KB, Pi) is made, the system reverts to the state just before Pi was added, thereby
removing both Pi and any inferences that were derived from Pi. The sentences Pi+1 through
Pn can then be added again. This is simple, and it guarantees that the knowledge base will
be consistent, but retracting Pi requires retracting and reasserting n − i sentences as well as
undoing and redoing all the inferences drawn from those sentences. For systems to which
many facts are being added—such as large commercial databases—this is impractical.
JTMS A more efficient approach is the justification-based truth maintenance system, or JTMS.
JUSTIFICATION In a JTMS, each sentence in the knowledge base is annotated with a justification consisting
of the set of sentences from which it was inferred. For example, if the knowledge base
already contains P ⇒ Q, then TELL(P) will cause Q to be added with the justification
{P, P ⇒ Q}. In general, a sentence can have any number of justifications. Justifications make retraction efficient. Given the call RETRACT(P), the JTMS will delete exactly
those sentences for which P is a member of every justification. So, if a sentence Q had
the single justification {P, P ⇒ Q}, it would be removed; if it had the additional justification {P, P ∨ R ⇒ Q}, it would still be removed; but if it also had the justification
{R, P ∨R ⇒ Q}, then it would be spared. In this way, the time required for retraction of P
depends only on the number of sentences derived from P rather than on the number of other
sentences added since P entered the knowledge base.
The JTMS assumes that sentences that are considered once will probably be considered
again, so rather than deleting a sentence from the knowledge base entirely when it loses
all justifications, we merely mark the sentence as being out of the knowledge base. If a
subsequent assertion restores one of the justifications, then we mark the sentence as being
back in. In this way, the JTMS retains all the inference chains that it uses and need not
rederive sentences when a justification becomes valid again.
In addition to handling the retraction of incorrect information, TMSs can be used to
speed up the analysis of multiple hypothetical situations. Suppose, for example, that the
Romanian Olympic Committee is choosing sites for the swimming, athletics, and equestrian events at the 2048 Games to be held in Romania. For example, let the first hypothesis be Site(Swimming,Pitesti), Site(Athletics, Bucharest), and Site(Equestrian, Arad).
A great deal of reasoning must then be done to work out the logistical consequences and
hence the desirability of this selection. If we want to consider Site(Athletics, Sibiu) instead, the TMS avoids the need to start again from scratch. Instead, we simply retract
Site(Athletics, Bucharest) and assert Site(Athletics, Sibiu) and the TMS takes care of the
necessary revisions. Inference chains generated from the choice of Bucharest can be reused
with Sibiu, provided that the conclusions are the same.
462 Chapter 12. Knowledge Representation
ATMS An assumption-based truth maintenance system, or ATMS, makes this type of contextswitching between hypothetical worlds particularly efficient. In a JTMS, the maintenance of
justifications allows you to move quickly from one state to another by making a few retractions and assertions, but at any time only one state is represented. An ATMS represents all the
states that have ever been considered at the same time. Whereas a JTMS simply labels each
sentence as being in or out, an ATMS keeps track, for each sentence, of which assumptions
would cause the sentence to be true. In other words, each sentence has a label that consists of
a set of assumption sets. The sentence holds just in those cases in which all the assumptions
in one of the assumption sets hold.
EXPLANATION Truth maintenance systems also provide a mechanism for generating explanations.
Technically, an explanation of a sentence P is a set of sentences E such that E entails P.
If the sentences in E are already known to be true, then E simply provides a sufficient baASSUMPTION sis for proving that P must be the case. But explanations can also include assumptions—
sentences that are not known to be true, but would suffice to prove P if they were true. For
example, one might not have enough information to prove that one’s car won’t start, but a
reasonable explanation might include the assumption that the battery is dead. This, combined
with knowledge of how cars operate, explains the observed nonbehavior. In most cases, we
will prefer an explanation E that is minimal, meaning that there is no proper subset of E that
is also an explanation. An ATMS can generate explanations for the “car won’t start” problem
by making assumptions (such as “gas in car” or “battery dead”) in any order we like, even if
some assumptions are contradictory. Then we look at the label for the sentence “car won’t
start” to read off the sets of assumptions that would justify the sentence.
The exact algorithms used to implement truth maintenance systems are a little complicated, and we do not cover them here. The computational complexity of the truth maintenance
problem is at least as great as that of propositional inference—that is, NP-hard. Therefore,
you should not expect truth maintenance to be a panacea. When used carefully, however, a
TMS can provide a substantial increase in the ability of a logical system to handle complex
environments and hypotheses.
12.7 THE INTERNET SHOPPING WORLD
In this final section we put together all we have learned to encode knowledge for a shopping
research agent that helps a buyer find product offers on the Internet. The shopping agent is
given a product description by the buyer and has the task of producing a list of Web pages
that offer such a product for sale, and ranking which offers are best. In some cases the
buyer’s product description will be precise, as in Canon Rebel XTi digital camera, and the
task is then to find the store(s) with the best offer. In other cases the description will be only
partially specified, as in digital camera for under $300, and the agent will have to compare
different products.
The shopping agent’s environment is the entire World Wide Web in its full complexity—
not a toy simulated environment. The agent’s percepts are Web pages, but whereas a human
Section 12.7. The Internet Shopping World 463
Example Online Store
Select from our fine line of products:
• Computers
• Cameras
• Books
• Videos
• Music
<h1>Example Online Store</h1>
<i>Select</i> from our fine line of products:
<ul>
<li> <a href="http://example.com/compu">Computers</a>
<li> <a href="http://example.com/camer">Cameras</a>
<li> <a href="http://example.com/books">Books</a>
<li> <a href="http://example.com/video">Videos</a>
<li> <a href="http://example.com/music">Music</a>
</ul>
Figure 12.8 A Web page from a generic online store in the form perceived by the human
user of a browser (top), and the corresponding HTML string as perceived by the browser or
the shopping agent (bottom). In HTML, characters between < and > are markup directives
that specify how the page is displayed. For example, the string <i>Select</i> means
to switch to italic font, display the word Select, and then end the use of italic font. A page
identifier such as http://example.com/books is called a uniform resource locator
(URL). The markup <a href="url">Books</a> means to create a hypertext link to url
with the anchor text Books.
Web user would see pages displayed as an array of pixels on a screen, the shopping agent
will perceive a page as a character string consisting of ordinary words interspersed with formatting commands in the HTML markup language. Figure 12.8 shows a Web page and a
corresponding HTML character string. The perception problem for the shopping agent involves extracting useful information from percepts of this kind.
Clearly, perception on Web pages is easier than, say, perception while driving a taxi in
Cairo. Nonetheless, there are complications to the Internet perception task. The Web page in
Figure 12.8 is simple compared to real shopping sites, which may include CSS, cookies, Java,
Javascript, Flash, robot exclusion protocols, malformed HTML, sound files, movies, and text
that appears only as part of a JPEG image. An agent that can deal with all of the Internet is
almost as complex as a robot that can move in the real world. We concentrate on a simple
agent that ignores most of these complications.
The agent’s first task is to collect product offers that are relevant to a query. If the query
is “laptops,” then a Web page with a review of the latest high-end laptop would be relevant,
but if it doesn’t provide a way to buy, it isn’t an offer. For now, we can say a page is an offer
if it contains the words “buy” or “price” or “add to cart” within an HTML link or form on the
464 Chapter 12. Knowledge Representation
page. For example, if the page contains a string of the form “<a ... add to cart ... </a”
then it is an offer. This could be represented in first-order logic, but it is more straightforward
to encode it into program code. We show how to do more sophisticated information extraction
in Section 22.4.
12.7.1 Following links
The strategy is to start at the home page of an online store and consider all pages that can be
reached by following relevant links.11 The agent will have knowledge of a number of stores,
for example:
Amazon ∈ OnlineStores ∧ Homepage(Amazon, “amazon.com”) .
Ebay ∈ OnlineStores ∧ Homepage(Ebay, “ebay.com”) .
ExampleStore ∈ OnlineStores ∧ Homepage(ExampleStore, “example.com”) .
These stores classify their goods into product categories, and provide links to the major categories from their home page. Minor categories can be reached through a chain of relevant
links, and eventually we will reach offers. In other words, a page is relevant to the query if it
can be reached by a chain of zero or more relevant category links from a store’s home page,
and then from one more link to the product offer. We can define relevance:
Relevant(page, query) ⇔
∃ store, home store ∈ OnlineStores ∧ Homepage(store, home)
∧ ∃ url, url 2 RelevantChain(home, url 2, query) ∧ Link(url 2, url)
∧ page = Contents(url) .
Here the predicate Link(from,to) means that there is a hyperlink from the from URL to
the to URL. To define what counts as a RelevantChain, we need to follow not just any old
hyperlinks, but only those links whose associated anchor text indicates that the link is relevant
to the product query. For this, we use LinkText(from,to,text) to mean that there is a link
between from and to with text as the anchor text. A chain of links between two URLs, start
and end, is relevant to a description d if the anchor text of each link is a relevant category
name for d. The existence of the chain itself is determined by a recursive definition, with the
empty chain (start = end) as the base case:
RelevantChain(start, end, query) ⇔ (start = end)
∨ (∃ u,text LinkText(start, u,text) ∧ RelevantCategoryName(query,text)
∧ RelevantChain(u, end, query)) .
Now we must define what it means for text to be a RelevantCategoryName for query.
First, we need to relate strings to the categories they name. This is done using the predicate
Name(s, c), which says that string s is a name for category c—for example, we might assert
that Name(“laptops”, LaptopComputers ). Some more examples of the Name predicate
appear in Figure 12.9(b). Next, we define relevance. Suppose that query is “laptops.” Then
RelevantCategoryName(query,text) is true when one of the following holds:
• The text and query name the same category—e.g., “notebooks” and “laptops.”
11 An alternative to the link-following strategy is to use an Internet search engine; the technology behind Internet
search, information retrieval, will be covered in Section 22.3.
Section 12.7. The Internet Shopping World 465
Books ⊂ Products
MusicRecordings ⊂ Products
MusicCDs ⊂ MusicRecordings
Electronics ⊂ Products
DigitalCameras ⊂ Electronics
StereoEquipment ⊂ Electronics
Computers ⊂ Electronics
DesktopComputers ⊂ Computers
LaptopComputers ⊂ Computers
...
Name(“books”, Books)
Name(“music”, MusicRecordings)
Name(“CDs”, MusicCDs)
Name(“electronics”,Electronics)
Name(“digital cameras”, DigitalCameras )
Name(“stereos”, StereoEquipment)
Name(“computers”, Computers)
Name(“desktops”, DesktopComputers)
Name(“laptops”, LaptopComputers )
Name(“notebooks”, LaptopComputers)
... (a) (b)
Figure 12.9 (a) Taxonomy of product categories. (b) Names for those categories.
• The text names a supercategory such as “computers.”
• The text names a subcategory such as “ultralight notebooks.”
The logical definition of RelevantCategoryName is as follows:
RelevantCategoryName(query,text) ⇔
∃ c1, c2 Name(query, c1) ∧ Name(text, c2) ∧ (c1 ⊆ c2 ∨ c2 ⊆ c1) . (12.1)
Otherwise, the anchor text is irrelevant because it names a category outside this line, such as
“clothes” or “lawn & garden.”
To follow relevant links, then, it is essential to have a rich hierarchy of product categories. The top part of this hierarchy might look like Figure 12.9(a). It will not be feasible to
list all possible shopping categories, because a buyer could always come up with some new
desire and manufacturers will always come out with new products to satisfy them (electric
kneecap warmers?). Nonetheless, an ontology of about a thousand categories will serve as a
very useful tool for most buyers.
In addition to the product hierarchy itself, we also need to have a rich vocabulary of
names for categories. Life would be much easier if there were a one-to-one correspondence between categories and the character strings that name them. We have already seen
the problem of synonymy—two names for the same category, such as “laptop computers”
and “laptops.” There is also the problem of ambiguity—one name for two or more different
categories. For example, if we add the sentence
Name(“CDs”, CertificatesOfDeposit)
to the knowledge base in Figure 12.9(b), then “CDs” will name two different categories.
Synonymy and ambiguity can cause a significant increase in the number of paths that
the agent has to follow, and can sometimes make it difficult to determine whether a given
page is indeed relevant. A much more serious problem is the very broad range of descriptions
that a user can type and category names that a store can use. For example, the link might say
“laptop” when the knowledge base has only “laptops” or the user might ask for “a computer
466 Chapter 12. Knowledge Representation
I can fit on the tray table of an economy-class airline seat.” It is impossible to enumerate in
advance all the ways a category can be named, so the agent will have to be able to do additional reasoning in some cases to determine if the Name relation holds. In the worst case, this
requires full natural language understanding, a topic that we will defer to Chapter 22. In practice, a few simple rules—such as allowing “laptop” to match a category named “laptops”—go
a long way. Exercise 12.10 asks you to develop a set of such rules after doing some research
into online stores.
Given the logical definitions from the preceding paragraphs and suitable knowledge
bases of product categories and naming conventions, are we ready to apply an inference
algorithm to obtain a set of relevant offers for our query? Not quite! The missing element
is the Contents(url) function, which refers to the HTML page at a given URL. The agent
doesn’t have the page contents of every URL in its knowledge base; nor does it have explicit
rules for deducing what those contents might be. Instead, we can arrange for the right HTTP
procedure to be executed whenever a subgoal involves the Contents function. In this way, it
appears to the inference engine as if the entire Web is inside the knowledge base. This is an
example of a general technique called procedural attachment, whereby particular predicates PROCEDURAL
ATTACHMENT
and functions can be handled by special-purpose methods.
12.7.2 Comparing offers
Let us assume that the reasoning processes of the preceding section have produced a set of
offer pages for our “laptops” query. To compare those offers, the agent must extract the relevant information—price, speed, disk size, weight, and so on—from the offer pages. This can
be a difficult task with real Web pages, for all the reasons mentioned previously. A common
WRAPPER way of dealing with this problem is to use programs called wrappers to extract information
from a page. The technology of information extraction is discussed in Section 22.4. For
now we assume that wrappers exist, and when given a page and a knowledge base, they add
assertions to the knowledge base. Typically, a hierarchy of wrappers would be applied to a
page: a very general one to extract dates and prices, a more specific one to extract attributes
for computer-related products, and if necessary a site-specific one that knows the format of a
particular store. Given a page on the example.com site with the text
IBM ThinkBook 970. Our price: $399.00
followed by various technical specifications, we would like a wrapper to extract information
such as the following:
∃ c, offer c∈ LaptopComputers ∧ offer ∈ProductOffers ∧
Manufacturer(c,IBM ) ∧ Model(c, ThinkBook970 ) ∧
ScreenSize(c,Inches(14)) ∧ ScreenType(c, ColorLCD) ∧
MemorySize(c, Gigabytes(2)) ∧ CPUSpeed(c, GHz (1.2)) ∧
OfferedProduct(offer , c) ∧ Store(offer , GenStore) ∧
URL(offer , “example.com/computers/34356.html”) ∧
Price(offer , $(399)) ∧ Date(offer , Today) .
This example illustrates several issues that arise when we take seriously the task of knowledge
engineering for commercial transactions. For example, notice that the price is an attribute of
Section 12.8. Summary 467
the offer, not the product itself. This is important because the offer at a given store may
change from day to day even for the same individual laptop; for some categories—such as
houses and paintings—the same individual object may even be offered simultaneously by
different intermediaries at different prices. There are still more complications that we have
not handled, such as the possibility that the price depends on the method of payment and on
the buyer’s qualifications for certain discounts. The final task is to compare the offers that
have been extracted. For example, consider these three offers:
A : 1.4 GHz CPU, 2GB RAM, 250 GB disk, $299 .
B : 1.2 GHz CPU, 4GB RAM, 350 GB disk, $500 .
C : 1.2 GHz CPU, 2GB RAM, 250 GB disk, $399 .
C is dominated by A; that is, A is cheaper and faster, and they are otherwise the same. In
general, X dominates Y if X has a better value on at least one attribute, and is not worse on
any attribute. But neither A nor B dominates the other. To decide which is better we need
to know how the buyer weighs CPU speed and price against memory and disk space. The
general topic of preferences among multiple attributes is addressed in Section 16.4; for now,
our shopping agent will simply return a list of all undominated offers that meet the buyer’s
description. In this example, both A and B are undominated. Notice that this outcome relies
on the assumption that everyone prefers cheaper prices, faster processors, and more storage.
Some attributes, such as screen size on a notebook, depend on the user’s particular preference
(portability versus visibility); for these, the shopping agent will just have to ask the user.
The shopping agent we have described here is a simple one; many refinements are
possible. Still, it has enough capability that with the right domain-specific knowledge it can
actually be of use to a shopper. Because of its declarative construction, it extends easily to
more complex applications. The main point of this section is to show that some knowledge
representation—in particular, the product hierarchy—is necessary for such an agent, and that
once we have some knowledge in this form, the rest follows naturally.
12.8 SUMMARY
By delving into the details of how one represents a variety of knowledge, we hope we have
given the reader a sense of how real knowledge bases are constructed and a feeling for the
interesting philosophical issues that arise. The major points are as follows:
• Large-scale knowledge representation requires a general-purpose ontology to organize
and tie together the various specific domains of knowledge.
• A general-purpose ontology needs to cover a wide variety of knowledge and should be
capable, in principle, of handling any domain.
• Building a large, general-purpose ontology is a significant challenge that has yet to be
fully realized, although current frameworks seem to be quite robust.
• We presented an upper ontology based on categories and the event calculus. We
covered categories, subcategories, parts, structured objects, measurements, substances,
events, time and space, change, and beliefs.
468 Chapter 12. Knowledge Representation
• Natural kinds cannot be defined completely in logic, but properties of natural kinds can
be represented.
• Actions, events, and time can be represented either in situation calculus or in more
expressive representations such as event calculus. Such representations enable an agent
to construct plans by logical inference.
• We presented a detailed analysis of the Internet shopping domain, exercising the general
ontology and showing how the domain knowledge can be used by a shopping agent.
• Special-purpose representation systems, such as semantic networks and description
logics, have been devised to help in organizing a hierarchy of categories. Inheritance
is an important form of inference, allowing the properties of objects to be deduced from
their membership in categories.
• The closed-world assumption, as implemented in logic programs, provides a simple
way to avoid having to specify lots of negative information. It is best interpreted as a
default that can be overridden by additional information.
• Nonmonotonic logics, such as circumscription and default logic, are intended to capture default reasoning in general.
• Truth maintenance systems handle knowledge updates and revisions efficiently.
BIBLIOGRAPHICAL AND HISTORICAL NOTES
Briggs (1985) claims that formal knowledge representation research began with classical Indian theorizing about the grammar of Shastric Sanskrit, which dates back to the first millennium B.C. In the West, the use of definitions of terms in ancient Greek mathematics can be
regarded as the earliest instance: Aristotle’s Metaphysics (literally, what comes after the book
on physics) is a near-synonym for Ontology. Indeed, the development of technical terminology in any field can be regarded as a form of knowledge representation.
Early discussions of representation in AI tended to focus on “problem representation”
rather than “knowledge representation.” (See, for example, Amarel’s (1968) discussion of the
Missionaries and Cannibals problem.) In the 1970s, AI emphasized the development of “expert systems” (also called “knowledge-based systems”) that could, if given the appropriate
domain knowledge, match or exceed the performance of human experts on narrowly defined
tasks. For example, the first expert system, DENDRAL (Feigenbaum et al., 1971; Lindsay
et al., 1980), interpreted the output of a mass spectrometer (a type of instrument used to analyze the structure of organic chemical compounds) as accurately as expert chemists. Although
the success of DENDRAL was instrumental in convincing the AI research community of the
importance of knowledge representation, the representational formalisms used in DENDRAL
are highly specific to the domain of chemistry. Over time, researchers became interested in
standardized knowledge representation formalisms and ontologies that could streamline the
process of creating new expert systems. In so doing, they ventured into territory previously
explored by philosophers of science and of language. The discipline imposed in AI by the
need for one’s theories to “work” has led to more rapid and deeper progress than was the case
Bibliographical and Historical Notes 469
when these problems were the exclusive domain of philosophy (although it has at times also
led to the repeated reinvention of the wheel).
The creation of comprehensive taxonomies or classifications dates back to ancient times.
Aristotle (384–322 B.C.) strongly emphasized classification and categorization schemes. His
Organon, a collection of works on logic assembled by his students after his death, included a
treatise called Categories in which he attempted to construct what we would now call an upper
ontology. He also introduced the notions of genus and species for lower-level classification.
Our present system of biological classification, including the use of “binomial nomenclature”
(classification via genus and species in the technical sense), was invented by the Swedish
biologist Carolus Linnaeus, or Carl von Linne (1707–1778). The problems associated with
natural kinds and inexact category boundaries have been addressed by Wittgenstein (1953),
Quine (1953), Lakoff (1987), and Schwartz (1977), among others.
Interest in larger-scale ontologies is increasing, as documented by the Handbook on
Ontologies (Staab, 2004). The OPENCYC project (Lenat and Guha, 1990; Matuszek et al.,
2006) has released a 150,000-concept ontology, with an upper ontology similar to the one in
Figure 12.1 as well as specific concepts like “OLED Display” and “iPhone,” which is a type
of “cellular phone,” which in turn is a type of “consumer electronics,” “phone,” “wireless
communication device,” and other concepts. The DBPEDIA project extracts structured data
from Wikipedia; specifically from Infoboxes: the boxes of attribute/value pairs that accompany many Wikipedia articles (Wu and Weld, 2008; Bizer et al., 2007). As of mid-2009,
DBPEDIA contains 2.6 million concepts, with about 100 facts per concept. The IEEE working group P1600.1 created the Suggested Upper Merged Ontology (SUMO) (Niles and Pease,
2001; Pease and Niles, 2002), which contains about 1000 terms in the upper ontology and
links to over 20,000 domain-specific terms. Stoffel et al. (1997) describe algorithms for efficiently managing a very large ontology. A survey of techniques for extracting knowledge
from Web pages is given by Etzioni et al. (2008).
On the Web, representation languages are emerging. RDF (Brickley and Guha, 2004)
allows for assertions to be made in the form of relational triples, and provides some means
for evolving the meaning of names over time. OWL (Smith et al., 2004) is a description logic
that supports inferences over these triples. So far, usage seems to be inversely proportional to
representational complexity: the traditional HTML and CSS formats account for over 99% of
Web content, followed by the simplest representation schemes, such as microformats (Khare,
2006) and RDFa (Adida and Birbeck, 2008), which use HTML and XHTML markup to
add attributes to literal text. Usage of sophisticated RDF and OWL ontologies is not yet
widespread, and the full vision of the Semantic Web (Berners-Lee et al., 2001) has not yet
been realized. The conferences on Formal Ontology in Information Systems (FOIS) contain
many interesting papers on both general and domain-specific ontologies.
The taxonomy used in this chapter was developed by the authors and is based in part
on their experience in the CYC project and in part on work by Hwang and Schubert (1993)
and Davis (1990, 2005). An inspirational discussion of the general project of commonsense
knowledge representation appears in Hayes’s (1978, 1985b) “Naive Physics Manifesto.”
Successful deep ontologies within a specific field include the Gene Ontology project
(Consortium, 2008) and CML, the Chemical Markup Language (Murray-Rust et al., 2003).
470 Chapter 12. Knowledge Representation
Doubts about the feasibility of a single ontology for all knowledge are expressed by
Doctorow (2001), Gruber (2004), Halevy et al. (2009), and Smith (2004), who states, “the
initial project of building one single ontology . . . has . . . largely been abandoned.”
The event calculus was introduced by Kowalski and Sergot (1986) to handle continuous
time, and there have been several variations (Sadri and Kowalski, 1995; Shanahan, 1997) and
overviews (Shanahan, 1999; Mueller, 2006). van Lambalgen and Hamm (2005) show how
the logic of events maps onto the language we use to talk about events. An alternative to the
event and situation calculi is the fluent calculus (Thielscher, 1999). James Allen introduced
time intervals for the same reason (Allen, 1984), arguing that intervals were much more natural than situations for reasoning about extended and concurrent events. Peter Ladkin (1986a,
1986b) introduced “concave” time intervals (intervals with gaps; essentially, unions of ordinary “convex” time intervals) and applied the techniques of mathematical abstract algebra to
time representation. Allen (1991) systematically investigates the wide variety of techniques
available for time representation; van Beek and Manchak (1996) analyze algorithms for temporal reasoning. There are significant commonalities between the event-based ontology given
in this chapter and an analysis of events due to the philosopher Donald Davidson (1980).
The histories in Pat Hayes’s (1985a) ontology of liquids and the chronicles in McDermott’s
(1985) theory of plans were also important influences on the field and this chapter.
The question of the ontological status of substances has a long history. Plato proposed
that substances were abstract entities entirely distinct from physical objects; he would say
MadeOf (Butter 3, Butter ) rather than Butter 3 ∈ Butter. This leads to a substance hierarchy in which, for example, UnsaltedButter is a more specific substance than Butter . The position adopted in this chapter, in which substances are categories of objects, was championed
by Richard Montague (1973). It has also been adopted in the CYC project. Copeland (1993)
mounts a serious, but not invincible, attack. The alternative approach mentioned in the chapter, in which butter is one object consisting of all buttery objects in the universe, was proposed
MEREOLOGY originally by the Polish logician Le´sniewski (1916). His mereology (the name is derived from
the Greek word for “part”) used the part–whole relation as a substitute for mathematical set
theory, with the aim of eliminating abstract entities such as sets. A more readable exposition
of these ideas is given by Leonard and Goodman (1940), and Goodman’s The Structure of
Appearance (1977) applies the ideas to various problems in knowledge representation. While
some aspects of the mereological approach are awkward—for example, the need for a separate inheritance mechanism based on part–whole relations—the approach gained the support
of Quine (1960). Harry Bunt (1985) has provided an extensive analysis of its use in knowledge representation. Casati and Varzi (1999) cover parts, wholes, and the spatial locations.
Mental objects have been the subject of intensive study in philosophy and AI. There
are three main approaches. The one taken in this chapter, based on modal logic and possible
worlds, is the classical approach from philosophy (Hintikka, 1962; Kripke, 1963; Hughes
and Cresswell, 1996). The book Reasoning about Knowledge (Fagin et al., 1995) provides a
thorough introduction. The second approach is a first-order theory in which mental objects
are fluents. Davis (2005) and Davis and Morgenstern (2005) describe this approach. It relies
on the possible-worlds formalism, and builds on work by Robert Moore (1980, 1985). The
SYNTACTIC THEORY third approach is a syntactic theory, in which mental objects are represented by character
Bibliographical and Historical Notes 471
strings. A string is just a complex term denoting a list of symbols, so CanFly(Clark ) can
be represented by the list of symbols [C, a, n, F, l, y,(, C, l, a, r, k,)]. The syntactic theory
of mental objects was first studied in depth by Kaplan and Montague (1960), who showed
that it led to paradoxes if not handled carefully. Ernie Davis (1990) provides an excellent
comparison of the syntactic and modal theories of knowledge.
The Greek philosopher Porphyry (c. 234–305 A.D.), commenting on Aristotle’s Categories, drew what might qualify as the first semantic network. Charles S. Peirce (1909)
developed existential graphs as the first semantic network formalism using modern logic.
Ross Quillian (1961), driven by an interest in human memory and language processing, initiated work on semantic networks within AI. An influential paper by Marvin Minsky (1975)
presented a version of semantic networks called frames; a frame was a representation of
an object or category, with attributes and relations to other objects or categories. The question of semantics arose quite acutely with respect to Quillian’s semantic networks (and those
of others who followed his approach), with their ubiquitous and very vague “IS-A links”
Woods’s (1975) famous article “What’s In a Link?” drew the attention of AI researchers to the
need for precise semantics in knowledge representation formalisms. Brachman (1979) elaborated on this point and proposed solutions. Patrick Hayes’s (1979) “The Logic of Frames”
cut even deeper, claiming that “Most of ‘frames’ is just a new syntax for parts of first-order
logic.” Drew McDermott’s (1978b) “Tarskian Semantics, or, No Notation without Denotation!” argued that the model-theoretic approach to semantics used in first-order logic should
be applied to all knowledge representation formalisms. This remains a controversial idea;
notably, McDermott himself has reversed his position in “A Critique of Pure Reason” (McDermott, 1987). Selman and Levesque (1993) discuss the complexity of inheritance with
exceptions, showing that in most formulations it is NP-complete.
The development of description logics is the most recent stage in a long line of research aimed at finding useful subsets of first-order logic for which inference is computationally tractable. Hector Levesque and Ron Brachman (1987) showed that certain logical
constructs—notably, certain uses of disjunction and negation—were primarily responsible
for the intractability of logical inference. Building on the KL-ONE system (Schmolze and
Lipkis, 1983), several researchers developed systems that incorporate theoretical complexity analysis, most notably KRYPTON (Brachman et al., 1983) and Classic (Borgida et al.,
1989). The result has been a marked increase in the speed of inference and a much better
understanding of the interaction between complexity and expressiveness in reasoning systems. Calvanese et al. (1999) summarize the state of the art, and Baader et al. (2007) present
a comprehensive handbook of description logic. Against this trend, Doyle and Patil (1991)
have argued that restricting the expressiveness of a language either makes it impossible to
solve certain problems or encourages the user to circumvent the language restrictions through
nonlogical means.
The three main formalisms for dealing with nonmonotonic inference—circumscription
(McCarthy, 1980), default logic (Reiter, 1980), and modal nonmonotonic logic (McDermott
and Doyle, 1980)—were all introduced in one special issue of the AI Journal. Delgrande and
Schaub (2003) discuss the merits of the variants, given 25 years of hindsight. Answer set
programming can be seen as an extension of negation as failure or as a refinement of circum-
472 Chapter 12. Knowledge Representation
scription; the underlying theory of stable model semantics was introduced by Gelfond and
Lifschitz (1988), and the leading answer set programming systems are DLV (Eiter et al., 1998)
and SMODELS (Niemel¨a et al., 2000). The disk drive example comes from the SMODELS user
manual (Syrj¨anen, 2000). Lifschitz (2001) discusses the use of answer set programming for
planning. Brewka et al. (1997) give a good overview of the various approaches to nonmonotonic logic. Clark (1978) covers the negation-as-failure approach to logic programming and
Clark completion. Van Emden and Kowalski (1976) show that every Prolog program without
negation has a unique minimal model. Recent years have seen renewed interest in applications of nonmonotonic logics to large-scale knowledge representation systems. The BENINQ
systems for handling insurance-benefit inquiries was perhaps the first commercially successful application of a nonmonotonic inheritance system (Morgenstern, 1998). Lifschitz (2001)
discusses the application of answer set programming to planning. A variety of nonmonotonic
reasoning systems based on logic programming are documented in the proceedings of the
conferences on Logic Programming and Nonmonotonic Reasoning (LPNMR).
The study of truth maintenance systems began with the TMS (Doyle, 1979) and RUP
(McAllester, 1980) systems, both of which were essentially JTMSs. Forbus and de Kleer
(1993) explain in depth how TMSs can be used in AI applications. Nayak and Williams
(1997) show how an efficient incremental TMS called an ITMS makes it feasible to plan the
operations of a NASA spacecraft in real time.
This chapter could not cover every area of knowledge representation in depth. The three
principal topics omitted are the following:
Qualitative physics: Qualitative physics is a subfield of knowledge representation concerned QUALITATIVE
PHYSICS
specifically with constructing a logical, nonnumeric theory of physical objects and processes.
The term was coined by Johan de Kleer (1975), although the enterprise could be said to
have started in Fahlman’s (1974) BUILD, a sophisticated planner for constructing complex
towers of blocks. Fahlman discovered in the process of designing it that most of the effort
(80%, by his estimate) went into modeling the physics of the blocks world to calculate the
stability of various subassemblies of blocks, rather than into planning per se. He sketches a
hypothetical naive-physics-like process to explain why young children can solve BUILD-like
problems without access to the high-speed floating-point arithmetic used in BUILD’s physical
modeling. Hayes (1985a) uses “histories”—four-dimensional slices of space-time similar to
Davidson’s events—to construct a fairly complex naive physics of liquids. Hayes was the
first to prove that a bath with the plug in will eventually overflow if the tap keeps running and
that a person who falls into a lake will get wet all over. Davis (2008) gives an update to the
ontology of liquids that describes the pouring of liquids into containers.
De Kleer and Brown (1985), Ken Forbus (1985), and Benjamin Kuipers (1985) independently and almost simultaneously developed systems that can reason about a physical
system based on qualitative abstractions of the underlying equations. Qualitative physics
soon developed to the point where it became possible to analyze an impressive variety of
complex physical systems (Yip, 1991). Qualitative techniques have been used to construct
novel designs for clocks, windshield wipers, and six-legged walkers (Subramanian and Wang,
1994). The collection Readings in Qualitative Reasoning about Physical Systems (Weld and
Exercises 473
de Kleer, 1990) an encyclopedia article by Kuipers (2001), and a handbook article by Davis
(2007) introduce to the field.
SPATIAL REASONING Spatial reasoning: The reasoning necessary to navigate in the wumpus world and shopping
world is trivial in comparison to the rich spatial structure of the real world. The earliest
serious attempt to capture commonsense reasoning about space appears in the work of Ernest
Davis (1986, 1990). The region connection calculus of Cohn et al. (1997) supports a form of
qualitative spatial reasoning and has led to new kinds of geographical information systems;
see also (Davis, 2006). As with qualitative physics, an agent can go a long way, so to speak,
without resorting to a full metric representation. When such a representation is necessary,
techniques developed in robotics (Chapter 25) can be used.
Psychological reasoning: Psychological reasoning involves the development of a working PSYCHOLOGICAL
REASONING
psychology for artificial agents to use in reasoning about themselves and other agents. This
is often based on so-called folk psychology, the theory that humans in general are believed
to use in reasoning about themselves and other humans. When AI researchers provide their
artificial agents with psychological theories for reasoning about other agents, the theories are
frequently based on the researchers’ description of the logical agents’ own design. Psychological reasoning is currently most useful within the context of natural language understanding,
where divining the speaker’s intentions is of paramount importance.
Minker (2001) collects papers by leading researchers in knowledge representation, summarizing 40 years of work in the field. The proceedings of the international conferences on
Principles of Knowledge Representation and Reasoning provide the most up-to-date sources
for work in this area. Readings in Knowledge Representation (Brachman and Levesque,
1985) and Formal Theories of the Commonsense World (Hobbs and Moore, 1985) are excellent anthologies on knowledge representation; the former focuses more on historically
important papers in representation languages and formalisms, the latter on the accumulation
of the knowledge itself. Davis (1990), Stefik (1995), and Sowa (1999) provide textbook introductions to knowledge representation, van Harmelen et al. (2007) contributes a handbook,
and a special issue of AI Journal covers recent progress (Davis and Morgenstern, 2004). The
biennial conference on Theoretical Aspects of Reasoning About Knowledge (TARK) covers
applications of the theory of knowledge in AI, economics, and distributed systems.
EXERCISES
12.1 Define an ontology in first-order logic for tic-tac-toe. The ontology should contain
situations, actions, squares, players, marks (X, O, or blank), and the notion of winning, losing,
or drawing a game. Also define the notion of a forced win (or draw): a position from which
a player can force a win (or draw) with the right sequence of actions. Write axioms for the
domain. (Note: The axioms that enumerate the different squares and that characterize the
winning positions are rather long. You need not write these out in full, but indicate clearly
what they look like.)
474 Chapter 12. Knowledge Representation
12.2 Figure 12.1 shows the top levels of a hierarchy for everything. Extend it to include
as many real categories as possible. A good way to do this is to cover all the things in your
everyday life. This includes objects and events. Start with waking up, and proceed in an
orderly fashion noting everything that you see, touch, do, and think about. For example,
a random sampling produces music, news, milk, walking, driving, gas, Soda Hall, carpet,
talking, Professor Fateman, chicken curry, tongue, $7, sun, the daily newspaper, and so on.
You should produce both a single hierarchy chart (on a large sheet of paper) and a
listing of objects and categories with the relations satisfied by members of each category.
Every object should be in a category, and every category should be in the hierarchy.
12.3 Develop a representational system for reasoning about windows in a window-based
computer interface. In particular, your representation should be able to describe:
• The state of a window: minimized, displayed, or nonexistent.
• Which window (if any) is the active window.
• The position of every window at a given time.
• The order (front to back) of overlapping windows.
• The actions of creating, destroying, resizing, and moving windows; changing the state
of a window; and bringing a window to the front. Treat these actions as atomic; that is,
do not deal with the issue of relating them to mouse actions. Give axioms describing
the effects of actions on fluents. You may use either event or situation calculus.
Assume an ontology containing situations, actions, integers (for x and y coordinates) and
windows. Define a language over this ontology; that is, a list of constants, function symbols,
and predicates with an English description of each. If you need to add more categories to the
ontology (e.g., pixels), you may do so, but be sure to specify these in your write-up. You may
(and should) use symbols defined in the text, but be sure to list these explicitly.
12.4 State the following in the language you developed for the previous exercise:
a. In situation S0, window W1 is behind W2 but sticks out on the left and right. Do not
state exact coordinates for these; describe the general situation.
b. If a window is displayed, then its top edge is higher than its bottom edge.
c. After you create a window w, it is displayed.
d. A window can be minimized if it is displayed.
12.5 (Adapted from an example by Doug Lenat.) Your mission is to capture, in logical
form, enough knowledge to answer a series of questions about the following simple scenario:
Yesterday John went to the North Berkeley Safeway supermarket and bought two
pounds of tomatoes and a pound of ground beef.
Start by trying to represent the content of the sentence as a series of assertions. You should
write sentences that have straightforward logical structure (e.g., statements that objects have
certain properties, that objects are related in certain ways, that all objects satisfying one property satisfy another). The following might help you get started:
Exercises 475
• Which classes, objects, and relations would you need? What are their parents, siblings
and so on? (You will need events and temporal ordering, among other things.)
• Where would they fit in a more general hierarchy?
• What are the constraints and interrelationships among them?
• How detailed must you be about each of the various concepts?
To answer the questions below, your knowledge base must include background knowledge.
You’ll have to deal with what kind of things are at a supermarket, what is involved with
purchasing the things one selects, what the purchases will be used for, and so on. Try to make
your representation as general as possible. To give a trivial example: don’t say “People buy
food from Safeway,” because that won’t help you with those who shop at another supermarket.
Also, don’t turn the questions into answers; for example, question (c) asks “Did John buy any
meat?”—not “Did John buy a pound of ground beef?”
Sketch the chains of reasoning that would answer the questions. If possible, use a
logical reasoning system to demonstrate the sufficiency of your knowledge base. Many of the
things you write might be only approximately correct in reality, but don’t worry too much;
the idea is to extract the common sense that lets you answer these questions at all. A truly
complete answer to this question is extremely difficult, probably beyond the state of the art of
current knowledge representation. But you should be able to put together a consistent set of
axioms for the limited questions posed here.
a. Is John a child or an adult? [Adult]
b. Does John now have at least two tomatoes? [Yes]
c. Did John buy any meat? [Yes]
d. If Mary was buying tomatoes at the same time as John, did he see her? [Yes]
e. Are the tomatoes made in the supermarket? [No]
f. What is John going to do with the tomatoes? [Eat them]
g. Does Safeway sell deodorant? [Yes]
h. Did John bring some money or a credit card to the supermarket? [Yes]
i. Does John have less money after going to the supermarket? [Yes]
12.6 Make the necessary additions or changes to your knowledge base from the previous
exercise so that the questions that follow can be answered. Include in your report a discussion
of your changes, explaining why they were needed, whether they were minor or major, and
what kinds of questions would necessitate further changes.
a. Are there other people in Safeway while John is there? [Yes—staff!]
b. Is John a vegetarian? [No]
c. Who owns the deodorant in Safeway? [Safeway Corporation]
d. Did John have an ounce of ground beef? [Yes]
e. Does the Shell station next door have any gas? [Yes]
f. Do the tomatoes fit in John’s car trunk? [Yes]
476 Chapter 12. Knowledge Representation
12.7 Represent the following seven sentences using and extending the representations developed in the chapter:
a. Water is a liquid between 0 and 100 degrees.
b. Water boils at 100 degrees.
c. The water in John’s water bottle is frozen.
d. Perrier is a kind of water.
e. John has Perrier in his water bottle.
f. All liquids have a freezing point.
g. A liter of water weighs more than a liter of alcohol.
12.8 Write definitions for the following:
a. ExhaustivePartDecomposition
b. PartPartition
c. PartwiseDisjoint
These should be analogous to the definitions for ExhaustiveDecomposition, Partition, and
Disjoint. Is it the case that PartPartition(s, BunchOf (s))? If so, prove it; if not, give a
counterexample and define sufficient conditions under which it does hold.
12.9 An alternative scheme for representing measures involves applying the units function
to an abstract length object. In such a scheme, one would write Inches(Length(L1)) =
1.5. How does this scheme compare with the one in the chapter? Issues include conversion
axioms, names for abstract quantities (such as “50 dollars”), and comparisons of abstract
measures in different units (50 inches is more than 50 centimeters).
12.10 Add sentences to extend the definition of the predicate Name(s, c) so that a string
such as “laptop computer” matches the appropriate category names from a variety of stores.
Try to make your definition general. Test it by looking at ten online stores, and at the category
names they give for three different categories. For example, for the category of laptops, we
found the names “Notebooks,” “Laptops,” “Notebook Computers,” “Notebook,” “Laptops
and Notebooks,” and “Notebook PCs.” Some of these can be covered by explicit Name facts,
while others could be covered by sentences for handling plurals, conjunctions, etc.
12.11 Write event calculus axioms to describe the actions in the wumpus world.
12.12 State the interval-algebra relation that holds between every pair of the following realworld events:
LK: The life of President Kennedy.
IK: The infancy of President Kennedy.
PK: The presidency of President Kennedy.
LJ: The life of President Johnson.
P J: The presidency of President Johnson.
LO: The life of President Obama.
Exercises 477
12.13 Investigate ways to extend the event calculus to handle simultaneous events. Is it
possible to avoid a combinatorial explosion of axioms?
12.14 Construct a representation for exchange rates between currencies that allows for daily
fluctuations.
12.15 Define the predicate Fixed, where Fixed(Location(x)) means that the location of
object x is fixed over time.
12.16 Describe the event of trading something for something else. Describe buying as a
kind of trading in which one of the objects traded is a sum of money.
12.17 The two preceding exercises assume a fairly primitive notion of ownership. For example, the buyer starts by owning the dollar bills. This picture begins to break down when,
for example, one’s money is in the bank, because there is no longer any specific collection
of dollar bills that one owns. The picture is complicated still further by borrowing, leasing,
renting, and bailment. Investigate the various commonsense and legal concepts of ownership,
and propose a scheme by which they can be represented formally.
12.18 (Adapted from Fagin et al. (1995).) Consider a game played with a deck of just 8
cards, 4 aces and 4 kings. The three players, Alice, Bob, and Carlos, are dealt two cards each.
Without looking at them, they place the cards on their foreheads so that the other players can
see them. Then the players take turns either announcing that they know what cards are on
their own forehead, thereby winning the game, or saying “I don’t know.” Everyone knows
the players are truthful and are perfect at reasoning about beliefs.
a. Game 1. Alice and Bob have both said “I don’t know.” Carlos sees that Alice has two
aces (A-A) and Bob has two kings (K-K). What should Carlos say? (Hint: consider all
three possible cases for Carlos: A-A, K-K, A-K.)
b. Describe each step of Game 1 using the notation of modal logic.
c. Game 2. Carlos, Alice, and Bob all said “I don’t know” on their first turn. Alice holds
K-K and Bob holds A-K. What should Carlos say on his second turn?
d. Game 3. Alice, Carlos, and Bob all say “I don’t know” on their first turn, as does Alice
on her second turn. Alice and Bob both hold A-K. What should Carlos say?
e. Prove that there will always be a winner to this game.
12.19 The assumption of logical omniscience, discussed on page 453, is of course not true
of any actual reasoners. Rather, it is an idealization of the reasoning process that may be
more or less acceptable depending on the applications. Discuss the reasonableness of the
assumption for each of the following applications of reasoning about knowledge:
a. Partial knowledge adversary games, such as card games. Here one player wants to
reason about what his opponent knows about the state of the game.
b. Chess with a clock. Here the player may wish to reason about the limits of his opponent’s or his own ability to find the best move in the time available. For instance, if
player A has much more time left than player B, then A will sometimes make a move
that greatly complicates the situation, in the hopes of gaining an advantage because he
has more time to work out the proper strategy.
478 Chapter 12. Knowledge Representation
c. A shopping agent in an environment in which there are costs of gathering information.
d. Reasoning about public key cryptography, which rests on the intractability of certain
computational problems.
12.20 Translate the following description logic expression (from page 457) into first-order
logic, and comment on the result:
And(Man, AtLeast(3, Son), AtMost(2, Daughter ),
All(Son, And(Unemployed, Married, All(Spouse, Doctor ))),
All(Daughter , And(Professor ,Fills(Department,Physics, Math)))) .
12.21 Recall that inheritance information in semantic networks can be captured logically
by suitable implication sentences. This exercise investigates the efficiency of using such
sentences for inheritance.
a. Consider the information in a used-car catalog such as Kelly’s Blue Book—for example, that 1973 Dodge vans are (or perhaps were once) worth $575. Suppose all this
information (for 11,000 models) is encoded as logical sentences, as suggested in the
chapter. Write down three such sentences, including that for 1973 Dodge vans. How
would you use the sentences to find the value of a particular car, given a backwardchaining theorem prover such as Prolog?
b. Compare the time efficiency of the backward-chaining method for solving this problem
with the inheritance method used in semantic nets.
c. Explain how forward chaining allows a logic-based system to solve the same problem
efficiently, assuming that the KB contains only the 11,000 sentences about prices.
d. Describe a situation in which neither forward nor backward chaining on the sentences
will allow the price query for an individual car to be handled efficiently.
e. Can you suggest a solution enabling this type of query to be solved efficiently in all
cases in logic systems? (Hint: Remember that two cars of the same year and model
have the same price.)
12.22 One might suppose that the syntactic distinction between unboxed links and singly
boxed links in semantic networks is unnecessary, because singly boxed links are always attached to categories; an inheritance algorithm could simply assume that an unboxed link
attached to a category is intended to apply to all members of that category. Show that this
argument is fallacious, giving examples of errors that would arise.
12.23 One part of the shopping process that was not covered in this chapter is checking
for compatibility between items. For example, if a digital camera is ordered, what accessory
batteries, memory cards, and cases are compatible with the camera? Write a knowledge base
that can determine the compatibility of a set of items and suggest replacements or additional
items if the shopper makes a choice that is not compatible. The knowledge base should works
with at least one line of products and extend easily to other lines.
12.24 A complete solution to the problem of inexact matches to the buyer’s description
in shopping is very difficult and requires a full array of natural language processing and
Exercises 479
information retrieval techniques. (See Chapters 22 and 23.) One small step is to allow the
user to specify minimum and maximum values for various attributes. The buyer must use the
following grammar for product descriptions:
Description → Category [Connector Modifier ]∗
Connector → “with” | “and” | “,”
Modifier → Attribute | Attribute Op Value
Op → “=” | “>” | “<”
Here, Category names a product category, Attribute is some feature such as “CPU” or
“price,” and Value is the target value for the attribute. So the query “computer with at least a
2.5 GHz CPU for under $500” must be re-expressed as “computer with CPU > 2.5 GHz and
price < $500.” Implement a shopping agent that accepts descriptions in this language.
12.25 Our description of Internet shopping omitted the all-important step of actually buying
the product. Provide a formal logical description of buying, using event calculus. That is,
define the sequence of events that occurs when a buyer submits a credit-card purchase and
then eventually gets billed and receives the product.
13 QUANTIFYING
UNCERTAINTY
In which we see how an agent can tame uncertainty with degrees of belief.
13.1 ACTING UNDER UNCERTAINTY
UNCERTAINTY Agents may need to handle uncertainty, whether due to partial observability, nondeterminism, or a combination of the two. An agent may never know for certain what state it’s in or
where it will end up after a sequence of actions.
We have seen problem-solving agents (Chapter 4) and logical agents (Chapters 7 and 11)
designed to handle uncertainty by keeping track of a belief state—a representation of the set
of all possible world states that it might be in—and generating a contingency plan that handles every possible eventuality that its sensors may report during execution. Despite its many
virtues, however, this approach has significant drawbacks when taken literally as a recipe for
creating agent programs:
• When interpreting partial sensor information, a logical agent must consider every logically possible explanation for the observations, no matter how unlikely. This leads to
impossible large and complex belief-state representations.
• A correct contingent plan that handles every eventuality can grow arbitrarily large and
must consider arbitrarily unlikely contingencies.
• Sometimes there is no plan that is guaranteed to achieve the goal—yet the agent must
act. It must have some way to compare the merits of plans that are not guaranteed.
Suppose, for example, that an automated taxi!automated has the goal of delivering a passenger to the airport on time. The agent forms a plan, A90, that involves leaving home 90
minutes before the flight departs and driving at a reasonable speed. Even though the airport
is only about 5 miles away, a logical taxi agent will not be able to conclude with certainty
that “Plan A90 will get us to the airport in time.” Instead, it reaches the weaker conclusion
“Plan A90 will get us to the airport in time, as long as the car doesn’t break down or run out
of gas, and I don’t get into an accident, and there are no accidents on the bridge, and the plane
doesn’t leave early, and no meteorite hits the car, and ... .” None of these conditions can be
480
Section 13.1. Acting under Uncertainty 481
deduced for sure, so the plan’s success cannot be inferred. This is the qualification problem
(page 268), for which we so far have seen no real solution.
Nonetheless, in some sense A90 is in fact the right thing to do. What do we mean by
this? As we discussed in Chapter 2, we mean that out of all the plans that could be executed,
A90 is expected to maximize the agent’s performance measure (where the expectation is relative to the agent’s knowledge about the environment). The performance measure includes
getting to the airport in time for the flight, avoiding a long, unproductive wait at the airport,
and avoiding speeding tickets along the way. The agent’s knowledge cannot guarantee any of
these outcomes for A90, but it can provide some degree of belief that they will be achieved.
Other plans, such as A180, might increase the agent’s belief that it will get to the airport on
time, but also increase the likelihood of a long wait. The right thing to do—the rational
decision—therefore depends on both the relative importance of various goals and the likelihood that, and degree to which, they will be achieved. The remainder of this section hones
these ideas, in preparation for the development of the general theories of uncertain reasoning
and rational decisions that we present in this and subsequent chapters.
13.1.1 Summarizing uncertainty
Let’s consider an example of uncertain reasoning: diagnosing a dental patient’s toothache.
Diagnosis—whether for medicine, automobile repair, or whatever—almost always involves
uncertainty. Let us try to write rules for dental diagnosis using propositional logic, so that we
can see how the logical approach breaks down. Consider the following simple rule:
Toothache ⇒ Cavity .
The problem is that this rule is wrong. Not all patients with toothaches have cavities; some
of them have gum disease, an abscess, or one of several other problems:
Toothache ⇒ Cavity ∨ GumProblem ∨ Abscess ...
Unfortunately, in order to make the rule true, we have to add an almost unlimited list of
possible problems. We could try turning the rule into a causal rule:
Cavity ⇒ Toothache .
But this rule is not right either; not all cavities cause pain. The only way to fix the rule
is to make it logically exhaustive: to augment the left-hand side with all the qualifications
required for a cavity to cause a toothache. Trying to use logic to cope with a domain like
medical diagnosis thus fails for three main reasons:
LAZINESS • Laziness: It is too much work to list the complete set of antecedents or consequents
needed to ensure an exceptionless rule and too hard to use such rules.
• Theoretical ignorance: Medical science has no complete theory for the domain. THEORETICAL
IGNORANCE
• Practical ignorance: Even if we know all the rules, we might be uncertain about a PRACTICAL
IGNORANCE
particular patient because not all the necessary tests have been or can be run.
The connection between toothaches and cavities is just not a logical consequence in either
direction. This is typical of the medical domain, as well as most other judgmental domains:
law, business, design, automobile repair, gardening, dating, and so on. The agent’s knowledge
482 Chapter 13. Quantifying Uncertainty
DEGREE OF BELIEF can at best provide only a degree of belief in the relevant sentences. Our main tool for
dealing with degrees of belief is probability theory. In the terminology of Section 8.1, the PROBABILITY
THEORY
ontological commitments of logic and probability theory are the same—that the world is
composed of facts that do or do not hold in any particular case—but the epistemological
commitments are different: a logical agent believes each sentence to be true or false or has
no opinion, whereas a probabilistic agent may have a numerical degree of belief between 0
(for sentences that are certainly false) and 1 (certainly true).
Probability provides a way of summarizing the uncertainty that comes from our laziness and ignorance, thereby solving the qualification problem. We might not know for sure
what afflicts a particular patient, but we believe that there is, say, an 80% chance—that is,
a probability of 0.8—that the patient who has a toothache has a cavity. That is, we expect
that out of all the situations that are indistinguishable from the current situation as far as our
knowledge goes, the patient will have a cavity in 80% of them. This belief could be derived
from statistical data—80% of the toothache patients seen so far have had cavities—or from
some general dental knowledge, or from a combination of evidence sources.
One confusing point is that at the time of our diagnosis, there is no uncertainty in the
actual world: the patient either has a cavity or doesn’t. So what does it mean to say the
probability of a cavity is 0.8? Shouldn’t it be either 0 or 1? The answer is that probability
statements are made with respect to a knowledge state, not with respect to the real world. We
say “The probability that the patient has a cavity, given that she has a toothache, is 0.8.” If we
later learn that the patient has a history of gum disease, we can make a different statement:
“The probability that the patient has a cavity, given that she has a toothache and a history of
gum disease, is 0.4.” If we gather further conclusive evidence against a cavity, we can say
“The probability that the patient has a cavity, given all we now know, is almost 0.” Note that
these statements do not contradict each other; each is a separate assertion about a different
knowledge state.
13.1.2 Uncertainty and rational decisions
Consider again the A90 plan for getting to the airport. Suppose it gives us a 97% chance
of catching our flight. Does this mean it is a rational choice? Not necessarily: there might
be other plans, such as A180, with higher probabilities. If it is vital not to miss the flight,
then it is worth risking the longer wait at the airport. What about A1440, a plan that involves
leaving home 24 hours in advance? In most circumstances, this is not a good choice, because
although it almost guarantees getting there on time, it involves an intolerable wait—not to
mention a possibly unpleasant diet of airport food.
PREFERENCE To make such choices, an agent must first have preferences between the different posOUTCOME sible outcomes of the various plans. An outcome is a completely specified state, including
such factors as whether the agent arrives on time and the length of the wait at the airport. We
UTILITY THEORY use utility theory to represent and reason with preferences. (The term utility is used here in
the sense of “the quality of being useful,” not in the sense of the electric company or water
works.) Utility theory says that every state has a degree of usefulness, or utility, to an agent
and that the agent will prefer states with higher utility.
Section 13.2. Basic Probability Notation 483
The utility of a state is relative to an agent. For example, the utility of a state in which
White has checkmated Black in a game of chess is obviously high for the agent playing White,
but low for the agent playing Black. But we can’t go strictly by the scores of 1, 1/2, and 0 that
are dictated by the rules of tournament chess—some players (including the authors) might be
thrilled with a draw against the world champion, whereas other players (including the former
world champion) might not. There is no accounting for taste or preferences: you might think
that an agent who prefers jalape˜no bubble-gum ice cream to chocolate chocolate chip is odd
or even misguided, but you could not say the agent is irrational. A utility function can account
for any set of preferences—quirky or typical, noble or perverse. Note that utilities can account
for altruism, simply by including the welfare of others as one of the factors.
Preferences, as expressed by utilities, are combined with probabilities in the general
DECISION THEORY theory of rational decisions called decision theory:
Decision theory = probability theory + utility theory .
The fundamental idea of decision theory is that an agent is rational if and only if it chooses
the action that yields the highest expected utility, averaged over all the possible outcomes
of the action. This is called the principle of maximum expected utility (MEU). Note that MAXIMUM EXPECTED
UTILITY
“expected” might seem like a vague, hypothetical term, but as it is used here it has a precise
meaning: it means the “average,” or “statistical mean” of the outcomes, weighted by the
probability of the outcome. We saw this principle in action in Chapter 5 when we touched
briefly on optimal decisions in backgammon; it is in fact a completely general principle.
Figure 13.1 sketches the structure of an agent that uses decision theory to select actions.
The agent is identical, at an abstract level, to the agents described in Chapters 4 and 7 that
maintain a belief state reflecting the history of percepts to date. The primary difference is
that the decision-theoretic agent’s belief state represents not just the possibilities for world
states but also their probabilities. Given the belief state, the agent can make probabilistic
predictions of action outcomes and hence select the action with highest expected utility. This
chapter and the next concentrate on the task of representing and computing with probabilistic
information in general. Chapter 15 deals with methods for the specific tasks of representing
and updating the belief state over time and predicting the environment. Chapter 16 covers
utility theory in more depth, and Chapter 17 develops algorithms for planning sequences of
actions in uncertain environments.
13.2 BASIC PROBABILITY NOTATION
For our agent to represent and use probabilistic information, we need a formal language.
The language of probability theory has traditionally been informal, written by human mathematicians to other human mathematicians. Appendix A includes a standard introduction to
elementary probability theory; here, we take an approach more suited to the needs of AI and
more consistent with the concepts of formal logic.
484 Chapter 13. Quantifying Uncertainty
function DT-AGENT(percept) returns an action
persistent: belief state, probabilistic beliefs about the current state of the world
action, the agent’s action
update belief state based on action and percept
calculate outcome probabilities for actions,
given action descriptions and current belief state
select action with highest expected utility
given probabilities of outcomes and utility information
return action
Figure 13.1 A decision-theoretic agent that selects rational actions.
13.2.1 What probabilities are about
Like logical assertions, probabilistic assertions are about possible worlds. Whereas logical
assertions say which possible worlds are strictly ruled out (all those in which the assertion is
false), probabilistic assertions talk about how probable the various worlds are. In probability
SAMPLE SPACE theory, the set of all possible worlds is called the sample space. The possible worlds are
mutually exclusive and exhaustive—two possible worlds cannot both be the case, and one
possible world must be the case. For example, if we are about to roll two (distinguishable)
dice, there are 36 possible worlds to consider: (1,1), (1,2), ..., (6,6). The Greek letter Ω
(uppercase omega) is used to refer to the sample space, and ω (lowercase omega) refers to
elements of the space, that is, particular possible worlds.
PROBABILITY MODEL A fully specified probability model associates a numerical probability P(ω) with each
possible world.1 The basic axioms of probability theory say that every possible world has a
probability between 0 and 1 and that the total probability of the set of possible worlds is 1:
0 ≤ P(ω) ≤ 1 for every ω and 
ω∈Ω
P(ω)=1 . (13.1)
For example, if we assume that each die is fair and the rolls don’t interfere with each other,
then each of the possible worlds (1,1), (1,2), ..., (6,6) has probability 1/36. On the other
hand, if the dice conspire to produce the same number, then the worlds (1,1), (2,2), (3,3), etc.,
might have higher probabilities, leaving the others with lower probabilities.
Probabilistic assertions and queries are not usually about particular possible worlds, but
about sets of them. For example, we might be interested in the cases where the two dice add
up to 11, the cases where doubles are rolled, and so on. In probability theory, these sets are
EVENT called events—a term already used extensively in Chapter 12 for a different concept. In AI,
the sets are always described by propositions in a formal language. (One such language is
described in Section 13.2.2.) For each proposition, the corresponding set contains just those
possible worlds in which the proposition holds. The probability associated with a proposition
1 For now, we assume a discrete, countable set of worlds. The proper treatment of the continuous case brings in
certain complications that are less relevant for most purposes in AI.
Section 13.2. Basic Probability Notation 485
is defined to be the sum of the probabilities of the worlds in which it holds:
For any proposition φ, P(φ) = 
ω∈φ
P(ω) . (13.2)
For example, when rolling fair dice, we have P(Total = 11) = P((5, 6)) + P((6, 5)) =
1/36 + 1/36 = 1/18. Note that probability theory does not require complete knowledge
of the probabilities of each possible world. For example, if we believe the dice conspire to
produce the same number, we might assert that P(doubles)=1/4 without knowing whether
the dice prefer double 6 to double 2. Just as with logical assertions, this assertion constrains
the underlying probability model without fully determining it.
Probabilities such as P(Total = 11) and P(doubles) are called unconditional or prior UNCONDITIONAL
PROBABILITY
PRIOR PROBABILITY probabilities (and sometimes just “priors” for short); they refer to degrees of belief in propositions in the absence of any other information. Most of the time, however, we have some
EVIDENCE information, usually called evidence, that has already been revealed. For example, the first
die may already be showing a 5 and we are waiting with bated breath for the other one to
stop spinning. In that case, we are interested not in the unconditional probability of rolling
doubles, but the conditional or posterior probability (or just “posterior” for short) of rolling CONDITIONAL
PROBABILITY
POSTERIOR
PROBABILITY doubles given that the first die is a 5. This probability is written P(doubles | Die1 = 5), where
the “ | ” is pronounced “given.” Similarly, if I am going to the dentist for a regular checkup,
the probability P(cavity)=0.2 might be of interest; but if I go to the dentist because I have
a toothache, it’s P(cavity |toothache)=0.6 that matters. Note that the precedence of “ | ” is
such that any expression of the form P(... | ...) always means P((...)|(...)).
It is important to understand that P(cavity)=0.2 is still valid after toothache is observed; it just isn’t especially useful. When making decisions, an agent needs to condition
on all the evidence it has observed. It is also important to understand the difference between conditioning and logical implication. The assertion that P(cavity | toothache)=0.6
does not mean “Whenever toothache is true, conclude that cavity is true with probability 0.6” rather it means “Whenever toothache is true and we have no further information,
conclude that cavity is true with probability 0.6.” The extra condition is important; for example, if we had the further information that the dentist found no cavities, we definitely
would not want to conclude that cavity is true with probability 0.6; instead we need to use
P(cavity|toothache ∧ ¬cavity)=0.
Mathematically speaking, conditional probabilities are defined in terms of unconditional probabilities as follows: for any propositions a and b, we have
P(a | b) = P(a ∧ b)
P(b) , (13.3)
which holds whenever P(b) > 0. For example,
P(doubles | Die1 = 5) = P(doubles ∧ Die1 = 5)
P(Die1 = 5) .
The definition makes sense if you remember that observing b rules out all those possible
worlds where b is false, leaving a set whose total probability is just P(b). Within that set, the
a-worlds satisfy a ∧ b and constitute a fraction P(a ∧ b)/P(b).
486 Chapter 13. Quantifying Uncertainty
The definition of conditional probability, Equation (13.3), can be written in a different
PRODUCT RULE form called the product rule:
P(a ∧ b) = P(a | b)P(b) ,
The product rule is perhaps easier to remember: it comes from the fact that, for a and b to be
true, we need b to be true, and we also need a to be true given b.
13.2.2 The language of propositions in probability assertions
In this chapter and the next, propositions describing sets of possible worlds are written in a
notation that combines elements of propositional logic and constraint satisfaction notation. In
the terminology of Section 2.4.7, it is a factored representation, in which a possible world
is represented by a set of variable/value pairs.
RANDOM VARIABLE Variables in probability theory are called random variables and their names begin with
an uppercase letter. Thus, in the dice example, Total and Die1 are random variables. Every
DOMAIN random variable has a domain—the set of possible values it can take on. The domain of
Total for two dice is the set {2,..., 12} and the domain of Die1 is {1,..., 6}. A Boolean
random variable has the domain {true, false} (notice that values are always lowercase); for
example, the proposition that doubles are rolled can be written as Doubles = true. By convention, propositions of the form A = true are abbreviated simply as a, while A = false is
abbreviated as ¬a. (The uses of doubles, cavity, and toothache in the preceding section are
abbreviations of this kind.) As in CSPs, domains can be sets of arbitrary tokens; we might
choose the domain of Age to be {juvenile,teen, adult} and the domain of Weather might
be {sunny, rain, cloudy, snow}. When no ambiguity is possible, it is common to use a value
by itself to stand for the proposition that a particular variable has that value; thus, sunny can
stand for Weather = sunny.
The preceding examples all have finite domains. Variables can have infinite domains,
too—either discrete (like the integers) or continuous (like the reals). For any variable with an
ordered domain, inequalities are also allowed, such as NumberOfAtomsInUniverse ≥ 1070.
Finally, we can combine these sorts of elementary propositions (including the abbreviated forms for Boolean variables) by using the connectives of propositional logic. For
example, we can express “The probability that the patient has a cavity, given that she is a
teenager with no toothache, is 0.1” as follows:
P(cavity | ¬toothache ∧ teen)=0.1 .
Sometimes we will want to talk about the probabilities of all the possible values of a random
variable. We could write:
P(Weather = sunny)=0.6
P(Weather = rain)=0.1
P(Weather = cloudy)=0.29
P(Weather = snow)=0.01 ,
but as an abbreviation we will allow
P(Weather ) = 0.6, 0.1, 0.29, 0.01 ,
Section 13.2. Basic Probability Notation 487
where the bold P indicates that the result is a vector of numbers, and where we assume a predefined ordering sunny, rain, cloudy, snow on the domain of Weather . We say that the
P statement defines a probability distribution for the random variable Weather . The P nota- PROBABILITY
DISTRIBUTION
tion is also used for conditional distributions: P(X | Y ) gives the values of P(X = xi | Y = yj )
for each possible i, j pair.
For continuous variables, it is not possible to write out the entire distribution as a vector,
because there are infinitely many values. Instead, we can define the probability that a random
variable takes on some value x as a parameterized function of x. For example, the sentence
P(NoonTemp = x) = Uniform[18C,26C](x)
expresses the belief that the temperature at noon is distributed uniformly between 18 and 26
degrees Celsius. We call this a probability density function. PROBABILITY
DENSITY FUNCTION
Probability density functions (sometimes called pdfs) differ in meaning from discrete
distributions. Saying that the probability density is uniform from 18C to 26C means that
there is a 100% chance that the temperature will fall somewhere in that 8C-wide region
and a 50% chance that it will fall in any 4C-wide region, and so on. We write the probability
density for a continuous random variable X at value x as P(X = x) or just P(x); the intuitive
definition of P(x) is the probability that X falls within an arbitrarily small region beginning
at x, divided by the width of the region:
P(x) = limdx→0
P(x ≤ X ≤ x + dx)/dx .
For NoonTemp we have
P(NoonTemp = x) = Uniform[18C,26C](x) =  1
8C if 18C ≤ x ≤ 26C
0 otherwise ,
where C stands for centigrade (not for a constant). In P(NoonTemp = 20.18C) = 1
8C , note
that 1
8C is not a probability, it is a probability density. The probability that NoonTemp is
exactly 20.18C is zero, because 20.18C is a region of width 0. Some authors use different
symbols for discrete distributions and density functions; we use P in both cases, since confusion seldom arises and the equations are usually identical. Note that probabilities are unitless
numbers, whereas density functions are measured with a unit, in this case reciprocal degrees.
In addition to distributions on single variables, we need notation for distributions on
multiple variables. Commas are used for this. For example, P(Weather , Cavity) denotes
the probabilities of all combinations of the values of Weather and Cavity. This is a 4 × 2
table of probabilities called the joint probability distribution of Weather and Cavity. We JOINT PROBABILITY
DISTRIBUTION
can also mix variables with and without values; P(sunny, Cavity) would be a two-element
vector giving the probabilities of a sunny day with a cavity and a sunny day with no cavity.
The P notation makes certain expressions much more concise than they might otherwise be.
For example, the product rules for all possible values of Weather and Cavity can be written
as a single equation:
P(Weather , Cavity) = P(Weather | Cavity)P(Cavity) ,
488 Chapter 13. Quantifying Uncertainty
instead of as these 4 × 2=8 equations (using abbreviations W and C):
P(W = sunny ∧ C = true) = P(W = sunny|C = true) P(C = true)
P(W = rain ∧ C = true) = P(W = rain|C = true) P(C = true)
P(W = cloudy ∧ C = true) = P(W = cloudy|C = true) P(C = true)
P(W = snow ∧ C = true) = P(W = snow|C = true) P(C = true)
P(W = sunny ∧ C = false) = P(W = sunny|C = false) P(C = false)
P(W = rain ∧ C = false) = P(W = rain|C = false) P(C = false)
P(W = cloudy ∧ C = false) = P(W = cloudy|C = false) P(C = false)
P(W = snow ∧ C = false) = P(W = snow|C = false) P(C = false) .
As a degenerate case, P(sunny, cavity) has no variables and thus is a one-element vector that is the probability of a sunny day with a cavity, which could also be written as
P(sunny, cavity) or P(sunny ∧ cavity). We will sometimes use P notation to derive results
about individual P values, and when we say “P(sunny)=0.6” it is really an abbreviation for
“P(sunny) is the one-element vector 0.6, which means that P(sunny)=0.6.”
Now we have defined a syntax for propositions and probability assertions and we have
given part of the semantics: Equation (13.2) defines the probability of a proposition as the sum
of the probabilities of worlds in which it holds. To complete the semantics, we need to say
what the worlds are and how to determine whether a proposition holds in a world. We borrow
this part directly from the semantics of propositional logic, as follows. A possible world is
defined to be an assignment of values to all of the random variables under consideration. It is
easy to see that this definition satisfies the basic requirement that possible worlds be mutually
exclusive and exhaustive (Exercise 13.5). For example, if the random variables are Cavity,
Toothache, and Weather , then there are 2 × 2 × 4 = 16 possible worlds. Furthermore, the
truth of any given proposition, no matter how complex, can be determined easily in such
worlds using the same recursive definition of truth as for formulas in propositional logic.
From the preceding definition of possible worlds, it follows that a probability model is
completely determined by the joint distribution for all of the random variables—the so-called
full joint probability distribution. For example, if the variables are Cavity, Toothache, FULL JOINT
PROBABILITY
DISTRIBUTION
and Weather , then the full joint distribution is given by P(Cavity, Toothache,Weather ).
This joint distribution can be represented as a 2 × 2 × 4 table with 16 entries. Because every
proposition’s probability is a sum over possible worlds, a full joint distribution suffices, in
principle, for calculating the probability of any proposition.
13.2.3 Probability axioms and their reasonableness
The basic axioms of probability (Equations (13.1) and (13.2)) imply certain relationships
among the degrees of belief that can be accorded to logically related propositions. For example, we can derive the familiar relationship between the probability of a proposition and the
probability of its negation:
P(¬a) =
ω∈¬a P(ω) by Equation (13.2)
=
ω∈¬a P(ω) +
ω∈a P(ω) −
ω∈a P(ω)
=
ω∈Ω P(ω) −
ω∈a P(ω) grouping the first two terms
= 1 − P(a) by (13.1) and (13.2).
Section 13.2. Basic Probability Notation 489
We can also derive the well-known formula for the probability of a disjunction, sometimes
called the inclusion–exclusion principle:
INCLUSION–
EXCLUSION
PRINCIPLE
P(a ∨ b) = P(a) + P(b) − P(a ∧ b) . (13.4)
This rule is easily remembered by noting that the cases where a holds, together with the cases
where b holds, certainly cover all the cases where a ∨ b holds; but summing the two sets of
cases counts their intersection twice, so we need to subtract P(a ∧ b). The proof is left as an
exercise (Exercise 13.6).
Equations (13.1) and (13.4) are often called Kolmogorov’s axioms in honor of the Rus- KOLMOGOROV’S
AXIOMS
sian mathematician Andrei Kolmogorov, who showed how to build up the rest of probability
theory from this simple foundation and how to handle the difficulties caused by continuous
variables.2 While Equation (13.2) has a definitional flavor, Equation (13.4) reveals that the
axioms really do constrain the degrees of belief an agent can have concerning logically related propositions. This is analogous to the fact that a logical agent cannot simultaneously
believe A, B, and ¬(A ∧ B), because there is no possible world in which all three are true.
With probabilities, however, statements refer not to the world directly, but to the agent’s own
state of knowledge. Why, then, can an agent not hold the following set of beliefs (even though
they violate Kolmogorov’s axioms)?
P(a)=0.4 P(a ∧ b)=0.0
P(b)=0.3 P(a ∨ b)=0.8 . (13.5)
This kind of question has been the subject of decades of intense debate between those who
advocate the use of probabilities as the only legitimate form for degrees of belief and those
who advocate alternative approaches.
One argument for the axioms of probability, first stated in 1931 by Bruno de Finetti
(and translated into English in de Finetti (1993)), is as follows: If an agent has some degree of
belief in a proposition a, then the agent should be able to state odds at which it is indifferent
to a bet for or against a.
3 Think of it as a game between two agents: Agent 1 states, “my
degree of belief in event a is 0.4.” Agent 2 is then free to choose whether to wager for or
against a at stakes that are consistent with the stated degree of belief. That is, Agent 2 could
choose to accept Agent 1’s bet that a will occur, offering $6 against Agent 1’s $4. Or Agent
2 could accept Agent 1’s bet that ¬a will occur, offering $4 against Agent 1’s $6. Then we
observe the outcome of a, and whoever is right collects the money. If an agent’s degrees of
belief do not accurately reflect the world, then you would expect that it would tend to lose
money over the long run to an opposing agent whose beliefs more accurately reflect the state
of the world.
But de Finetti proved something much stronger: If Agent 1 expresses a set of degrees
of belief that violate the axioms of probability theory then there is a combination of bets by
Agent 2 that guarantees that Agent 1 will lose money every time. For example, suppose that
Agent 1 has the set of degrees of belief from Equation (13.5). Figure 13.2 shows that if Agent
2 The difficulties include the Vitali set, a well-defined subset of the interval [0, 1] with no well-defined size.
3 One might argue that the agent’s preferences for different bank balances are such that the possibility of losing
$1 is not counterbalanced by an equal possibility of winning $1. One possible response is to make the bet amounts
small enough to avoid this problem. Savage’s analysis (1954) circumvents the issue altogether.
490 Chapter 13. Quantifying Uncertainty
2 chooses to bet $4 on a, $3 on b, and $2 on ¬(a ∨ b), then Agent 1 always loses money,
regardless of the outcomes for a and b. De Finetti’s theorem implies that no rational agent
can have beliefs that violate the axioms of probability.
Agent 1 Agent 2 Outcomes and payoffs to Agent 1
Proposition Belief Bet Stakes a, b a,¬b ¬a, b ¬a,¬b
a 0.4 a 4 to 6 –6 –6 4 4
b 0.3 b 3 to 7 –7 3 –7 3
a ∨ b 0.8 ¬(a ∨ b) 2 to 8 2 2 2 –8
–11 –1 –1 –1
Figure 13.2 Because Agent 1 has inconsistent beliefs, Agent 2 is able to devise a set of
bets that guarantees a loss for Agent 1, no matter what the outcome of a and b.
One common objection to de Finetti’s theorem is that this betting game is rather contrived. For example, what if one refuses to bet? Does that end the argument? The answer is
that the betting game is an abstract model for the decision-making situation in which every
agent is unavoidably involved at every moment. Every action (including inaction) is a kind
of bet, and every outcome can be seen as a payoff of the bet. Refusing to bet is like refusing
to allow time to pass.
Other strong philosophical arguments have been put forward for the use of probabilities,
most notably those of Cox (1946), Carnap (1950), and Jaynes (2003). They each construct a
set of axioms for reasoning with degrees of beliefs: no contradictions, correspondence with
ordinary logic (for example, if belief in A goes up, then belief in ¬A must go down), and so
on. The only controversial axiom is that degrees of belief must be numbers, or at least act
like numbers in that they must be transitive (if belief in A is greater than belief in B, which is
greater than belief in C, then belief in A must be greater than C) and comparable (the belief
in A must be one of equal to, greater than, or less than belief in B). It can then be proved that
probability is the only approach that satisfies these axioms.
The world being the way it is, however, practical demonstrations sometimes speak
louder than proofs. The success of reasoning systems based on probability theory has been
much more effective in making converts. We now look at how the axioms can be deployed to
make inferences.
13.3 INFERENCE USING FULL JOINT DISTRIBUTIONS
In this section we describe a simple method for probabilistic inference—that is, the compu- PROBABILISTIC
INFERENCE
tation of posterior probabilities for query propositions given observed evidence. We use the
full joint distribution as the “knowledge base” from which answers to all questions may be derived. Along the way we also introduce several useful techniques for manipulating equations
involving probabilities.
Section 13.3. Inference Using Full Joint Distributions 491
WHERE DO PROBABILITIES COME FROM?
There has been endless debate over the source and status of probability numbers.
The frequentist position is that the numbers can come only from experiments: if
we test 100 people and find that 10 of them have a cavity, then we can say that
the probability of a cavity is approximately 0.1. In this view, the assertion “the
probability of a cavity is 0.1” means that 0.1 is the fraction that would be observed
in the limit of infinitely many samples. From any finite sample, we can estimate
the true fraction and also calculate how accurate our estimate is likely to be.
The objectivist view is that probabilities are real aspects of the universe—
propensities of objects to behave in certain ways—rather than being just descriptions of an observer’s degree of belief. For example, the fact that a fair coin comes
up heads with probability 0.5 is a propensity of the coin itself. In this view, frequentist measurements are attempts to observe these propensities. Most physicists
agree that quantum phenomena are objectively probabilistic, but uncertainty at the
macroscopic scale—e.g., in coin tossing—usually arises from ignorance of initial
conditions and does not seem consistent with the propensity view.
The subjectivist view describes probabilities as a way of characterizing an
agent’s beliefs, rather than as having any external physical significance. The subjective Bayesian view allows any self-consistent ascription of prior probabilities to
propositions, but then insists on proper Bayesian updating as evidence arrives.
In the end, even a strict frequentist position involves subjective analysis because of the reference class problem: in trying to determine the outcome probability of a particular experiment, the frequentist has to place it in a reference class of
“similar” experiments with known outcome frequencies. I. J. Good (1983, p. 27)
wrote, “every event in life is unique, and every real-life probability that we estimate in practice is that of an event that has never occurred before.” For example,
given a particular patient, a frequentist who wants to estimate the probability of a
cavity will consider a reference class of other patients who are similar in important
ways—age, symptoms, diet—and see what proportion of them had a cavity. If the
dentist considers everything that is known about the patient—weight to the nearest
gram, hair color, mother’s maiden name—then the reference class becomes empty.
This has been a vexing problem in the philosophy of science.
The principle of indifference attributed to Laplace (1816) states that propositions that are syntactically “symmetric” with respect to the evidence should be
accorded equal probability. Various refinements have been proposed, culminating
in the attempt by Carnap and others to develop a rigorous inductive logic, capable of computing the correct probability for any proposition from any collection of
observations. Currently, it is believed that no unique inductive logic exists; rather,
any such logic rests on a subjective prior probability distribution whose effect is
diminished as more observations are collected.
492 Chapter 13. Quantifying Uncertainty
toothache ¬toothache
catch ¬catch catch ¬catch
cavity 0.108 0.012 0.072 0.008
¬cavity 0.016 0.064 0.144 0.576
Figure 13.3 A full joint distribution for the Toothache, Cavity, Catch world.
We begin with a simple example: a domain consisting of just the three Boolean variables
Toothache, Cavity, and Catch (the dentist’s nasty steel probe catches in my tooth). The full
joint distribution is a 2 × 2 × 2 table as shown in Figure 13.3.
Notice that the probabilities in the joint distribution sum to 1, as required by the axioms
of probability. Notice also that Equation (13.2) gives us a direct way to calculate the probability of any proposition, simple or complex: simply identify those possible worlds in which the
proposition is true and add up their probabilities. For example, there are six possible worlds
in which cavity ∨ toothache holds:
P(cavity ∨ toothache)=0.108 + 0.012 + 0.072 + 0.008 + 0.016 + 0.064 = 0.28 .
One particularly common task is to extract the distribution over some subset of variables or
a single variable. For example, adding the entries in the first row gives the unconditional or
marginal probability4 of cavity: MARGINAL
PROBABILITY
P(cavity)=0.108 + 0.012 + 0.072 + 0.008 = 0.2 .
MARGINALIZATION This process is called marginalization, or summing out—because we sum up the probabilities for each possible value of the other variables, thereby taking them out of the equation.
We can write the following general marginalization rule for any sets of variables Y and Z:
P(Y) = 
z∈Z
P(Y, z) , (13.6)
where
z∈Z means to sum over all the possible combinations of values of the set of variables
Z. We sometimes abbreviate this as
z, leaving Z implicit. We just used the rule as
P(Cavity) = 
z∈{Catch,Toothache}
P(Cavity, z) . (13.7)
A variant of this rule involves conditional probabilities instead of joint probabilities, using
the product rule:
P(Y) = 
z
P(Y | z)P(z) . (13.8)
CONDITIONING This rule is called conditioning. Marginalization and conditioning turn out to be useful rules
for all kinds of derivations involving probability expressions.
In most cases, we are interested in computing conditional probabilities of some variables, given evidence about others. Conditional probabilities can be found by first using
4 So called because of a common practice among actuaries of writing the sums of observed frequencies in the
margins of insurance tables.
Section 13.3. Inference Using Full Joint Distributions 493
Equation (13.3) to obtain an expression in terms of unconditional probabilities and then evaluating the expression from the full joint distribution. For example, we can compute the
probability of a cavity, given evidence of a toothache, as follows:
P(cavity | toothache) = P(cavity ∧ toothache)
P(toothache)
= 0.108 + 0.012
0.108 + 0.012 + 0.016 + 0.064 = 0.6 .
Just to check, we can also compute the probability that there is no cavity, given a toothache:
P(¬cavity |toothache) = P(¬cavity ∧ toothache)
P(toothache)
= 0.016 + 0.064
0.108 + 0.012 + 0.016 + 0.064 = 0.4 .
The two values sum to 1.0, as they should. Notice that in these two calculations the term
1/P(toothache ) remains constant, no matter which value of Cavity we calculate. In fact,
NORMALIZATION it can be viewed as a normalization constant for the distribution P(Cavity |toothache),
ensuring that it adds up to 1. Throughout the chapters dealing with probability, we use α to
denote such constants. With this notation, we can write the two preceding equations in one:
P(Cavity |toothache) = α P(Cavity,toothache)
= α [P(Cavity,toothache, catch) + P(Cavity,toothache,¬catch)]
= α [0.108, 0.016 + 0.012, 0.064] = α 0.12, 0.08 = 0.6, 0.4 .
In other words, we can calculate P(Cavity |toothache) even if we don’t know the value of
P(toothache)! We temporarily forget about the factor 1/P(toothache ) and add up the values
for cavity and ¬cavity, getting 0.12 and 0.08. Those are the correct relative proportions, but
they don’t sum to 1, so we normalize them by dividing each one by 0.12 + 0.08, getting
the true probabilities of 0.6 and 0.4. Normalization turns out to be a useful shortcut in many
probability calculations, both to make the computation easier and to allow us to proceed when
some probability assessment (such as P(toothache)) is not available.
From the example, we can extract a general inference procedure. We begin with the
case in which the query involves a single variable, X (Cavity in the example). Let E be the
list of evidence variables (just Toothache in the example), let e be the list of observed values
for them, and let Y be the remaining unobserved variables (just Catch in the example). The
query is P(X | e) and can be evaluated as
P(X | e) = α P(X, e) = α

y
P(X, e, y) , (13.9)
where the summation is over all possible ys (i.e., all possible combinations of values of the
unobserved variables Y). Notice that together the variables X, E, and Y constitute the complete set of variables for the domain, so P(X, e, y) is simply a subset of probabilities from the
full joint distribution.
Given the full joint distribution to work with, Equation (13.9) can answer probabilistic
queries for discrete variables. It does not scale well, however: for a domain described by n
Boolean variables, it requires an input table of size O(2n) and takes O(2n) time to process the
494 Chapter 13. Quantifying Uncertainty
table. In a realistic problem we could easily have n > 100, making O(2n) impractical. The
full joint distribution in tabular form is just not a practical tool for building reasoning systems.
Instead, it should be viewed as the theoretical foundation on which more effective approaches
may be built, just as truth tables formed a theoretical foundation for more practical algorithms
like DPLL. The remainder of this chapter introduces some of the basic ideas required in
preparation for the development of realistic systems in Chapter 14.
13.4 INDEPENDENCE
Let us expand the full joint distribution in Figure 13.3 by adding a fourth variable, Weather .
The full joint distribution then becomes P(Toothache, Catch, Cavity,Weather ), which has
2 × 2 × 2 × 4 = 32 entries. It contains four “editions” of the table shown in Figure 13.3,
one for each kind of weather. What relationship do these editions have to each other and to
the original three-variable table? For example, how are P(toothache, catch, cavity, cloudy)
and P(toothache, catch, cavity) related? We can use the product rule:
P(toothache, catch, cavity, cloudy)
= P(cloudy |toothache, catch, cavity)P(toothache, catch, cavity) .
Now, unless one is in the deity business, one should not imagine that one’s dental problems
influence the weather. And for indoor dentistry, at least, it seems safe to say that the weather
does not influence the dental variables. Therefore, the following assertion seems reasonable:
P(cloudy |toothache, catch, cavity) = P(cloudy) . (13.10)
From this, we can deduce
P(toothache, catch, cavity, cloudy) = P(cloudy)P(toothache, catch, cavity) .
A similar equation exists for every entry in P(Toothache, Catch, Cavity,Weather ). In fact,
we can write the general equation
P(Toothache, Catch, Cavity, Weather ) = P(Toothache, Catch, Cavity)P(Weather ) .
Thus, the 32-element table for four variables can be constructed from one 8-element table
and one 4-element table. This decomposition is illustrated schematically in Figure 13.4(a).
INDEPENDENCE The property we used in Equation (13.10) is called independence (also marginal independence and absolute independence). In particular, the weather is independent of one’s
dental problems. Independence between propositions a and b can be written as
P(a | b) = P(a) or P(b | a) = P(b) or P(a ∧ b) = P(a)P(b) . (13.11)
All these forms are equivalent (Exercise 13.12). Independence between variables X and Y
can be written as follows (again, these are all equivalent):
P(X | Y ) = P(X) or P(Y | X) = P(Y ) or P(X, Y ) = P(X)P(Y ) .
Independence assertions are usually based on knowledge of the domain. As the toothache–
weather example illustrates, they can dramatically reduce the amount of information necessary to specify the full joint distribution. If the complete set of variables can be divided
Section 13.5. Bayes’ Rule and Its Use 495
Weather
Toothache Catch
Cavity
decomposes
 into
Toothache Catch Weather
Cavity
decomposes
 into
Coin1 Coinn
Coin1 Coinn
(a) (b)
Figure 13.4 Two examples of factoring a large joint distribution into smaller distributions,
using absolute independence. (a) Weather and dental problems are independent. (b) Coin
flips are independent.
into independent subsets, then the full joint distribution can be factored into separate joint
distributions on those subsets. For example, the full joint distribution on the outcome of n
independent coin flips, P(C1,...,Cn), has 2n entries, but it can be represented as the product of n single-variable distributions P(Ci). In a more practical vein, the independence of
dentistry and meteorology is a good thing, because otherwise the practice of dentistry might
require intimate knowledge of meteorology, and vice versa.
When they are available, then, independence assertions can help in reducing the size of
the domain representation and the complexity of the inference problem. Unfortunately, clean
separation of entire sets of variables by independence is quite rare. Whenever a connection,
however indirect, exists between two variables, independence will fail to hold. Moreover,
even independent subsets can be quite large—for example, dentistry might involve dozens of
diseases and hundreds of symptoms, all of which are interrelated. To handle such problems,
we need more subtle methods than the straightforward concept of independence.
13.5 BAYES’ RULE AND ITS USE
On page 486, we defined the product rule. It can actually be written in two forms:
P(a ∧ b) = P(a | b)P(b) and P(a ∧ b) = P(b | a)P(a) .
Equating the two right-hand sides and dividing by P(a), we get
P(b | a) = P(a | b)P(b)
P(a) . (13.12)
BAYES’ RULE This equation is known as Bayes’ rule (also Bayes’ law or Bayes’ theorem). This simple
equation underlies most modern AI systems for probabilistic inference.
496 Chapter 13. Quantifying Uncertainty
The more general case of Bayes’ rule for multivalued variables can be written in the P
notation as follows:
P(Y | X) = P(X | Y )P(Y )
P(X) ,
As before, this is to be taken as representing a set of equations, each dealing with specific values of the variables. We will also have occasion to use a more general version conditionalized
on some background evidence e:
P(Y | X, e) = P(X | Y, e)P(Y | e)
P(X | e) . (13.13)
13.5.1 Applying Bayes’ rule: The simple case
On the surface, Bayes’ rule does not seem very useful. It allows us to compute the single
term P(b | a) in terms of three terms: P(a | b), P(b), and P(a). That seems like two steps
backwards, but Bayes’ rule is useful in practice because there are many cases where we do
have good probability estimates for these three numbers and need to compute the fourth.
Often, we perceive as evidence the effect of some unknown cause and we would like to
determine that cause. In that case, Bayes’ rule becomes
P(cause | effect) = P(effect | cause)P(cause)
P(effect) .
CAUSAL The conditional probability P(effect | cause) quantifies the relationship in the causal direcDIAGNOSTIC tion, whereas P(cause | effect) describes the diagnostic direction. In a task such as medical
diagnosis, we often have conditional probabilities on causal relationships (that is, the doctor
knows P(symptoms | disease)) and want to derive a diagnosis, P(disease | symptoms). For
example, a doctor knows that the disease meningitis causes the patient to have a stiff neck,
say, 70% of the time. The doctor also knows some unconditional facts: the prior probability that a patient has meningitis is 1/50,000, and the prior probability that any patient has a
stiff neck is 1%. Letting s be the proposition that the patient has a stiff neck and m be the
proposition that the patient has meningitis, we have
P(s | m)=0.7
P(m)=1/50000
P(s)=0.01
P(m | s) = P(s | m)P(m)
P(s) = 0.7 × 1/50000
0.01 = 0.0014 . (13.14)
That is, we expect less than 1 in 700 patients with a stiff neck to have meningitis. Notice that
even though a stiff neck is quite strongly indicated by meningitis (with probability 0.7), the
probability of meningitis in the patient remains small. This is because the prior probability of
stiff necks is much higher than that of meningitis.
Section 13.3 illustrated a process by which one can avoid assessing the prior probability
of the evidence (here, P(s)) by instead computing a posterior probability for each value of
Section 13.5. Bayes’ Rule and Its Use 497
the query variable (here, m and ¬m) and then normalizing the results. The same process can
be applied when using Bayes’ rule. We have
P(M | s) = α P(s | m)P(m), P(s | ¬m)P(¬m) .
Thus, to use this approach we need to estimate P(s | ¬m) instead of P(s). There is no free
lunch—sometimes this is easier, sometimes it is harder. The general form of Bayes’ rule with
normalization is
P(Y | X) = α P(X | Y )P(Y ) , (13.15)
where α is the normalization constant needed to make the entries in P(Y | X) sum to 1.
One obvious question to ask about Bayes’ rule is why one might have available the
conditional probability in one direction, but not the other. In the meningitis domain, perhaps
the doctor knows that a stiff neck implies meningitis in 1 out of 5000 cases; that is, the doctor
has quantitative information in the diagnostic direction from symptoms to causes. Such a
doctor has no need to use Bayes’ rule. Unfortunately, diagnostic knowledge is often more
fragile than causal knowledge. If there is a sudden epidemic of meningitis, the unconditional
probability of meningitis, P(m), will go up. The doctor who derived the diagnostic probability P(m | s) directly from statistical observation of patients before the epidemic will have
no idea how to update the value, but the doctor who computes P(m | s) from the other three
values will see that P(m | s) should go up proportionately with P(m). Most important, the
causal information P(s | m) is unaffected by the epidemic, because it simply reflects the way
meningitis works. The use of this kind of direct causal or model-based knowledge provides
the crucial robustness needed to make probabilistic systems feasible in the real world.
13.5.2 Using Bayes’ rule: Combining evidence
We have seen that Bayes’ rule can be useful for answering probabilistic queries conditioned
on one piece of evidence—for example, the stiff neck. In particular, we have argued that
probabilistic information is often available in the form P(effect | cause). What happens when
we have two or more pieces of evidence? For example, what can a dentist conclude if her
nasty steel probe catches in the aching tooth of a patient? If we know the full joint distribution
(Figure 13.3), we can read off the answer:
P(Cavity |toothache ∧ catch) = α 0.108, 0.016≈0.871, 0.129 .
We know, however, that such an approach does not scale up to larger numbers of variables.
We can try using Bayes’ rule to reformulate the problem:
P(Cavity |toothache ∧ catch)
= α P(toothache ∧ catch | Cavity) P(Cavity) . (13.16)
For this reformulation to work, we need to know the conditional probabilities of the conjunction toothache ∧catch for each value of Cavity. That might be feasible for just two evidence
variables, but again it does not scale up. If there are n possible evidence variables (X rays,
diet, oral hygiene, etc.), then there are 2n possible combinations of observed values for which
we would need to know conditional probabilities. We might as well go back to using the
full joint distribution. This is what first led researchers away from probability theory toward
498 Chapter 13. Quantifying Uncertainty
approximate methods for evidence combination that, while giving incorrect answers, require
fewer numbers to give any answer at all.
Rather than taking this route, we need to find some additional assertions about the
domain that will enable us to simplify the expressions. The notion of independence in Section 13.4 provides a clue, but needs refining. It would be nice if Toothache and Catch were
independent, but they are not: if the probe catches in the tooth, then it is likely that the tooth
has a cavity and that the cavity causes a toothache. These variables are independent, however, given the presence or the absence of a cavity. Each is directly caused by the cavity, but
neither has a direct effect on the other: toothache depends on the state of the nerves in the
tooth, whereas the probe’s accuracy depends on the dentist’s skill, to which the toothache is
irrelevant.5 Mathematically, this property is written as
P(toothache ∧ catch | Cavity) = P(toothache | Cavity)P(catch | Cavity) . (13.17)
This equation expresses the conditional independence of toothache and catch given Cavity. CONDITIONAL
INDEPENDENCE
We can plug it into Equation (13.16) to obtain the probability of a cavity:
P(Cavity |toothache ∧ catch)
= α P(toothache | Cavity) P(catch | Cavity) P(Cavity) . (13.18)
Now the information requirements are the same as for inference, using each piece of evidence separately: the prior probability P(Cavity) for the query variable and the conditional
probability of each effect, given its cause.
The general definition of conditional independence of two variables X and Y , given a
third variable Z, is
P(X, Y | Z) = P(X | Z)P(Y | Z) .
In the dentist domain, for example, it seems reasonable to assert conditional independence of
the variables Toothache and Catch, given Cavity:
P(Toothache, Catch | Cavity) = P(Toothache | Cavity)P(Catch | Cavity) . (13.19)
Notice that this assertion is somewhat stronger than Equation (13.17), which asserts independence only for specific values of Toothache and Catch. As with absolute independence in
Equation (13.11), the equivalent forms
P(X | Y,Z) = P(X |Z) and P(Y | X, Z) = P(Y | Z)
can also be used (see Exercise 13.17). Section 13.4 showed that absolute independence assertions allow a decomposition of the full joint distribution into much smaller pieces. It turns
out that the same is true for conditional independence assertions. For example, given the
assertion in Equation (13.19), we can derive a decomposition as follows:
P(Toothache, Catch, Cavity)
= P(Toothache, Catch | Cavity)P(Cavity) (product rule)
= P(Toothache | Cavity)P(Catch | Cavity)P(Cavity) (using 13.19).
(The reader can easily check that this equation does in fact hold in Figure 13.3.) In this way,
the original large table is decomposed into three smaller tables. The original table has seven
5 We assume that the patient and dentist are distinct individuals.
Section 13.6. The Wumpus World Revisited 499
independent numbers (23 = 8 entries in the table, but they must sum to 1, so 7 are independent). The smaller tables contain five independent numbers (for a conditional probability
distributions such as P(T|C there are two rows of two numbers, and each row sums to 1, so
that’s two independent numbers; for a prior distribution like P(C) there is only one independent number). Going from seven to five might not seem like a major triumph, but the point
is that, for n symptoms that are all conditionally independent given Cavity, the size of the
representation grows as O(n) instead of O(2n). That means that conditional independence
assertions can allow probabilistic systems to scale up; moreover, they are much more comSEPARATION monly available than absolute independence assertions. Conceptually, Cavity separates
Toothache and Catch because it is a direct cause of both of them. The decomposition of
large probabilistic domains into weakly connected subsets through conditional independence
is one of the most important developments in the recent history of AI.
The dentistry example illustrates a commonly occurring pattern in which a single cause
directly influences a number of effects, all of which are conditionally independent, given the
cause. The full joint distribution can be written as
P(Cause, Effect1,..., Effectn) = P(Cause)

i
P(Effecti | Cause) .
NAIVE BAYES Such a probability distribution is called a naive Bayes model—“naive” because it is often
used (as a simplifying assumption) in cases where the “effect” variables are not actually
conditionally independent given the cause variable. (The naive Bayes model is sometimes
called a Bayesian classifier, a somewhat careless usage that has prompted true Bayesians
to call it the idiot Bayes model.) In practice, naive Bayes systems can work surprisingly
well, even when the conditional independence assumption is not true. Chapter 20 describes
methods for learning naive Bayes distributions from observations.
13.6 THE WUMPUS WORLD REVISITED
We can combine of the ideas in this chapter to solve probabilistic reasoning problems in the
wumpus world. (See Chapter 7 for a complete description of the wumpus world.) Uncertainty
arises in the wumpus world because the agent’s sensors give only partial information about
the world. For example, Figure 13.5 shows a situation in which each of the three reachable
squares—[1,3], [2,2], and [3,1]—might contain a pit. Pure logical inference can conclude
nothing about which square is most likely to be safe, so a logical agent might have to choose
randomly. We will see that a probabilistic agent can do much better than the logical agent.
Our aim is to calculate the probability that each of the three squares contains a pit. (For
this example we ignore the wumpus and the gold.) The relevant properties of the wumpus
world are that (1) a pit causes breezes in all neighboring squares, and (2) each square other
than [1,1] contains a pit with probability 0.2. The first step is to identify the set of random
variables we need:
• As in the propositional logic case, we want one Boolean variable Pij for each square,
which is true iff square [i, j] actually contains a pit.
500 Chapter 13. Quantifying Uncertainty
OK
 1,1 2,1 3,1 4,1
 1,2 2,2 3,2 4,2
 1,3 2,3 3,3 4,3
 1,4 2,4
OK OK
 3,4 4,4
B
B
 1,1 2,1 3,1 4,1
 1,2 2,2 3,2 4,2
 1,3 2,3 3,3 4,3
 1,4 2,4 3,4 4,4
KNOWN
FRONTIER
QUERY
OTHER
(a) (b)
Figure 13.5 (a) After finding a breeze in both [1,2] and [2,1], the agent is stuck—there is
no safe place to explore. (b) Division of the squares into Known, Frontier , and Other , for
a query about [1,3].
• We also have Boolean variables Bij that are true iff square [i, j] is breezy; we include
these variables only for the observed squares—in this case, [1,1], [1,2], and [2,1].
The next step is to specify the full joint distribution, P(P1,1,...,P4,4, B1,1, B1,2, B2,1). Applying the product rule, we have
P(P1,1,...,P4,4, B1,1, B1,2, B2,1) =
P(B1,1, B1,2, B2,1 | P1,1,...,P4,4)P(P1,1,...,P4,4) .
This decomposition makes it easy to see what the joint probability values should be. The
first term is the conditional probability distribution of a breeze configuration, given a pit
configuration; its values are 1 if the breezes are adjacent to the pits and 0 otherwise. The
second term is the prior probability of a pit configuration. Each square contains a pit with
probability 0.2, independently of the other squares; hence,
P(P1,1,...,P4,4) = 
4,4
i,j = 1,1
P(Pi,j ) . (13.20)
For a particular configuration with exactly n pits, P(P1,1,...,P4,4)=0.2n × 0.816−n.
In the situation in Figure 13.5(a), the evidence consists of the observed breeze (or its
absence) in each square that is visited, combined with the fact that each such square contains
no pit. We abbreviate these facts as b = ¬b1,1∧b1,2∧b2,1 and known = ¬p1,1∧¬p1,2∧¬p2,1.
We are interested in answering queries such as P(P1,3 | known, b): how likely is it that [1,3]
contains a pit, given the observations so far?
To answer this query, we can follow the standard approach of Equation (13.9), namely,
summing over entries from the full joint distribution. Let Unknown be the set of Pi,j vari-
Section 13.6. The Wumpus World Revisited 501
ables for squares other than the Known squares and the query square [1,3]. Then, by Equation (13.9), we have
P(P1,3 | known, b) = α 
unknown
P(P1,3, unknown, known, b) .
The full joint probabilities have already been specified, so we are done—that is, unless we
care about computation. There are 12 unknown squares; hence the summation contains
212 = 4096 terms. In general, the summation grows exponentially with the number of squares.
Surely, one might ask, aren’t the other squares irrelevant? How could [4,4] affect
whether [1,3] has a pit? Indeed, this intuition is correct. Let Frontier be the pit variables
(other than the query variable) that are adjacent to visited squares, in this case just [2,2] and
[3,1]. Also, let Other be the pit variables for the other unknown squares; in this case, there are
10 other squares, as shown in Figure 13.5(b). The key insight is that the observed breezes are
conditionally independent of the other variables, given the known, frontier, and query variables. To use the insight, we manipulate the query formula into a form in which the breezes
are conditioned on all the other variables, and then we apply conditional independence:
P(P1,3 | known, b)
= α 
unknown
P(P1,3, known, b, unknown) (by Equation (13.9))
= α 
unknown
P(b | P1,3, known, unknown)P(P1,3, known, unknown)
(by the product rule)
= α 
frontier

other
P(b | known, P1,3, frontier , other )P(P1,3, known, frontier , other )
= α 
frontier

other
P(b | known, P1,3, frontier )P(P1,3, known, frontier , other ) ,
where the final step uses conditional independence: b is independent of other given known,
P1,3, and frontier . Now, the first term in this expression does not depend on the Other
variables, so we can move the summation inward:
P(P1,3 | known, b)
= α 
frontier
P(b | known, P1,3, frontier )

other
P(P1,3, known, frontier , other ) .
By independence, as in Equation (13.20), the prior term can be factored, and then the terms
can be reordered:
P(P1,3 | known, b)
= α 
frontier
P(b | known, P1,3, frontier )

other
P(P1,3)P(known)P(frontier )P(other )
= α P(known)P(P1,3) 
frontier
P(b | known, P1,3, frontier )P(frontier )

other
P(other )
= α P(P1,3) 
frontier
P(b | known, P1,3, frontier )P(frontier ) ,
502 Chapter 13. Quantifying Uncertainty
OK
 1,1 2,1 3,1
 1,2
OK OK
B
B
OK
 1,1 2,1
 1,2 2,2
OK OK
B
B
OK
 1,1 2,1 3,1
 1,2
OK OK
B
B
0.2 x 0.2 = 0.04 0.2 x 0.8 = 0.16 0.8 x 0.2 = 0.16
OK
 1,1 2,1
 1,2
 1,3
OK OK
B
B
OK
 1,1 2,1 3,1
 1,2
 1,3
OK OK
B
B
0.2 x 0.2 = 0.04 0.2 x 0.8 = 0.16
(a) (b)
 2,2
 1,3
 3,1
 1,3
 2,2
 1,3
 3,1
 2,2 2,2
Figure 13.6 Consistent models for the frontier variables P2,2 and P3,1, showing
P(frontier ) for each model: (a) three models with P1,3 = true showing two or three pits,
and (b) two models with P1,3 = false showing one or two pits.
where the last step folds

P(known) into the normalizing constant and uses the fact that
other P(other ) equals 1.
Now, there are just four terms in the summation over the frontier variables P2,2 and
P3,1. The use of independence and conditional independence has completely eliminated the
other squares from consideration.
Notice that the expression P(b | known, P1,3, frontier ) is 1 when the frontier is consistent with the breeze observations, and 0 otherwise. Thus, for each value of P1,3, we sum over
the logical models for the frontier variables that are consistent with the known facts. (Compare with the enumeration over models in Figure 7.5 on page 241.) The models and their
associated prior probabilities—P(frontier )—are shown in Figure 13.6. We have
P(P1,3 | known, b) = α 0.2(0.04 + 0.16 + 0.16), 0.8(0.04 + 0.16)≈0.31, 0.69 .
That is, [1,3] (and [3,1] by symmetry) contains a pit with roughly 31% probability. A similar
calculation, which the reader might wish to perform, shows that [2,2] contains a pit with
roughly 86% probability. The wumpus agent should definitely avoid [2,2]! Note that our
logical agent from Chapter 7 did not know that [2,2] was worse than the other squares. Logic
can tell us that it is unknown whether there is a pit in [2, 2], but we need probability to tell us
how likely it is.
What this section has shown is that even seemingly complicated problems can be formulated precisely in probability theory and solved with simple algorithms. To get efficient
solutions, independence and conditional independence relationships can be used to simplify
the summations required. These relationships often correspond to our natural understanding
of how the problem should be decomposed. In the next chapter, we develop formal representations for such relationships as well as algorithms that operate on those representations to
perform probabilistic inference efficiently.
Section 13.7. Summary 503
13.7 SUMMARY
This chapter has suggested probability theory as a suitable foundation for uncertain reasoning
and provided a gentle introduction to its use.
• Uncertainty arises because of both laziness and ignorance. It is inescapable in complex,
nondeterministic, or partially observable environments.
• Probabilities express the agent’s inability to reach a definite decision regarding the truth
of a sentence. Probabilities summarize the agent’s beliefs relative to the evidence.
• Decision theory combines the agent’s beliefs and desires, defining the best action as the
one that maximizes expected utility.
• Basic probability statements include prior probabilities and conditional probabilities
over simple and complex propositions.
• The axioms of probability constrain the possible assignments of probabilities to propositions. An agent that violates the axioms must behave irrationally in some cases.
• The full joint probability distribution specifies the probability of each complete assignment of values to random variables. It is usually too large to create or use in its
explicit form, but when it is available it can be used to answer queries simply by adding
up entries for the possible worlds corresponding to the query propositions.
• Absolute independence between subsets of random variables allows the full joint distribution to be factored into smaller joint distributions, greatly reducing its complexity.
Absolute independence seldom occurs in practice.
• Bayes’ rule allows unknown probabilities to be computed from known conditional
probabilities, usually in the causal direction. Applying Bayes’ rule with many pieces of
evidence runs into the same scaling problems as does the full joint distribution.
• Conditional independence brought about by direct causal relationships in the domain
might allow the full joint distribution to be factored into smaller, conditional distributions. The naive Bayes model assumes the conditional independence of all effect
variables, given a single cause variable, and grows linearly with the number of effects.
• A wumpus-world agent can calculate probabilities for unobserved aspects of the world,
thereby improving on the decisions of a purely logical agent. Conditional independence
makes these calculations tractable.
BIBLIOGRAPHICAL AND HISTORICAL NOTES
Probability theory was invented as a way of analyzing games of chance. In about 850 A.D.
the Indian mathematician Mahaviracarya described how to arrange a set of bets that can’t lose
(what we now call a Dutch book). In Europe, the first significant systematic analyses were
produced by Girolamo Cardano around 1565, although publication was posthumous (1663).
By that time, probability had been established as a mathematical discipline due to a series of
504 Chapter 13. Quantifying Uncertainty
results established in a famous correspondence between Blaise Pascal and Pierre de Fermat
in 1654. As with probability itself, the results were initially motivated by gambling problems
(see Exercise 13.9). The first published textbook on probability was De Ratiociniis in Ludo
Aleae (Huygens, 1657). The “laziness and ignorance” view of uncertainty was described
by John Arbuthnot in the preface of his translation of Huygens (Arbuthnot, 1692): “It is
impossible for a Die, with such determin’d force and direction, not to fall on such determin’d
side, only I don’t know the force and direction which makes it fall on such determin’d side,
and therefore I call it Chance, which is nothing but the want of art...”
Laplace (1816) gave an exceptionally accurate and modern overview of probability; he
was the first to use the example “take two urns, A and B, the first containing four white and
two black balls, . . . ” The Rev. Thomas Bayes (1702–1761) introduced the rule for reasoning
about conditional probabilities that was named after him (Bayes, 1763). Bayes only considered the case of uniform priors; it was Laplace who independently developed the general
case. Kolmogorov (1950, first published in German in 1933) presented probability theory in
a rigorously axiomatic framework for the first time. R´enyi (1970) later gave an axiomatic
presentation that took conditional probability, rather than absolute probability, as primitive.
Pascal used probability in ways that required both the objective interpretation, as a property of the world based on symmetry or relative frequency, and the subjective interpretation,
based on degree of belief—the former in his analyses of probabilities in games of chance, the
latter in the famous “Pascal’s wager” argument about the possible existence of God. However, Pascal did not clearly realize the distinction between these two interpretations. The
distinction was first drawn clearly by James Bernoulli (1654–1705).
Leibniz introduced the “classical” notion of probability as a proportion of enumerated,
equally probable cases, which was also used by Bernoulli, although it was brought to prominence by Laplace (1749–1827). This notion is ambiguous between the frequency interpretation and the subjective interpretation. The cases can be thought to be equally probable either
because of a natural, physical symmetry between them, or simply because we do not have
any knowledge that would lead us to consider one more probable than another. The use of
this latter, subjective consideration to justify assigning equal probabilities is known as the
principle of indifference. The principle is often attributed to Laplace, but he never isolated PRINCIPLE OF
INDIFFERENCE
the principle explicitly. George Boole and John Venn both referred to it as the principle of
insufficient reason; the modern name is due to Keynes (1921). PRINCIPLE OF
INSUFFICIENT
REASON
The debate between objectivists and subjectivists became sharper in the 20th century.
Kolmogorov (1963), R. A. Fisher (1922), and Richard von Mises (1928) were advocates of
the relative frequency interpretation. Karl Popper’s (1959, first published in German in 1934)
“propensity” interpretation traces relative frequencies to an underlying physical symmetry.
Frank Ramsey (1931), Bruno de Finetti (1937), R. T. Cox (1946), Leonard Savage (1954),
Richard Jeffrey (1983), and E. T. Jaynes (2003) interpreted probabilities as the degrees of
belief of specific individuals. Their analyses of degree of belief were closely tied to utilities and to behavior—specifically, to the willingness to place bets. Rudolf Carnap, following
Leibniz and Laplace, offered a different kind of subjective interpretation of probability—
not as any actual individual’s degree of belief, but as the degree of belief that an idealized
individual should have in a particular proposition a, given a particular body of evidence e.
Bibliographical and Historical Notes 505
Carnap attempted to go further than Leibniz or Laplace by making this notion of degree of
CONFIRMATION confirmation mathematically precise, as a logical relation between a and e. The study of this
INDUCTIVE LOGIC relation was intended to constitute a mathematical discipline called inductive logic, analogous to ordinary deductive logic (Carnap, 1948, 1950). Carnap was not able to extend his
inductive logic much beyond the propositional case, and Putnam (1963) showed by adversarial arguments that some fundamental difficulties would prevent a strict extension to languages
capable of expressing arithmetic.
Cox’s theorem (1946) shows that any system for uncertain reasoning that meets his set
of assumptions is equivalent to probability theory. This gave renewed confidence to those
who already favored probability, but others were not convinced, pointing to the assumptions
(primarily that belief must be represented by a single number, and thus the belief in ¬p must
be a function of the belief in p). Halpern (1999) describes the assumptions and shows some
gaps in Cox’s original formulation. Horn (2003) shows how to patch up the difficulties.
Jaynes (2003) has a similar argument that is easier to read.
The question of reference classes is closely tied to the attempt to find an inductive logic.
The approach of choosing the “most specific” reference class of sufficient size was formally
proposed by Reichenbach (1949). Various attempts have been made, notably by Henry Kyburg (1977, 1983), to formulate more sophisticated policies in order to avoid some obvious
fallacies that arise with Reichenbach’s rule, but such approaches remain somewhat ad hoc.
More recent work by Bacchus, Grove, Halpern, and Koller (1992) extends Carnap’s methods
to first-order theories, thereby avoiding many of the difficulties associated with the straightforward reference-class method. Kyburg and Teng (2006) contrast probabilistic inference
with nonmonotonic logic.
Bayesian probabilistic reasoning has been used in AI since the 1960s, especially in
medical diagnosis. It was used not only to make a diagnosis from available evidence, but also
to select further questions and tests by using the theory of information value (Section 16.6)
when available evidence was inconclusive (Gorry, 1968; Gorry et al., 1973). One system
outperformed human experts in the diagnosis of acute abdominal illnesses (de Dombal et al.,
1974). Lucas et al. (2004) gives an overview. These early Bayesian systems suffered from a
number of problems, however. Because they lacked any theoretical model of the conditions
they were diagnosing, they were vulnerable to unrepresentative data occurring in situations
for which only a small sample was available (de Dombal et al., 1981). Even more fundamentally, because they lacked a concise formalism (such as the one to be described in Chapter 14)
for representing and using conditional independence information, they depended on the acquisition, storage, and processing of enormous tables of probabilistic data. Because of these
difficulties, probabilistic methods for coping with uncertainty fell out of favor in AI from the
1970s to the mid-1980s. Developments since the late 1980s are described in the next chapter.
The naive Bayes model for joint distributions has been studied extensively in the pattern recognition literature since the 1950s (Duda and Hart, 1973). It has also been used, often
unwittingly, in information retrieval, beginning with the work of Maron (1961). The probabilistic foundations of this technique, described further in Exercise 13.22, were elucidated by
Robertson and Sparck Jones (1976). Domingos and Pazzani (1997) provide an explanation
506 Chapter 13. Quantifying Uncertainty
for the surprising success of naive Bayesian reasoning even in domains where the independence assumptions are clearly violated.
There are many good introductory textbooks on probability theory, including those by
Bertsekas and Tsitsiklis (2008) and Grinstead and Snell (1997). DeGroot and Schervish
(2001) offer a combined introduction to probability and statistics from a Bayesian standpoint. Richard Hamming’s (1991) textbook gives a mathematically sophisticated introduction to probability theory from the standpoint of a propensity interpretation based on physical
symmetry. Hacking (1975) and Hald (1990) cover the early history of the concept of probability. Bernstein (1996) gives an entertaining popular account of the story of risk.
EXERCISES
13.1 Show from first principles that P(a | b ∧ a)=1.
13.2 Using the axioms of probability, prove that any probability distribution on a discrete
random variable must sum to 1.
13.3 For each of the following statements, either prove it is true or give a counterexample.
a. If P(a | b, c) = P(b | a, c), then P(a | c) = P(b | c)
b. If P(a | b, c) = P(a), then P(b | c) = P(b)
c. If P(a | b) = P(a), then P(a | b, c) = P(a | c)
13.4 Would it be rational for an agent to hold the three beliefs P(A)=0.4, P(B)=0.3, and
P(A ∨ B)=0.5? If so, what range of probabilities would be rational for the agent to hold for
A ∧ B? Make up a table like the one in Figure 13.2, and show how it supports your argument
about rationality. Then draw another version of the table where P(A ∨ B)=0.7. Explain
why it is rational to have this probability, even though the table shows one case that is a loss
and three that just break even. (Hint: what is Agent 1 committed to about the probability of
each of the four cases, especially the case that is a loss?)
13.5 This question deals with the properties of possible worlds, defined on page 488 as
assignments to all random variables. We will work with propositions that correspond to
exactly one possible world because they pin down the assignments of all the variables. In
ATOMIC EVENT probability theory, such propositions are called atomic events. For example, with Boolean
variables X1, X2, X3, the proposition x1 ∧ ¬x2 ∧ ¬x3 fixes the assignment of the variables;
in the language of propositional logic, we would say it has exactly one model.
a. Prove, for the case of n Boolean variables, that any two distinct atomic events are
mutually exclusive; that is, their conjunction is equivalent to false.
b. Prove that the disjunction of all possible atomic events is logically equivalent to true.
c. Prove that any proposition is logically equivalent to the disjunction of the atomic events
that entail its truth.
Exercises 507
13.6 Prove Equation (13.4) from Equations (13.1) and (13.2).
13.7 Consider the set of all possible five-card poker hands dealt fairly from a standard deck
of fifty-two cards.
a. How many atomic events are there in the joint probability distribution (i.e., how many
five-card hands are there)?
b. What is the probability of each atomic event?
c. What is the probability of being dealt a royal straight flush? Four of a kind?
13.8 Given the full joint distribution shown in Figure 13.3, calculate the following:
a. P(toothache).
b. P(Cavity).
c. P(Toothache | cavity).
d. P(Cavity | toothache ∨ catch).
13.9 In his letter of August 24, 1654, Pascal was trying to show how a pot of money should
be allocated when a gambling game must end prematurely. Imagine a game where each turn
consists of the roll of a die, player E gets a point when the die is even, and player O gets a
point when the die is odd. The first player to get 7 points wins the pot. Suppose the game is
interrupted with E leading 4–2. How should the money be fairly split in this case? What is
the general formula? (Fermat and Pascal made several errors before solving the problem, but
you should be able to get it right the first time.)
13.10 Deciding to put probability theory to good use, we encounter a slot machine with
three independent wheels, each producing one of the four symbols BAR, BELL, LEMON, or
CHERRY with equal probability. The slot machine has the following payout scheme for a bet
of 1 coin (where “?” denotes that we don’t care what comes up for that wheel):
BAR/BAR/BAR pays 20 coins
BELL/BELL/BELL pays 15 coins
LEMON/LEMON/LEMON pays 5 coins
CHERRY/CHERRY/CHERRY pays 3 coins
CHERRY/CHERRY/? pays 2 coins
CHERRY/?/? pays 1 coin
a. Compute the expected “payback” percentage of the machine. In other words, for each
coin played, what is the expected coin return?
b. Compute the probability that playing the slot machine once will result in a win.
c. Estimate the mean and median number of plays you can expect to make until you go
broke, if you start with 10 coins. You can run a simulation to estimate this, rather than
trying to compute an exact answer.
13.11 We wish to transmit an n-bit message to a receiving agent. The bits in the message are
independently corrupted (flipped) during transmission with  probability each. With an extra
parity bit sent along with the original information, a message can be corrected by the receiver
508 Chapter 13. Quantifying Uncertainty
if at most one bit in the entire message (including the parity bit) has been corrupted. Suppose
we want to ensure that the correct message is received with probability at least 1− δ. What is
the maximum feasible value of n? Calculate this value for the case  = 0.001, δ = 0.01.
13.12 Show that the three forms of independence in Equation (13.11) are equivalent.
13.13 Consider two medical tests, A and B, for a virus. Test A is 95% effective at recognizing the virus when it is present, but has a 10% false positive rate (indicating that the virus
is present, when it is not). Test B is 90% effective at recognizing the virus, but has a 5% false
positive rate. The two tests use independent methods of identifying the virus. The virus is
carried by 1% of all people. Say that a person is tested for the virus using only one of the tests,
and that test comes back positive for carrying the virus. Which test returning positive is more
indicative of someone really carrying the virus? Justify your answer mathematically.
13.14 Suppose you are given a coin that lands heads with probability x and tails with
probability 1 − x. Are the outcomes of successive flips of the coin independent of each
other given that you know the value of x? Are the outcomes of successive flips of the coin
independent of each other if you do not know the value of x? Justify your answer.
13.15 After your yearly checkup, the doctor has bad news and good news. The bad news
is that you tested positive for a serious disease and that the test is 99% accurate (i.e., the
probability of testing positive when you do have the disease is 0.99, as is the probability of
testing negative when you don’t have the disease). The good news is that this is a rare disease,
striking only 1 in 10,000 people of your age. Why is it good news that the disease is rare?
What are the chances that you actually have the disease?
13.16 It is quite often useful to consider the effect of some specific propositions in the
context of some general background evidence that remains fixed, rather than in the complete
absence of information. The following questions ask you to prove more general versions of
the product rule and Bayes’ rule, with respect to some background evidence e:
a. Prove the conditionalized version of the general product rule:
P(X, Y | e) = P(X | Y, e)P(Y | e) .
b. Prove the conditionalized version of Bayes’ rule in Equation (13.13).
13.17 Show that the statement of conditional independence
P(X, Y | Z) = P(X | Z)P(Y | Z)
is equivalent to each of the statements
P(X | Y,Z) = P(X |Z) and P(B | X, Z) = P(Y | Z) .
13.18 Suppose you are given a bag containing n unbiased coins. You are told that n − 1 of
these coins are normal, with heads on one side and tails on the other, whereas one coin is a
fake, with heads on both sides.
a. Suppose you reach into the bag, pick out a coin at random, flip it, and get a head. What
is the (conditional) probability that the coin you chose is the fake coin?
Exercises 509
b. Suppose you continue flipping the coin for a total of k times after picking it and see k
heads. Now what is the conditional probability that you picked the fake coin?
c. Suppose you wanted to decide whether the chosen coin was fake by flipping it k times.
The decision procedure returns fake if all k flips come up heads; otherwise it returns
normal. What is the (unconditional) probability that this procedure makes an error?
13.19 In this exercise, you will complete the normalization calculation for the meningitis
example. First, make up a suitable value for P(s | ¬m), and use it to calculate unnormalized
values for P(m | s) and P(¬m | s) (i.e., ignoring the P(s) term in the Bayes’ rule expression,
Equation (13.14)). Now normalize these values so that they add to 1.
13.20 Let X, Y , Z be Boolean random variables. Label the eight entries in the joint distribution P(X, Y, Z) as a through h. Express the statement that X and Y are conditionally
independent given Z, as a set of equations relating a through h. How many nonredundant
equations are there?
13.21 (Adapted from Pearl (1988).) Suppose you are a witness to a nighttime hit-and-run
accident involving a taxi in Athens. All taxis in Athens are blue or green. You swear, under
oath, that the taxi was blue. Extensive testing shows that, under the dim lighting conditions,
discrimination between blue and green is 75% reliable.
a. Is it possible to calculate the most likely color for the taxi? (Hint: distinguish carefully
between the proposition that the taxi is blue and the proposition that it appears blue.)
b. What if you know that 9 out of 10 Athenian taxis are green?
13.22 Text categorization is the task of assigning a given document to one of a fixed set of
categories on the basis of the text it contains. Naive Bayes models are often used for this
task. In these models, the query variable is the document category, and the “effect” variables
are the presence or absence of each word in the language; the assumption is that words occur
independently in documents, with frequencies determined by the document category.
a. Explain precisely how such a model can be constructed, given as “training data” a set
of documents that have been assigned to categories.
b. Explain precisely how to categorize a new document.
c. Is the conditional independence assumption reasonable? Discuss.
13.23 In our analysis of the wumpus world, we used the fact that each square contains a
pit with probability 0.2, independently of the contents of the other squares. Suppose instead
that exactly N/5 pits are scattered at random among the N squares other than [1,1]. Are
the variables Pi,j and Pk,l still independent? What is the joint distribution P(P1,1,...,P4,4)
now? Redo the calculation for the probabilities of pits in [1,3] and [2,2].
13.24 Redo the probability calculation for pits in [1,3] and [2,2], assuming that each square
contains a pit with probability 0.01, independent of the other squares. What can you say
about the relative performance of a logical versus a probabilistic agent in this case?
13.25 Implement a hybrid probabilistic agent for the wumpus world, based on the hybrid
agent in Figure 7.20 and the probabilistic inference procedure outlined in this chapter.
14 PROBABILISTIC
REASONING
In which we explain how to build network models to reason under uncertainty
according to the laws of probability theory.
Chapter 13 introduced the basic elements of probability theory and noted the importance of
independence and conditional independence relationships in simplifying probabilistic representations of the world. This chapter introduces a systematic way to represent such relationships explicitly in the form of Bayesian networks. We define the syntax and semantics of
these networks and show how they can be used to capture uncertain knowledge in a natural and efficient way. We then show how probabilistic inference, although computationally
intractable in the worst case, can be done efficiently in many practical situations. We also
describe a variety of approximate inference algorithms that are often applicable when exact
inference is infeasible. We explore ways in which probability theory can be applied to worlds
with objects and relations—that is, to first-order, as opposed to propositional, representations.
Finally, we survey alternative approaches to uncertain reasoning.
14.1 REPRESENTING KNOWLEDGE IN AN UNCERTAIN DOMAIN
In Chapter 13, we saw that the full joint probability distribution can answer any question about
the domain, but can become intractably large as the number of variables grows. Furthermore,
specifying probabilities for possible worlds one by one is unnatural and tedious.
We also saw that independence and conditional independence relationships among variables can greatly reduce the number of probabilities that need to be specified in order to define
the full joint distribution. This section introduces a data structure called a Bayesian network1 BAYESIAN NETWORK
to represent the dependencies among variables. Bayesian networks can represent essentially
any full joint probability distribution and in many cases can do so very concisely.
1 This is the most common name, but there are many synonyms, including belief network, probabilistic network, causal network, and knowledge map. In statistics, the term graphical model refers to a somewhat
broader class that includes Bayesian networks. An extension of Bayesian networks called a decision network or
influence diagram is covered in Chapter 16.
510
Section 14.1. Representing Knowledge in an Uncertain Domain 511
A Bayesian network is a directed graph in which each node is annotated with quantitative probability information. The full specification is as follows:
1. Each node corresponds to a random variable, which may be discrete or continuous.
2. A set of directed links or arrows connects pairs of nodes. If there is an arrow from node
X to node Y , X is said to be a parent of Y. The graph has no directed cycles (and hence
is a directed acyclic graph, or DAG.
3. Each node Xi has a conditional probability distribution P(Xi | P arents(Xi))that quantifies the effect of the parents on the node.
The topology of the network—the set of nodes and links—specifies the conditional independence relationships that hold in the domain, in a way that will be made precise shortly. The
intuitive meaning of an arrow is typically that X has a direct influence on Y, which suggests
that causes should be parents of effects. It is usually easy for a domain expert to decide what
direct influences exist in the domain—much easier, in fact, than actually specifying the probabilities themselves. Once the topology of the Bayesian network is laid out, we need only
specify a conditional probability distribution for each variable, given its parents. We will
see that the combination of the topology and the conditional distributions suffices to specify
(implicitly) the full joint distribution for all the variables.
Recall the simple world described in Chapter 13, consisting of the variables Toothache,
Cavity, Catch, and Weather . We argued that Weather is independent of the other variables; furthermore, we argued that Toothache and Catch are conditionally independent,
given Cavity. These relationships are represented by the Bayesian network structure shown
in Figure 14.1. Formally, the conditional independence of Toothache and Catch, given
Cavity, is indicated by the absence of a link between Toothache and Catch. Intuitively, the
network represents the fact that Cavity is a direct cause of Toothache and Catch, whereas
no direct causal relationship exists between Toothache and Catch.
Now consider the following example, which is just a little more complex. You have
a new burglar alarm installed at home. It is fairly reliable at detecting a burglary, but also
responds on occasion to minor earthquakes. (This example is due to Judea Pearl, a resident
of Los Angeles—hence the acute interest in earthquakes.) You also have two neighbors, John
and Mary, who have promised to call you at work when they hear the alarm. John nearly
always calls when he hears the alarm, but sometimes confuses the telephone ringing with
Weather Cavity
Toothache Catch
Figure 14.1 A simple Bayesian network in which Weather is independent of the other
three variables and Toothache and Catch are conditionally independent, given Cavity.
512 Chapter 14. Probabilistic Reasoning
.001
P(B)
Alarm
Earthquake
JohnCalls MaryCalls
Burglary
A P(J)
t
f
.90
.05
B
t
t
f
f
E
t
f
t
f
P(A)
.95
.29
.001
.94
.002
P(E)
A P(M)
t
f
.70
.01
Figure 14.2 A typical Bayesian network, showing both the topology and the conditional
probability tables (CPTs). In the CPTs, the letters B, E, A, J, and M stand for Burglary,
Earthquake, Alarm, JohnCalls, and MaryCalls , respectively.
the alarm and calls then, too. Mary, on the other hand, likes rather loud music and often
misses the alarm altogether. Given the evidence of who has or has not called, we would like
to estimate the probability of a burglary.
A Bayesian network for this domain appears in Figure 14.2. The network structure
shows that burglary and earthquakes directly affect the probability of the alarm’s going off,
but whether John and Mary call depends only on the alarm. The network thus represents
our assumptions that they do not perceive burglaries directly, they do not notice minor earthquakes, and they do not confer before calling.
The conditional distributions in Figure 14.2 are shown as a conditional probability
table, or CPT. (This form of table can be used for discrete variables; other representations, CONDITIONAL
PROBABILITY TABLE
including those suitable for continuous variables, are described in Section 14.2.) Each row
CONDITIONING CASE in a CPT contains the conditional probability of each node value for a conditioning case.
A conditioning case is just a possible combination of values for the parent nodes—a miniature possible world, if you like. Each row must sum to 1, because the entries represent an
exhaustive set of cases for the variable. For Boolean variables, once you know that the probability of a true value is p, the probability of false must be 1 – p, so we often omit the second
number, as in Figure 14.2. In general, a table for a Boolean variable with k Boolean parents
contains 2k independently specifiable probabilities. A node with no parents has only one row,
representing the prior probabilities of each possible value of the variable.
Notice that the network does not have nodes corresponding to Mary’s currently listening
to loud music or to the telephone ringing and confusing John. These factors are summarized
in the uncertainty associated with the links from Alarm to JohnCalls and MaryCalls. This
shows both laziness and ignorance in operation: it would be a lot of work to find out why those
factors would be more or less likely in any particular case, and we have no reasonable way to
obtain the relevant information anyway. The probabilities actually summarize a potentially
Section 14.2. The Semantics of Bayesian Networks 513
infinite set of circumstances in which the alarm might fail to go off (high humidity, power
failure, dead battery, cut wires, a dead mouse stuck inside the bell, etc.) or John or Mary
might fail to call and report it (out to lunch, on vacation, temporarily deaf, passing helicopter,
etc.). In this way, a small agent can cope with a very large world, at least approximately. The
degree of approximation can be improved if we introduce additional relevant information.
14.2 THE SEMANTICS OF BAYESIAN NETWORKS
The previous section described what a network is, but not what it means. There are two
ways in which one can understand the semantics of Bayesian networks. The first is to see
the network as a representation of the joint probability distribution. The second is to view
it as an encoding of a collection of conditional independence statements. The two views are
equivalent, but the first turns out to be helpful in understanding how to construct networks,
whereas the second is helpful in designing inference procedures.
14.2.1 Representing the full joint distribution
Viewed as a piece of “syntax,” a Bayesian network is a directed acyclic graph with some
numeric parameters attached to each node. One way to define what the network means—its
semantics—is to define the way in which it represents a specific joint distribution over all the
variables. To do this, we first need to retract (temporarily) what we said earlier about the parameters associated with each node. We said that those parameters correspond to conditional
probabilities P(Xi | P arents(Xi)); this is a true statement, but until we assign semantics to
the network as a whole, we should think of them just as numbers θ(Xi | P arents(Xi)).
A generic entry in the joint distribution is the probability of a conjunction of particular
assignments to each variable, such as P(X1 = x1 ∧ ... ∧ Xn = xn). We use the notation
P(x1,...,xn) as an abbreviation for this. The value of this entry is given by the formula
P(x1,...,xn) = n
i = 1
θ(xi | parents(Xi)) , (14.1)
where parents(Xi) denotes the values of P arents(Xi) that appear in x1,...,xn. Thus,
each entry in the joint distribution is represented by the product of the appropriate elements
of the conditional probability tables (CPTs) in the Bayesian network.
From this definition, it is easy to prove that the parameters θ(Xi | P arents(Xi)) are
exactly the conditional probabilities P(Xi | P arents(Xi)) implied by the joint distribution
(see Exercise 14.2). Hence, we can rewrite Equation (14.1) as
P(x1,...,xn) = n
i = 1
P(xi | parents(Xi)) . (14.2)
In other words, the tables we have been calling conditional probability tables really are conditional probability tables according to the semantics defined in Equation (14.1).
To illustrate this, we can calculate the probability that the alarm has sounded, but neither
a burglary nor an earthquake has occurred, and both John and Mary call. We multiply entries
514 Chapter 14. Probabilistic Reasoning
from the joint distribution (using single-letter names for the variables):
P(j, m, a,¬b,¬e) = P(j | a)P(m | a)P(a | ¬b ∧ ¬e)P(¬b)P(¬e)
= 0.90 × 0.70 × 0.001 × 0.999 × 0.998 = 0.000628 .
Section 13.3 explained that the full joint distribution can be used to answer any query about
the domain. If a Bayesian network is a representation of the joint distribution, then it too can
be used to answer any query, by summing all the relevant joint entries. Section 14.4 explains
how to do this, but also describes methods that are much more efficient.
A method for constructing Bayesian networks
Equation (14.2) defines what a given Bayesian network means. The next step is to explain
how to construct a Bayesian network in such a way that the resulting joint distribution is a
good representation of a given domain. We will now show that Equation (14.2) implies certain
conditional independence relationships that can be used to guide the knowledge engineer in
constructing the topology of the network. First, we rewrite the entries in the joint distribution
in terms of conditional probability, using the product rule (see page 486):
P(x1,...,xn) = P(xn | xn−1,...,x1)P(xn−1,...,x1) .
Then we repeat the process, reducing each conjunctive probability to a conditional probability
and a smaller conjunction. We end up with one big product:
P(x1,...,xn) = P(xn | xn−1,...,x1)P(xn−1 | xn−2,...,x1) ··· P(x2 | x1)P(x1)
= n
i = 1
P(xi | xi−1,...,x1) .
CHAIN RULE This identity is called the chain rule. It holds for any set of random variables. Comparing it
with Equation (14.2), we see that the specification of the joint distribution is equivalent to the
general assertion that, for every variable Xi in the network,
P(Xi | Xi−1,...,X1) = P(Xi | P arents(Xi)) , (14.3)
provided that P arents(Xi) ⊆ {Xi−1,...,X1}. This last condition is satisfied by numbering
the nodes in a way that is consistent with the partial order implicit in the graph structure.
What Equation (14.3) says is that the Bayesian network is a correct representation of
the domain only if each node is conditionally independent of its other predecessors in the
node ordering, given its parents. We can satisfy this condition with this methodology:
1. Nodes: First determine the set of variables that are required to model the domain. Now
order them, {X1,...,Xn}. Any order will work, but the resulting network will be more
compact if the variables are ordered such that causes precede effects.
2. Links: For i = 1 to n do:
• Choose, from X1,...,Xi−1, a minimal set of parents for Xi, such that Equation (14.3) is satisfied.
• For each parent insert a link from the parent to Xi.
• CPTs: Write down the conditional probability table, P(Xi|Parents(Xi)).
Section 14.2. The Semantics of Bayesian Networks 515
Intuitively, the parents of node Xi should contain all those nodes in X1, ..., Xi−1 that
directly influence Xi. For example, suppose we have completed the network in Figure 14.2
except for the choice of parents for MaryCalls. MaryCalls is certainly influenced by whether
there is a Burglary or an Earthquake, but not directly influenced. Intuitively, our knowledge
of the domain tells us that these events influence Mary’s calling behavior only through their
effect on the alarm. Also, given the state of the alarm, whether John calls has no influence on
Mary’s calling. Formally speaking, we believe that the following conditional independence
statement holds:
P(MaryCalls | JohnCalls , Alarm,Earthquake, Burglary) = P(MaryCalls | Alarm) .
Thus, Alarm will be the only parent node for MaryCalls.
Because each node is connected only to earlier nodes, this construction method guarantees that the network is acyclic. Another important property of Bayesian networks is that they
contain no redundant probability values. If there is no redundancy, then there is no chance
for inconsistency: it is impossible for the knowledge engineer or domain expert to create a
Bayesian network that violates the axioms of probability.
Compactness and node ordering
As well as being a complete and nonredundant representation of the domain, a Bayesian network can often be far more compact than the full joint distribution. This property is what
makes it feasible to handle domains with many variables. The compactness of Bayesian networks is an example of a general property of locally structured (also called sparse) systems. LOCALLY
STRUCTURED
SPARSE In a locally structured system, each subcomponent interacts directly with only a bounded
number of other components, regardless of the total number of components. Local structure
is usually associated with linear rather than exponential growth in complexity. In the case of
Bayesian networks, it is reasonable to suppose that in most domains each random variable
is directly influenced by at most k others, for some constant k. If we assume n Boolean
variables for simplicity, then the amount of information needed to specify each conditional
probability table will be at most 2k numbers, and the complete network can be specified by
n2k numbers. In contrast, the joint distribution contains 2n numbers. To make this concrete,
suppose we have n = 30 nodes, each with five parents (k = 5). Then the Bayesian network
requires 960 numbers, but the full joint distribution requires over a billion.
There are domains in which each variable can be influenced directly by all the others,
so that the network is fully connected. Then specifying the conditional probability tables requires the same amount of information as specifying the joint distribution. In some domains,
there will be slight dependencies that should strictly be included by adding a new link. But
if these dependencies are tenuous, then it may not be worth the additional complexity in the
network for the small gain in accuracy. For example, one might object to our burglary network on the grounds that if there is an earthquake, then John and Mary would not call even
if they heard the alarm, because they assume that the earthquake is the cause. Whether to
add the link from Earthquake to JohnCalls and MaryCalls (and thus enlarge the tables)
depends on comparing the importance of getting more accurate probabilities with the cost of
specifying the extra information.
516 Chapter 14. Probabilistic Reasoning
JohnCalls
MaryCalls
Alarm
Burglary
Earthquake
MaryCalls
Alarm
Earthquake
Burglary
JohnCalls
(a) (b)
Figure 14.3 Network structure depends on order of introduction. In each network, we
have introduced nodes in top-to-bottom order.
Even in a locally structured domain, we will get a compact Bayesian network only if
we choose the node ordering well. What happens if we happen to choose the wrong order? Consider the burglary example again. Suppose we decide to add the nodes in the order
MaryCalls, JohnCalls, Alarm, Burglary, Earthquake. We then get the somewhat more
complicated network shown in Figure 14.3(a). The process goes as follows:
• Adding MaryCalls: No parents.
• Adding JohnCalls: If Mary calls, that probably means the alarm has gone off, which
of course would make it more likely that John calls. Therefore, JohnCalls needs
MaryCalls as a parent.
• Adding Alarm: Clearly, if both call, it is more likely that the alarm has gone off than if
just one or neither calls, so we need both MaryCalls and JohnCalls as parents.
• Adding Burglary: If we know the alarm state, then the call from John or Mary might
give us information about our phone ringing or Mary’s music, but not about burglary:
P(Burglary | Alarm, JohnCalls , MaryCalls) = P(Burglary | Alarm) .
Hence we need just Alarm as parent.
• Adding Earthquake: If the alarm is on, it is more likely that there has been an earthquake. (The alarm is an earthquake detector of sorts.) But if we know that there has
been a burglary, then that explains the alarm, and the probability of an earthquake would
be only slightly above normal. Hence, we need both Alarm and Burglary as parents.
The resulting network has two more links than the original network in Figure 14.2 and requires three more probabilities to be specified. What’s worse, some of the links represent
tenuous relationships that require difficult and unnatural probability judgments, such as as-
Section 14.2. The Semantics of Bayesian Networks 517
sessing the probability of Earthquake, given Burglary and Alarm. This phenomenon is
quite general and is related to the distinction between causal and diagnostic models introduced in Section 13.5.1 (see also Exercise 8.13). If we try to build a diagnostic model with
links from symptoms to causes (as from MaryCalls to Alarm or Alarm to Burglary), we
end up having to specify additional dependencies between otherwise independent causes (and
often between separately occurring symptoms as well). If we stick to a causal model, we end
up having to specify fewer numbers, and the numbers will often be easier to come up with. In
the domain of medicine, for example, it has been shown by Tversky and Kahneman (1982)
that expert physicians prefer to give probability judgments for causal rules rather than for
diagnostic ones.
Figure 14.3(b) shows a very bad node ordering: MaryCalls, JohnCalls, Earthquake,
Burglary, Alarm. This network requires 31 distinct probabilities to be specified—exactly the
same number as the full joint distribution. It is important to realize, however, that any of the
three networks can represent exactly the same joint distribution. The last two versions simply
fail to represent all the conditional independence relationships and hence end up specifying a
lot of unnecessary numbers instead.
14.2.2 Conditional independence relations in Bayesian networks
We have provided a “numerical” semantics for Bayesian networks in terms of the representation of the full joint distribution, as in Equation (14.2). Using this semantics to derive a
method for constructing Bayesian networks, we were led to the consequence that a node is
conditionally independent of its other predecessors, given its parents. It turns out that we
can also go in the other direction. We can start from a “topological” semantics that specifies
the conditional independence relationships encoded by the graph structure, and from this we
can derive the “numerical” semantics. The topological semantics2 specifies that each variDESCENDANT able is conditionally independent of its non-descendants, given its parents. For example, in
Figure 14.2, JohnCalls is independent of Burglary, Earthquake, and MaryCalls given the
value of Alarm. The definition is illustrated in Figure 14.4(a). From these conditional independence assertions and the interpretation of the network parameters θ(Xi | P arents(Xi))
as specifications of conditional probabilities P(Xi | P arents(Xi)), the full joint distribution
given in Equation (14.2) can be reconstructed. In this sense, the “numerical” semantics and
the “topological” semantics are equivalent.
Another important independence property is implied by the topological semantics: a
node is conditionally independent of all other nodes in the network, given its parents, children,
MARKOV BLANKET and children’s parents—that is, given its Markov blanket. (Exercise 14.7 asks you to prove
this.) For example, Burglary is independent of JohnCalls and MaryCalls, given Alarm and
Earthquake. This property is illustrated in Figure 14.4(b).
2 There is also a general topological criterion called d-separation for deciding whether a set of nodes X is
conditionally independent of another set Y, given a third set Z. The criterion is rather complicated and is not
needed for deriving the algorithms in this chapter, so we omit it. Details may be found in Pearl (1988) or Darwiche
(2009). Shachter (1998) gives a more intuitive method of ascertaining d-separation.
518 Chapter 14. Probabilistic Reasoning
. . .
U . . . 1
X
Um
Yn
Znj
Y1
Z1j
. . .
U1 . . . Um
Yn
Znj
Y1
Z1j
X
(a) (b)
Figure 14.4 (a) A node X is conditionally independent of its non-descendants (e.g., the
Zij s) given its parents (the Uis shown in the gray area). (b) A node X is conditionally
independent of all other nodes in the network given its Markov blanket (the gray area).
14.3 EFFICIENT REPRESENTATION OF CONDITIONAL DISTRIBUTIONS
Even if the maximum number of parents k is smallish, filling in the CPT for a node requires
up to O(2k) numbers and perhaps a great deal of experience with all the possible conditioning
cases. In fact, this is a worst-case scenario in which the relationship between the parents and
the child is completely arbitrary. Usually, such relationships are describable by a canonical
distribution that fits some standard pattern. In such cases, the complete table can be specified CANONICAL
DISTRIBUTION
by naming the pattern and perhaps supplying a few parameters—much easier than supplying
an exponential number of parameters.
The simplest example is provided by deterministic nodes. A deterministic node has DETERMINISTIC
NODES
its value specified exactly by the values of its parents, with no uncertainty. The relationship
can be a logical one: for example, the relationship between the parent nodes Canadian, US,
Mexican and the child node NorthAmerican is simply that the child is the disjunction of
the parents. The relationship can also be numerical: for example, if the parent nodes are
the prices of a particular model of car at several dealers and the child node is the price that
a bargain hunter ends up paying, then the child node is the minimum of the parent values;
or if the parent nodes are a lake’s inflows (rivers, runoff, precipitation) and outflows (rivers,
evaporation, seepage) and the child is the change in the water level of the lake, then the value
of the child is the sum of the inflow parents minus the sum of the outflow parents.
Uncertain relationships can often be characterized by so-called noisy logical relationNOISY-OR ships. The standard example is the noisy-OR relation, which is a generalization of the logical OR. In propositional logic, we might say that Fever is true if and only if Cold, Flu, or
Malaria is true. The noisy-OR model allows for uncertainty about the ability of each parent to cause the child to be true—the causal relationship between parent and child may be
Section 14.3. Efficient Representation of Conditional Distributions 519
inhibited, and so a patient could have a cold, but not exhibit a fever. The model makes two
assumptions. First, it assumes that all the possible causes are listed. (If some are missing,
LEAK NODE we can always add a so-called leak node that covers “miscellaneous causes.”) Second, it
assumes that inhibition of each parent is independent of inhibition of any other parents: for
example, whatever inhibits Malaria from causing a fever is independent of whatever inhibits
Flu from causing a fever. Given these assumptions, Fever is false if and only if all its true
parents are inhibited, and the probability of this is the product of the inhibition probabilities
q for each parent. Let us suppose these individual inhibition probabilities are as follows:
qcold = P(¬fever | cold,¬flu,¬malaria)=0.6 ,
qflu = P(¬fever | ¬cold, flu,¬malaria)=0.2 ,
qmalaria = P(¬fever | ¬cold,¬flu, malaria)=0.1 .
Then, from this information and the noisy-OR assumptions, the entire CPT can be built. The
general rule is that
P(xi | parents(Xi)) = 1 − 
{j:Xj = true}
qj ,
where the product is taken over the parents that are set to true for that row of the CPT. The
following table illustrates this calculation:
Cold Flu Malaria P(Fever) P(¬Fever)
FFF 0.0 1.0
FFT 0.9 0.1
FTF 0.8 0.2
FTT 0.98 0.02 = 0.2 × 0.1
TFF 0.4 0.6
TFT 0.94 0.06 = 0.6 × 0.1
TTF 0.88 0.12 = 0.6 × 0.2
TTT 0.988 0.012 = 0.6 × 0.2 × 0.1
In general, noisy logical relationships in which a variable depends on k parents can be described using O(k) parameters instead of O(2k) for the full conditional probability table.
This makes assessment and learning much easier. For example, the CPCS network (Pradhan et al., 1994) uses noisy-OR and noisy-MAX distributions to model relationships among
diseases and symptoms in internal medicine. With 448 nodes and 906 links, it requires only
8,254 values instead of 133,931,430 for a network with full CPTs.
Bayesian nets with continuous variables
Many real-world problems involve continuous quantities, such as height, mass, temperature,
and money; in fact, much of statistics deals with random variables whose domains are continuous. By definition, continuous variables have an infinite number of possible values, so it is
impossible to specify conditional probabilities explicitly for each value. One possible way to
DISCRETIZATION handle continuous variables is to avoid them by using discretization—that is, dividing up the
520 Chapter 14. Probabilistic Reasoning
Subsidy Harvest
Buys
Cost
Figure 14.5 A simple network with discrete variables (Subsidy and Buys) and continuous
variables (Harvest and Cost).
possible values into a fixed set of intervals. For example, temperatures could be divided into
(<0oC), (0oC−100oC), and (>100oC). Discretization is sometimes an adequate solution,
but often results in a considerable loss of accuracy and very large CPTs. The most common solution is to define standard families of probability density functions (see Appendix A)
PARAMETER that are specified by a finite number of parameters. For example, a Gaussian (or normal)
distribution N(μ, σ2)(x) has the mean μ and the variance σ2 as parameters. Yet another
NONPARAMETRIC solution—sometimes called a nonparametric representation—is to define the conditional
distribution implicitly with a collection of instances, each containing specific values of the
parent and child variables. We explore this approach further in Chapter 18.
A network with both discrete and continuous variables is called a hybrid Bayesian
network. To specify a hybrid network, we have to specify two new kinds of distributions: HYBRID BAYESIAN
NETWORK
the conditional distribution for a continuous variable given discrete or continuous parents;
and the conditional distribution for a discrete variable given continuous parents. Consider the
simple example in Figure 14.5, in which a customer buys some fruit depending on its cost,
which depends in turn on the size of the harvest and whether the government’s subsidy scheme
is operating. The variable Cost is continuous and has continuous and discrete parents; the
variable Buys is discrete and has a continuous parent.
For the Cost variable, we need to specify P(Cost | Harvest, Subsidy). The discrete
parent is handled by enumeration—that is, by specifying both P(Cost | Harvest, subsidy)
and P(Cost | Harvest,¬subsidy). To handle Harvest, we specify how the distribution over
the cost c depends on the continuous value h of Harvest. In other words, we specify the
parameters of the cost distribution as a function of h. The most common choice is the linear
LINEAR GAUSSIAN Gaussian distribution, in which the child has a Gaussian distribution whose mean μ varies
linearly with the value of the parent and whose standard deviation σ is fixed. We need two
distributions, one for subsidy and one for ¬subsidy, with different parameters:
P(c | h, subsidy) = N(ath + bt, σ2
t)(c) = 1
σt
√2π
e
− 1
2
“c−(ath+bt)
σt
”2
P(c | h,¬subsidy) = N(afh + bf , σ2
f )(c) = 1
σf
√2π
e
− 1
2
„c−(af h+bf )
σf
«2
.
For this example, then, the conditional distribution for Cost is specified by naming the linear
Gaussian distribution and providing the parameters at, bt, σt, af , bf , and σf . Figures 14.6(a)
Section 14.3. Efficient Representation of Conditional Distributions 521
0 2 4 6 8 10 Cost c 02 46 81012
Harvest h
0
0.1
0.2
0.3
0.4
P(c | h, subsidy)
0 2 4 6 8 10 Cost c 02 46 81012
Harvest h
0
0.1
0.2
0.3
0.4
P(c | h, ¬subsidy)
0 2 4 6 8 10 Cost c 02 4 6 81012
Harvest h
0
0.1
0.2
0.3
0.4
P(c | h)
(a) (b) (c)
Figure 14.6 The graphs in (a) and (b) show the probability distribution over Cost as a
function of Harvest size, with Subsidy true and false, respectively. Graph (c) shows the
distribution P(Cost | Harvest), obtained by summing over the two subsidy cases.
and (b) show these two relationships. Notice that in each case the slope is negative, because
cost decreases as supply increases. (Of course, the assumption of linearity implies that the
cost becomes negative at some point; the linear model is reasonable only if the harvest size is
limited to a narrow range.) Figure 14.6(c) shows the distribution P(c | h), averaging over the
two possible values of Subsidy and assuming that each has prior probability 0.5. This shows
that even with very simple models, quite interesting distributions can be represented.
The linear Gaussian conditional distribution has some special properties. A network
containing only continuous variables with linear Gaussian distributions has a joint distribution that is a multivariate Gaussian distribution (see Appendix A) over all the variables (Exercise 14.9). Furthermore, the posterior distribution given any evidence also has this property.3
When discrete variables are added as parents (not as children) of continuous variables, the
network defines a conditional Gaussian, or CG, distribution: given any assignment to the CONDITIONAL
GAUSSIAN
discrete variables, the distribution over the continuous variables is a multivariate Gaussian.
Now we turn to the distributions for discrete variables with continuous parents. Consider, for example, the Buys node in Figure 14.5. It seems reasonable to assume that the
customer will buy if the cost is low and will not buy if it is high and that the probability of
buying varies smoothly in some intermediate region. In other words, the conditional distribution is like a “soft” threshold function. One way to make soft thresholds is to use the integral
of the standard normal distribution:
Φ(x) =  x
−∞
N(0, 1)(x)dx .
Then the probability of Buys given Cost might be
P(buys | Cost = c) = Φ((−c + μ)/σ) ,
which means that the cost threshold occurs around μ, the width of the threshold region is proportional to σ, and the probability of buying decreases as cost increases. This probit distri3 It follows that inference in linear Gaussian networks takes only O(n3) time in the worst case, regardless of the
network topology. In Section 14.4, we see that inference for networks of discrete variables is NP-hard.
522 Chapter 14. Probabilistic Reasoning
 0
 0.2
 0.4
 0.6
 0.8
 1
 0 2 4 6 8 10 12
P(c)
Cost c
 0
 0.2
 0.4
 0.6
 0.8
 1
 0 2 4 6 8 10 12
P(buys | c)
Cost c
Logit
Probit
(a) (b)
Figure 14.7 (a) A normal (Gaussian) distribution for the cost threshold, centered on
μ = 6.0 with standard deviation σ = 1.0. (b) Logit and probit distributions for the probability
of buys given cost, for the parameters μ = 6.0 and σ = 1.0.
bution (pronounced “pro-bit” and short for “probability unit”) is illustrated in Figure 14.7(a). PROBIT
DISTRIBUTION
The form can be justified by proposing that the underlying decision process has a hard threshold, but that the precise location of the threshold is subject to random Gaussian noise.
LOGIT DISTRIBUTION An alternative to the probit model is the logit distribution (pronounced “low-jit”). It
uses the logistic function 1/(1 + e−x LOGISTIC FUNCTION ) to produce a soft threshold:
P(buys | Cost = c) = 1
1 + exp(−2 −c+μ
σ )
.
This is illustrated in Figure 14.7(b). The two distributions look similar, but the logit actually
has much longer “tails.” The probit is often a better fit to real situations, but the logit is sometimes easier to deal with mathematically. It is used widely in neural networks (Chapter 20).
Both probit and logit can be generalized to handle multiple continuous parents by taking a
linear combination of the parent values.
14.4 EXACT INFERENCE IN BAYESIAN NETWORKS
The basic task for any probabilistic inference system is to compute the posterior probability
EVENT distribution for a set of query variables, given some observed event—that is, some assignment of values to a set of evidence variables. To simplify the presentation, we will consider
only one query variable at a time; the algorithms can easily be extended to queries with multiple variables. We will use the notation from Chapter 13: X denotes the query variable; E
denotes the set of evidence variables E1,...,Em, and e is a particular observed event; Y will
HIDDEN VARIABLE denotes the nonevidence, nonquery variables Y1,...,Yl (called the hidden variables). Thus,
the complete set of variables is X = {X} ∪ E ∪ Y. A typical query asks for the posterior
probability distribution P(X | e).
Section 14.4. Exact Inference in Bayesian Networks 523
In the burglary network, we might observe the event in which JohnCalls = true and
MaryCalls = true. We could then ask for, say, the probability that a burglary has occurred:
P(Burglary | JohnCalls = true, MaryCalls = true) = 0.284, 0.716 .
In this section we discuss exact algorithms for computing posterior probabilities and will
consider the complexity of this task. It turns out that the general case is intractable, so Section 14.5 covers methods for approximate inference.
14.4.1 Inference by enumeration
Chapter 13 explained that any conditional probability can be computed by summing terms
from the full joint distribution. More specifically, a query P(X | e) can be answered using
Equation (13.9), which we repeat here for convenience:
P(X | e) = α P(X, e) = α 
y
P(X, e, y) .
Now, a Bayesian network gives a complete representation of the full joint distribution. More
specifically, Equation (14.2) on page 513 shows that the terms P(x, e, y) in the joint distribution can be written as products of conditional probabilities from the network. Therefore, a
query can be answered using a Bayesian network by computing sums of products of conditional probabilities from the network.
Consider the query P(Burglary | JohnCalls = true, MaryCalls = true). The hidden
variables for this query are Earthquake and Alarm. From Equation (13.9), using initial
letters for the variables to shorten the expressions, we have4
P(B | j, m) = α P(B, j, m) = α 
e

a
P(B, j, m, e, a,) .
The semantics of Bayesian networks (Equation (14.2)) then gives us an expression in terms
of CPT entries. For simplicity, we do this just for Burglary = true:
P(b | j, m) = α 
e

a
P(b)P(e)P(a | b, e)P(j | a)P(m | a) .
To compute this expression, we have to add four terms, each computed by multiplying five
numbers. In the worst case, where we have to sum out almost all the variables, the complexity
of the algorithm for a network with n Boolean variables is O(n2n).
An improvement can be obtained from the following simple observations: the P(b)
term is a constant and can be moved outside the summations over a and e, and the P(e) term
can be moved outside the summation over a. Hence, we have
P(b | j, m) = α P(b)

e
P(e)

a
P(a | b, e)P(j | a)P(m | a) . (14.4)
This expression can be evaluated by looping through the variables in order, multiplying CPT
entries as we go. For each summation, we also need to loop over the variable’s possible
4 An expression such as P
e P(a, e) means to sum P(A = a, E = e) for all possible values of e. When E is
Boolean, there is an ambiguity in that P(e) is used to mean both P(E = true) and P(E = e), but it should be
clear from context which is intended; in particular, in the context of a sum the latter is intended.
524 Chapter 14. Probabilistic Reasoning
values. The structure of this computation is shown in Figure 14.8. Using the numbers from
Figure 14.2, we obtain P(b | j, m) = α × 0.00059224. The corresponding computation for
¬b yields α × 0.0014919; hence,
P(B | j, m) = α 0.00059224, 0.0014919≈0.284, 0.716 .
That is, the chance of a burglary, given calls from both neighbors, is about 28%.
The evaluation process for the expression in Equation (14.4) is shown as an expression
tree in Figure 14.8. The ENUMERATION-ASK algorithm in Figure 14.9 evaluates such trees
using depth-first recursion. The algorithm is very similar in structure to the backtracking algorithm for solving CSPs (Figure 6.5) and the DPLL algorithm for satisfiability (Figure 7.17).
The space complexity of ENUMERATION-ASK is only linear in the number of variables:
the algorithm sums over the full joint distribution without ever constructing it explicitly. Unfortunately, its time complexity for a network with n Boolean variables is always O(2n)—
better than the O(n 2n) for the simple approach described earlier, but still rather grim.
Note that the tree in Figure 14.8 makes explicit the repeated subexpressions evaluated by the algorithm. The products P(j | a)P(m | a) and P(j | ¬a)P(m | ¬a) are computed
twice, once for each value of e. The next section describes a general method that avoids such
wasted computations.
14.4.2 The variable elimination algorithm
The enumeration algorithm can be improved substantially by eliminating repeated calculations of the kind illustrated in Figure 14.8. The idea is simple: do the calculation once and
save the results for later use. This is a form of dynamic programming. There are several versions of this approach; we present the variable elimination algorithm, which is the simplest. VARIABLE
ELIMINATION
Variable elimination works by evaluating expressions such as Equation (14.4) in right-to-left
order (that is, bottom up in Figure 14.8). Intermediate results are stored, and summations over
each variable are done only for those portions of the expression that depend on the variable.
Let us illustrate this process for the burglary network. We evaluate the expression
P(B | j, m) = α P(B)    f1(B)

e
P(e)    f2(E)

a
P(a | B,e)    f3(A,B,E)
P(j | a)    f4(A)
P(m | a)    f5(A)
.
Notice that we have annotated each part of the expression with the name of the corresponding
FACTOR factor; each factor is a matrix indexed by the values of its argument variables. For example,
the factors f4(A) and f5(A) corresponding to P(j | a) and P(m | a) depend just on A because
J and M are fixed by the query. They are therefore two-element vectors:
f4(A) =  P(j | a)
P(j | ¬a)

=
 0.90
0.05 
f5(A) =  P(m | a)
P(m | ¬a)

=
 0.70
0.01 
.
f3(A, B, E) will be a 2 × 2 × 2 matrix, which is hard to show on the printed page. (The “first”
element is given by P(a | b, e)=0.95 and the “last” by P(¬a | ¬b,¬e)=0.999.) In terms of
factors, the query expression is written as
P(B | j, m) = α f1(B) × 
e
f2(E) × 
a
f3(A, B, E) × f4(A) × f5(A)
Section 14.4. Exact Inference in Bayesian Networks 525
P(j|a)
.90
P(m|a)
.70 .01
P(m|¬a)
.05
P( j|¬a) P( j|a)
.90
P(m|a)
.70 .01
P(m|¬a)
.05
P( j|¬a)
P(b)
.001
P(e)
.002
P(¬e)
.998
P(a|b,e)
.95 .06
P(¬a|b,¬e)
.05
P(¬a|b,e)
.94
P(a|b,¬e)
Figure 14.8 The structure of the expression shown in Equation (14.4). The evaluation
proceeds top down, multiplying values along each path and summing at the “+” nodes. Notice
the repetition of the paths for j and m.
function ENUMERATION-ASK(X , e, bn) returns a distribution over X
inputs: X , the query variable
e, observed values for variables E
bn, a Bayes net with variables {X} ∪ E ∪ Y /* Y = hidden variables */
Q(X )← a distribution over X , initially empty
for each value xi of X do
Q(xi)← ENUMERATE-ALL(bn.VARS, exi )
where exi is e extended with X = xi
return NORMALIZE(Q(X))
function ENUMERATE-ALL(vars, e) returns a real number
if EMPTY?(vars) then return 1.0
Y ← FIRST(vars)
if Y has value y in e
then return P(y | parents(Y )) × ENUMERATE-ALL(REST(vars), e)
else return
y P(y | parents(Y )) × ENUMERATE-ALL(REST(vars), ey)
where ey is e extended with Y = y
Figure 14.9 The enumeration algorithm for answering queries on Bayesian networks.
526 Chapter 14. Probabilistic Reasoning
where the “×” operator is not ordinary matrix multiplication but instead the pointwise product operation, to be described shortly. POINTWISE
PRODUCT
The process of evaluation is a process of summing out variables (right to left) from
pointwise products of factors to produce new factors, eventually yielding a factor that is the
solution, i.e., the posterior distribution over the query variable. The steps are as follows:
• First, we sum out A from the product of f3, f4, and f5. This gives us a new 2 × 2 factor
f6(B,E) whose indices range over just B and E:
f6(B,E) = 
a
f3(A, B, E) × f4(A) × f5(A)
= (f3(a, B, E) × f4(a) × f5(a)) + (f3(¬a, B, E) × f4(¬a) × f5(¬a)).
Now we are left with the expression
P(B | j, m) = α f1(B) × 
e
f2(E) × f6(B,E) .
• Next, we sum out E from the product of f2 and f6:
f7(B) = 
e
f2(E) × f6(B,E)
= f2(e) × f6(B,e) + f2(¬e) × f6(B,¬e) .
This leaves the expression
P(B | j, m) = α f1(B) × f7(B)
which can be evaluated by taking the pointwise product and normalizing the result.
Examining this sequence, we see that two basic computational operations are required: pointwise product of a pair of factors, and summing out a variable from a product of factors. The
next section describes each of these operations.
Operations on factors
The pointwise product of two factors f1 and f2 yields a new factor f whose variables are
the union of the variables in f1 and f2 and whose elements are given by the product of the
corresponding elements in the two factors. Suppose the two factors have variables Y1,...,Yk
in common. Then we have
f(X1 ...Xj , Y1 ...Yk, Z1 ...Zl) = f1(X1 ...Xj , Y1 ...Yk) f2(Y1 ...Yk, Z, ...Zl).
If all the variables are binary, then f1 and f2 have 2j+k and 2k+l entries, respectively, and
the pointwise product has 2j+k+l entries. For example, given two factors f1(A, B) and
f2(B,C), the pointwise product f1 × f2 = f3(A, B, C) has 21+1+1 = 8 entries, as illustrated
in Figure 14.10. Notice that the factor resulting from a pointwise product can contain more
variables than any of the factors being multiplied and that the size of a factor is exponential in
the number of variables. This is where both space and time complexity arise in the variable
elimination algorithm.
Section 14.4. Exact Inference in Bayesian Networks 527
A B f1(A, B) B C f2(B,C) A B C f3(A, B, C)
T T .3 T T .2 T T T .3 × .2 = .06
T F .7 T F .8 T T F .3 × .8 = .24
F T .9 F T .6 T F T .7 × .6 = .42
F F .1 F F .4 T F F .7 × .4 = .28
F T T .9 × .2 = .18
F T F .9 × .8 = .72
F F T .1 × .6 = .06
F F F .1 × .4 = .04
Figure 14.10 Illustrating pointwise multiplication: f1(A, B) × f2(B,C) = f3(A, B, C).
Summing out a variable from a product of factors is done by adding up the submatrices
formed by fixing the variable to each of its values in turn. For example, to sum out A from
f3(A, B, C), we write
f(B,C) = 
a
f3(A, B, C) = f3(a, B, C) + f3(¬a, B, C)
=
 .06 .24
.42 .28 
+
 .18 .72
.06 .04 
=
 .24 .96
.48 .32 
.
The only trick is to notice that any factor that does not depend on the variable to be summed
out can be moved outside the summation. For example, if we were to sum out E first in the
burglary network, the relevant part of the expression would be

e
f2(E) × f3(A, B, E) × f4(A) × f5(A) = f4(A) × f5(A) × 
e
f2(E) × f3(A, B, E).
Now the pointwise product inside the summation is computed, and the variable is summed
out of the resulting matrix.
Notice that matrices are not multiplied until we need to sum out a variable from the
accumulated product. At that point, we multiply just those matrices that include the variable
to be summed out. Given functions for pointwise product and summing out, the variable
elimination algorithm itself can be written quite simply, as shown in Figure 14.11.
Variable ordering and variable relevance
The algorithm in Figure 14.11 includes an unspecified ORDER function to choose an ordering
for the variables. Every choice of ordering yields a valid algorithm, but different orderings
cause different intermediate factors to be generated during the calculation. For example, in
the calculation shown previously, we eliminated A before E; if we do it the other way, the
calculation becomes
P(B | j, m) = α f1(B) × 
a
f4(A) × f5(A) × 
e
f2(E) × f3(A, B, E) ,
during which a new factor f6(A, B) will be generated.
In general, the time and space requirements of variable elimination are dominated by
the size of the largest factor constructed during the operation of the algorithm. This in turn
528 Chapter 14. Probabilistic Reasoning
function ELIMINATION-ASK(X , e, bn) returns a distribution over X
inputs: X , the query variable
e, observed values for variables E
bn, a Bayesian network specifying joint distribution P(X1,...,Xn)
factors ← [ ]
for each var in ORDER(bn.VARS) do
factors ← [MAKE-FACTOR(var , e)|factors]
if var is a hidden variable then factors ← SUM-OUT(var ,factors )
return NORMALIZE(POINTWISE-PRODUCT(factors))
Figure 14.11 The variable elimination algorithm for inference in Bayesian networks.
is determined by the order of elimination of variables and by the structure of the network.
It turns out to be intractable to determine the optimal ordering, but several good heuristics
are available. One fairly effective method is a greedy one: eliminate whichever variable
minimizes the size of the next factor to be constructed.
Let us consider one more query: P(JohnCalls | Burglary = true). As usual, the first
step is to write out the nested summation:
P(J | b) = α P(b)

e
P(e)

a
P(a | b, e)P(J | a)

m
P(m | a) .
Evaluating this expression from right to left, we notice something interesting:
m P(m | a)
is equal to 1 by definition! Hence, there was no need to include it in the first place; the variable M is irrelevant to this query. Another way of saying this is that the result of the query
P(JohnCalls | Burglary = true) is unchanged if we remove MaryCalls from the network
altogether. In general, we can remove any leaf node that is not a query variable or an evidence
variable. After its removal, there may be some more leaf nodes, and these too may be irrelevant. Continuing this process, we eventually find that every variable that is not an ancestor
of a query variable or evidence variable is irrelevant to the query. A variable elimination
algorithm can therefore remove all these variables before evaluating the query.
14.4.3 The complexity of exact inference
The complexity of exact inference in Bayesian networks depends strongly on the structure of
the network. The burglary network of Figure 14.2 belongs to the family of networks in which
there is at most one undirected path between any two nodes in the network. These are called
SINGLY CONNECTED singly connected networks or polytrees, and they have a particularly nice property: The time
POLYTREE and space complexity of exact inference in polytrees is linear in the size of the network. Here,
the size is defined as the number of CPT entries; if the number of parents of each node is
bounded by a constant, then the complexity will also be linear in the number of nodes.
For multiply connected networks, such as that of Figure 14.12(a), variable elimination MULTIPLY
CONNECTED
can have exponential time and space complexity in the worst case, even when the number
of parents per node is bounded. This is not surprising when one considers that because it
Section 14.4. Exact Inference in Bayesian Networks 529
P(C)=.5
C P(R)
t
f
.80
.20
C P(S)
t
f
.10
.50
S R
t t
t f
f t
f f
.90
.90
.00
.99
Cloudy
Sprinkler Rain
 Wet
Grass
P(W)
P(C)=.5
t
f
.08 .02 .72 .18
P(S+R=x)
S+R P(W)
t t
t f
f t
f f
.90
.90
.00
.99
Cloudy
Spr+Rain
 Wet
Grass
.10 .40 .10 .40
C t t t f f t f f
(a) (b)
Figure 14.12 (a) A multiply connected network with conditional probability tables. (b) A
clustered equivalent of the multiply connected network.
includes inference in propositional logic as a special case, inference in Bayesian networks is
NP-hard. In fact, it can be shown (Exercise 14.16) that the problem is as hard as that of computing the number of satisfying assignments for a propositional logic formula. This means
that it is #P-hard (“number-P hard”)—that is, strictly harder than NP-complete problems.
There is a close connection between the complexity of Bayesian network inference and
the complexity of constraint satisfaction problems (CSPs). As we discussed in Chapter 6,
the difficulty of solving a discrete CSP is related to how “treelike” its constraint graph is.
Measures such as tree width, which bound the complexity of solving a CSP, can also be
applied directly to Bayesian networks. Moreover, the variable elimination algorithm can be
generalized to solve CSPs as well as Bayesian networks.
14.4.4 Clustering algorithms
The variable elimination algorithm is simple and efficient for answering individual queries. If
we want to compute posterior probabilities for all the variables in a network, however, it can
be less efficient. For example, in a polytree network, one would need to issue O(n) queries
costing O(n) each, for a total of O(n2 CLUSTERING ) time. Using clustering algorithms (also known as
JOIN TREE join tree algorithms), the time can be reduced to O(n). For this reason, these algorithms are
widely used in commercial Bayesian network tools.
The basic idea of clustering is to join individual nodes of the network to form cluster nodes in such a way that the resulting network is a polytree. For example, the multiply
connected network shown in Figure 14.12(a) can be converted into a polytree by combining the Sprinkler and Rain node into a cluster node called Sprinkler+Rain, as shown in
Figure 14.12(b). The two Boolean nodes are replaced by a “meganode” that takes on four
possible values: tt, tf, f t, and ff. The meganode has only one parent, the Boolean variable
Cloudy, so there are two conditioning cases. Although this example doesn’t show it, the
process of clustering often produces meganodes that share some variables.
530 Chapter 14. Probabilistic Reasoning
Once the network is in polytree form, a special-purpose inference algorithm is required,
because ordinary inference methods cannot handle meganodes that share variables with each
other. Essentially, the algorithm is a form of constraint propagation (see Chapter 6) where the
constraints ensure that neighboring meganodes agree on the posterior probability of any variables that they have in common. With careful bookkeeping, this algorithm is able to compute
posterior probabilities for all the nonevidence nodes in the network in time linear in the size
of the clustered network. However, the NP-hardness of the problem has not disappeared: if a
network requires exponential time and space with variable elimination, then the CPTs in the
clustered network will necessarily be exponentially large.
14.5 APPROXIMATE INFERENCE IN BAYESIAN NETWORKS
Given the intractability of exact inference in large, multiply connected networks, it is essential to consider approximate inference methods. This section describes randomized sampling
MONTE CARLO algorithms, also called Monte Carlo algorithms, that provide approximate answers whose
accuracy depends on the number of samples generated. Monte Carlo algorithms, of which
simulated annealing (page 126) is an example, are used in many branches of science to estimate quantities that are difficult to calculate exactly. In this section, we are interested in
sampling applied to the computation of posterior probabilities. We describe two families of
algorithms: direct sampling and Markov chain sampling. Two other approaches—variational
methods and loopy propagation—are mentioned in the notes at the end of the chapter.
14.5.1 Direct sampling methods
The primitive element in any sampling algorithm is the generation of samples from a known
probability distribution. For example, an unbiased coin can be thought of as a random variable
Coin with values heads ,tails and a prior distribution P(Coin) = 0.5, 0.5. Sampling
from this distribution is exactly like flipping the coin: with probability 0.5 it will return heads,
and with probability 0.5 it will return tails. Given a source of random numbers uniformly
distributed in the range [0, 1], it is a simple matter to sample any distribution on a single
variable, whether discrete or continuous. (See Exercise 14.17.)
The simplest kind of random sampling process for Bayesian networks generates events
from a network that has no evidence associated with it. The idea is to sample each variable
in turn, in topological order. The probability distribution from which the value is sampled is
conditioned on the values already assigned to the variable’s parents. This algorithm is shown
in Figure 14.13. We can illustrate its operation on the network in Figure 14.12(a), assuming
an ordering [Cloudy, Sprinkler , Rain,WetGrass ]:
1. Sample from P(Cloudy) = 0.5, 0.5, value is true.
2. Sample from P(Sprinkler | Cloudy = true) = 0.1, 0.9, value is false.
3. Sample from P(Rain | Cloudy = true) = 0.8, 0.2, value is true.
4. Sample from P(WetGrass | Sprinkler = false, Rain = true) = 0.9, 0.1, value istrue.
In this case, PRIOR-SAMPLE returns the event [true, false,true,true].
Section 14.5. Approximate Inference in Bayesian Networks 531
function PRIOR-SAMPLE(bn) returns an event sampled from the prior specified by bn
inputs: bn, a Bayesian network specifying joint distribution P(X1,...,Xn)
x← an event with n elements
foreach variable Xi in X1,...,Xn do
x[i] ← a random sample from P(Xi | parents(Xi))
return x
Figure 14.13 A sampling algorithm that generates events from a Bayesian network. Each
variable is sampled according to the conditional distribution given the values already sampled
for the variable’s parents.
It is easy to see that PRIOR-SAMPLE generates samples from the prior joint distribution
specified by the network. First, let SPS (x1,...,xn) be the probability that a specific event is
generated by the PRIOR-SAMPLE algorithm. Just looking at the sampling process, we have
SPS (x1 ...xn) = n
i = 1
P(xi | parents(Xi))
because each sampling step depends only on the parent values. This expression should look
familiar, because it is also the probability of the event according to the Bayesian net’s representation of the joint distribution, as stated in Equation (14.2). That is, we have
SPS (x1 ...xn) = P(x1 ...xn) .
This simple fact makes it easy to answer questions by using samples.
In any sampling algorithm, the answers are computed by counting the actual samples
generated. Suppose there are N total samples, and let NPS (x1,...,xn) be the number of
times the specific event x1,...,xn occurs in the set of samples. We expect this number, as a
fraction of the total, to converge in the limit to its expected value according to the sampling
probability:
lim
N→∞
NPS (x1,...,xn)
N = SPS (x1,...,xn) = P(x1,...,xn) . (14.5)
For example, consider the event produced earlier: [true, false,true,true]. The sampling
probability for this event is
SPS (true, false,true,true)=0.5 × 0.9 × 0.8 × 0.9=0.324 .
Hence, in the limit of large N, we expect 32.4% of the samples to be of this event.
Whenever we use an approximate equality (“≈”) in what follows, we mean it in exactly
this sense—that the estimated probability becomes exact in the large-sample limit. Such an
CONSISTENT estimate is called consistent. For example, one can produce a consistent estimate of the
probability of any partially specified event x1,...,xm, where m ≤ n, as follows:
P(x1,...,xm) ≈ NPS (x1,...,xm)/N . (14.6)
That is, the probability of the event can be estimated as the fraction of all complete events
generated by the sampling process that match the partially specified event. For example, if
532 Chapter 14. Probabilistic Reasoning
we generate 1000 samples from the sprinkler network, and 511 of them have Rain = true,
then the estimated probability of rain, written as Pˆ(Rain = true), is 0.511.
Rejection sampling in Bayesian networks
Rejection sampling is a general method for producing samples from a hard-to-sample distri- REJECTION
SAMPLING
bution given an easy-to-sample distribution. In its simplest form, it can be used to compute
conditional probabilities—that is, to determine P(X | e). The REJECTION-SAMPLING algorithm is shown in Figure 14.14. First, it generates samples from the prior distribution specified
by the network. Then, it rejects all those that do not match the evidence. Finally, the estimate
Pˆ(X = x | e) is obtained by counting how often X = x occurs in the remaining samples.
Let Pˆ(X | e) be the estimated distribution that the algorithm returns. From the definition
of the algorithm, we have
Pˆ(X | e) = α NPS (X, e) = NPS (X, e)
NPS (e) .
From Equation (14.6), this becomes
Pˆ(X | e) ≈
P(X, e)
P(e) = P(X | e) .
That is, rejection sampling produces a consistent estimate of the true probability.
Continuing with our example from Figure 14.12(a), let us assume that we wish to estimate P(Rain | Sprinkler = true), using 100 samples. Of the 100 that we generate, suppose
that 73 have Sprinkler = false and are rejected, while 27 have Sprinkler = true; of the 27,
8 have Rain = true and 19 have Rain = false. Hence,
P(Rain | Sprinkler = true) ≈ NORMALIZE(8, 19) = 0.296, 0.704 .
The true answer is 0.3, 0.7. As more samples are collected, the estimate will converge to
the true answer. The standard deviation of the error in each probability will be proportional
to 1/
√n, where n is the number of samples used in the estimate.
The biggest problem with rejection sampling is that it rejects so many samples! The
fraction of samples consistent with the evidence e drops exponentially as the number of evidence variables grows, so the procedure is simply unusable for complex problems.
Notice that rejection sampling is very similar to the estimation of conditional probabilities directly from the real world. For example, to estimate P(Rain | RedSkyAtNight = true),
one can simply count how often it rains after a red sky is observed the previous evening—
ignoring those evenings when the sky is not red. (Here, the world itself plays the role of
the sample-generation algorithm.) Obviously, this could take a long time if the sky is very
seldom red, and that is the weakness of rejection sampling.
Likelihood weighting
Likelihood weighting avoids the inefficiency of rejection sampling by generating only events LIKELIHOOD
WEIGHTING
that are consistent with the evidence e. It is a particular instance of the general statistical
technique of importance sampling, tailored for inference in Bayesian networks. We begin by IMPORTANCE
SAMPLING
Section 14.5. Approximate Inference in Bayesian Networks 533
function REJECTION-SAMPLING(X , e, bn,N ) returns an estimate of P(X|e)
inputs: X , the query variable
e, observed values for variables E
bn, a Bayesian network
N , the total number of samples to be generated
local variables: N, a vector of counts for each value of X , initially zero
for j = 1 to N do
x← PRIOR-SAMPLE(bn)
if x is consistent with e then
N[x ] ←N[x ]+1 where x is the value of X in x
return NORMALIZE(N)
Figure 14.14 The rejection-sampling algorithm for answering queries given evidence in a
Bayesian network.
describing how the algorithm works; then we show that it works correctly—that is, generates
consistent probability estimates.
LIKELIHOOD-WEIGHTING (see Figure 14.15) fixes the values for the evidence variables E and samples only the nonevidence variables. This guarantees that each event generated is consistent with the evidence. Not all events are equal, however. Before tallying the
counts in the distribution for the query variable, each event is weighted by the likelihood that
the event accords to the evidence, as measured by the product of the conditional probabilities
for each evidence variable, given its parents. Intuitively, events in which the actual evidence
appears unlikely should be given less weight.
Let us apply the algorithm to the network shown in Figure 14.12(a), with the query
P(Rain | Cloudy = true,WetGrass = true) and the ordering Cloudy, Sprinkler, Rain, WetGrass. (Any topological ordering will do.) The process goes as follows: First, the weight w
is set to 1.0. Then an event is generated:
1. Cloudy is an evidence variable with value true. Therefore, we set
w ← w × P(Cloudy = true)=0.5 .
2. Sprinkler is not an evidence variable, so sample from P(Sprinkler | Cloudy = true) =
0.1, 0.9; suppose this returns false.
3. Similarly, sample from P(Rain | Cloudy = true) = 0.8, 0.2; suppose this returns
true.
4. WetGrass is an evidence variable with value true. Therefore, we set
w ← w × P(WetGrass = true | Sprinkler = false, Rain = true)=0.45 .
Here WEIGHTED-SAMPLE returns the event [true, false,true,true] with weight 0.45, and
this is tallied under Rain = true.
To understand why likelihood weighting works, we start by examining the sampling
probability SWS for WEIGHTED-SAMPLE. Remember that the evidence variables E are fixed
534 Chapter 14. Probabilistic Reasoning
function LIKELIHOOD-WEIGHTING(X , e, bn,N ) returns an estimate of P(X|e)
inputs: X , the query variable
e, observed values for variables E
bn, a Bayesian network specifying joint distribution P(X1,...,Xn)
N , the total number of samples to be generated
local variables: W, a vector of weighted counts for each value of X , initially zero
for j = 1 to N do
x,w ← WEIGHTED-SAMPLE(bn, e)
W[x ] ←W[x ] + w where x is the value of X in x
return NORMALIZE(W)
function WEIGHTED-SAMPLE(bn, e) returns an event and a weight
w ← 1; x ←an event with n elements initialized from e
foreach variable Xi in X1,...,Xn do
if Xi is an evidence variable with value xi in e
then w ←w × P(Xi = xi | parents(Xi))
else x[i] ← a random sample from P(Xi | parents(Xi))
return x, w
Figure 14.15 The likelihood-weighting algorithm for inference in Bayesian networks. In
WEIGHTED-SAMPLE, each nonevidence variable is sampled according to the conditional
distribution given the values already sampled for the variable’s parents, while a weight is
accumulated based on the likelihood for each evidence variable.
with values e. We call the nonevidence variables Z (including the query variable X). The
algorithm samples each variable in Z given its parent values:
SWS (z, e) = 
l
i = 1
P(zi | parents(Zi)) . (14.7)
Notice that P arents(Zi) can include both nonevidence variables and evidence variables. Unlike the prior distribution P(z), the distribution SWS pays some attention to the evidence: the
sampled values for each Zi will be influenced by evidence among Zi’s ancestors. For example, when sampling Sprinkler the algorithm pays attention to the evidence Cloudy = true in
its parent variable. On the other hand, SWS pays less attention to the evidence than does the
true posterior distribution P(z | e), because the sampled values for each Zi ignore evidence
among Zi’s non-ancestors.5 For example, when sampling Sprinkler and Rain the algorithm
ignores the evidence in the child variable WetGrass = true; this means it will generate many
samples with Sprinkler = false and Rain = false despite the fact that the evidence actually
rules out this case.
5 Ideally, we would like to use a sampling distribution equal to the true posterior P(z | e), to take all the evidence
into account. This cannot be done efficiently, however. If it could, then we could approximate the desired
probability to arbitrary accuracy with a polynomial number of samples. It can be shown that no such polynomialtime approximation scheme can exist.
Section 14.5. Approximate Inference in Bayesian Networks 535
The likelihood weight w makes up for the difference between the actual and desired
sampling distributions. The weight for a given sample x, composed from z and e, is the
product of the likelihoods for each evidence variable given its parents (some or all of which
may be among the Zis):
w(z, e) = m
i = 1
P(ei | parents(Ei)) . (14.8)
Multiplying Equations (14.7) and (14.8), we see that the weighted probability of a sample has
the particularly convenient form
SWS (z, e)w(z, e) = 
l
i = 1
P(zi | parents(Zi)) m
i = 1
P(ei | parents(Ei))
= P(z, e) (14.9)
because the two products cover all the variables in the network, allowing us to use Equation (14.2) for the joint probability.
Now it is easy to show that likelihood weighting estimates are consistent. For any
particular value x of X, the estimated posterior probability can be calculated as follows:
Pˆ(x | e) = α 
y
NWS (x, y, e)w(x, y, e) from LIKELIHOOD-WEIGHTING
≈ α

y
SWS (x, y, e)w(x, y, e) for large N
= α

y
P(x, y, e) by Equation (14.9)
= α
P(x, e) = P(x | e) .
Hence, likelihood weighting returns consistent estimates.
Because likelihood weighting uses all the samples generated, it can be much more efficient than rejection sampling. It will, however, suffer a degradation in performance as the
number of evidence variables increases. This is because most samples will have very low
weights and hence the weighted estimate will be dominated by the tiny fraction of samples
that accord more than an infinitesimal likelihood to the evidence. The problem is exacerbated
if the evidence variables occur late in the variable ordering, because then the nonevidence
variables will have no evidence in their parents and ancestors to guide the generation of samples. This means the samples will be simulations that bear little resemblance to the reality
suggested by the evidence.
14.5.2 Inference by Markov chain simulation
Markov chain Monte Carlo (MCMC) algorithms work quite differently from rejection sam- MARKOV CHAIN
MONTE CARLO
pling and likelihood weighting. Instead of generating each sample from scratch, MCMC algorithms generate each sample by making a random change to the preceding sample. It is
therefore helpful to think of an MCMC algorithm as being in a particular current state specifying a value for every variable and generating a next state by making random changes to the
536 Chapter 14. Probabilistic Reasoning
current state. (If this reminds you of simulated annealing from Chapter 4 or WALKSAT from
Chapter 7, that is because both are members of the MCMC family.) Here we describe a parGIBBS SAMPLING ticular form of MCMC called Gibbs sampling, which is especially well suited for Bayesian
networks. (Other forms, some of them significantly more powerful, are discussed in the notes
at the end of the chapter.) We will first describe what the algorithm does, then we will explain
why it works.
Gibbs sampling in Bayesian networks
The Gibbs sampling algorithm for Bayesian networks starts with an arbitrary state (with the
evidence variables fixed at their observed values) and generates a next state by randomly
sampling a value for one of the nonevidence variables Xi. The sampling for Xi is done
conditioned on the current values of the variables in the Markov blanket of Xi. (Recall from
page 517 that the Markov blanket of a variable consists of its parents, children, and children’s
parents.) The algorithm therefore wanders randomly around the state space—the space of
possible complete assignments—flipping one variable at a time, but keeping the evidence
variables fixed.
Consider the query P(Rain | Sprinkler = true,WetGrass = true) applied to the network in Figure 14.12(a). The evidence variables Sprinkler and WetGrass are fixed to their
observed values and the nonevidence variables Cloudy and Rain are initialized randomly—
let us say to true and false respectively. Thus, the initial state is [true,true, false,true].
Now the nonevidence variables are sampled repeatedly in an arbitrary order. For example:
1. Cloudy is sampled, given the current values of its Markov blanket variables: in this
case, we sample from P(Cloudy | Sprinkler = true, Rain = false). (Shortly, we will
show how to calculate this distribution.) Suppose the result is Cloudy = false. Then
the new current state is [false,true, false,true].
2. Rain is sampled, given the current values of its Markov blanket variables: in this case,
we sample from P(Rain | Cloudy = false, Sprinkler = true,WetGrass = true). Suppose this yields Rain = true. The new current state is [false,true,true,true].
Each state visited during this process is a sample that contributes to the estimate for the query
variable Rain. If the process visits 20 states where Rain is true and 60 states where Rain is
false, then the answer to the query is NORMALIZE(20, 60) = 0.25, 0.75. The complete
algorithm is shown in Figure 14.16.
Why Gibbs sampling works
We will now show that Gibbs sampling returns consistent estimates for posterior probabilities. The material in this section is quite technical, but the basic claim is straightforward:
the sampling process settles into a “dynamic equilibrium” in which the long-run fraction of
time spent in each state is exactly proportional to its posterior probability. This remarkable
TRANSITION
PROBABILITY property follows from the specific transition probability with which the process moves from
one state to another, as defined by the conditional distribution given the Markov blanket of
the variable being sampled.
Section 14.5. Approximate Inference in Bayesian Networks 537
function GIBBS-ASK(X , e, bn,N ) returns an estimate of P(X|e)
local variables: N, a vector of counts for each value of X , initially zero
Z, the nonevidence variables in bn
x, the current state of the network, initially copied from e
initialize x with random values for the variables in Z
for j = 1 to N do
for each Zi in Z do
set the value of Zi in x by sampling from P(Zi|mb(Zi))
N[x ] ←N[x ]+1 where x is the value of X in x
return NORMALIZE(N)
Figure 14.16 The Gibbs sampling algorithm for approximate inference in Bayesian networks; this version cycles through the variables, but choosing variables at random also works.
Let q(x → x
) be the probability that the process makes a transition from state x to
state x MARKOV CHAIN . This transition probability defines what is called a Markov chain on the state space.
(Markov chains also figure prominently in Chapters 15 and 17.) Now suppose that we run
the Markov chain for t steps, and let πt(x) be the probability that the system is in state x at
time t. Similarly, let πt+1(x
) be the probability of being in state x at time t + 1. Given
πt(x), we can calculate πt+1(x
) by summing, for all states the system could be in at time t,
the probability of being in that state times the probability of making the transition to x
:
πt+1(x
) = 
x
πt(x)q(x → x
) .
We say that the chain has reached its stationary distribution if πt = πt+1. Let us call this STATIONARY
DISTRIBUTION
stationary distribution π; its defining equation is therefore
π(x
) = 
x
π(x)q(x → x
) for all x . (14.10)
ERGODIC Provided the transition probability distribution q is ergodic—that is, every state is reachable
from every other and there are no strictly periodic cycles—there is exactly one distribution π
satisfying this equation for any given q.
Equation (14.10) can be read as saying that the expected “outflow” from each state (i.e.,
its current “population”) is equal to the expected “inflow” from all the states. One obvious
way to satisfy this relationship is if the expected flow between any pair of states is the same
in both directions; that is,
π(x)q(x → x
) = π(x
)q(x → x) for all x, x . (14.11)
When these equations hold, we say that q(x → x DETAILED BALANCE ) is in detailed balance with π(x).
We can show that detailed balance implies stationarity simply by summing over x in
Equation (14.11). We have

x
π(x)q(x → x
) = 
x
π(x
)q(x → x) = π(x
)

x
q(x → x) = π(x
)
538 Chapter 14. Probabilistic Reasoning
where the last step follows because a transition from x is guaranteed to occur.
The transition probability q(x → x
) defined by the sampling step in GIBBS-ASK is
actually a special case of the more general definition of Gibbs sampling, according to which
each variable is sampled conditionally on the current values of all the other variables. We
start by showing that this general definition of Gibbs sampling satisfies the detailed balance
equation with a stationary distribution equal to P(x | e), (the true posterior distribution on
the nonevidence variables). Then, we simply observe that, for Bayesian networks, sampling
conditionally on all variables is equivalent to sampling conditionally on the variable’s Markov
blanket (see page 517).
To analyze the general Gibbs sampler, which samples each Xi in turn with a transition
probability qi that conditions on all the other variables, we define Xi to be these other variables (except the evidence variables); their values in the current state are xi. If we sample a
new value x
i for Xi conditionally on all the other variables, including the evidence, we have
qi(x → x
) = qi((xi, xi) → (x
i, xi)) = P(x
i | xi, e) .
Now we show that the transition probability for each step of the Gibbs sampler is in detailed
balance with the true posterior:
π(x)qi(x → x
) = P(x | e)P(x
i | xi, e) = P(xi, xi | e)P(x
i | xi, e)
= P(xi | xi, e)P(xi | e)P(x
i | xi, e) (using the chain rule on the first term)
= P(xi | xi, e)P(x
i, xi | e) (using the chain rule backward)
= π(x
)qi(x → x) .
We can think of the loop “for each Zi in Z do” in Figure 14.16 as defining one large transition
probability q that is the sequential composition q1 ◦ q2 ◦···◦ qn of the transition probabilities
for the individual variables. It is easy to show (Exercise 14.19) that if each of qi and qj has
π as its stationary distribution, then the sequential composition qi ◦ qj does too; hence the
transition probability q for the whole loop has P(x | e) as its stationary distribution. Finally,
unless the CPTs contain probabilities of 0 or 1—which can cause the state space to become
disconnected—it is easy to see that q is ergodic. Hence, the samples generated by Gibbs
sampling will eventually be drawn from the true posterior distribution.
The final step is to show how to perform the general Gibbs sampling step—sampling
Xi from P(Xi | xi, e)—in a Bayesian network. Recall from page 517 that a variable is independent of all other variables given its Markov blanket; hence,
P(x
i | xi, e) = P(x
i | mb(Xi)) ,
where mb(Xi) denotes the values of the variables in Xi’s Markov blanket, MB(Xi). As
shown in Exercise 14.7, the probability of a variable given its Markov blanket is proportional
to the probability of the variable given its parents times the probability of each child given its
respective parents:
P(x
i | mb(Xi)) = α P(x
i | parents(Xi)) × 
Yj∈Children(Xi)
P(yj | parents(Yj )) . (14.12)
Hence, to flip each variable Xi conditioned on its Markov blanket, the number of multiplications required is equal to the number of Xi’s children.
Section 14.6. Relational and First-Order Probability Models 539
Recommendation(C1, B1)
Honesty(C1) Kindness(C1)
Quality(B1)
Recommendation(C1, B1)
Honesty(C1) Kindness(C1)
Quality(B1)
Recommendation(C2, B1)
Honesty(C2) Kindness(C2)
Quality(B2)
Recommendation(C1, B2) Recommendation(C2, B2)
(a) (b)
Figure 14.17 (a) Bayes net for a single customer C1 recommending a single book B1.
Honest(C1) is Boolean, while the other variables have integer values from 1 to 5. (b) Bayes
net with two customers and two books.
14.6 RELATIONAL AND FIRST-ORDER PROBABILITY MODELS
In Chapter 8, we explained the representational advantages possessed by first-order logic in
comparison to propositional logic. First-order logic commits to the existence of objects and
relations among them and can express facts about some or all of the objects in a domain. This
often results in representations that are vastly more concise than the equivalent propositional
descriptions. Now, Bayesian networks are essentially propositional: the set of random variables is fixed and finite, and each has a fixed domain of possible values. This fact limits the
applicability of Bayesian networks. If we can find a way to combine probability theory with
the expressive power of first-order representations, we expect to be able to increase dramatically the range of problems that can be handled.
For example, suppose that an online book retailer would like to provide overall evaluations of products based on recommendations received from its customers. The evaluation
will take the form of a posterior distribution over the quality of the book, given the available evidence. The simplest solution to base the evaluation on the average recommendation,
perhaps with a variance determined by the number of recommendations, but this fails to take
into account the fact that some customers are kinder than others and some are less honest than
others. Kind customers tend to give high recommendations even to fairly mediocre books,
while dishonest customers give very high or very low recommendations for reasons other
than quality—for example, they might work for a publisher.6
For a single customer C1, recommending a single book B1, the Bayes net might look
like the one shown in Figure 14.17(a). (Just as in Section 9.1, expressions with parentheses
such as Honest(C1) are just fancy symbols—in this case, fancy names for random variables.)
6 A game theorist would advise a dishonest customer to avoid detection by occasionally recommending a good
book from a competitor. See Chapter 17.
540 Chapter 14. Probabilistic Reasoning
With two customers and two books, the Bayes net looks like the one in Figure 14.17(b). For
larger numbers of books and customers, it becomes completely impractical to specify the
network by hand.
Fortunately, the network has a lot of repeated structure. Each Recommendation(c, b)
variable has as its parents the variables Honest(c), Kindness(c), and Quality(b). Moreover,
the CPTs for all the Recommendation(c, b) variables are identical, as are those for all the
Honest(c) variables, and so on. The situation seems tailor-made for a first-order language.
We would like to say something like
Recommendation(c, b) ∼ RecCPT(Honest(c), Kindness (c), Quality(b))
with the intended meaning that a customer’s recommendation for a book depends on the
customer’s honesty and kindness and the book’s quality according to some fixed CPT. This
section develops a language that lets us say exactly this, and a lot more besides.
14.6.1 Possible worlds
Recall from Chapter 13 that a probability model defines a set Ω of possible worlds with
a probability P(ω) for each world ω. For Bayesian networks, the possible worlds are assignments of values to variables; for the Boolean case in particular, the possible worlds are
identical to those of propositional logic. For a first-order probability model, then, it seems
we need the possible worlds to be those of first-order logic—that is, a set of objects with
relations among them and an interpretation that maps constant symbols to objects, predicate
symbols to relations, and function symbols to functions on those objects. (See Section 8.2.)
The model also needs to define a probability for each such possible world, just as a Bayesian
network defines a probability for each assignment of values to variables.
Let us suppose, for a moment, that we have figured out how to do this. Then, as usual
(see page 485), we can obtain the probability of any first-order logical sentence φ as a sum
over the possible worlds where it is true:
P(φ) = 
ω:φ is true in ω
P(ω) . (14.13)
Conditional probabilities P(φ | e) can be obtained similarly, so we can, in principle, ask any
question we want of our model—e.g., “Which books are most likely to be recommended
highly by dishonest customers?”—and get an answer. So far, so good.
There is, however, a problem: the set of first-order models is infinite. We saw this
explicitly in Figure 8.4 on page 293, which we show again in Figure 14.18 (top). This means
that (1) the summation in Equation (14.13) could be infeasible, and (2) specifying a complete,
consistent distribution over an infinite set of worlds could be very difficult.
Section 14.6.2 explores one approach to dealing with this problem. The idea is to
borrow not from the standard semantics of first-order logic but from the database semantics defined in Section 8.2.8 (page 299). The database semantics makes the unique names
assumption—here, we adopt it for the constant symbols. It also assumes domain closure—
there are no more objects than those that are named. We can then guarantee a finite set of
possible worlds by making the set of objects in each world be exactly the set of constant
Section 14.6. Relational and First-Order Probability Models 541
R J R J R J R J R J R J
. . . . . . . . .
. . .
R J
R
J
R J
R
J
R J
R
J
R J
R
J
R J
R
J
Figure 14.18 Top: Some members of the set of all possible worlds for a language with two
constant symbols, R and J, and one binary relation symbol, under the standard semantics for
first-order logic. Bottom: the possible worlds under database semantics. The interpretation
of the constant symbols is fixed, and there is a distinct object for each constant symbol.
symbols that are used; as shown in Figure 14.18 (bottom), there is no uncertainty about the
mapping from symbols to objects or about the objects that exist. We will call models defined
in this way relational probability models, or RPMs.7 The most significant difference be- RELATIONAL
PROBABILITY MODEL
tween the semantics of RPMs and the database semantics introduced in Section 8.2.8 is that
RPMs do not make the closed-world assumption—obviously, assuming that every unknown
fact is false doesn’t make sense in a probabilistic reasoning system!
When the underlying assumptions of database semantics fail to hold, RPMs won’t work
well. For example, a book retailer might use an ISBN (International Standard Book Number)
as a constant symbol to name each book, even though a given “logical” book (e.g., “Gone
With the Wind”) may have several ISBNs. It would make sense to aggregate recommendations across multiple ISBNs, but the retailer may not know for sure which ISBNs are really
the same book. (Note that we are not reifying the individual copies of the book, which might
be necessary for used-book sales, car sales, and so on.) Worse still, each customer is identified by a login ID, but a dishonest customer may have thousands of IDs! In the computer
SIBYL security field, these multiple IDs are called sibyls and their use to confound a reputation sysSIBYL ATTACK tem is called a sibyl attack. Thus, even a simple application in a relatively well-defined,
online domain involves both existence uncertainty (what are the real books and customers EXISTENCE
UNCERTAINTY
underlying the observed data) and identity uncertainty (which symbol really refer to the IDENTITY
UNCERTAINTY
same object). We need to bite the bullet and define probability models based on the standard
semantics of first-order logic, for which the possible worlds vary in the objects they contain
and in the mappings from symbols to objects. Section 14.6.3 shows how to do this.
7 The name relational probability model was given by Pfeffer (2000) to a slightly different representation, but
the underlying ideas are the same.
542 Chapter 14. Probabilistic Reasoning
14.6.2 Relational probability models
Like first-order logic, RPMs have constant, function, and predicate symbols. (It turns out to
be easier to view predicates as functions that return true or false.) We will also assume a
TYPE SIGNATURE type signature for each function, that is, a specification of the type of each argument and the
function’s value. If the type of each object is known, many spurious possible worlds are eliminated by this mechanism. For the book-recommendation domain, the types are Customer
and Book , and the type signatures for the functions and predicates are as follows:
Honest : Customer → {true, false}Kindness : Customer → {1, 2, 3, 4, 5}
Quality : Book → {1, 2, 3, 4, 5}
Recommendation : Customer × Book → {1, 2, 3, 4, 5}
The constant symbols will be whatever customer and book names appear in the retailer’s data
set. In the example given earlier (Figure 14.17(b)), these were C1, C2 and B1, B2.
Given the constants and their types, together with the functions and their type signatures, the random variables of the RPM are obtained by instantiating each function with each
possible combination of objects: Honest(C1), Quality(B2), Recommendation(C1, B2),
and so on. These are exactly the variables appearing in Figure 14.17(b). Because each type
has only finitely many instances, the number of basic random variables is also finite.
To complete the RPM, we have to write the dependencies that govern these random
variables. There is one dependency statement for each function, where each argument of the
function is a logical variable (i.e., a variable that ranges over objects, as in first-order logic):
Honest(c) ∼ 0.99, 0.01
Kindness(c) ∼ 0.1, 0.1, 0.2, 0.3, 0.3
Quality(b) ∼ 0.05, 0.2, 0.4, 0.2, 0.15
Recommendation(c, b) ∼ RecCPT(Honest(c), Kindness (c), Quality(b))
where RecCPT is a separately defined conditional distribution with 2 × 5 × 5 = 50 rows,
each with 5 entries. The semantics of the RPM can be obtained by instantiating these dependencies for all known constants, giving a Bayesian network (as in Figure 14.17(b)) that
defines a joint distribution over the RPM’s random variables.8
We can refine the model by introducing a context-specific independence to reflect the CONTEXT-SPECIFIC
INDEPENDENCE
fact that dishonest customers ignore quality when giving a recommendation; moreover, kindness plays no role in their decisions. A context-specific independence allows a variable to be
independent of some of its parents given certain values of others; thus, Recommendation(c, b)
is independent of Kindness(c) and Quality(b) when Honest(c) = false:
Recommendation(c, b) ∼ if Honest(c) then
HonestRecCPT(Kindness(c), Quality(b))
else 0.4, 0.1, 0.0, 0.1, 0.4 .
8 Some technical conditions must be observed to guarantee that the RPM defines a proper distribution. First,
the dependencies must be acyclic, otherwise the resulting Bayesian network will have cycles and will not define
a proper distribution. Second, the dependencies must be well-founded, that is, there can be no infinite ancestor
chains, such as might arise from recursive dependencies. Under some circumstances (see Exercise 14.6), a fixedpoint calculation yields a well-defined probability model for a recursive RPM.
Section 14.6. Relational and First-Order Probability Models 543
Recommendation(C1, B1)
Honesty(C1) Kindness(C1 Quality(B ) 1)
Recommendation(C2, B1)
Quality(B2)
Fan(C1, A1) Fan(C1, A2) Author(B2)
Figure 14.19 Fragment of the equivalent Bayes net when Author(B2) is unknown.
This kind of dependency may look like an ordinary if–then–else statement on a programming
language, but there is a key difference: the inference engine doesn’t necessarily know the
value of the conditional test!
We can elaborate this model in endless ways to make it more realistic. For example,
suppose that an honest customer who is a fan of a book’s author always gives the book a 5,
regardless of quality:
Recommendation(c, b) ∼ if Honest(c) then
if Fan(c, Author (b)) then Exactly(5)
else HonestRecCPT(Kindness(c), Quality(b))
else 0.4, 0.1, 0.0, 0.1, 0.4
Again, the conditional test Fan(c, Author (b)) is unknown, but if a customer gives only 5s to
a particular author’s books and is not otherwise especially kind, then the posterior probability
that the customer is a fan of that author will be high. Furthermore, the posterior distribution
will tend to discount the customer’s 5s in evaluating the quality of that author’s books.
In the preceding example, we implicitly assumed that the value of Author (b) is known
for every b, but this may not be the case. How can the system reason about whether, say, C1
is a fan of Author (B2) when Author (B2) is unknown? The answer is that the system may
have to reason about all possible authors. Suppose (to keep things simple) that there are just
two authors, A1 and A2. Then Author (B2) is a random variable with two possible values,
A1 and A2, and it is a parent of Recommendation(C1, B2). The variables Fan(C1, A1) and
Fan(C1, A2) are parents too. The conditional distribution for Recommendation(C1, B2) is
MULTIPLEXER then essentially a multiplexer in which the Author (B2) parent acts as a selector to choose
which of Fan(C1, A1) and Fan(C1, A2) actually gets to influence the recommendation. A
fragment of the equivalent Bayes net is shown in Figure 14.19. Uncertainty in the value
of Author (B2), which affects the dependency structure of the network, is an instance of
relational uncertainty. RELATIONAL
UNCERTAINTY
In case you are wondering how the system can possibly work out who the author of
B2 is: consider the possibility that three other customers are fans of A1 (and have no other
favorite authors in common) and all three have given B2 a 5, even though most other customers find it quite dismal. In that case, it is extremely likely that A1 is the author of B2.
544 Chapter 14. Probabilistic Reasoning
The emergence of sophisticated reasoning like this from an RPM model of just a few lines
is an intriguing example of how probabilistic influences spread through the web of interconnections among objects in the model. As more dependencies and more objects are added, the
picture conveyed by the posterior distribution often becomes clearer and clearer.
The next question is how to do inference in RPMs. One approach is to collect the
evidence and query and the constant symbols therein, construct the equivalent Bayes net,
and apply any of the inference methods discussed in this chapter. This technique is called
UNROLLING unrolling. The obvious drawback is that the resulting Bayes net may be very large. Furthermore, if there are many candidate objects for an unknown relation or function—for example,
the unknown author of B2—then some variables in the network may have many parents.
Fortunately, much can be done to improve on generic inference algorithms. First, the
presence of repeated substructure in the unrolled Bayes net means that many of the factors
constructed during variable elimination (and similar kinds of tables constructed by clustering algorithms) will be identical; effective caching schemes have yielded speedups of three
orders of magnitude for large networks. Second, inference methods developed to take advantage of context-specific independence in Bayes nets find many applications in RPMs. Third,
MCMC inference algorithms have some interesting properties when applied to RPMs with
relational uncertainty. MCMC works by sampling complete possible worlds, so in each state
the relational structure is completely known. In the example given earlier, each MCMC state
would specify the value of Author (B2), and so the other potential authors are no longer parents of the recommendation nodes for B2. For MCMC, then, relational uncertainty causes no
increase in network complexity; instead, the MCMC process includes transitions that change
the relational structure, and hence the dependency structure, of the unrolled network.
All of the methods just described assume that the RPM has to be partially or completely
unrolled into a Bayesian network. This is exactly analogous to the method of propositionalization for first-order logical inference. (See page 322.) Resolution theorem-provers and
logic programming systems avoid propositionalizing by instantiating the logical variables
only as needed to make the inference go through; that is, they lift the inference process above
the level of ground propositional sentences and make each lifted step do the work of many
ground steps. The same idea applied in probabilistic inference. For example, in the variable
elimination algorithm, a lifted factor can represent an entire set of ground factors that assign
probabilities to random variables in the RPM, where those random variables differ only in the
constant symbols used to construct them. The details of this method are beyond the scope of
this book, but references are given at the end of the chapter.
14.6.3 Open-universe probability models
We argued earlier that database semantics was appropriate for situations in which we know
exactly the set of relevant objects that exist and can identify them unambiguously. (In particular, all observations about an object are correctly associated with the constant symbol that
names it.) In many real-world settings, however, these assumptions are simply untenable. We
gave the examples of multiple ISBNs and sibyl attacks in the book-recommendation domain
(to which we will return in a moment), but the phenomenon is far more pervasive:
Section 14.6. Relational and First-Order Probability Models 545
• A vision system doesn’t know what exists, if anything, around the next corner, and may
not know if the object it sees now is the same one it saw a few minutes ago.
• A text-understanding system does not know in advance the entities that will be featured
in a text, and must reason about whether phrases such as “Mary,” “Dr. Smith,” “she,”
“his cardiologist,” “his mother,” and so on refer to the same object.
• An intelligence analyst hunting for spies never knows how many spies there really are
and can only guess whether various pseudonyms, phone numbers, and sightings belong
to the same individual.
In fact, a major part of human cognition seems to require learning what objects exist and
being able to connect observations—which almost never come with unique IDs attached—to
hypothesized objects in the world.
OPEN UNIVERSE For these reasons, we need to be able to write so-called open-universe probability
models or OUPMs based on the standard semantics of first-order logic, as illustrated at the
top of Figure 14.18. A language for OUPMs provides a way of writing such models easily
while guaranteeing a unique, consistent probability distribution over the infinite space of
possible worlds.
The basic idea is to understand how ordinary Bayesian networks and RPMs manage
to define a unique probability model and to transfer that insight to the first-order setting. In
essence, a Bayes net generates each possible world, event by event, in the topological order
defined by the network structure, where each event is an assignment of a value to a variable.
An RPM extends this to entire sets of events, defined by the possible instantiations of the
logical variables in a given predicate or function. OUPMs go further by allowing generative
steps that add objects to the possible world under construction, where the number and type
of objects may depend on the objects that are already in that world. That is, the event being
generated is not the assignment of a value to a variable, but the very existence of objects.
One way to do this in OUPMs is to add statements that define conditional distributions
over the numbers of objects of various kinds. For example, in the book-recommendation
domain, we might want to distinguish between customers (real people) and their login IDs.
Suppose we expect somewhere between 100 and 10,000 distinct customers (whom we cannot
observe directly). We can express this as a prior log-normal distribution9 as follows:
# Customer ∼ LogNormal[6.9, 2.32]() .
We expect honest customers to have just one ID, whereas dishonest customers might have
anywhere between 10 and 1000 IDs:
# LoginID(Owner = c) ∼ if Honest(c) then Exactly(1)
else LogNormal[6.9, 2.32]() .
This statement defines the number of login IDs for a given owner, who is a customer. The
ORIGIN FUNCTION Owner function is called an origin function because it says where each generated object
came from. In the formal semantics of BLOG (as distinct from first-order logic), the domain
elements in each possible world are actually generation histories (e.g., “the fourth login ID of
the seventh customer”) rather than simple tokens.
9 A distribution LogNormal[μ, σ2](x) is equivalent to a distribution N[μ, σ2](x) over loge(x).
546 Chapter 14. Probabilistic Reasoning
Subject to technical conditions of acyclicity and well-foundedness similar to those for
RPMs, open-universe models of this kind define a unique distribution over possible worlds.
Furthermore, there exist inference algorithms such that, for every such well-defined model
and every first-order query, the answer returned approaches the true posterior arbitrarily
closely in the limit. There are some tricky issues involved in designing these algorithms.
For example, an MCMC algorithm cannot sample directly in the space of possible worlds
when the size of those worlds is unbounded; instead, it samples finite, partial worlds, relying on the fact that only finitely many objects can be relevant to the query in distinct ways.
Moreover, transitions must allow for merging two objects into one or splitting one into two.
(Details are given in the references at the end of the chapter.) Despite these complications,
the basic principle established in Equation (14.13) still holds: the probability of any sentence
is well defined and can be calculated.
Research in this area is still at an early stage, but already it is becoming clear that firstorder probabilistic reasoning yields a tremendous increase in the effectiveness of AI systems
at handling uncertain information. Potential applications include those mentioned above—
computer vision, text understanding, and intelligence analysis—as well as many other kinds
of sensor interpretation.
14.7 OTHER APPROACHES TO UNCERTAIN REASONING
Other sciences (e.g., physics, genetics, and economics) have long favored probability as a
model for uncertainty. In 1819, Pierre Laplace said, “Probability theory is nothing but common sense reduced to calculation.” In 1850, James Maxwell said, “The true logic for this
world is the calculus of Probabilities, which takes account of the magnitude of the probability which is, or ought to be, in a reasonable man’s mind.”
Given this long tradition, it is perhaps surprising that AI has considered many alternatives to probability. The earliest expert systems of the 1970s ignored uncertainty and used
strict logical reasoning, but it soon became clear that this was impractical for most real-world
domains. The next generation of expert systems (especially in medical domains) used probabilistic techniques. Initial results were promising, but they did not scale up because of the
exponential number of probabilities required in the full joint distribution. (Efficient Bayesian
network algorithms were unknown then.) As a result, probabilistic approaches fell out of
favor from roughly 1975 to 1988, and a variety of alternatives to probability were tried for a
variety of reasons:
• One common view is that probability theory is essentially numerical, whereas human
judgmental reasoning is more “qualitative.” Certainly, we are not consciously aware
of doing numerical calculations of degrees of belief. (Neither are we aware of doing
unification, yet we seem to be capable of some kind of logical reasoning.) It might be
that we have some kind of numerical degrees of belief encoded directly in strengths
of connections and activations in our neurons. In that case, the difficulty of conscious
access to those strengths is not surprising. One should also note that qualitative reason-
Section 14.7. Other Approaches to Uncertain Reasoning 547
ing mechanisms can be built directly on top of probability theory, so the “no numbers”
argument against probability has little force. Nonetheless, some qualitative schemes
have a good deal of appeal in their own right. One of the best studied is default reasoning, which treats conclusions not as “believed to a certain degree,” but as “believed
until a better reason is found to believe something else.” Default reasoning is covered
in Chapter 12.
• Rule-based approaches to uncertainty have also been tried. Such approaches hope to
build on the success of logical rule-based systems, but add a sort of “fudge factor” to
each rule to accommodate uncertainty. These methods were developed in the mid-1970s
and formed the basis for a large number of expert systems in medicine and other areas.
• One area that we have not addressed so far is the question of ignorance, as opposed
to uncertainty. Consider the flipping of a coin. If we know that the coin is fair, then
a probability of 0.5 for heads is reasonable. If we know that the coin is biased, but
we do not know which way, then 0.5 for heads is again reasonable. Obviously, the
two cases are different, yet the outcome probability seems not to distinguish them. The
Dempster–Shafer theory uses interval-valued degrees of belief to represent an agent’s
knowledge of the probability of a proposition.
• Probability makes the same ontological commitment as logic: that propositions are true
or false in the world, even if the agent is uncertain as to which is the case. Researchers
in fuzzy logic have proposed an ontology that allows vagueness: that a proposition can
be “sort of” true. Vagueness and uncertainty are in fact orthogonal issues.
The next three subsections treat some of these approaches in slightly more depth. We will not
provide detailed technical material, but we cite references for further study.
14.7.1 Rule-based methods for uncertain reasoning
Rule-based systems emerged from early work on practical and intuitive systems for logical
inference. Logical systems in general, and logical rule-based systems in particular, have three
desirable properties:
LOCALITY • Locality: In logical systems, whenever we have a rule of the form A ⇒ B, we can
conclude B, given evidence A, without worrying about any other rules. In probabilistic
systems, we need to consider all the evidence.
DETACHMENT • Detachment: Once a logical proof is found for a proposition B, the proposition can be
used regardless of how it was derived. That is, it can be detached from its justification.
In dealing with probabilities, on the other hand, the source of the evidence for a belief
is important for subsequent reasoning.
TRUTHFUNCTIONALITY • Truth-functionality: In logic, the truth of complex sentences can be computed from
the truth of the components. Probability combination does not work this way, except
under strong global independence assumptions.
There have been several attempts to devise uncertain reasoning schemes that retain these
advantages. The idea is to attach degrees of belief to propositions and rules and to devise
purely local schemes for combining and propagating those degrees of belief. The schemes
548 Chapter 14. Probabilistic Reasoning
are also truth-functional; for example, the degree of belief in A ∨ B is a function of the belief
in A and the belief in B.
The bad news for rule-based systems is that the properties of locality, detachment, and
truth-functionality are simply not appropriate for uncertain reasoning. Let us look at truthfunctionality first. Let H1 be the event that a fair coin flip comes up heads, let T1 be the event
that the coin comes up tails on that same flip, and let H2 be the event that the coin comes
up heads on a second flip. Clearly, all three events have the same probability, 0.5, and so a
truth-functional system must assign the same belief to the disjunction of any two of them.
But we can see that the probability of the disjunction depends on the events themselves and
not just on their probabilities:
P(A) P(B) P(A ∨ B)
P(H1)=0.5 P(H1 ∨ H1)=0.50
P(H1)=0.5 P(T1)=0.5 P(H1 ∨ T1)=1.00
P(H2)=0.5 P(H1 ∨ H2)=0.75
It gets worse when we chain evidence together. Truth-functional systems have rules of the
form A %→ B that allow us to compute the belief in B as a function of the belief in the rule
and the belief in A. Both forward- and backward-chaining systems can be devised. The belief
in the rule is assumed to be constant and is usually specified by the knowledge engineer—for
example, as A %→0.9 B.
Consider the wet-grass situation from Figure 14.12(a) (page 529). If we wanted to be
able to do both causal and diagnostic reasoning, we would need the two rules
Rain %→ WetGrass and WetGrass %→ Rain .
These two rules form a feedback loop: evidence for Rain increases the belief in WetGrass,
which in turn increases the belief in Rain even more. Clearly, uncertain reasoning systems
need to keep track of the paths along which evidence is propagated.
Intercausal reasoning (or explaining away) is also tricky. Consider what happens when
we have the two rules
Sprinkler %→ WetGrass and WetGrass %→ Rain .
Suppose we see that the sprinkler is on. Chaining forward through our rules, this increases the
belief that the grass will be wet, which in turn increases the belief that it is raining. But this
is ridiculous: the fact that the sprinkler is on explains away the wet grass and should reduce
the belief in rain. A truth-functional system acts as if it also believes Sprinkler %→ Rain.
Given these difficulties, how can truth-functional systems be made useful in practice?
The answer lies in restricting the task and in carefully engineering the rule base so that undesirable interactions do not occur. The most famous example of a truth-functional system
CERTAINTY FACTOR for uncertain reasoning is the certainty factors model, which was developed for the MYCIN
medical diagnosis program and was widely used in expert systems of the late 1970s and
1980s. Almost all uses of certainty factors involved rule sets that were either purely diagnostic (as in MYCIN) or purely causal. Furthermore, evidence was entered only at the “roots”
of the rule set, and most rule sets were singly connected. Heckerman (1986) has shown that,
Section 14.7. Other Approaches to Uncertain Reasoning 549
under these circumstances, a minor variation on certainty-factor inference was exactly equivalent to Bayesian inference on polytrees. In other circumstances, certainty factors could yield
disastrously incorrect degrees of belief through overcounting of evidence. As rule sets became larger, undesirable interactions between rules became more common, and practitioners
found that the certainty factors of many other rules had to be “tweaked” when new rules were
added. For these reasons, Bayesian networks have largely supplanted rule-based methods for
uncertain reasoning.
14.7.2 Representing ignorance: Dempster–Shafer theory
The Dempster–Shafer theory is designed to deal with the distinction between uncertainty DEMPSTER–SHAFER
THEORY
and ignorance. Rather than computing the probability of a proposition, it computes the
probability that the evidence supports the proposition. This measure of belief is called a
BELIEF FUNCTION belief function, written Bel(X).
We return to coin flipping for an example of belief functions. Suppose you pick a
coin from a magician’s pocket. Given that the coin might or might not be fair, what belief
should you ascribe to the event that it comes up heads? Dempster–Shafer theory says that
because you have no evidence either way, you have to say that the belief Bel(Heads)=0
and also that Bel(¬Heads)=0. This makes Dempster–Shafer reasoning systems skeptical
in a way that has some intuitive appeal. Now suppose you have an expert at your disposal
who testifies with 90% certainty that the coin is fair (i.e., he is 90% sure that P(Heads) =
0.5). Then Dempster–Shafer theory gives Bel(Heads)=0.9 × 0.5=0.45 and likewise
Bel(¬Heads)=0.45. There is still a 10 percentage point “gap” that is not accounted for by
the evidence.
The mathematical underpinnings of Dempster–Shafer theory have a similar flavor to
those of probability theory; the main difference is that, instead of assigning probabilities
MASS to possible worlds, the theory assigns masses to sets of possible world, that is, to events.
The masses still must add to 1 over all possible events. Bel(A) is defined to be the sum of
masses for all events that are subsets of (i.e., that entail) A, including A itself. With this
definition, Bel(A) and Bel(¬A) sum to at most 1, and the gap—the interval between Bel(A)
and 1 − Bel(¬A)—is often interpreted as bounding the probability of A.
As with default reasoning, there is a problem in connecting beliefs to actions. Whenever
there is a gap in the beliefs, then a decision problem can be defined such that a Dempster–
Shafer system is unable to make a decision. In fact, the notion of utility in the Dempster–
Shafer model is not yet well understood because the meanings of masses and beliefs themselves have yet to be understood. Pearl (1988) has argued that Bel(A) should be interpreted
not as a degree of belief in A but as the probability assigned to all the possible worlds (now
interpreted as logical theories) in which A is provable. While there are cases in which this
quantity might be of interest, it is not the same as the probability that A is true.
A Bayesian analysis of the coin-flipping example would suggest that no new formalism
is necessary to handle such cases. The model would have two variables: the Bias of the coin
(a number between 0 and 1, where 0 is a coin that always shows tails and 1 a coin that always
shows heads) and the outcome of the next Flip. The prior probability distribution for Bias
550 Chapter 14. Probabilistic Reasoning
would reflect our beliefs based on the source of the coin (the magician’s pocket): some small
probability that it is fair and some probability that it is heavily biased toward heads or tails.
The conditional distribution P(Flip | Bias) simply defines how the bias operates. If P(Bias)
is symmetric about 0.5, then our prior probability for the flip is
P(Flip = heads) =  1
0
P(Bias = x)P(Flip = heads | Bias = x) dx = 0.5 .
This is the same prediction as if we believe strongly that the coin is fair, but that does not
mean that probability theory treats the two situations identically. The difference arises after
the flips in computing the posterior distribution for Bias. If the coin came from a bank, then
seeing it come up heads three times running would have almost no effect on our strong prior
belief in its fairness; but if the coin comes from the magician’s pocket, the same evidence
will lead to a stronger posterior belief that the coin is biased toward heads. Thus, a Bayesian
approach expresses our “ignorance” in terms of how our beliefs would change in the face of
future information gathering.
14.7.3 Representing vagueness: Fuzzy sets and fuzzy logic
FUZZY SET THEORY Fuzzy set theory is a means of specifying how well an object satisfies a vague description.
For example, consider the proposition “Nate is tall.” Is this true if Nate is 5 10? Most
people would hesitate to answer “true” or “false,” preferring to say, “sort of.” Note that this
is not a question of uncertainty about the external world—we are sure of Nate’s height. The
issue is that the linguistic term “tall” does not refer to a sharp demarcation of objects into two
classes—there are degrees of tallness. For this reason, fuzzy set theory is not a method for
uncertain reasoning at all. Rather, fuzzy set theory treats Tall as a fuzzy predicate and says
that the truth value of Tall(Nate) is a number between 0 and 1, rather than being just true
or false. The name “fuzzy set” derives from the interpretation of the predicate as implicitly
defining a set of its members—a set that does not have sharp boundaries.
FUZZY LOGIC Fuzzy logic is a method for reasoning with logical expressions describing membership
in fuzzy sets. For example, the complex sentence Tall(Nate) ∧ Heavy(Nate) has a fuzzy
truth value that is a function of the truth values of its components. The standard rules for
evaluating the fuzzy truth, T, of a complex sentence are
T(A ∧ B) = min(T(A), T(B))
T(A ∨ B) = max(T(A), T(B))
T(¬A)=1 − T(A) .
Fuzzy logic is therefore a truth-functional system—a fact that causes serious difficulties.
For example, suppose that T(Tall(Nate)) = 0.6 and T(Heavy(Nate)) = 0.4. Then we have
T(Tall(Nate) ∧ Heavy(Nate)) = 0.4, which seems reasonable, but we also get the result
T(Tall(Nate) ∧ ¬Tall(Nate)) = 0.4, which does not. Clearly, the problem arises from the
inability of a truth-functional approach to take into account the correlations or anticorrelations
among the component propositions.
FUZZY CONTROL Fuzzy control is a methodology for constructing control systems in which the mapping
between real-valued input and output parameters is represented by fuzzy rules. Fuzzy control has been very successful in commercial products such as automatic transmissions, video
Section 14.8. Summary 551
cameras, and electric shavers. Critics (see, e.g., Elkan, 1993) argue that these applications
are successful because they have small rule bases, no chaining of inferences, and tunable
parameters that can be adjusted to improve the system’s performance. The fact that they are
implemented with fuzzy operators might be incidental to their success; the key is simply to
provide a concise and intuitive way to specify a smoothly interpolated, real-valued function.
There have been attempts to provide an explanation of fuzzy logic in terms of probability theory. One idea is to view assertions such as “Nate is Tall” as discrete observations made
concerning a continuous hidden variable, Nate’s actual Height. The probability model specifies P(Observer says Nate is tall | Height), perhaps using a probit distribution as described
on page 522. A posterior distribution over Nate’s height can then be calculated in the usual
way, for example, if the model is part of a hybrid Bayesian network. Such an approach is not
truth-functional, of course. For example, the conditional distribution
P(Observer says Nate is tall and heavy | Height,Weight)
allows for interactions between height and weight in the causing of the observation. Thus,
someone who is eight feet tall and weighs 190 pounds is very unlikely to be called “tall and
heavy,” even though “eight feet” counts as “tall” and “190 pounds” counts as “heavy.”
Fuzzy predicates can also be given a probabilistic interpretation in terms of random
RANDOM SET sets—that is, random variables whose possible values are sets of objects. For example, Tall
is a random set whose possible values are sets of people. The probability P(Tall = S1),
where S1 is some particular set of people, is the probability that exactly that set would be
identified as “tall” by an observer. Then the probability that “Nate is tall” is the sum of the
probabilities of all the sets of which Nate is a member.
Both the hybrid Bayesian network approach and the random sets approach appear to
capture aspects of fuzziness without introducing degrees of truth. Nonetheless, there remain
many open issues concerning the proper representation of linguistic observations and continuous quantities—issues that have been neglected by most outside the fuzzy community.
14.8 SUMMARY
This chapter has described Bayesian networks, a well-developed representation for uncertain
knowledge. Bayesian networks play a role roughly analogous to that of propositional logic
for definite knowledge.
• A Bayesian network is a directed acyclic graph whose nodes correspond to random
variables; each node has a conditional distribution for the node, given its parents.
• Bayesian networks provide a concise way to represent conditional independence relationships in the domain.
• A Bayesian network specifies a full joint distribution; each joint entry is defined as the
product of the corresponding entries in the local conditional distributions. A Bayesian
network is often exponentially smaller than an explicitly enumerated joint distribution.
• Many conditional distributions can be represented compactly by canonical families of
552 Chapter 14. Probabilistic Reasoning
distributions. Hybrid Bayesian networks, which include both discrete and continuous
variables, use a variety of canonical distributions.
• Inference in Bayesian networks means computing the probability distribution of a set
of query variables, given a set of evidence variables. Exact inference algorithms, such
as variable elimination, evaluate sums of products of conditional probabilities as efficiently as possible.
• In polytrees (singly connected networks), exact inference takes time linear in the size
of the network. In the general case, the problem is intractable.
• Stochastic approximation techniques such as likelihood weighting and Markov chain
Monte Carlo can give reasonable estimates of the true posterior probabilities in a network and can cope with much larger networks than can exact algorithms.
• Probability theory can be combined with representational ideas from first-order logic to
produce very powerful systems for reasoning under uncertainty. Relational probability models (RPMs) include representational restrictions that guarantee a well-defined
probability distribution that can be expressed as an equivalent Bayesian network. Openuniverse probability models handle existence and identity uncertainty, defining probabilty distributions over the infinite space of first-order possible worlds.
• Various alternative systems for reasoning under uncertainty have been suggested. Generally speaking, truth-functional systems are not well suited for such reasoning.
BIBLIOGRAPHICAL AND HISTORICAL NOTES
The use of networks to represent probabilistic information began early in the 20th century,
with the work of Sewall Wright on the probabilistic analysis of genetic inheritance and animal growth factors (Wright, 1921, 1934). I. J. Good (1961), in collaboration with Alan
Turing, developed probabilistic representations and Bayesian inference methods that could
be regarded as a forerunner of modern Bayesian networks—although the paper is not often
cited in this context.10 The same paper is the original source for the noisy-OR model.
The influence diagram representation for decision problems, which incorporated a
DAG representation for random variables, was used in decision analysis in the late 1970s
(see Chapter 16), but only enumeration was used for evaluation. Judea Pearl developed the
message-passing method for carrying out inference in tree networks (Pearl, 1982a) and polytree networks (Kim and Pearl, 1983) and explained the importance of causal rather than diagnostic probability models, in contrast to the certainty-factor systems then in vogue.
The first expert system using Bayesian networks was CONVINCE (Kim, 1983). Early
applications in medicine included the MUNIN system for diagnosing neuromuscular disorders
(Andersen et al., 1989) and the PATHFINDER system for pathology (Heckerman, 1991). The
CPCS system (Pradhan et al., 1994) is a Bayesian network for internal medicine consisting
10 I. J. Good was chief statistician for Turing’s code-breaking team in World War II. In 2001: A Space Odyssey
(Clarke, 1968a), Good and Minsky are credited with making the breakthrough that led to the development of the
HAL 9000 computer.
Bibliographical and Historical Notes 553
of 448 nodes, 906 links and 8,254 conditional probability values. (The front cover shows a
portion of the network.)
Applications in engineering include the Electric Power Research Institute’s work on
monitoring power generators (Morjaria et al., 1995), NASA’s work on displaying timecritical information at Mission Control in Houston (Horvitz and Barry, 1995), and the general
field of network tomography, which aims to infer unobserved local properties of nodes and
links in the Internet from observations of end-to-end message performance (Castro et al.,
2004). Perhaps the most widely used Bayesian network systems have been the diagnosisand-repair modules (e.g., the Printer Wizard) in Microsoft Windows (Breese and Heckerman,
1996) and the Office Assistant in Microsoft Office (Horvitz et al., 1998). Another important application area is biology: Bayesian networks have been used for identifying human
genes by reference to mouse genes (Zhang et al., 2003), inferring cellular networks Friedman
(2004), and many other tasks in bioinformatics. We could go on, but instead we’ll refer you
to Pourret et al. (2008), a 400-page guide to applications of Bayesian networks.
Ross Shachter (1986), working in the influence diagram community, developed the first
complete algorithm for general Bayesian networks. His method was based on goal-directed
reduction of the network using posterior-preserving transformations. Pearl (1986) developed
a clustering algorithm for exact inference in general Bayesian networks, utilizing a conversion
to a directed polytree of clusters in which message passing was used to achieve consistency
over variables shared between clusters. A similar approach, developed by the statisticians
David Spiegelhalter and Steffen Lauritzen (Lauritzen and Spiegelhalter, 1988), is based on
MARKOV NETWORK conversion to an undirected form of graphical model called a Markov network. This approach is implemented in the HUGIN system, an efficient and widely used tool for uncertain
reasoning (Andersen et al., 1989). Boutilier et al. (1996) show how to exploit context-specific
independence in clustering algorithms.
The basic idea of variable elimination—that repeated computations within the overall
sum-of-products expression can be avoided by caching—appeared in the symbolic probabilistic inference (SPI) algorithm (Shachter et al., 1990). The elimination algorithm we describe
is closest to that developed by Zhang and Poole (1994). Criteria for pruning irrelevant variables were developed by Geiger et al. (1990) and by Lauritzen et al. (1990); the criterion we
give is a simple special case of these. Dechter (1999) shows how the variable elimination idea
is essentially identical to nonserial dynamic programming (Bertele and Brioschi, 1972), an NONSERIAL DYNAMIC
PROGRAMMING
algorithmic approach that can be applied to solve a range of inference problems in Bayesian
networks—for example, finding the most likely explanation for a set of observations. This
connects Bayesian network algorithms to related methods for solving CSPs and gives a direct
measure of the complexity of exact inference in terms of the tree width of the network. Wexler
and Meek (2009) describe a method of preventing exponential growth in the size of factors
computed in variable elimination; their algorithm breaks down large factors into products of
smaller factors and simultaneously computes an error bound for the resulting approximation.
The inclusion of continuous random variables in Bayesian networks was considered
by Pearl (1988) and Shachter and Kenley (1989); these papers discussed networks containing only continuous variables with linear Gaussian distributions. The inclusion of discrete
variables has been investigated by Lauritzen and Wermuth (1989) and implemented in the
554 Chapter 14. Probabilistic Reasoning
cHUGIN system (Olesen, 1993). Further analysis of linear Gaussian models, with connections to many other models used in statistics, appears in Roweis and Ghahramani (1999) The
probit distribution is usually attributed to Gaddum (1933) and Bliss (1934), although it had
been discovered several times in the 19th century. Bliss’s work was expanded considerably
by Finney (1947). The probit has been used widely for modeling discrete choice phenomena
and can be extended to handle more than two choices (Daganzo, 1979). The logit model was
introduced by Berkson (1944); initially much derided, it eventually became more popular
than the probit model. Bishop (1995) gives a simple justification for its use.
Cooper (1990) showed that the general problem of inference in unconstrained Bayesian
networks is NP-hard, and Paul Dagum and Mike Luby (1993) showed the corresponding
approximation problem to be NP-hard. Space complexity is also a serious problem in both
clustering and variable elimination methods. The method of cutset conditioning, which was
developed for CSPs in Chapter 6, avoids the construction of exponentially large tables. In a
Bayesian network, a cutset is a set of nodes that, when instantiated, reduces the remaining
nodes to a polytree that can be solved in linear time and space. The query is answered by
summing over all the instantiations of the cutset, so the overall space requirement is still linear (Pearl, 1988). Darwiche (2001) describes a recursive conditioning algorithm that allows
a complete range of space/time tradeoffs.
The development of fast approximation algorithms for Bayesian network inference is
a very active area, with contributions from statistics, computer science, and physics. The
rejection sampling method is a general technique that is long known to statisticians; it was
first applied to Bayesian networks by Max Henrion (1988), who called it logic sampling.
Likelihood weighting, which was developed by Fung and Chang (1989) and Shachter and
Peot (1989), is an example of the well-known statistical method of importance sampling.
Cheng and Druzdzel (2000) describe an adaptive version of likelihood weighting that works
well even when the evidence has very low prior likelihood.
Markov chain Monte Carlo (MCMC) algorithms began with the Metropolis algorithm,
due to Metropolis et al. (1953), which was also the source of the simulated annealing algorithm described in Chapter 4. The Gibbs sampler was devised by Geman and Geman (1984)
for inference in undirected Markov networks. The application of MCMC to Bayesian networks is due to Pearl (1987). The papers collected by Gilks et al. (1996) cover a wide variety
of applications of MCMC, several of which were developed in the well-known BUGS package (Gilks et al., 1994).
There are two very important families of approximation methods that we did not cover
in the chapter. The first is the family of variational approximation methods, which can be VARIATIONAL
APPROXIMATION
used to simplify complex calculations of all kinds. The basic idea is to propose a reduced
version of the original problem that is simple to work with, but that resembles the original
problem as closely as possible. The reduced problem is described by some variational parameters λ that are adjusted to minimize a distance function D between the original and VARIATIONAL
PARAMETER
the reduced problem, often by solving the system of equations ∂D/∂λ = 0. In many cases,
strict upper and lower bounds can be obtained. Variational methods have long been used in
MEAN FIELD statistics (Rustagi, 1976). In statistical physics, the mean-field method is a particular variational approximation in which the individual variables making up the model are assumed
Bibliographical and Historical Notes 555
to be completely independent. This idea was applied to solve large undirected Markov networks (Peterson and Anderson, 1987; Parisi, 1988). Saul et al. (1996) developed the mathematical foundations for applying variational methods to Bayesian networks and obtained
accurate lower-bound approximations for sigmoid networks with the use of mean-field methods. Jaakkola and Jordan (1996) extended the methodology to obtain both lower and upper
bounds. Since these early papers, variational methods have been applied to many specific
families of models. The remarkable paper by Wainwright and Jordan (2008) provides a unifying theoretical analysis of the literature on variational methods.
A second important family of approximation algorithms is based on Pearl’s polytree
message-passing algorithm (1982a). This algorithm can be applied to general networks, as
suggested by Pearl (1988). The results might be incorrect, or the algorithm might fail to terminate, but in many cases, the values obtained are close to the true values. Little attention
was paid to this so-called belief propagation (or BP) approach until McEliece et al. (1998) BELIEF
PROPAGATION
observed that message passing in a multiply connected Bayesian network was exactly the
TURBO DECODING computation performed by the turbo decoding algorithm (Berrou et al., 1993), which provided a major breakthrough in the design of efficient error-correcting codes. The implication
is that BP is both fast and accurate on the very large and very highly connected networks used
for decoding and might therefore be useful more generally. Murphy et al. (1999) presented a
promising empirical study of BP’s performance, and Weiss and Freeman (2001) established
strong convergence results for BP on linear Gaussian networks. Weiss (2000b) shows how an
approximation called loopy belief propagation works, and when the approximation is correct.
Yedidia et al. (2005) made further connections between loopy propagation and ideas from
statistical physics.
The connection between probability and first-order languages was first studied by Carnap (1950). Gaifman (1964) and Scott and Krauss (1966) defined a language in which probabilities could be associated with first-order sentences and for which models were probability
measures on possible worlds. Within AI, this idea was developed for propositional logic
by Nilsson (1986) and for first-order logic by Halpern (1990). The first extensive investigation of knowledge representation issues in such languages was carried out by Bacchus
(1990). The basic idea is that each sentence in the knowledge base expressed a constraint on
the distribution over possible worlds; one sentence entails another if it expresses a stronger
constraint. For example, the sentence ∀ x P(Hungry(x)) > 0.2 rules out distributions
in which any object is hungry with probability less than 0.2; thus, it entails the sentence
∀ x P(Hungry(x)) > 0.1. It turns out that writing a consistent set of sentences in these
languages is quite difficult and constructing a unique probability model nearly impossible
unless one adopts the representation approach of Bayesian networks by writing suitable sentences about conditional probabilities.
Beginning in the early 1990s, researchers working on complex applications noticed
the expressive limitations of Bayesian networks and developed various languages for writing
“templates” with logical variables, from which large networks could be constructed automatically for each problem instance (Breese, 1992; Wellman et al., 1992). The most important
such language was BUGS (Bayesian inference Using Gibbs Sampling) (Gilks et al., 1994),
which combined Bayesian networks with the indexed random variable notation common in INDEXED RANDOM
VARIABLE
556 Chapter 14. Probabilistic Reasoning
statistics. (In BUGS, an indexed random variable looks like X[i], where i has a defined integer
range.) These languages inherited the key property of Bayesian networks: every well-formed
knowledge base defines a unique, consistent probability model. Languages with well-defined
semantics based on unique names and domain closure drew on the representational capabilities of logic programming (Poole, 1993; Sato and Kameya, 1997; Kersting et al., 2000)
and semantic networks (Koller and Pfeffer, 1998; Pfeffer, 2000). Pfeffer (2007) went on to
develop IBAL, which represents first-order probability models as probabilistic programs in a
programming language extended with a randomization primitive. Another important thread
was the combination of relational and first-order notations with (undirected) Markov networks (Taskar et al., 2002; Domingos and Richardson, 2004), where the emphasis has been
less on knowledge representation and more on learning from large data sets.
Initially, inference in these models was performed by generating an equivalent Bayesian
network. Pfeffer et al. (1999) introduced a variable elimination algorithm that cached each
computed factor for reuse by later computations involving the same relations but different
objects, thereby realizing some of the computational gains of lifting. The first truly lifted
inference algorithm was a lifted form of variable elimination described by Poole (2003) and
subsequently improved by de Salvo Braz et al. (2007). Further advances, including cases
where certain aggregate probabilities can be computed in closed form, are described by Milch
et al. (2008) and Kisynski and Poole (2009). Pasula and Russell (2001) studied the application
of MCMC to avoid building the complete equivalent Bayes net in cases of relational and
identity uncertainty. Getoor and Taskar (2007) collect many important papers on first-order
probability models and their use in machine learning.
Probabilistic reasoning about identity uncertainty has two distinct origins. In statisRECORD LINKAGE tics, the problem of record linkage arises when data records do not contain standard unique
identifiers—for example, various citations of this book might name its first author “Stuart
Russell” or “S. J. Russell” or even “Stewart Russle,” and other authors may use the some of
the same names. Literally hundreds of companies exist solely to solve record linkage problems in financial, medical, census, and other data. Probabilistic analysis goes back to work
by Dunn (1946); the Fellegi–Sunter model (1969), which is essentially naive Bayes applied
to matching, still dominates current practice. The second origin for work on identity uncertainty is multitarget tracking (Sittler, 1964), which we cover in Chapter 15. For most of its
history, work in symbolic AI assumed erroneously that sensors could supply sentences with
unique identifiers for objects. The issue was studied in the context of language understanding
by Charniak and Goldman (1992) and in the context of surveillance by (Huang and Russell,
1998) and Pasula et al. (1999). Pasula et al. (2003) developed a complex generative model
for authors, papers, and citation strings, involving both relational and identity uncertainty,
and demonstrated high accuracy for citation information extraction. The first formally defined language for open-universe probability models was BLOG (Milch et al., 2005), which
came with a complete (albeit slow) MCMC inference algorithm for all well-defined mdoels.
(The program code faintly visible on the front cover of this book is part of a BLOG model
for detecting nuclear explosions from seismic signals as part of the UN Comprehensive Test
Ban Treaty verification regime.) Laskey (2008) describes another open-universe modeling
language called multi-entity Bayesian networks.
Bibliographical and Historical Notes 557
As explained in Chapter 13, early probabilistic systems fell out of favor in the early
1970s, leaving a partial vacuum to be filled by alternative methods. Certainty factors were
invented for use in the medical expert system MYCIN (Shortliffe, 1976), which was intended
both as an engineering solution and as a model of human judgment under uncertainty. The
collection Rule-Based Expert Systems (Buchanan and Shortliffe, 1984) provides a complete
overview of MYCIN and its descendants (see also Stefik, 1995). David Heckerman (1986)
showed that a slightly modified version of certainty factor calculations gives correct probabilistic results in some cases, but results in serious overcounting of evidence in other cases.
The PROSPECTOR expert system (Duda et al., 1979) used a rule-based approach in which the
rules were justified by a (seldom tenable) global independence assumption.
Dempster–Shafer theory originates with a paper by Arthur Dempster (1968) proposing
a generalization of probability to interval values and a combination rule for using them. Later
work by Glenn Shafer (1976) led to the Dempster-Shafer theory’s being viewed as a competing approach to probability. Pearl (1988) and Ruspini et al. (1992) analyze the relationship
between the Dempster–Shafer theory and standard probability theory.
Fuzzy sets were developed by Lotfi Zadeh (1965) in response to the perceived difficulty
of providing exact inputs to intelligent systems. The text by Zimmermann (2001) provides
a thorough introduction to fuzzy set theory; papers on fuzzy applications are collected in
Zimmermann (1999). As we mentioned in the text, fuzzy logic has often been perceived
incorrectly as a direct competitor to probability theory, whereas in fact it addresses a different
POSSIBILITY THEORY set of issues. Possibility theory (Zadeh, 1978) was introduced to handle uncertainty in fuzzy
systems and has much in common with probability. Dubois and Prade (1994) survey the
connections between possibility theory and probability theory.
The resurgence of probability depended mainly on Pearl’s development of Bayesian
networks as a method for representing and using conditional independence information. This
resurgence did not come without a fight; Peter Cheeseman’s (1985) pugnacious “In Defense
of Probability” and his later article “An Inquiry into Computer Understanding” (Cheeseman,
1988, with commentaries) give something of the flavor of the debate. Eugene Charniak
helped present the ideas to AI researchers with a popular article, “Bayesian networks without tears”11 (1991), and book (1993). The book by Dean and Wellman (1991) also helped
introduce Bayesian networks to AI researchers. One of the principal philosophical objections
of the logicists was that the numerical calculations that probability theory was thought to require were not apparent to introspection and presumed an unrealistic level of precision in our
uncertain knowledge. The development of qualitative probabilistic networks (Wellman,
1990a) provided a purely qualitative abstraction of Bayesian networks, using the notion of
positive and negative influences between variables. Wellman shows that in many cases such
information is sufficient for optimal decision making without the need for the precise specification of probability values. Goldszmidt and Pearl (1996) take a similar approach. Work
by Adnan Darwiche and Matt Ginsberg (1992) extracts the basic properties of conditioning
and evidence combination from probability theory and shows that they can also be applied in
logical and default reasoning. Often, programs speak louder than words, and the ready avail11 The title of the original version of the article was “Pearl for swine.”
558 Chapter 14. Probabilistic Reasoning
ability of high-quality software such as the Bayes Net toolkit (Murphy, 2001) accelerated the
adoption of the technology.
The most important single publication in the growth of Bayesian networks was undoubtedly the text Probabilistic Reasoning in Intelligent Systems (Pearl, 1988). Several excellent
texts (Lauritzen, 1996; Jensen, 2001; Korb and Nicholson, 2003; Jensen, 2007; Darwiche,
2009; Koller and Friedman, 2009) provide thorough treatments of the topics we have covered in this chapter. New research on probabilistic reasoning appears both in mainstream
AI journals, such as Artificial Intelligence and the Journal of AI Research, and in more specialized journals, such as the International Journal of Approximate Reasoning. Many papers
on graphical models, which include Bayesian networks, appear in statistical journals. The
proceedings of the conferences on Uncertainty in Artificial Intelligence (UAI), Neural Information Processing Systems (NIPS), and Artificial Intelligence and Statistics (AISTATS) are
excellent sources for current research.
EXERCISES
14.1 We have a bag of three biased coins a, b, and c with probabilities of coming up heads
of 20%, 60%, and 80%, respectively. One coin is drawn randomly from the bag (with equal
likelihood of drawing each of the three coins), and then the coin is flipped three times to
generate the outcomes X1, X2, and X3.
a. Draw the Bayesian network corresponding to this setup and define the necessary CPTs.
b. Calculate which coin was most likely to have been drawn from the bag if the observed
flips come out heads twice and tails once.
14.2 Equation (14.1) on page 513 defines the joint distribution represented by a Bayesian
network in terms of the parameters θ(Xi | P arents(Xi)). This exercise asks you to derive the
equivalence between the parameters and the conditional probabilities P(Xi | P arents(Xi))
from this definition.
